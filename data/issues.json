{"javascript":[{"number":1,"title":"【Q001】js 有几种基本的数据类型","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/1","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 动态类型\r\nJS 是一种 **弱类型** 或者说 **动态类型** 语言。\r\n这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。\r\n这也意味着你可以使用同一个变量保存不同类型的数据：\r\n```javascript\r\nlet foo = 42;    // foo 现在是一个数字\r\nfoo     = 'bar'; // foo 现在是一个字符串\r\nfoo     = true;  // foo 现在是一个布尔值\r\n```\r\n\r\n## 2. 数据类型\r\nJavaScript 语言中类型集合由 `基础数据类型` 和 `引用数据类型` 组成。\r\n\r\n### 基础数据类型\r\n直接表示在语言底层的不可变数据，也叫 **原始值**，共有 **7** 个：\r\n\r\n- 布尔 Boolean\r\n- 空类 Null\r\n- 未定义 Undefined\r\n- 数字 Number\r\n- 字符串 String\r\n- 大整数 BigInt（es6新增）\r\n- 符号 Symbol（es6新增）\r\n\r\n### 引用数据类型\r\n`引用类型` 的值是保存在内存中的对象（同时保存在栈内存和堆内存中），`引用类型` 的值是按引用访问的。\r\n\r\n- Object 对象\r\n- Array 数组\r\n- Function 函数\r\n- RegExp 正则\r\n- Date 日期"}]},{"number":2,"title":"【Q002】如何判断 js 数据类型","labels":["javascript"],"body":"基础类型和复杂类型","url":"https://github.com/kangyana/daily-question/issues/2","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"### typeof用于判断基本数据类型，无法区分object、array、null\r\n```javascript\r\n    typeof 1 // 'number'\r\n    typeof \"1\" // 'string'\r\n    typeof undefined // 'undefined'\r\n    \r\n    typeof null // 'object'\r\n    typeof [] // 'object'\r\n    typeof {} // 'object'\r\n    typeof function() {} // 'function'\r\n```\r\n\r\n### 区分object和array，可以使用`Array.isArray()`\r\n```javascript\r\n    Array.isArray([1, 2, 3]); // true\r\n    Array.isArray({foo: 123}); // false\r\n    Array.isArray(\"foobar\"); // false\r\n    Array.isArray(undefined); // false\r\n```"}]},{"number":3,"title":"【Q003】typeof和instanceof的区别","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/3","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 一、typeof\r\n`typeof`操作符返回一个字符串，表示未经计算的操作数的类型。\r\n\r\n语法：\r\n```javascript\r\ntypeof operand\r\n```\r\n\r\n|类型 | 结果 |\r\n| ---- | ---- |\r\n| undefined | `\"undefined\"` |\r\n| boolean | `\"boolean\"` |\r\n| string | `\"string\"` |\r\n| symbol | `\"symbol\"` |\r\n| bigInt | `\"bigint\"` |\r\n| function | `\"function\"` |\r\n| object \\| array \\| null | `\"object\"` |\r\n\r\n由上表可得知，`typeof`是无法区分`object` | `array` | `null`类型的。\r\n\r\n## 二、instanceof\r\n`instanceof` 运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。\r\n\r\n语法：\r\n```javascript\r\nobject instanceof constructor\r\n```\r\n\r\n只能用于构造函数，无法用于基础类型。\r\n\r\n## 三、总结区别\r\n`typeof`与`instanceof`都是判断数据类型的方法，区别如下：\r\n\r\n- `typeof`会返回一个变量的基本类型，instanceof返回的是一个布尔值。\r\n- `instanceof` 可以准确地判断复杂引用数据类型，但是无法判断基本类型。\r\n- `typeof`无法判断除了`function`外的引用类型。\r\n"}]},{"number":4,"title":"【Q004】如何判断一个变量是不是Array","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/4","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. instanceof 判断\r\n```javascript\r\nvar arr = [1,2,3];\r\narr instanceof Array; // true\r\narr instanceof Object; // false\r\n\r\nvar obj = {id:1};\r\nobj instanceof Array; // false\r\nobj instanceof Object; // true\r\n```\r\n\r\n## 2. 构造函数 判断\r\n```javascript\r\nvar arr = [1,2,3];\r\narr.__proto__.constructor === Array; //  true\r\n\r\nvar obj = {id:1};\r\nobj.__proto__.constructor === Object; // true\r\n```\r\n\r\n## 3. toString() 判断\r\n```javascript\r\nvar arr = [1,2,3];\r\nObject.prototype.toString.call(arr);  // [object Array]\r\n\r\nvar obj = {id:1};\r\nObject.prototype.toString.call(obj); // [object Object]\r\n```\r\n\r\n## 4. Array.isArray() 判断\r\n```javascript\r\nvar arr = [1,2,3];\r\nArray.isArray(arr); //  true\r\n\r\nvar obj = {id:1};\r\nArray.isArray(obj); // false\r\n```"}]},{"number":5,"title":"【Q005】==和===有什么不同","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/5","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. ==\r\n等于运算符 `==` 检查其两个操作数是否相等，并返回 `Boolean` 结果。\r\n同时会尝试强制类型转换。\r\n\r\n隐式转换：\r\n`string` 和 `number` 比较时，会自动转换为 `number` 类型。\r\n\r\n## 2. ===\r\n全等运算符 `===` 检查其两个操作数是否相等，并返回 `Boolean` 结果。\r\n它总是认为不同类型的操作数是不同的。\r\n\r\n## 3. 区别\r\n\r\n- `==` 不会比较数据类型，`===` 会检查类型\r\n- `==`会隐式转换"}]},{"number":6,"title":"【Q006】事件机制","labels":["javascript"],"body":"事件循环","url":"https://github.com/kangyana/daily-question/issues/6","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"JavaScript 有一个基于 **事件循环** 的并发模型，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。\r\n\r\n## 1. 可视化描述\r\n![Alt](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop/the_javascript_runtime_environment_example.svg)\r\n\r\n## 2. 栈（stack)\r\n栈是由多个 **函数调用** 形成的 **帧** 组成\r\n\r\n```javascript\r\nfunction foo(b) {\r\n  let a = 10;\r\n  return a + b + 11;\r\n}\r\n\r\nfunction bar(x) {\r\n  let y = 3;\r\n  return foo(x * y);\r\n}\r\n\r\nconsole.log(bar(7)); // 42\r\n```\r\n\r\n当调用 `bar` 时，第一个帧被创建并压入栈中，帧中包含了 `bar` 的参数和局部变量。\r\n当 `bar` 调用 `foo` 时，第二个帧被创建并被压入栈中，放在第一个帧之上，帧中包含 `foo` 的参数和局部变量。\r\n当 `foo` 执行完毕然后返回时，第二个帧就被弹出栈（剩下 `bar` 函数的调用帧 ）。\r\n当 `bar` 也执行完毕然后返回时，第一个帧也被弹出，栈就被清空了。\r\n\r\n## 3. 堆（heap）\r\n堆是放 **object** 的 **内存区域**\r\n\r\n## 4. 队列（queue）\r\n队列是 **待处理消息的消息队列**，每一个消息都关联着一个用以处理这个消息的回调函数。\r\n\r\n在 **事件循环** 期间的某个时刻，运行时会从最先进入队列的消息开始处理队列中的消息。\r\n被处理的消息会被移出队列，并作为输入参数来调用与之关联的函数。\r\n正如前面所提到的，调用一个函数总是会为其创造一个新的栈帧。\r\n\r\n函数的处理会一直进行到执行栈再次为空为止；然后事件循环将会处理队列中的下一个消息。\r\n\r\n## 5. 事件循环（event loop）\r\n之所以称之为 **事件循环**，是因为它经常按照类似如下的方式来被实现：\r\n\r\n```javascript\r\nwhile (queue.waitForMessage()) {\r\n  queue.processNextMessage();\r\n}\r\n```\r\n\r\n`queue.waitForMessage()` 会同步地等待消息到达 "}]},{"number":7,"title":"【Q007】事件委托","labels":["javascript"],"body":"事件流、事件冒泡","url":"https://github.com/kangyana/daily-question/issues/7","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 事件委托\r\n将事件侦听器添加到一个父级元素上。\r\n这样就只用添加一次事件侦听器，可以避免向很多 DOM 节点添加多个事件侦听器。\r\n\r\n## 2. 事件冒泡\r\n事件委托的实现是利用 **事件冒泡** 的机制。\r\n事件流：事件的触发会从最底层的 DOM 元素开始发生，一直向上传播，直到 document 对象。\r\n\r\n## 3. 优点\r\n\r\n- 减少了内存消耗，优化程序性能\r\n- 动态绑定事件，减少重复工作"}]},{"number":8,"title":"【Q008】e.preventDefault()是干什么的","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/8","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"- **e.preventDefault()** 取消默认事件\r\n- **e.stopPropagation()** 防止冒泡和捕获 \r\n"}]},{"number":9,"title":"【Q009】JS中this是如何工作的","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/9","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"**this** 永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。\r\n\r\n## 1. 全局环境中\r\n`this` 指向全局对象\r\n\r\n```javascript\r\n// 在浏览器中\r\nconsole.log(this === window); // true\r\n\r\n// 在 Node 中\r\nconsole.log(this === globalThis); // true\r\n```\r\n## 2. 函数内部\r\n`this` 的值取决于函数被调用的方式。\r\n\r\n非严格模式下，`this` 的值默认指向全局对象\r\n```javascript\r\nfunction f1(){\r\n  return this;\r\n}\r\n\r\nf1() === window;   // true\r\n```\r\n\r\n严格模式下，如果进入执行环境时没有设置 `this` 的值，`this` 会保持为 `undefined`\r\n```javascript\r\nfunction f2(){\r\n  \"use strict\";\r\n  return this;\r\n}\r\n\r\nf2() === undefined; // true\r\n```\r\n\r\n如果要想把 `this` 的值从一个环境传到另一个，就要用 `call` 或者 `apply` 方法\r\n\r\n## 3. 类内部\r\n`this` 在 `类` 中的表现与在函数中类似，因为类本质上也是函数，但也有一些区别和注意事项\r\n\r\n在类的构造函数中，this 是一个常规对象。类中所有 **非静态的方法** 都会被添加到 `this` 的原型中\r\n```javascript\r\nclass Example {\r\n  constructor() {\r\n    const proto = Object.getPrototypeOf(this);\r\n    console.log(Object.getOwnPropertyNames(proto));\r\n  }\r\n  first(){}\r\n  second(){}\r\n  static third(){}\r\n}\r\n\r\nnew Example(); // ['constructor', 'first', 'second']\r\n```\r\n## 4. 派生类内部\r\n派生类的构造函数没有初始的 `this` 绑定，在调用 super() 之前引用 `this` 会报错\r\n\r\n## 5. bind()后\r\n`this` 的值指向绑定的参数\r\n```javascript\r\nfunction f(){\r\n  return this.a;\r\n}\r\n\r\nvar g = f.bind({a:\"azerty\"});\r\nconsole.log(g()); // azerty\r\n```\r\n\r\n## 6. 箭头函数内部\r\n`this` 的值指向外部环境，相当于传递了 `this`"}]},{"number":10,"title":"【Q010】apply、call、bind的区别，及源码实现","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/10","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. apply()\r\n`apply()` 方法调用一个具有给定 `this` 值的函数，以及以一个数组的形式提供的参数\r\n```javascript\r\nconst numbers = [5, 6, 2, 3, 7];\r\n\r\nconst max = Math.max.apply(null, numbers); // 7\r\n```\r\n\r\n源码实现\r\n```javascript\r\nFunction.prototype.myApply = function (context, args) {\r\n    context = context || window;\r\n    let fn = Symbol();\r\n    context[fn] = this;\r\n    return context[fn](...args);\r\n}\r\n```\r\n\r\n## 2. call()\r\n`call` 方法使用一个指定的 `this` 值和单独给出的一个或多个参数来调用一个函数\r\n\r\n可以用来实现 **继承**\r\n```javascript\r\nfunction Product(name, price) {\r\n  this.name = name;\r\n  this.price = price;\r\n}\r\n\r\nfunction Food(name, price) {\r\n  Product.call(this, name, price);\r\n  this.category = 'food';\r\n}\r\n\r\nconsole.log(new Food('cheese', 5).name); // cheese\r\n```\r\n\r\n源码实现，与apply区别只有参数变化\r\n```javascript\r\nFunction.prototype.myCall = function (context, ...args) {\r\n    context = context || window;\r\n    let fn = Symbol();\r\n    context[fn] = this;\r\n    return context[fn](...args);\r\n}\r\n```\r\n\r\n## 3. bind()\r\n`bind()` 方法创建一个新的函数，在 ·bind()· 被调用时，这个新函数的 this 被指定为 `bind()` 的第一个参数，而其余参数将作为新函数的参数\r\n\r\n```javascript\r\nconst module = {\r\n  x: 42,\r\n  getX: function() {\r\n    return this.x;\r\n  }\r\n};\r\n\r\nconst unboundGetX = module.getX;\r\nconsole.log(unboundGetX()); // undefined（函数内this指向全局）\r\n\r\nconst boundGetX = unboundGetX.bind(module);\r\nconsole.log(boundGetX()); // 42\r\n```\r\n\r\n源码实现\r\n```javascript\r\n\r\nFunction.prototype.myBind = function (context) {\r\n    const self = this\r\n    const args = Array.from(arguments).slice(1)\r\n \r\n    return function F() {\r\n        const newArgs = args.concat([...arguments])\r\n        if (this instanceof F) {\r\n            return new self(...newArgs)\r\n        } else {\r\n            return self.apply(context, newArgs)\r\n        }\r\n    }\r\n```\r\n\r\n## 4. 区别\r\n\r\n- `apply` 与 `call` 非常相似，`call` 接受一个参数列表，而 `apply` 接受一个参数的单数组\r\n- `call`、`apply` 是直接调用，`bind` 是返回某个函数，等待某个状态触发再执行\r\n\r\n"}]},{"number":11,"title":"【Q011】js中new关键字原理","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/11","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## new原理\r\n`new` 操作符用来创建构造函数的实例，以这种方式调用构造函数会执行如下操作：\r\n\r\n- 在内存中创建一个新对象；\r\n- 这个对象内部的[[Prototype]]特性被复制为构造函数的prototype属性;\r\n- 构造函数内部的this被复制为这个新对象（即this指向新对象）；\r\n- 执行构造函数内部的代码（给新对象添加属性）；\r\n- 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新实例。\r\n\r\n## 代码实现\r\n\r\n1. 使用Object.create继承prototype属性\r\n```javascript\r\nfunction myNew (constructor, ...args) {\r\n    var obj = Object.create(constructor.prototype);\r\n    var result = constructor.apply(obj, args);\r\n    return typeof result === 'object' ? result : obj;\r\n}\r\n```\r\n\r\n2. 重写新对象的__proto__属性\r\n```javascript\r\nfunction myNew (constructor, ...args) {\r\n    var obj = new Object();\r\n    obj.__proto__  = constructor.prototype;\r\n    var result = constructor.apply(obj, args);\r\n    return typeof result === 'object' ? result : obj;\r\n}\r\n```"}]},{"number":12,"title":"【Q012】JS 中继承是如何实现的","labels":["javascript"],"body":"7种方法","url":"https://github.com/kangyana/daily-question/issues/12","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 原型链\r\n让一个 **构造函数** 的原型是另一个类型的实例，`new` 出来的实例\r\n```javascript\r\nfunction Person () {\r\n  this.name = 'zs';\r\n}\r\n\r\nfunction Man () {};\r\nMan.prototype = new Person();\r\n\r\nnew Man().name // 'zs'\r\n```\r\n\r\n优点：写法方便简洁，容易理解\r\n缺点：对象实例共享所有继承的属性和方法。传教子类型实例的时候，不能传递参数，因为这个对象是一次性创建的（没办法定制化）\r\n\r\n## 2. 借用构造函数继承\r\n在子类型构造函数的内部调用父类型构造函数；使用 apply() 或 call() 方法将父对象的构造函数绑定在子对象上\r\n```javascript\r\nfunction Person (name) {\r\n  this.name = name;\r\n}\r\n\r\nfunction Man (name) {\r\n  Person.call(this, name)\r\n};\r\n```\r\n\r\n优点：解决了原型链实现继承的不能传参的问题和父类的原型共享的问题\r\n缺点：借用构造函数的缺点是方法都在构造函数中定义，因此无法实现函数复用。在父类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式\r\n\r\n## 3. 组合继承（经典继承）\r\n将 `原型链` 和 `借用构造函数` 的组合到一块。\r\n使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。\r\n\r\n```javascript\r\nfunction Person (name) {\r\n  this.name = name;\r\n}\r\nPerson.prototype.sayName = function () {\r\n  console.log('My name is ' + this.name);\r\n}\r\n\r\nfunction Man (name) {\r\n  Person.call(this, name)\r\n};\r\nMan.prototype = new Person();\r\n\r\nnew Man('zs').sayName  // 'My name is zs'\r\n```\r\n\r\n优点: 解决了原型链继承和借用构造函数继承造成的影响\r\n缺点: 无论在什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部\r\n\r\n## 4. 原型式继承\r\n创建一个新对象，挂到新建对象的原型上\r\n```javascript\r\nfunction Person () {\r\n  this.name = 'zs';\r\n}\r\n\r\nvar man = Object.create(Person);\r\n\r\nman.name // 'zs'\r\n```\r\n优点是：不需要单独创建构造函数\r\n缺点是：属性中包含的引用值始终会在相关对象间共享，子类实例不能向父类传参\r\n\r\n## 5. 寄生式继承\r\n寄生式继承的思路与(寄生) `原型式继承` 和 `工厂模式` 似, 即创建一个仅用于封装继承过程的函数,该函数在内部以某种方式来增强对象,最后再像真的是它做了所有工作一样返回对象\r\n\r\n```javascrip\r\nfunction objectCopy(obj) {\r\n  function Fun() { };\r\n  Fun.prototype = obj;\r\n  return new Fun();\r\n}\r\n\r\nfunction createAnother(obj) {\r\n  let clone = objectCopy(obj);\r\n  clone.sayName = function () {\r\n    console.log('My name is ' + this.name);\r\n  };\r\n  return clone;\r\n}\r\n\r\nvar person = { name: 'zs' };\r\n\r\ncreateAnother(person).sayName(); // 'My name is zs'\r\n```\r\n\r\n优点：写法简单，不需要单独创建构造函数\r\n缺点：通过寄生式继承给对象添加函数会导致函数难以复用\r\n\r\n## 6. 寄生组合式继承\r\n通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型\r\n\r\n```javascript\r\n// ...\r\nfunction inheritPrototype(child, parent) {\r\n  let prototype = objectCopy(parent.prototype);\r\n  prototype.constructor = child;\r\n  Child.prototype = prototype;\r\n}\r\n```\r\n优点是：高效率只调用一次父构造函数，并且因此避免了在子原型上面创建不必要，多余的属性。与此同时，原型链还能保持不变\r\n缺点是：代码复杂\r\n\r\n# 7. Class实现继承\r\n优点：语法简单易懂,操作更方便\r\n缺点：并不是所有的浏览器都支持class关键字\r\n"}]},{"number":13,"title":"【Q013】JS 原型和原型链","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/13","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 原型\r\n每个函数都有一个特殊的属性叫作 `原型（prototype）`\r\n每个对象都有一个属性叫作 `__proto__`，这个属性会指向该对象的原型\r\n每个原型都有一个 `constructor` 属性指向关联的构造函数\r\n\r\n## 2. 原型链\r\n当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止\r\n这种原型组成的链状结构就是 `原型链`"}]},{"number":14,"title":"【Q014】闭包与作用域链","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/14","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 作用域\r\n`作用域` 是指程序源代码中 **定义变量** 的区域\r\n作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限\r\n\r\n## 2. 作用域链\r\n当访问一个变量时，解释器会首先在当前作用域查找，如果没有找到，就去父作用域找，直到找到该变量或者不在父作用域中，这就是 `作用域链`\r\n\r\n## 3. 闭包\r\n`闭包` 是指有权访问另外一个函数作用域中的变量的 `函数`\r\n闭包是将函数内部和函数外部连接起来的桥梁\r\n\r\n优点：\r\n\r\n- 闭包里的变量不会污染全局，因为变量被封在闭包里\r\n- 所有变量都在闭包里保证了隐私性和私有性\r\n- 可以让这些局部变量保存在内存中，实现变量数据共享\r\n\r\n缺点：\r\n形成闭包即要把一个函数当成值传递，而且该函数还引用这另一个函数的作用域链使得被引用的函数不能被回收，使用不当容易造成内存泄漏\r\n"}]},{"number":15,"title":"【Q015】let、const、var的区别","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/15","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. var\r\n`var` 语句 用于声明一个函数范围或全局范围的变量，并可将其初始化为一个值（可选）。\r\n\r\n用 `var` 声明的变量的作用域是它当前的执行上下文及其闭包（嵌套函数），或者对于声明在任何函数外的变量来说是全局。\r\n`var` 声明的变量，会提升到该作用域的最顶部。\r\n\r\n## 2. let\r\n`let` 语句声明一个块级作用域的局部变量，并可以初始化为一个值（可选）。\r\n\r\n与 `var` 关键字不同的是，`var` 声明的变量作用域是全局或者整个函数块的。\r\n`var` 和 `let` 的另一个重要区别，`let` 声明的变量不会在作用域中被提升，它是在编译时才初始化。\r\n\r\n## 3. const\r\n常量是块级范围的，非常类似用 `let`。但常量的值是无法（通过重新赋值）改变的，也不能被重新声明。\r\n\r\n`const` 声明创建一个值的只读引用。变量标识符不能重新分配，但改变对象的内容。\r\n\r\n## 4. 区别\r\n\r\n- `var` 在全局作用域声明的变量会变成全局变量，例如浏览器环境下挂载在window对象上。`var`和 `let` 不会。\r\n- `var`和 `let` 声明的变量可以重新赋值，`const` 声明的变量只能改变对象的内容。\r\n"}]},{"number":16,"title":"【Q016】JS 中变量声明提升","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/16","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 变量提升\r\n`var` 声明的 **变量** 和 **函数声明** ，会在代码执行前移动到全局代码的开头位置。\r\n```javascript\r\nbla = 2\r\nvar bla;\r\n\r\n// 可以隐式地（implicitly）将以上代码理解为：\r\n\r\nvar bla;\r\nbla = 2;\r\n```\r\n\r\n因此，建议始终在作用域顶部声明变量（全局代码的顶部和函数代码的顶部），这可以清楚知道哪些变量是函数作用域，哪些变量在作用域链上解决。\r\n\r\n重要的是，提升将影响变量声明，而不会影响其值的初始化。仅在运行到赋值语句时初始化变量的值。在此之前，变量的值始终为 `undefined` 。\r\n```javascript\r\nfunction do_something() {\r\n  console.log(bar); // undefined\r\n  var bar = 111;\r\n  console.log(bar); // 111\r\n}\r\n\r\n// 可以隐式地将以上代码理解为：\r\n\r\nfunction do_something() {\r\n  var bar;\r\n  console.log(bar); // undefined\r\n  bar = 111;\r\n  console.log(bar); // 111\r\n}\r\n```"}]},{"number":17,"title":"【Q017】JS 模块化","labels":["javascript"],"body":"理解模块化发展过程，理解 CommonJS，AMD，CMD，UMD，ES6 模块化","url":"https://github.com/kangyana/daily-question/issues/17","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 原生js的模块化\r\n原生js有几个问题：\r\n\r\n- 代码复用\r\n- 全局作用域污染\r\n- 可维护性\r\n\r\n为了解决这些问题，出现了 `命名空间`  和 `匿名闭包 IIFE 模式`，对代码进行封装，并通过提供外部方法来对它们进行访问。\r\n```javascript\r\n// 命名空间\r\nvar namespace = {}\r\nnamespace.add = function(a, b) {\r\n    console.log(a + b)\r\n}\r\nnamespace.add(1, 2)\r\n\r\n// IIEF\r\nvar utils = (function() {\r\n    var module = {}\r\n    module.multiply = function(a, b) {\r\n        console.log(a * b)\r\n    }\r\n    return module\r\n}())\r\nutils.multiply(1,2)\r\n```\r\n\r\n## 2. CommonJS\r\n09年 `CommonJS`（或者称作 CJS）规范推出，在 **NodeJS** 中实现。主要方法是 **exports** 和 **require**。\r\n```javascript\r\n// utils.js 文件\r\nfunction add(a, b) {\r\n    console.log(a + b)\r\n}\r\nmodule.exports.add = add\r\n\r\n// main.js 文件\r\nvar add = require('./utils').add\r\nadd(1, 2)\r\n```\r\n`CJS` 出来以后，服务端的模块概念已经形成，很自然地，大家就想要客户端模块。\r\n但是 `CJS` 是同步的，服务端读取本地硬盘可以很快同步加载完成，但是浏览器同步读取服务器端的模块可能需要很长的时间，浏览器将会处于”假死”状态。\r\n所以出现异步加载 js 文件的 AMD。\r\n\r\n## 3. AMD\r\n`AMD` 是异步模块定义（Asynchronous Module Definition）。\r\n它采用异步方式加载模块，模块的加载不影响它后面语句的运行。\r\n所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。\r\n\r\n```javascript\r\n// utils.js 文件\r\ndefine([], function() {\r\n    return {\r\n        add: function(a, b) {\r\n            console.log(a + b)\r\n        }\r\n    }\r\n})\r\n\r\n// main.js 文件\r\nrequire(['./utils'], function(utils) {\r\n    utils.add(1, 2)\r\n})\r\n```\r\n\r\n由于原生js不支持，使用 `AMD` 规范进行开发需要用到对应的库函数：`RequireJS`。\r\n`requireJS` 主要解决两个问题：\r\n\r\n- 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器\r\n- js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长\r\n\r\n## 4. CMD\r\n\r\n`CMD`（Common Module Definition）是玉伯在开发 `SeaJS` 的时候提出来的，`SeaJS` 要解决的问题和 `RequireJS` 一样。\r\n不同于 AMD 的依赖前置，CMD 是就近依赖。\r\n\r\n```javascript\r\n// AMD\r\nrequire(['./utils', 'a', 'b'], function(utils) {\r\n    console.log(1)\r\n    // 还没有用到 utils a b 等模块，但是 AMD 已经初始化了所有模块\r\n    console.log(2)\r\n    utils.add(1, 2)\r\n})\r\n\r\n// CMD\r\ndefine(function(require, exports, module){\r\n    console.log(1)\r\n    if(false) {\r\n        var utils = require('./utils') // 需要时再 require，不执行就不会加载\r\n        utils.add(1, 2)\r\n    }\r\n})\r\n```\r\n\r\n但是在 `AMD` 也是支持依赖就近，也就是 `CMD` 这样的写法的，所以，`RequireJS` 中，以上两种方式都能执行。\r\n不过，`RequireJS` 官方文档中，默认都是采用依赖前置的写法。\r\n\r\n## 5. UMD\r\n`UMD` 通用模块定义（Universal Module Definition），同时兼容服务端（CJS）和客户端（AMD）的模块化。\r\n\r\n```javascript\r\n// utils.js 文件同上\r\n(function(root, factory) {\r\n    if (typeof define === 'function' && define.amd) {\r\n        //AMD\r\n        define(['utils'], factory)\r\n    } else if (typeof exports === 'object') {\r\n        //CommonJS\r\n        var utils = require('utils')\r\n        module.exports = factory(utils)\r\n    } else {\r\n        root.result = factory(root.utils)\r\n    }\r\n}(this, function(utils) {\r\n    utils.add(1, 2)\r\n}))\r\n```\r\n\r\n## 6. ES6 模块化\r\n`ES6`（ES2015）自带的模块化，使用 **import** 和 **export** 关键字来导入和导出模块。\r\n\r\n```javascript\r\n// utils.js 文件\r\nexport const utils = {\r\n    add: function(a, b) {\r\n        console.log(a + b)\r\n    }\r\n}\r\n\r\n// main.js 文件\r\nimport { utils } from \"./utils\"\r\nutils.add(1, 2)\r\n```\r\n\r\n## 7. CommonJS 和 ES6 的区别\r\n`CommonJS` 模块输出的是一个值的拷贝，`ES6` 模块输出的是值的引用。\r\n`CommonJS` 模块是运行时加载，`ES6` 模块是编译时输出接口。"}]},{"number":18,"title":"【Q018】IIFE 立即执行函数","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/18","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. IIFE 立即调用函数表达式\r\n`IIFE` (Immediately Invoked Function Expression)是一个在定义时就会立即执行的函数。\r\n\r\n```javascript\r\n(function () {\r\n    // to something...\r\n})();\r\n```\r\n这是一个被称为 **自执行匿名函数** 的设计模式，主要包含两部分。\r\n第一部分是包围在 **圆括号运算符** 里的一个匿名函数，这个匿名函数拥有独立的词法作用域。\r\n这不仅避免了外界访问此 `IIFE` 中的变量，而且又不会污染全局作用域。\r\n\r\n## 2. IIFE 的优点\r\n\r\n- `IIFE` 中定义的任何变量和函数，都会在执行结束时被销毁。适合做初始化工作。\r\n- 创建 **块级作用域** ，避免了向全局作用域中添加变量和函数，因此也避免了多人开发中全局变量和函数的命名冲突。\r\n- `IIFE` 中定义的任何变量和函数，都会在执行结束时被销毁。这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了。"}]},{"number":19,"title":"【Q019】匿名函数","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/19","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 什么是匿名函数\r\n\r\n- `匿名函数`，即没有名称的函数\r\n- 如果单独只写一个匿名函数，此时是不符合语法要求的会报错。需要给 `匿名函数` 包裹一个括号，使之成为 **表达式**\r\n- 被小括号包裹的内容会被js识别为一个函数表达式\r\n\r\n## 2. 创建方式\r\n\r\n```javascript\r\n(function () {\r\n      // to something...\r\n}());\r\n```\r\n"}]},{"number":20,"title":"【Q020】箭头函数","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/20","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 箭头函数\r\n`箭头函数表达式` 的语法比 `函数表达式` 更简洁，并且没有自己的 this、arguments、super或new.target。\r\n`箭头函数表达式` 更适用于那些本来需要 `匿名函数` 的地方，并且它不能用作 `构造函数`。\r\n\r\n```javascript\r\nconst materials = [\r\n  'Hydrogen',\r\n  'Helium',\r\n  'Lithium',\r\n  'Beryllium'\r\n];\r\n\r\nconsole.log(materials.map(material => material.length)); // [8, 6, 7, 9]\r\n```\r\n\r\n## 更短的函数\r\n```javascript\r\nvar elements = [\r\n  'Hydrogen',\r\n  'Helium',\r\n  'Lithium',\r\n  'Beryllium'\r\n];\r\n\r\nelements.map(function(element) {\r\n  return element.length;\r\n}); // [8, 6, 7, 9]\r\n\r\n// 上面的普通函数可以改写成如下的箭头函数\r\nelements.map((element) => {\r\n  return element.length;\r\n});\r\n\r\n// 当箭头函数只有一个参数时，可以省略参数的圆括号\r\nelements.map(element => {\r\n return element.length;\r\n});\r\n\r\n// 当箭头函数的函数体只有一个 `return` 语句时，可以省略 `return` 关键字和方法体的花括号\r\nelements.map(element => element.length);\r\n```\r\n\r\n## 没有单独的this\r\n`箭头函数` 不会创建自己的this，它只会从自己的作用域链的上一层继承 `this`。\r\n```javascript\r\nfunction Person(){\r\n  this.age = 0;\r\n\r\n  setInterval(() => {\r\n    this.age++; // this 正确地指向 p 实例\r\n  }, 1000);\r\n}\r\n\r\nvar p = new Person();\r\n```\r\n\r\n## 与严格模式的关系\r\n鉴于 `this` 是词法层面上的，`严格模式` 中与 `this` 相关的规则都将被忽略。\r\n```javascript\r\nvar f = () => { 'use strict'; return this; };\r\nf() === window; // true\r\n```\r\n\r\n## 通过 call 或 apply 调用\r\n由于 `箭头函数` 没有自己的 `this` 指针，通过 call() 、apply()、bind() 方法调用一个函数时，只能传递参数，他们的第一个参数会被忽略。\r\n```javascript\r\nvar adder = {\r\n  base : 1,\r\n\r\n  add : function(a) {\r\n    var f = v => v + this.base;\r\n    return f(a);\r\n  },\r\n\r\n  addThruCall: function(a) {\r\n    var f = v => v + this.base;\r\n    var b = {\r\n      base : 2\r\n    };\r\n\r\n    return f.call(b, a);\r\n  }\r\n};\r\n\r\nconsole.log(adder.add(1));         // 输出 2\r\nconsole.log(adder.addThruCall(1)); // 仍然输出 2\r\n```\r\n\r\n## 不绑定arguments\r\n`箭头函数` 不绑定Arguments 对象。因此，在本示例中，arguments只是引用了封闭作用域内的 arguments：\r\n```javascript\r\nvar arguments = [1, 2, 3];\r\nvar arr = () => arguments[0];\r\n\r\narr(); // 1\r\n\r\nfunction foo(n) {\r\n  var f = () => arguments[0] + n; // 隐式绑定 foo 函数的 arguments 对象. arguments[0] 是 n，即传给 foo 函数的第一个参数\r\n  return f();\r\n}\r\n\r\nfoo(1); // 2\r\nfoo(2); // 4\r\nfoo(3); // 6\r\nfoo(3,2);//6\r\n```\r\n\r\n## 使用 new 操作符\r\n`箭头函数` 不能用作构造器，和 `new` 一起用会抛出错误。\r\n```javascript\r\nvar Foo = () => {};\r\nvar foo = new Foo(); // TypeError: Foo is not a constructor\r\n```\r\n\r\n## 使用prototype属性\r\n箭头函数没有 `prototype` 属性。\r\n```javascript\r\nvar Foo = () => {};\r\nconsole.log(Foo.prototype); // undefined\r\n```\r\n\r\n## 使用 yield 关键字\r\n`yield` 关键字通常不能在 `箭头函数` 中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作函数生成器。\r\n\r\n## 返回对象字面量\r\n记住用 `params => {object:literal}` 这种简单的语法 **返回对象字面量** 是行不通的。\r\n```javascript\r\nvar func = () => { foo: 1 };\r\n// Calling func() returns undefined!\r\n\r\nvar func = () => { foo: function() {} };\r\n// SyntaxError: function statement requires a name\r\n```\r\n\r\n这是因为花括号（`{}`）里面的代码被解析为一系列语句（即 `foo` 被认为是一个标签，而非对象字面量的组成部分）\r\n所以，记得用圆括号把对象字面量包起来：\r\n\r\n```javascript\r\nvar func = () => ({foo: 1});\r\n```\r\n"}]},{"number":21,"title":"【Q021】函数柯里化","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/21","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 柯里化（Currying）\r\n[柯里化（Currying）](https://en.wikipedia.org/wiki/Currying)是一种关于函数的高阶技术。它不仅被用于 JavaScript，还被用于其他编程语言。\r\n`柯里化` 是一种函数的 **转换** ，它是指将一个函数从可调用的 f(a, b, c) 转换为可调用的 f(a)(b)(c)。\r\n`柯里化` 不会调用函数，它只是对函数进行转换。\r\n\r\n```javascript\r\n// 柯里化函数\r\nfunction curry(f) {\r\n  return function(a) {\r\n    return function(b) {\r\n      return f(a, b);\r\n    };\r\n  };\r\n}\r\n\r\n// 求和函数\r\nfunction sum(a, b) {\r\n  return a + b;\r\n}\r\n\r\nconsole.log(curry(sum)(1)(2)) // 3\r\n```\r\n正如你所看到的，实现非常简单：只有两个包装器（wrapper）。\r\n\r\n- curry(func) 的结果就是一个包装器 function(a)。\r\n- 当它被像 curriedSum(1) 这样调用时，它的参数会被保存在词法环境中，然后返回一个新的包装器 function(b)。\r\n- 然后这个包装器被以 2 为参数调用，并且，它将该调用传递给原始的 sum 函数。\r\n\r\n柯里化更高级的实现，例如 lodash 库的 [_.curry](https://lodash.com/docs#curry)，会返回一个包装器，该包装器允许函数被正常调用或者以偏函数（partial）的方式调用：\r\n```javascript\r\nfunction sum(a, b) {\r\n  return a + b;\r\n}\r\n\r\nvar curriedSum = _.curry(sum); // 使用来自 lodash 库的 _.curry\r\nconsole.log(curriedSum(1, 2)); // 3，仍可正常调用\r\nconsole.log(curriedSum(1)(2)); // 3，以偏函数的方式调用\r\n```\r\n\r\n## 2. 柯里化的目的\r\n要了解它的好处，我们需要一个实际中的例子。\r\n\r\n例如，我们有一个用于格式化和输出信息的日志（logging）函数 `log(date, importance, message)`。\r\n在实际项目中，此类函数具有很多有用的功能，例如通过网络发送日志（log）：\r\n```javascript\r\nfunction log(date, importance, message) {\r\n  console.log(`[${date.getHours()}:${date.getMinutes()}] [${importance}] ${message}`);\r\n}\r\n```\r\n\r\n柯里化之后，log 仍正常运行，也可以以柯里化形式运行：\r\n```javascript\r\nlog = _.curry(log);\r\n\r\nlog(new Date(), \"DEBUG\", \"some debug\"); // log(a, b, c)\r\n\r\nlog(new Date())(\"DEBUG\")(\"some debug\"); // log(a)(b)(c)\r\n```\r\n\r\n现在可以轻松地为当前日志创建便捷函数：\r\n```javascript\r\n// logNow 会是带有固定第一个参数的日志的偏函数\r\nvar logNow = log(new Date());\r\n\r\n// 使用它\r\nlogNow(\"INFO\", \"message\"); // [HH:mm] INFO message\r\n```\r\n\r\n现在，logNow 是具有固定第一个参数的 log，换句话说，就是更简短的“偏应用函数（partially applied function）”或“偏函数（partial）”。\r\n\r\n可以更进一步，为当前的调试日志（debug log）提供便捷函数：\r\n```javascript\r\nvar debugNow = logNow(\"DEBUG\");\r\n\r\ndebugNow(\"message\"); // [HH:mm] DEBUG message\r\n```\r\n\r\n总结：\r\n\r\n- 柯里化之后，我们没有丢失任何东西：log 依然可以被正常调用。\r\n- 我们可以轻松地生成偏函数，例如用于生成今天的日志的偏函数。\r\n\r\n## 3. 柯里化的实现\r\n```javascript\r\nfunction curry(func) {\r\n  return function curried(...args) {\r\n    if (args.length >= func.length) {\r\n      return func.apply(this, args);\r\n    } else {\r\n      return function(...args2) {\r\n        return curried.apply(this, args.concat(args2));\r\n      }\r\n    }\r\n  };\r\n}\r\n```\r\n\r\n## 4. 总结\r\n\r\n- `柯里化` 是一种转换，将 f(a,b,c) 转换为可以被以 f(a)(b)(c) 的形式进行调用。JavaScript 实现通常都保持该函数可以被正常调用，并且如果参数数量不足，则返回偏函数。\r\n- `柯里化` 让我们能够更容易地获取偏函数。就像我们在日志记录示例中看到的那样，普通函数 log(date, importance, message) 在被柯里化之后，当我们调用它的时候传入一个参数（如 log(date)）或两个参数（log(date, importance)）时，它会返回偏函数。"}]},{"number":22,"title":"【Q022】Promise","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/22","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. promise\r\n`Promise` 对象用于表示一个异步操作的最终完成（或失败）及其结果值。\r\n异步方法并不会立即返回最终的值，而是会返回一个 promise，以便在未来某个时候把值交给使用者。\r\n\r\n一个 Promise 必然处于以下几种状态之一：\r\n\r\n- 待定（pending）：初始状态，既没有被兑现，也没有被拒绝。\r\n- 已兑现（fulfilled）：意味着操作成功完成。\r\n- 已拒绝（rejected）：意味着操作失败。\r\n\r\n## 2. Promise 的链式调用\r\n因为 `Promise.prototype.then`、`Promise.prototype.catch` 和 `Promise.prototype.finally`方法返回的是 promise，所以它们可以被链式调用。\r\n![Alt](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/promises.png)\r\n\r\n我们用 promise 的 `then` 方法排列起来的相关处理程序就会被调用。\r\n`.then()` 方法需要两个参数，第一个参数作为处理已兑现状态的回调函数，而第二个参数则作为处理已拒绝状态的回调函数。\r\n```javascript\r\nconst myPromise = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    resolve('foo');\r\n  }, 300);\r\n});\r\n\r\nmyPromise\r\n  .then(handleResolvedA, handleRejectedA)\r\n  .then(handleResolvedB, handleRejectedB)\r\n  .then(handleResolvedC, handleRejectedC);\r\n```\r\n\r\n当 `.then()` 中缺少能够返回 promise 对象的函数时，链式调用就直接继续进行下一环操作。\r\n因此，链式调用可以在最后一个 `.catch()` 之前把所有的处理已拒绝状态的回调函数都省略掉。\r\n```javascript\r\nmyPromise\r\n  .then(handleResolvedA)\r\n  .then(handleResolvedB)\r\n  .then(handleResolvedC)\r\n  .catch(handleRejectedAny);\r\n```\r\n\r\n## 3. finally清理\r\n如果你想在 promise 执行完毕后无论其结果怎样都做一些处理或清理时，`.finally()` 方法可能是有用的。\r\n\r\n`.finally()` 虽然与 `.then(onFinally, onFinally)` 类似，它们不同的是：\r\n\r\n- 调用内联函数时，不需要多次声明该函数或为该函数创建一个变量保存它。\r\n- 由于无法知道 promise 的最终状态，所以 finally 的回调函数中不接收任何参数，它仅用于无论最终结果如何都要执行的情况。"}]},{"number":23,"title":"【Q023】async/await","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/23","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. async 函数\r\n`async` 函数是使用 **async关键字** 声明的函数。`async` 函数是 `AsyncFunction` 构造函数的实例， 并且其中允许使用 **await关键字**。\r\n**async和await关键字** 让我们可以用一种更简洁的方式写出基于`Promise` 的异步行为，而无需刻意地链式调用 `promise`。\r\n\r\n在函数前面的 **async关键字** 做了一件事情：使用函数始终返回一个 promise。其他值将自动被包装在一个 resolved 的 promise 中。\r\n```javascript\r\nasync function f() {\r\n  return 1;\r\n}\r\n\r\nasync function f2() {\r\n  return Promise.resolve(1);\r\n}\r\n\r\nf().then(console.log); // 1\r\nf2().then(console.log); // 1\r\n```\r\n\r\n## 2. await 关键字\r\n`await` 让 JavaScript 引擎等待直到 promise 完成（settle）并返回结果。\r\n```javascript\r\nasync function f() {\r\n  var promise = new Promise((resolve, reject) => {\r\n    setTimeout(() => resolve(\"done!\"), 1000)\r\n  });\r\n\r\n  var result = await promise; // 等待，直到 promise resolve (*)\r\n  console.log(result); // \"done!\"\r\n}\r\n\r\nf();\r\n```\r\n这个函数在执行的时候，“暂停”在了` (*)` 那一行，并在 promise settle 时，拿到 `result` 作为结果继续往下执行。\r\n所以上面这段代码在一秒后显示 “done!”。\r\n\r\n强调一下：await 实际上会暂停函数的执行，直到 promise 状态变为 settled，然后以 promise 的结果继续执行。\r\n这个行为不会耗费任何 CPU 资源，因为 JavaScript 引擎可以同时处理其他任务：执行其他脚本，处理事件等。\r\n\r\n相比于 promise.then，它只是获取 promise 的结果的一个更优雅的语法，并且也更易于读写。\r\n\r\n## 3. Error 处理\r\n如果一个 promise 正常 resolve，`await promise` 返回的就是其结果。\r\n但是如果 promise 被 reject，它将 throw 这个 error，就像在这一行有一个 `throw` 语句那样。\r\n\r\n可以在函数调用后面添加 .catch 来处理这个 error：\r\n```javascript\r\nasync function f() {\r\n  var response = await fetch('http://no-such-url/');\r\n}\r\n\r\n// f() 变成了一个 rejected 的 promise\r\nf().catch(console.log); // TypeError: failed to fetch // (*)\r\n```\r\n\r\n## 4. 总结\r\n函数前面的关键字 async 有两个作用：\r\n\r\n- 让这个函数总是返回一个 promise。\r\n- 允许在该函数内使用 await。\r\n\r\nPromise 前的关键字 await 使 JavaScript 引擎等待该 promise settle，然后有两种情况：\r\n\r\n- 如果有 error，就会抛出异常 —— 就像那里调用了 throw error 一样。\r\n- 否则，就返回结果。\r\n\r\n"}]},{"number":24,"title":"【Q024】Generator","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/24","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. function* 生成器函数\r\n`function*` 这种声明方式会定义一个 **生成器函数** (generator function)，它返回一个 `Generator对象`。\r\n```javascript\r\nfunction* generator(i) {\r\n  yield i;\r\n  yield i + 10;\r\n}\r\n\r\nconst gen = generator(10);\r\nconsole.log(gen.next().value); // 10\r\nconsole.log(gen.next().value); // 20\r\n```\r\n\r\n**生成器函数** 在执行时能暂停，后面又能从暂停处继续执行。\r\n\r\n调用一个生成器函数并不会马上执行它里面的语句，而是返回一个这个生成器的 **迭代器（iterator）对象**。\r\n当这个迭代器的 `next()` 方法被调用时，其内的语句会执行到后续出现 `yield` 的位置为止，`yield` 后紧跟迭代器要返回的值。\r\n或者如果用的是 `yield*`，则表示将执行权移交给另一个生成器函数（当前生成器暂停执行）。\r\n\r\n调用 `next()` 方法时，如果传入了参数，那么这个参数会传给**上一条执行的 yield 语句左边的变量**，例如下面例子中的x：\r\n```javascript\r\nfunction *gen(){\r\n    yield 10;\r\n    x = yield 'foo';\r\n    yield x;\r\n}\r\n\r\nvar gen_obj = gen();\r\nconsole.log(gen_obj.next());// 执行 yield 10，返回 10\r\nconsole.log(gen_obj.next());// 执行 yield 'foo'，返回 'foo'\r\nconsole.log(gen_obj.next(100));// 将 100 赋给上一条 yield 'foo' 的左值，即执行 x=100，返回 100\r\nconsole.log(gen_obj.next());// 执行完毕，value 为 undefined，done 为 true\r\n\r\n```\r\n\r\nyield* 的示例：\r\n```javascript\r\nfunction* anotherGenerator(i) {\r\n  yield i + 1;\r\n  yield i + 2;\r\n  yield i + 3;\r\n}\r\n\r\nfunction* generator(i){\r\n  yield i;\r\n  yield* anotherGenerator(i);// 移交执行权\r\n  yield i + 10;\r\n}\r\n\r\nvar gen = generator(10);\r\nconsole.log(gen.next().value); // 10\r\nconsole.log(gen.next().value); // 11\r\nconsole.log(gen.next().value); // 12\r\nconsole.log(gen.next().value); // 13\r\nconsole.log(gen.next().value); // 20\r\n```\r\n\r\n## 2. Generator对象\r\n`生成器对象` 是由一个 `generator function` 返回的。\r\n```javascript\r\nfunction* gen() {\r\n  yield 1;\r\n  yield 2;\r\n  yield 3;\r\n}\r\n\r\nlet g = gen(); // \"Generator { }\"\r\n```\r\n\r\n## 3. 迭代器对象 iterator\r\n挖坑ing"}]},{"number":25,"title":"【Q025】对象遍历 和 数组遍历","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/25","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"# 一. 对象遍历\r\n## 1. for...in\r\n`for...in` 语句以任意顺序迭代一个对象的除[Symbol](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol)以外的[可枚举](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties)属性，包括继承的可枚举属性。\r\n\r\n```javascript\r\nvar obj = {a:1, b:2, c:3};\r\n\r\nfor (var prop in obj) {\r\n  console.log(\"obj.\" + prop + \" = \" + obj[prop]);\r\n}\r\n\r\n// \"obj.a = 1\"\r\n// \"obj.b = 2\"\r\n// \"obj.c = 3\"\r\n```\r\n\r\n`for...in` 还会获取到**原型链上的可枚举属性**，不过可以使用 `hasOwnProperty()` 方法过滤掉。\r\n```javascript\r\nvar triangle = {a: 1, b: 2, c: 3};\r\n\r\nfunction ColoredTriangle() {\r\n  this.color = 'red';\r\n}\r\n\r\nColoredTriangle.prototype = triangle;\r\n\r\nvar obj = new ColoredTriangle();\r\n\r\nfor (var prop in obj) {\r\n  if (obj.hasOwnProperty(prop)) {\r\n    console.log(`obj.${prop} = ${obj[prop]}`);\r\n  }\r\n}\r\n\r\n// \"obj.color = red\"\r\n```\r\n\r\n### 为什么用 for ... in?\r\n\r\n它最常用的地方应该是用于调试，可以更方便的去检查对象属性。\r\n你在处理有key-value数据，需要检查其中的任何键是否为某值的情况时，推荐用 `for...in`。\r\n\r\n## 2. for...of\r\n`for...of`语句在 **可迭代对象**（包括Array，Map，Set，String，TypedArray，arguments） 上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。\r\n\r\n如果使用 `for...of` 遍历对象，需要给对象的原型一个迭代器方法：\r\n```javascript\r\nvar obj = {\r\n    a:1,\r\n    b:2,\r\n    c:3\r\n};\r\n\r\nobj[Symbol.iterator] = function*(){\r\n    var keys = Object.keys(obj);\r\n    for(var k of keys){\r\n        yield k\r\n    }\r\n};\r\n\r\nfor(var k of obj){\r\n    console.log(k, obj[k]);\r\n}\r\n\r\n// 'a' 1\r\n// 'b' 2\r\n// 'c' 3\r\n```\r\n\r\n### for...of与for...in的区别?\r\n\r\n无论是 `for...in` 还是 `for...of` 语句都是迭代一些东西。它们之间的主要区别在于它们的迭代方式。\r\n- `for...in` 可以迭代Object。\r\n- `for...of` 可以迭代Array等其他 **可迭代对象** ，想迭代Object要给一个迭代器属性。\r\n- `for...in` 还会获取到**原型链上的可枚举属性**\r\n\r\n## 3. Object.keys()\r\n`Object.keys()` 方法会返回一个由一个给定对象的自身可枚举 **属性名（key）组成的数组**，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致。\r\n\r\n```javascript\r\nconst object1 = {\r\n  a: 'somestring',\r\n  b: 42,\r\n  c: false\r\n};\r\n\r\nconsole.log(Object.keys(object1)); //  [\"a\", \"b\", \"c\"]\r\n```\r\n注意：\r\n\r\n- 在 ES5 中，如果此方法的参数不是对象（而是一个原始值），那么它会抛出 **TypeError**。\r\n- 在 ES6 中，非对象的参数将被强制转换为一个对象。\r\n\r\n## 4. Object.getOwnPropertyNames()\r\n`Object.getOwnPropertyNames()` 方法返回一个由指定对象的所有自身属性的 **属性名（key）组成的数组**（属性名 包括不可枚举属性但不包括 `Symbol` 值作为名称的属性）。\r\n\r\n```javascript\r\n// 数组对象\r\nvar arr = [\"a\", \"b\", \"c\"];\r\nconsole.log(Object.getOwnPropertyNames(arr).sort()); // [\"0\", \"1\", \"2\", \"length\"]\r\n\r\n// 类数组对象\r\nvar obj = { 0: \"a\", 1: \"b\", 2: \"c\"};\r\nconsole.log(Object.getOwnPropertyNames(obj).sort()); // [\"0\", \"1\", \"2\"]\r\n\r\n//不可枚举属性\r\nvar my_obj = Object.create({}, {\r\n  getFoo: {\r\n    value: function() { return this.foo; },\r\n    enumerable: false\r\n  }\r\n});\r\nmy_obj.foo = 1;\r\nconsole.log(Object.getOwnPropertyNames(my_obj).sort()); // [\"foo\", \"getFoo\"]\r\n```\r\n\r\n### 如果你只要获取到可枚举属性，请使用 `Object.keys` 或用 `for...in` 循环。\r\n\r\n## 5. Object.getOwnPropertySymbols()\r\n`Object.getOwnPropertySymbols()` 方法返回一个给定对象自身的所有 `Symbol` 属性的数组。\r\n\r\n```javascript\r\nvar obj = {};\r\nvar a = Symbol(\"a\");\r\nvar b = Symbol.for(\"b\");\r\n\r\nobj[a] = \"localSymbol\";\r\nobj[b] = \"globalSymbol\";\r\n\r\nvar objectSymbols = Object.getOwnPropertySymbols(obj);\r\n\r\nconsole.log(objectSymbols.length); // 2\r\nconsole.log(objectSymbols)         // [Symbol(a), Symbol(b)]\r\nconsole.log(objectSymbols[0])      // Symbol(a)\r\n```\r\n\r\n### 与 `Object.getOwnPropertyNames()` 类似，您可以将给定对象的所有符号属性作为 `Symbol` 数组获取。\r\n请注意，`Object.getOwnPropertyNames()` 本身不包含对象的 `Symbol` 属性，只包含字符串属性。\r\n\r\n因为所有的对象在初始化的时候不会包含任何的 `Symbol`，除非你在对象上赋值了 `Symbol` 否则Object.getOwnPropertySymbols()只会返回一个空的数组。\r\n\r\n## 6. Reflect.ownKeys()\r\n`Reflect.ownKeys()` 返回一个由目标对象自身的**属性键（key）组成的数组**。\r\n```javascript\r\nconst object1 = {\r\n  property1: 42,\r\n  property2: 13\r\n};\r\n\r\nconst array1 = [];\r\n\r\nconsole.log(Reflect.ownKeys(object1)); // [\"property1\", \"property2\"]\r\nconsole.log(Reflect.ownKeys(array1)); //  [\"length\"]\r\n```\r\n\r\n### Reflect.ownKeys 方法返回一个由目标对象自身的属性键组成的数组。它的返回值等同于`Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))`。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"# 二、数组遍历\r\n## 1. for 循环\r\n`for循环` 很古老，它在 ECMAScript 1 中就已经存在了。for 循环记录 arr 每个元素的索引和值：\r\n```javascript\r\nconst arr = ['a', 'b', 'c'];\r\narr.prop = 'property value';\r\n\r\nfor (let index=0; index < arr.length; index++) {\r\n  const elem = arr[index];\r\n  console.log(index, elem);\r\n}\r\n\r\n// 0, 'a'\r\n// 1, 'b'\r\n// 2, 'c'\r\n```\r\n\r\n### for 循环的优缺点是什么？\r\n\r\n- 优：它用途广泛。\r\n- 缺：但是当我们要遍历数组时也很麻烦。\r\n- 优：如果我们不想从第一个数组元素开始循环时它仍然很有用，用其他的循环机制很难做到这一点。\r\n\r\n## 2. for-in循环\r\n`for-in循环` 与 `for循环` 一样古老，同样在 ECMAScript 1中就存在了。下面的代码用 for-in 循环输出 arr 的 key：\r\n```javascript\r\nconst arr = ['a', 'b', 'c'];\r\narr.prop = 'property value';\r\n\r\nfor (const key in arr) {\r\n  console.log(key);\r\n}\r\n\r\n// '0'\r\n// '1'\r\n// '2'\r\n// 'prop'\r\n```\r\n\r\n### for-in 不是循环遍历数组的好方法：\r\n\r\n- 它访问的是属性键（key），而不是值（value）。\r\n- 作为属性键（key），数组元素的索引是字符串，而不是数字。\r\n- 它访问的是所有可枚举的属性键（自己的和继承的），而不仅仅是 `Array` 元素的那些。\r\n\r\n### for-in 访问继承属性的实际用途是：遍历对象的所有可枚举属性。\r\n\r\n## 3. 数组方法 .forEach()\r\n鉴于 `for` 和 `for-in` 都不特别适合在数组上循环，因此在 ECMAScript 5 中引入了一个辅助方法：Array.prototype.forEach()：\r\n```javascript\r\nconst arr = ['a', 'b', 'c'];\r\narr.prop = 'property value';\r\n\r\narr.forEach((elem, index) => {\r\n  console.log(elem, index);\r\n});\r\n\r\n// 'a', 0\r\n// 'b', 1\r\n// 'c', 2\r\n```\r\n\r\n### forEach 循环的优缺点是什么？\r\n\r\n- 优：它使我们无需执行大量操作就能够可访问数组元素和索引。\r\n- 缺：不能在它的循环体中使用 `await`。\r\n- 缺：不能提前退出 `forEach()循环`。而在 `for循环` 中可以使用 `break`。\r\n\r\n### 中止 .forEach() 的解决方法\r\n\r\n## 4. 数组方法 .some()\r\n如果想要中止 `.forEach()` 之类的循环，建议使用：`.some()` \r\n`.some()` 还会循环遍历所有数组元素，并在其回调返回真值时停止。\r\n```javascript\r\nconst arr = ['red', 'green', 'blue'];\r\narr.some((elem, index) => {\r\n  if (index >= 2) {\r\n    return true; // 中止循环\r\n  }\r\n  console.log(elem);\r\n  //此回调隐式返回 `undefined`，这\r\n  //是一个伪值。 因此，循环继续。\r\n});\r\n\r\n// 'red'\r\n// 'green'\r\n```\r\n\r\n## 5. for-of 循环\r\nfor-of 循环在 ECMAScript 6 开始支持：\r\n\r\n```javascript\r\nconst arr = ['a', 'b', 'c'];\r\narr.prop = 'property value';\r\n\r\nfor (const elem of arr) {\r\n  console.log(elem);\r\n}\r\n\r\n// 'a'\r\n// 'b'\r\n// 'c'\r\n```\r\n\r\n### for-of 在循环遍历数组时非常有效：\r\n\r\n- 用来遍历数组元素。\r\n- 可以使用 `await`。\r\n- 可以将 `break` 和 `continue` 用于外部作用域。\r\n\r\n## 6. 总结\r\n`for-of` 循环的可用性比 `for`，`for-in` 和 `.forEach()` 更好。\r\n\r\n通常四种循环机制之间的性能差异应该是无关紧要。\r\n如果你要做一些运算量很大的事，还是切换到 `WebAssembly` 更好一些。\r\n\r\n"}]},{"number":26,"title":"【Q026】常见的数组方法","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/26","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"# 一、数组遍历相关\r\n## 1. Array.prototype.entries()\r\n`entries()` 方法返回一个新的 **Array Iterator** 对象，该对象包含数组中每个索引的键/值对。\r\n```javascript\r\nconst array1 = ['a', 'b', 'c'];\r\nconst iterator1 = array1.entries();\r\n\r\nconsole.log(iterator1.next().value); // [0, \"a\"]\r\nconsole.log(iterator1.next().value); // [1, \"b\"]\r\n```\r\n\r\n### 常用于与 `for...of` 构成数组遍历：\r\n```javascript\r\nconst a = [\"a\", \"b\", \"c\"];\r\n\r\nfor (const [index, element] of a.entries()) {\r\n    console.log(index, element);\r\n}\r\n\r\n// 0 'a'\r\n// 1 'b'\r\n// 2 'c'\r\n```\r\n\r\n## 2. Array.prototype.every()\r\n`every()` 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。\r\n\r\n备注： 若收到一个空数组，此方法在任何情况下都会返回 true。\r\n\r\n```javascript\r\nconst array1 = [1, 30, 39, 29, 10, 13];\r\n\r\nconst flag = array1.every((item) => item < 40);\r\nconsole.log(flag); // true\r\n```\r\n\r\n### 常用于判断每一项都符合条件\r\n\r\n## 3. Array.prototype.filter()\r\n`filter()` 方法创建给定数组一部分的 `浅拷贝`，其包含通过所提供函数实现的测试的所有元素。\r\n```javascript\r\nconst words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];\r\n\r\nconst result = words.filter(word => word.length > 6);\r\nconsole.log(result); // [\"exuberant\", \"destruction\", \"present\"]\r\n```\r\n\r\n### 常用于筛选数组\r\n\r\n## 4. Array.prototype.flat()\r\n`flat()` 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。\r\n\r\n根据参数提取嵌套数组的结构深度，默认值为 1：\r\n```javascript\r\nconst arr1 = [0, 1, 2, [3, 4], [[5, 6]]];\r\n\r\nconsole.log(arr1.flat()); // [0, 1, 2, 3, 4, [5, 6]]\r\nconsole.log(arr1.flat(2)); // [0, 1, 2, 3, 4, 5, 6]\r\n```\r\n\r\n还可以移除数组中的空项：\r\n```javascript\r\nvar arr4 = [1, 2, , 4, 5];\r\n\r\nconsole.log(arr4.flat()); // [1, 2, 4, 5]\r\n````\r\n\r\n### 常用于数组降维\r\n\r\n## 5. Array.prototype.flatMap()\r\n`flatMap()` 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。\r\n它与 `map` 连着深度值为 1 的 `flat` 的效果几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些。\r\n\r\n```javascript\r\nconst arr1 = [1, 2, [3], [4, 5], 6, []];\r\n\r\nconsole.log(arr1.flatMap(num => num)); // [1, 2, 3, 4, 5, 6]\r\n// 效果等同于\r\nconsole.log(arr1.map(num => num).flat()) // [1, 2, 3, 4, 5, 6]\r\n```\r\n\r\n### 可用于 需要在 `map()` 时 **插入/减少** 某一项\r\n```javascript\r\nvar a = [5, 4, -3, 20, 17, -33, -4, 18]\r\n\r\na.flatMap((n) => {\r\n  if (n < 0) return [];\r\n  if (n % 2 == 0) return [n];\r\n  return [n-1, 1]\r\n})\r\n\r\nconsole.log(a); // [4, 1, 4, 20, 16, 1, 18]\r\n```\r\n\r\n替代方案（低效，不推荐）：\r\n\r\n`reduce()` 加 `concat()`\r\n```javascript\r\nvar arr = [1, 2, 3, 4];\r\n\r\narr.flatMap(x => [x, x * 2]); // [1, 2, 2, 4, 3, 6, 4, 8]\r\n// \r\narr.reduce((acc, x) => acc.concat([x, x * 2]), []); // [1, 2, 2, 4, 3, 6, 4, 8]\r\n```\r\n\r\n## 6. Array.prototype.forEach()\r\n`forEach()` 方法对数组的每个元素执行一次给定的函数。\r\n```javascript\r\nconst array1 = ['a', 'b', 'c'];\r\n\r\narray1.forEach(element => console.log(element));\r\n\r\n// \"a\"\r\n// \"b\"\r\n// \"c\"\r\n```\r\n\r\n`forEach` 不会直接改变调用它的对象，但是那个对象可能会被 `callbackFn` 函数改变。\r\n\r\n备注：除了抛出异常以外，没有办法中止或跳出 forEach() 循环。\r\n\r\n若你需要提前终止循环，你可以使用：\r\n\r\n- for循环\r\n- for...in/for...of 循环\r\n- Array.prototype.every()\r\n- Array.prototype.some()\r\n- Array.prototype.find()\r\n- Array.prototype.findIndex()\r\n\r\n最后四个方法，甚至可以对数组元素判断，以便确定是否需要继续遍历。\r\n\r\n### 常用于 *不需要异步* 且 *不需要提前跳出* 的数组循环。\r\n\r\n## 7. Array.prototype.keys()\r\n`keys()` 方法返回一个包含数组中每个索引键的 `Array Iterator` 对象。\r\n```javascript\r\nconst array1 = ['a', 'b', 'c'];\r\nconst iterator = array1.keys();\r\n\r\nfor (const key of iterator) {\r\n  console.log(key);\r\n}\r\n\r\n// 0\r\n// 1\r\n// 2\r\n```\r\n\r\n### 此方法很少使用\r\n\r\n## 8. Array.prototype.map()\r\n`map()` 方法 **创建一个新数组**，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。\r\n```javascript\r\nconst array1 = [1, 4, 9, 16];\r\n\r\nconsole.log(array1.map(x => x * 2)); // [2, 8, 18, 32]\r\n```\r\n\r\n若你不想返回的新数组，请使用 `forEach()` 或 `for...of`。\r\n\r\n### 常用于 遍历修改某一项 且 创建新数组。\r\n\r\n### 经典八股文：\r\n```javascript\r\n[\"1\", \"2\", \"3\"].map(parseInt); \r\n```\r\n我们期望输出 [1, 2, 3], 而实际结果是 [1, NaN, NaN]\r\n\r\n`parseInt` 经常被带着一个参数使用，但是这里接受两个。\r\n第一个参数是一个表达式而第二个是回调函数的基，`Array.prototype.map` 传递 3 个参数：element，index，array\r\n\r\n第三个参数被 `parseInt` 忽视了，但不是第二个。因此可能出现混淆。\r\n下面是迭代步骤的拆解：\r\n```javascript\r\nparseInt(\"1\", 0); // 1\r\nparseInt(\"2\", 1); // NaN\r\nparseInt(\"3\", 2); // NaN\r\n```\r\n\r\n## 9. Array.prototype.reduce()\r\n`reduce()` 方法对数组中的每个元素按序执行一个由您提供的 **reducer** 函数。\r\n每一次运行 **reducer** 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。\r\n```javascript\r\nconst array1 = [1, 2, 3, 4];\r\n\r\n// 求和\r\nconst initialValue = 0;\r\nconst sum = array1.reduce((prev, cur) => prev + cur, initialValue);\r\n\r\nconsole.log(sum); // 10\r\n```\r\n\r\n### 常用于累加对象数组里的值，例如求和\r\n\r\n数组去重\r\n```javascript\r\nvar arrary1 = ['a', 'b', 'a', 'b', 'c', 'e', 'e', 'c', 'd', 'd', 'd', 'd']\r\n\r\nvar array2 = arrary1.reduce((prev, cur) => {\r\n  if (prev.indexOf(cur) === -1) prev.push(cur)\r\n  return prev\r\n}, [])\r\n\r\nconsole.log(array2); // ['a', 'b', 'c', 'e', 'd']\r\n```\r\n\r\n对象数组分组\r\n```javascript\r\nvar array1 = [\r\n  { type: 'fruit', name: 'apple' },\r\n  { type: 'vegetable', name: 'tomato' },\r\n  { type: 'fruit', name: 'mango' },\r\n]\r\n\r\nconst dictionary = {};\r\n\r\narray1.reduce((prev, cur) => {\r\n  if (prev[cur.type]) {\r\n    prev[cur.type].push(cur)\r\n  } else {\r\n    prev[cur.type] = [cur]\r\n  }\r\n  return prev\r\n}, dictionary)\r\n\r\nconsole.log(dictionary); // {fruit: Array(2), vegetable: Array(1)}\r\n```\r\n\r\n## 10. Array.prototype.reduceRight()\r\n`reduceRight()` 方法接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。\r\n```javascript\r\nconst array1 = [[0, 1], [2, 3], [4, 5]];\r\n\r\nconst result = array1.reduceRight((acc, cur) => acc.concat(cur));\r\nconsole.log(result); // [4, 5, 2, 3, 0, 1]\r\n```\r\n\r\n### `reduce` 与 `reduceRight` 之间的区别：正序遍历和倒序遍历\r\n```javascript\r\nvar a = ['1', '2', '3', '4', '5'];\r\nvar left  = a.reduce((prev, cur) => prev + cur);\r\nvar right = a.reduceRight((prev, cur) => prev + cur);\r\n\r\nconsole.log(left);  // \"12345\"\r\nconsole.log(right); // \"54321\"\r\n```\r\n\r\n## 11. Array.prototype.some()\r\n`some()` 方法测试数组中是不是至少有 1 个元素通过了被提供的函数测试。它返回的是一个 `Boolean` 类型的值。\r\n```javascript\r\nconst array = [1, 2, 3, 4, 5];\r\n\r\nconsole.log(array.some((item) => item % 2 === 0)); // true\r\n```\r\n\r\n备注： 如果用一个空数组进行测试，在任何情况下它返回的都是false。\r\n\r\n### 常用于检查数组是否存在不符合条件的值。（性能推荐，找到第一个值就跳出循环）\r\n\r\n## 12. Array.prototype.values()\r\n`values()` 方法返回一个新的 `Array Iterator` 对象，该对象包含数组每个索引的值。\r\n```javascript\r\nconst array1 = ['a', 'b', 'c'];\r\nconst iterator = array1.values();\r\n\r\nfor (const value of iterator) {\r\n  console.log(value);\r\n}\r\n\r\n// \"a\"\r\n// \"b\"\r\n// \"c\"\r\n```\r\n\r\n### 与 `key()` 方法一样很少被使用\r\n\r\n## 13. Array.prototype[@@iterator]()\r\n`@@iterator` 和 `values()` 的初始值是同一个函数对象。\r\n\r\n### 同 `values()` 方法使用"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"# 二、数组增删改\r\n## 1. Array.prototype.concat()\r\n`concat()` 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。\r\n```javascript\r\nconst array1 = ['a', 'b', 'c'];\r\nconst array2 = ['d', 'e', 'f'];\r\nconst array3 = array1.concat(array2);\r\n\r\nconsole.log(array3); // [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]\r\n```\r\n\r\n### 常用于合并数组\r\n\r\n使用 Symbol.isConcatSpreadable 合并类数组对象\r\n`concat` 默认情况下不会将类数组对象视作数组——仅在 `Symbol.isConcatSpreadable` 被设置为真值（例如，true）时才会将类数组对象视作数组。\r\n```javascript\r\nconst obj1 = { 0: 1, 1: 2, 2: 3, length: 3 };\r\nconst obj2 = { 0: 1, 1: 2, 2: 3, length: 3, [Symbol.isConcatSpreadable]: true };\r\n\r\nconsole.log([0].concat(obj1, obj2)); // [ 0, { '0': 1, '1': 2, '2': 3, length: 3 }, 1, 2, 3 ]\r\n```\r\n\r\n## 2. Array.prototype.copyWithin()\r\n`copyWithin()` 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。\r\n```javascript\r\nconst array1 = ['a', 'b', 'c', 'd', 'e'];\r\n\r\nconsole.log(array1.copyWithin(0, 3, 4)); // [\"d\", \"b\", \"c\", \"d\", \"e\"]\r\nconsole.log(array1.copyWithin(1, 3)); // [\"d\", \"d\", \"e\", \"d\", \"e\"]\r\n```\r\n\r\n### `copyWithin` 就像 C 和 C++ 的 `memcpy` 函数一样，且它是用来移动 `Array` 或者 `TypedArray` 数据的一个高性能的方法。\r\n复制以及粘贴序列这两者是为一体的操作;即使复制和粘贴区域重叠，粘贴的序列也会有拷贝来的值。\r\n\r\n## 3. Array.prototype.fill()\r\n`fill()` 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。\r\n```javascript\r\nconst array1 = [1, 2, 3, 4];\r\n\r\nconsole.log(array1.fill(0, 2, 4)); // [1, 2, 0, 0]\r\nconsole.log(array1.fill(5, 1)); // [1, 5, 5, 5]\r\nconsole.log(array1.fill(6)); // [6, 6, 6, 6]\r\n```\r\n\r\n### 常用于快速填充数组\r\n\r\n## 4. Array.prototype.pop()\r\n`pop()` 方法从数组中删除最后一个元素，并返回该元素的值。此方法会更改数组的长度。\r\n```javascript\r\nconst plants = ['broccoli', 'cauliflower', 'cabbage', 'kale', 'tomato'];\r\n\r\nconsole.log(plants.pop()); // \"tomato\"\r\nconsole.log(plants); // [\"broccoli\", \"cauliflower\", \"cabbage\", \"kale\"]\r\n\r\nplants.pop();\r\nconsole.log(plants); // [\"broccoli\", \"cauliflower\", \"cabbage\"]\r\n```\r\n\r\n### 常用于删除掉数组的最后一位\r\n\r\n## 5. Array.prototype.push()\r\n`push()` 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。\r\n```javascript\r\nconst animals = ['pigs', 'goats', 'sheep'];\r\n\r\nconst count = animals.push('cows');\r\nconsole.log(count); // 4\r\nconsole.log(animals); // [\"pigs\", \"goats\", \"sheep\", \"cows\"]\r\n\r\nanimals.push('chickens', 'cats', 'dogs');\r\nconsole.log(animals); // [\"pigs\", \"goats\", \"sheep\", \"cows\", \"chickens\", \"cats\", \"dogs\"]\r\n```\r\n\r\n### 常用于给数组添加元素\r\n\r\n合并两个数组\r\n```javascript\r\nvar vegetables = ['parsnip', 'potato'];\r\nvar moreVegs = ['celery', 'beetroot'];\r\n\r\n// 相当于 vegetables.push(...moreVegs);\r\nArray.prototype.push.apply(vegetables, moreVegs);\r\n\r\nconsole.log(vegetables); // ['parsnip', 'potato', 'celery', 'beetroot']\r\n```\r\n\r\n像数组一样使用对象\r\n`push` 是特意设计为通用的，我们可以使用它来获得便利。\r\n```javascript\r\nvar obj = {\r\n    length: 0,\r\n\r\n    addElem: function addElem (elem) {\r\n        // obj.length is automatically incremented\r\n        // every time an element is added.\r\n        [].push.call(this, elem);\r\n    }\r\n};\r\n\r\nobj.addElem({});\r\nobj.addElem({});\r\n\r\nconsole.log(obj.length); // 2\r\nconsole.log(obj); // {0: {}, 1: {}, length: 2, addElem: ƒ}\r\n```\r\n\r\n## 6. Array.prototype.shift()\r\n`shift()` 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。\r\n```javascript\r\nconst array1 = [1, 2, 3];\r\n\r\nconst firstElement = array1.shift();\r\n\r\nconsole.log(array1); // [2, 3]\r\nconsole.log(firstElement); // 1\r\n```\r\n\r\n### 常用于删除数组中第一位\r\n\r\n## 7. Array.prototype.slice()\r\n`slice()` 方法返回一个新的数组对象，这一对象是一个由 `begin` 和 `end` 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。\r\n```javascript\r\nconst animals = ['ant', 'bison', 'camel', 'duck', 'elephant'];\r\n\r\nconsole.log(animals.slice(2)); // [\"camel\", \"duck\", \"elephant\"]\r\nconsole.log(animals.slice(2, 4)); // [\"camel\", \"duck\"]\r\nconsole.log(animals.slice(1, 5)); // [\"bison\", \"camel\", \"duck\", \"elephant\"]\r\nconsole.log(animals.slice(-2)); // [\"duck\", \"elephant\"]\r\nconsole.log(animals.slice(2, -1)); // [\"camel\", \"duck\"]\r\nconsole.log(animals.slice()); // [\"ant\", \"bison\", \"camel\", \"duck\", \"elephant\"]\r\n```\r\n\r\n### 常用于截取数组\r\n\r\n类数组对象转数组\r\n```javascript\r\nfunction list() {\r\n  return Array.prototype.slice.call(arguments);\r\n}\r\n\r\nvar list1 = list(1, 2, 3); // [1, 2, 3]\r\n```\r\n除了使用 `Array.prototype.slice.call(arguments)`，你也可以简单的使用 `[].slice.call(arguments) 来代替`。另外，你可以使用 `bind` 来简化该过程。\r\n```javascript\r\nfunction list() {\r\n  return Function.prototype.call.bind(Array.prototype.slice)(arguments);\r\n}\r\n\r\nvar list1 = list(1, 2, 3); // [1, 2, 3]\r\n```\r\n\r\n## 8. Array.prototype.splice()\r\n`splice()` 方法通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容。此方法会改变原数组。\r\n```javascript\r\nconst months = ['Jan', 'March', 'April', 'June'];\r\nmonths.splice(1, 0, 'Feb');\r\n\r\nconsole.log(months); // [\"Jan\", \"Feb\", \"March\", \"April\", \"June\"]\r\n\r\nmonths.splice(4, 1, 'May');\r\n\r\nconsole.log(months); // [\"Jan\", \"Feb\", \"March\", \"April\", \"May\"]\r\n```\r\n\r\n### 常用于替换数组中某一段\r\n\r\n## 9. Array.prototype.unshift()\r\n`unshift()` 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度。\r\n```javascript\r\nconst array1 = [1, 2, 3];\r\n\r\nconsole.log(array1.unshift(4, 5)); // 5\r\nconsole.log(array1); // [4, 5, 1, 2, 3]\r\n```\r\n\r\n### 常用于添加多个元素到数组开头"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"# 3. 数组查询\r\n## 1. Array.prototype.at()\r\n`at()` 方法接收一个整数值并返回该索引的项目，允许正数和负数。负整数从数组中的最后一个项目开始倒数。\r\n```javascript\r\nconst array1 = [5, 12, 8, 130, 44];\r\n\r\nlet index = 2;\r\nconsole.log(`${index}: ${array1.at(index)}`); // \"2: 8\"\r\n\r\nindex = -2;\r\nconsole.log(`${index}: ${array1.at(index)}`); // \"-2: 130\"\r\n```\r\n\r\n### 常用于快速寻找数组最后一个值\r\n\r\n比较不同的数组方法\r\n这个例子比较了选择 `Array` 中倒数第二项的不同方法，凸显了 `at()` 方法的简洁性和可读性。\r\n```javascript\r\n// 数组及数组元素。\r\nconst colors = ['red', 'green', 'blue'];\r\n\r\n// 使用长度属性。\r\nconst lengthWay = colors[colors.length-2];\r\nconsole.log(lengthWay); // 'green'\r\n\r\n// 使用 slice() 方法。注意会返回一个数组。\r\nconst sliceWay = colors.slice(-2, -1);\r\nconsole.log(sliceWay[0]); // 'green'\r\n\r\n// 使用 at() 方法。\r\nconst atWay = colors.at(-2);\r\nconsole.log(atWay); // 'green'\r\n```\r\n\r\n## 2. Array.prototype.find()\r\n`find()` 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 `undefined`。\r\n```javascript\r\nconst array1 = [5, 12, 8, 130, 44];\r\n\r\nconst found = array1.find(element => element > 10);\r\nconsole.log(found); // 12\r\n```\r\n\r\n### 常用于 用对象的属性查找数组里的对象\r\n```javascript\r\nconst inventory = [\r\n  {name: 'apples', quantity: 2},\r\n  {name: 'bananas', quantity: 0},\r\n  {name: 'cherries', quantity: 5}\r\n];\r\n\r\nvar item = inventory.find(item => item.name === 'cherries');\r\nconsole.log(item); // { name: 'cherries', quantity: 5 }\r\n```\r\n\r\n## 3. Array.prototype.findIndex()\r\n`findIndex()` 方法返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1。\r\n```javascript\r\nconst array1 = [5, 12, 8, 130, 44];\r\n\r\nconst index = array1.findIndex(element => element > 13);\r\nconsole.log(index); // 3\r\n```\r\n\r\n### 常用于 查找数组中第一个匹配元素的索引。\r\n\r\n## 4. Array.prototype.findLast()\r\n`findLast()` 方法返回数组中满足提供的测试函数条件的最后一个元素的值。如果没有找到对应元素，则返回 `undefined`。\r\n```javascript\r\nconst array1 = [5, 12, 8, 130, 44];\r\n\r\nconst item = array1.findLast(element => element > 13);\r\nconsole.log(item); // 44\r\n```\r\n\r\n### 常用于 查找数组中最后一个匹配元素。\r\n\r\n## 5. Array.prototype.findLastIndex()\r\n`findLastIndex()` 方法返回数组中满足提供的测试函数条件的最后一个元素的索引。若没有找到对应元素，则返回 -1。\r\n```javascript\r\nconst array1 = [5, 12, 8, 130, 44];\r\n\r\nconst item = array1.findLastIndex(element => element > 13);\r\nconsole.log(item); // 4\r\n```\r\n\r\n### 常用于 查找数组中最后一个匹配元素的索引。\r\n\r\n## 6. Array.prototype.includes()\r\n`includes()` 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 `true`，否则返回 `false`。\r\n```javascript\r\nconst array1 = [1, 2, 3];\r\n\r\nconsole.log(array1.includes(2)); // true\r\n\r\nconst pets = ['cat', 'dog', 'bat'];\r\n\r\nconsole.log(pets.includes('cat')); // true\r\nconsole.log(pets.includes('at')); // false\r\n```\r\n\r\n`includes()` 方法有意设计为通用方法。它不要求this值是数组对象，所以它可以被用于其他类型的对象 (比如类数组对象)。\r\n```javascript\r\n(function() {\r\n  console.log([].includes.call(arguments, 'a')); // true\r\n  console.log([].includes.call(arguments, 'd')); // false\r\n})('a','b','c');\r\n···\r\n\r\n### 常用于 快速查找一个值是否包含在该数组中。\r\n\r\n## 7. Array.prototype.indexOf()\r\n`indexOf()` 方法返回在数组中可以找到给定元素的第一个索引，如果不存在，则返回 -1。\r\n```javascript\r\nconst beasts = ['ant', 'bison', 'camel', 'duck', 'bison'];\r\n\r\nconsole.log(beasts.indexOf('bison')); // 1\r\nconsole.log(beasts.indexOf('bison', 2)); // 4\r\nconsole.log(beasts.indexOf('giraffe')); // -1\r\n```\r\n\r\n### 常用于 快速查找数组中第一个匹配元素的索引。\r\n\r\n## 8. Array.prototype.lastIndexOf()\r\n`lastIndexOf()` 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。\r\n从数组的后面向前查找，从 `fromIndex` 处开始。\r\n```javascript\r\nconst animals = ['Dodo', 'Tiger', 'Penguin', 'Dodo'];\r\n\r\nconsole.log(animals.lastIndexOf('Dodo')); // 3\r\nconsole.log(animals.lastIndexOf('Tiger')); // 1\r\n```\r\n\r\n### 常用于 快速查找数组中最后一个匹配元素的索引。\r\n\r\n## 9. 总结\r\n如果你需要查找的方法：\r\n\r\n- 第一个匹配的元素，使用 `find()`。\r\n- 最后一个匹配的元素，使用 `findLast()`。\r\n- 第一个匹配元素的索引，使用 `findIndex()`。\r\n- 最后一个匹配元素的索引，使用 `findLastIndex()`。\r\n- 纯粹查第一个匹配的索引，使用 `indexOf()`。它类似于 `findIndex()`，但是会检查每个元素是否和值相等，而不是使用一个测试函数。\r\n- 纯粹查最后一个匹配的索引，使用 `lastIndexOf()`。\r\n- 一个值是否包含在该数组中，使用 `includes()`。同样地，它检查每个元素是否和值相等，而不是使用一个测试函数。\r\n- 是否有任意一个元素满足提供的测试函数，使用 `some()`。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"# 4. 数组创建\r\n## 1. Array.of()\r\n`Array.of()` 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。\r\n\r\n### `Array.of()` 和 `Array` 构造函数之间的区别在于处理整数参数：\r\nArray.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个长度为 7 的空数组。\r\n```javascrpt\r\nArray.of(7); // [7]\r\nArray(7); // [empty × 7]\r\n\r\nArray.of(1, 2, 3); // [1, 2, 3]\r\nArray(1, 2, 3);    // [1, 2, 3]\r\n```\r\n\r\n## 2. Array.from()\r\n`Array.from()` 方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。\r\n```javascript\r\nconsole.log(Array.from('foo')); // [\"f\", \"o\", \"o\"]\r\n\r\nconsole.log(Array.from([1, 2, 3], x => x + x)); // [2, 4, 6]\r\n```\r\n\r\n### 常用于 根据指定数据创建数组\r\n\r\n数组去重合并\r\n```javascript\r\nfunction combine(){\r\n    let arr = [].concat.apply([], arguments);  // 没有去重复的新数组\r\n    return Array.from(new Set(arr));\r\n}\r\n\r\nvar m = [1, 2, 2];\r\nvar n = [2, 3, 3];\r\nconsole.log(combine(m,n)); // [1, 2, 3]\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"# 5. 其他\r\n## 1. Array.isArray()\r\n`Array.isArray()` 用于确定传递的值是否是一个 `Array`。\r\n```javascript\r\nArray.isArray([1, 2, 3]);  // true\r\nArray.isArray({foo: 123}); // false\r\nArray.isArray('foobar');   // false\r\nArray.isArray(undefined);  // false\r\n```\r\n\r\n### `Array.isArray()` 和 `instanceof` 的区别\r\n当检测 `Array` 实例时，`Array.isArray` 优于 `instanceof`，因为 `Array.isArray` 能检测 `iframes`。\r\n```javascript\r\nconst iframe = document.createElement('iframe');\r\ndocument.body.appendChild(iframe);\r\nxArray = window.frames[window.frames.length-1].Array;\r\nconst arr = new xArray(1,2,3); // [1,2,3]\r\n\r\n// 正确检查 Array\r\nArray.isArray(arr);  // true\r\n// Considered harmful, because doesn't work through iframes\r\narr instanceof Array; // false\r\n```\r\n\r\n### 常用于 精准的判断数据类型是否为数组\r\n\r\n## 2. Array.prototype.join()\r\n`join()` 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。\r\n如果数组只有一个项目，那么将返回该项目而不使用分隔符。\r\n```javascript\r\nconst elements = ['Fire', 'Air', 'Water'];\r\n\r\nconsole.log(elements.join()); // \"Fire,Air,Water\"\r\nconsole.log(elements.join('')); // \"FireAirWater\"\r\nconsole.log(elements.join('-')); // \"Fire-Air-Water\"\r\n```\r\n\r\n警告： 如果一个元素为 `undefined` 或 `null`，它会被转换为空字符串。\r\n\r\n### 常用于拼接字符串\r\n\r\n## 3. Array.prototype.reverse()\r\n`reverse()` 方法将数组中元素的位置颠倒，并返回该数组。\r\n该方法会改变原数组。\r\n```javascript\r\nconst array1 = ['one', 'two', 'three'];\r\n\r\nconst reversed = array1.reverse();\r\nconsole.log('reversed:', reversed); // [\"three\", \"two\", \"one\"]\r\nconsole.log('array1:', array1); // [\"three\", \"two\", \"one\"]\r\n```\r\n\r\n### 常用于数组反转排序\r\n\r\n## 4. Array.prototype.sort()\r\n`sort()` 方法用[原地算法](https://zh.wikipedia.org/wiki/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)对数组的元素进行排序，并返回数组。\r\n默认排序顺序是在将元素转换为字符串，然后比较它们的 UTF-16 代码单元值序列时构建的。\r\n```javascript\r\nconst months = ['March', 'Jan', 'Feb', 'Dec'];\r\n\r\nconsole.log(months.sort()); // [\"Dec\", \"Feb\", \"Jan\", \"March\"]\r\n\r\nconst array1 = [1, 30, 4, 21, 100000];\r\n\r\nconsole.log(array1.sort()); // [1, 100000, 21, 30, 4]\r\n```\r\n\r\n比较函数的基本用法：\r\n```javascript\r\nfunction compareFn(a, b) {\r\n  if (在某些排序规则中，a 小于 b) {\r\n    return -1;\r\n  }\r\n  if (在这一排序规则下，a 大于 b) {\r\n    return 1;\r\n  }\r\n  // a 一定等于 b\r\n  return 0;\r\n}\r\n```\r\n\r\n比较数字（升序排列）\r\n```javascript\r\nfunction compareNumbers(a, b) {\r\n  return a - b;\r\n}\r\n```\r\n\r\n对非 ASCII 字符排序\r\n当排序非 ASCII 字符的字符串（如包含类似 e, é, è, a, ä 等字符的字符串）。\r\n一些非英语语言的字符串需要使用 `String.localeCompare`。\r\n```javascript\r\nvar items = ['réservé', 'premier', 'cliché', 'communiqué', 'café', 'adieu'];\r\nitems.sort((a, b) =>  a.localeCompare(b));\r\n\r\nconsole.log(items); //  ['adieu', 'café', 'cliché', 'communiqué', 'premier', 'réservé']\r\n```\r\n\r\n### 常用于数组手动排序\r\n\r\n## 5. Array.prototype.toLocaleString()\r\n`toLocaleString()` 返回一个字符串表示数组中的元素。\r\n数组中的元素将使用各自的 `toLocaleString` 方法转成字符串，这些字符串将使用一个特定语言环境的字符串（例如逗号）隔开。\r\n```javascript\r\nconst array1 = [1, 'a', new Date('21 Dec 1997 14:12:00 UTC')];\r\nconst localeString = array1.toLocaleString('en', { timeZone: 'UTC' });\r\n\r\nconsole.log(localeString); // \"1,a,12/21/1997, 2:12:00 PM\"\r\n```\r\n\r\n数组中的元素将会使用各自的 `toLocaleString` 方法：\r\n\r\n- Object: Object.prototype.toLocaleString()\r\n- Number: Number.prototype.toLocaleString()\r\n- Date: Date.prototype.toLocaleString()\r\n\r\n### 用于数字货币转换：\r\n```javascript\r\nvar prices = ['￥7', 500, 8123, 12];\r\n\r\nprices.toLocaleString('ja-JP', { style: 'currency', currency: 'JPY' }); // \"￥7,￥500,￥8,123,￥12\"\r\n```\r\n\r\n## 6. Array.prototype.toString()\r\n`toString()` 方法返回一个字符串，表示指定的数组及其元素。\r\n```javascript\r\nconst array1 = [1, 2, 'a', '1a'];\r\n\r\nconsole.log(array1.toString()); // \"1,2,a,1a\"\r\n```\r\n\r\n`Array` 对象覆盖了 `Object` 的 `toString` 方法。\r\n对于数组对象，`toString` 方法在内部调用 `join()` 方法拼接数组中的元素并返回一个字符串，其中包含用逗号分隔的每个数组元素。\r\n如果 `join` 方法不可用，或者它不是一个函数，将使用 `Object.prototype.toString` 代替，返回 `[object Array]`。\r\n\r\n备注：当一个数组被作为文本值或者进行字符串拼接操作时，将会自动调用其 `toString` 方法。\r\n\r\n### 经典八股文：\r\n`Object.prototype.toString` 和 `Object.toString` 是一回事吗？\r\n\r\n不是。 \r\n因为 `Object.toString` 是 `Object.__proto__.toString`，也就是去上一级的原型中拿的方法，是 `Function.prototype.toString`。\r\n同理 `Number`，`String`，`Array` 里的 `toString` 也和 `Object.prototype.toString` 不一样，而且它们也都被重写了 `toString` 方法。\r\n"}]},{"number":27,"title":"【Q027】Ajax 工作原理","labels":["javascript"],"body":"着重理解，XMLHttpRequest","url":"https://github.com/kangyana/daily-question/issues/27","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 什么是Ajax？\r\n`AJAX`（Asynchronous JavaScript And XML）是使用 `XMLHttpRequest` 对象与服务器通信。\r\n它可以使用 JSON，XML，HTML 和 text 文本等格式发送和接收数据。\r\n`AJAX` 最吸引人的就是它的“异步”特性，也就是说它可以在不重新刷新页面的情况下与服务器通信，交换数据，或更新页面。\r\n\r\n你可以使用 AJAX 最主要的两个特性做下列事：\r\n\r\n- 在不重新加载页面的情况下发送请求给服务器。\r\n- 接受并使用从服务器发来的数据。\r\n\r\n### 如何发送 http 请求\r\n使用 `XMLHttpRequest` 方法建立一个请求：\r\n```javascript\r\nif (window.XMLHttpRequest) { // Mozilla, Safari, IE7+ ...\r\n    httpRequest = new XMLHttpRequest();\r\n} else if (window.ActiveXObject) { // IE 6 and older\r\n    httpRequest = new ActiveXObject(\"Microsoft.XMLHTTP\");\r\n}\r\n```\r\n\r\n请求响应的回调函数：\r\n```javascript\r\nhttpRequest.onreadystatechange = function(){\r\n    if (httpRequest.readyState === XMLHttpRequest.DONE) {\r\n        // Everything is good, the response was received.\r\n    } else {\r\n        // Not ready yet.\r\n    }\r\n};\r\n```\r\n\r\n发送一个实际的请求：\r\n```javascript\r\nhttpRequest.open('GET', 'http://www.example.org/some.file', true);\r\nhttpRequest.send();\r\n```\r\n\r\n可以在 `send` 调用之前设置请求头：\r\n```javascript\r\nhttpRequest.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. Ajax 工作原理\r\n\r\n![Alt](https://raw.githubusercontent.com/kangyana/img-storage/master/xhr_process.png)\r\n\r\n1. 浏览器调用xhr去请求服务器。\r\n2. 浏览器继续做其他工作。\r\n3. xhr请求服务器。\r\n4. 服务器响应xhr。\r\n5. xhr通知浏览器响应的数据。\r\n6. 浏览器利用xhr收到的数据渲染页面。"}]},{"number":28,"title":"【Q028】fetch","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/28","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. fetch\r\n`fetch`API 用于访问和操纵 HTTP 管道的一些具体部分，例如请求和响应。\r\n\r\n这种功能以前是使用 `XMLHttpRequest` 实现的，`Fetch` 提供了一个更理想的替代方案。\r\n```javascript\r\nfetch('http://example.com/movies.json')\r\n  .then(response => response.json())\r\n  .then(data => console.log(data));\r\n```\r\n\r\n### `fetch` 与 `jQuery.ajax()` 的区别：\r\n\r\n- 当接收到一个代表错误的 HTTP 状态码时，从 fetch() 返回的 Promise 不会被标记为 reject，即使响应的 HTTP 状态码是 404 或 500。\r\n相反，它会将 Promise 状态标记为 resolve（如果响应的 HTTP 状态码不在 200 - 299 的范围内，则设置 resolve 返回值的 ok 属性为 false），仅当网络故障时或请求被阻止时，才会标记为 reject。\r\n- fetch 不会发送跨域 cookie，除非你使用了 credentials 的 初始化选项。"}]},{"number":29,"title":"【Q029】同源策略（same-origin policy）","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/29","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 同源策略\r\n`同源策略` 是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。\r\n\r\n## 2. 同源的定义\r\n如果两个 URL 的 protocol (如果有指定的话) 和 host 都相同的话，则这两个 URL 是同源。\r\n这个方案也被称为“协议/主机/端口元组”，或者直接是“元组”。（“元组”是指一组项目构成的整体，双重/三重/四重/五重/等的通用形式）。\r\n\r\n下表给出了与 URL `http://store.company.com/dir/page.html` 的源进行对比的示例：\r\n\r\nURL | 结果 | 原因\r\n-- | -- | --\r\nhttp://store.company.com/dir2/other.html | 同源 | 只有路径不同\r\nhttp://store.company.com/dir/inner/another.html | 同源 | 只有路径不同\r\nhttps://store.company.com/secure.html | 失败 | 协议不同\r\nhttp://store.company.com:81/dir/etc.html | 失败 | 端口不同 ( http:// 默认端口是 80)\r\nhttp://news.company.com/dir/other.html | 失败 | 主机不同\r\n\r\n## 3. 源的继承\r\n在页面中通过 `about:blank` 或 `javascript: URL` 执行的脚本会继承打开该 URL 的文档的源，因为这些类型的 URLs 没有包含源服务器的相关信息。\r\n\r\n## 4. 源的更改\r\n满足某些限制条件的情况下，页面是可以修改它的源。脚本可以将 `document.domain` 的值设置为其当前域或其当前域的父域。如果将其设置为其当前域的父域，则这个较短的父域将用于后续源检查。\r\n\r\n例如：假设 http://store.company.com/dir/other.html 文档中的一个脚本执行以下语句：\r\n```javascript\r\ndocument.domain = \"company.com\";\r\n```\r\n\r\n## 5. 跨源网络访问\r\n同源策略控制不同源之间的交互，例如在使用 `XMLHttpRequest` 或 `<img>` 标签时则会受到同源策略的约束。这些交互通常分为三类：\r\n\r\n- 跨源写操作（Cross-origin writes）一般是被允许的。例如链接（links），重定向以及表单提交。特定少数的 HTTP 请求需要添加 预检请求。\r\n- 跨源资源嵌入（Cross-origin embedding）一般是被允许（后面会举例说明）。\r\n- 跨源读操作（Cross-origin reads）一般是不被允许的，但常可以通过内嵌资源来巧妙的进行读取访问。例如，你可以读取嵌入图片的高度和宽度，调用内嵌脚本的方法，或 availability of an embedded resource。\r\n\r\n以下是可能嵌入跨源的资源的一些示例：\r\n\r\n- `<script src=\"...\"></script>` 标签嵌入跨源脚本。语法错误信息只能被同源脚本中捕捉到。\r\n- `<link rel=\"stylesheet\" href=\"...\">` 标签嵌入 CSS。由于 CSS 的 松散的语法规则，CSS 的跨源需要一个设置正确的 HTTP 头部 Content-Type 。不同浏览器有不同的限制。\r\n- 通过 `<img>` 展示的图片。支持的图片格式包括 PNG,JPEG,GIF,BMP,SVG,...\r\n- 通过 `<video>` 播放的多媒体资源。\r\n- 通过 `<object>` 和 `<applet>`  嵌入的插件。\r\n- 通过 `@font-face` 引入的字体。一些浏览器允许跨源字体（cross-origin fonts），一些需要同源字体（same-origin fonts）。\r\n- 通过 `<iframe>` 载入的任何资源。站点可以使用 X-Frame-Options 消息头来阻止这种形式的跨源交互。\r\n\r\n### 总结：资源和脚本可能会跨域。\r\n\r\n如何允许跨源访问：\r\n可以使用 `CORS` 来允许跨源访问。CORS 是 `HTTP` 的一部分，它允许服务端来指定哪些主机可以从这个服务端加载资源。\r\n\r\n如何阻止跨源访问：\r\n\r\n- 阻止跨源写操作，只要检测请求中的一个不可推测的标记 (CSRF token) 即可，这个标记被称为 Cross-Site Request Forgery (CSRF) 标记。你必须使用这个标记来阻止页面的跨源读操作。\r\n- 阻止资源的跨源读取，需要保证该资源是不可嵌入的。阻止嵌入行为是必须的，因为嵌入资源通常向其暴露信息。\r\n- 阻止跨源嵌入，需要确保你的资源不能通过以上列出的可嵌入资源格式使用。浏览器可能不会遵守 Content-Type 头部定义的类型。例如，如果您在 HTML 文档中指定 `<script>` 标记，则浏览器将尝试将标签内部的 HTML 解析为 JavaScript。当您的资源不是您网站的入口点时，您还可以使用 CSRF 令牌来防止嵌入。\r\n\r\n## 6. 跨源脚本 API 访问\r\n\r\n允许以下对 Window 属性的跨源访问：\r\n\r\n方法\r\n-- | \r\nwindow.blur\r\nwindow.close\r\nwindow.focus\r\nwindow.postMessage\r\n\r\n属性 | 权限\r\n-- | --\r\nwindow.closed | 只读\r\nwindow.frames | 只读\r\nwindow.length | 只读\r\nwindow.location | 读/写\r\nwindow.opener | 只读\r\nwindow.parent | 只读\r\nwindow.self | 只读\r\nwindow.top | 只读\r\nwindow.window | 只读\r\n\r\n允许以下对 Location 属性的跨源访问：\r\n\r\n方法\r\n-- | \r\nlocation.replace\r\n\r\n属性 | 权限\r\n-- | --\r\nHTMLAnchorElement.href | 只写\r\n\r\n某些浏览器允许访问除上述外更多的属性。\r\n\r\n## 7. 跨源数据存储访问\r\n访问存储在浏览器中的数据，如 `localStorage` 和 `IndexedDB`，是以源进行分割。\r\n每个源都拥有自己单独的存储空间，一个源中的 JavaScript 脚本不能对属于其它源的数据进行读写操作。\r\n\r\n`Cookies`使用不同的源定义方式。\r\n一个页面可以为本域和其父域设置 cookie，只要是父域不是公共后缀（public suffix）即可。\r\nFirefox 和 Chrome 使用 `Public Suffix List` 检测一个域是否是公共后缀（public suffix）。\r\nInternet Explorer 使用其内部的方法来检测域是否是公共后缀。\r\n不管使用哪个协议（HTTP/HTTPS）或端口号，浏览器都允许给定的域以及其任何子域名 (sub-domains) 访问 cookie。\r\n当你设置 cookie 时，你可以使用 Domain、Path、Secure、和 HttpOnly 标记来限定其无障碍。\r\n当你读取 cookie 时，你无法知道它是在哪里被设置的。\r\n即使您只使用安全的 https 连接，您看到的任何 cookie 都有可能是使用不安全的连接进行设置的。"}]},{"number":30,"title":"【Q030】JS strict模式","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/30","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 严格模式（strict mode）\r\n**ECMAScript 5**的 `严格模式` 是采用具有限制性 JavaScript 变体的一种方式，从而使代码隐式地脱离“马虎模式/稀松模式/懒散模式“（sloppy mode）。\r\n\r\n`严格模式` 的效果：\r\n\r\n- 严格模式通过抛出错误来消除了一些原有静默错误。\r\n- 严格模式修复了一些导致 JavaScript 引擎难以执行优化的缺陷：有时候，相同的代码，严格模式可以比非严格模式下运行得更快。\r\n- 严格模式禁用了在 ECMAScript 的未来版本中可能会定义的一些语法。\r\n\r\n## 2. 开启严格模式\r\n`严格模式` 可以应用到整个脚本或个别函数中，下表给出了应用范围：\r\n\r\n环境 | 结果\r\n-- | --\r\neva | ✅\r\nFunction | ✅\r\n内联事件处理属性 | ✅\r\nWindowTimers.setTimeout()| ✅\r\n块级作用域 {} | ❌\r\n\r\n### 为脚本开启严格模式\r\n// 整个脚本都开启严格模式的语法\r\n```javascript\r\n\"use strict\";\r\nvar v = \"Hi!  I'm a strict mode script!\";\r\n```\r\n\r\n### 为函数开启严格模式\r\n```javascript\r\nfunction strict() {\r\n  // 函数级别严格模式语法\r\n  'use strict';\r\n  function nested() {\r\n    return \"And so am I!\";\r\n  }\r\n  return \"Hi!  I'm a strict mode function!  \" + nested();\r\n}\r\n\r\nfunction notStrict() {\r\n  return \"I'm not strict.\";\r\n}\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 3. 严格模式的效果\r\n\r\n### 1. 将过失错误转成异常\r\n\r\n- 不行允许意外直接创建全局变量\r\n```javascript\r\n\"use strict\";\r\n                       // 假如有一个全局变量叫做mistypedVariable\r\nmistypedVaraible = 17; // 因为变量名拼写错误\r\n                       // 这一行代码就会抛出 ReferenceError\r\n```\r\n\r\n- 静默失败，只读属性不允许赋值\r\n```javascript\r\n\"use strict\";\r\n\r\n// 给不可写属性赋值\r\nvar obj1 = {};\r\nObject.defineProperty(obj1, \"x\", { value: 42, writable: false });\r\nobj1.x = 9; // 抛出 TypeError 错误\r\n\r\n// 给只读属性赋值\r\nvar obj2 = { get x() { return 17; } };\r\nobj2.x = 5; // 抛出 TypeError 错误\r\n\r\n// 给不可扩展对象的新属性赋值\r\nvar fixed = {};\r\nObject.preventExtensions(fixed);\r\nfixed.newProp = \"ohai\"; // 抛出 TypeError 错误\r\n```\r\n- 不允许删除不可删除的属性\r\n```javascript\r\n\"use strict\";\r\ndelete Object.prototype; // 抛出 TypeError 错误\r\n```\r\n- 不允许重名属性\r\n```javascript\r\n\"use strict\";\r\nvar o = { p: 1, p: 2 }; // !!! 语法错误\r\n```\r\n- 不允许参数重名\r\n```javascript\r\nfunction sum(a, a, c) { // !!! 语法错误\r\n  \"use strict\";\r\n  return a + a + c; // 代码运行到这里会出错\r\n}\r\n```\r\n- 禁止八进制数字语法\r\n```javascript\r\nvar a = 0o10; // ES6: 八进制\r\n```\r\n- 禁止设置 `primitive` 值的属性\r\n```javascript\r\n(function() {\r\n  \"use strict\";\r\n\r\n  false.true = \"\";              //TypeError\r\n  (14).sailing = \"home\";        //TypeError\r\n  \"with\".you = \"far away\";      //TypeError\r\n})();\r\n```\r\n\r\n### 2. 简化变量的使用\r\n\r\n- 禁用 `with` 语法\r\n```javascript\r\n\"use strict\";\r\nvar x = 17;\r\nwith (obj) { // !!! 语法错误\r\n  // 如果没有开启严格模式，with 中的这个 x 会指向 with 上面的那个 x，还是 obj.x？\r\n  // 如果不运行代码，我们无法知道，因此，这种代码让引擎无法进行优化，速度也就会变慢。\r\n  x;\r\n}\r\n```\r\n- 限制 `eval` 的作用域，避免影响到上层\r\n```javascript\r\nvar x = 17;\r\nvar evalX = eval(\"'use strict'; var x = 42; x\");\r\nconsole.assert(x === 17);\r\nconsole.assert(evalX === 42);\r\n```\r\n- 禁止删除变量 delete name\r\n```javascript\r\n\"use strict\";\r\n\r\nvar x;\r\ndelete x; // !!! 语法错误\r\n\r\neval(\"var y; delete y;\"); // !!! 语法错误\r\n```\r\n\r\n### 3. 让eval和arguments变的简单\r\n\r\n- 名称 `eval` 和 `arguments` 不能通过程序语法被绑定或赋值\r\n```javascript\r\n\"use strict\";\r\neval = 17;\r\narguments++;\r\n++eval;\r\nvar obj = { set p(arguments) { } };\r\nvar eval;\r\ntry { } catch (arguments) { }\r\nfunction x(eval) { }\r\nfunction arguments() { }\r\nvar y = function eval() { };\r\nvar f = new Function(\"arguments\", \"'use strict'; return 17;\");\r\n```\r\n\r\n- 参数的值不会随 arguments 对象的值的改变而变化\r\n```javascript\r\nfunction f(a) {\r\n  \"use strict\";\r\n  a = 42;\r\n  return [a, arguments[0]];\r\n}\r\nvar pair = f(17);\r\nconsole.assert(pair[0] === 42);\r\nconsole.assert(pair[1] === 17);\r\n```\r\n\r\n- 不再支持 `arguments.callee`\r\n```javascript\r\n\"use strict\";\r\nvar f = function() { return arguments.callee; };\r\nf(); // 抛出类型错误\r\n```\r\n\r\n### 4. 严格模式下更安全\r\n\r\n- 在严格模式下通过this传递给一个函数的值不会被强制转换为一个对象。\r\n```javascript\r\n\"use strict\";\r\nfunction fun() { return this; }\r\nconsole.assert(fun() === undefined);\r\nconsole.assert(fun.call(2) === 2);\r\nconsole.assert(fun.apply(null) === null);\r\nconsole.assert(fun.call(undefined) === undefined);\r\nconsole.assert(fun.bind(true)() === true);\r\n```\r\n\r\n- 函数内禁止使用 `fun.caller 和 `fun.arguments` 进行拓展\r\n```javascript\r\nfunction restricted() {\r\n  \"use strict\";\r\n  restricted.caller;    // 抛出类型错误\r\n  restricted.arguments; // 抛出类型错误\r\n}\r\n\r\nfunction privilegedInvoker() {\r\n  return restricted();\r\n}\r\n\r\nprivilegedInvoker();\r\n```\r\n\r\n- arguments不会再提供访问与调用这个函数相关的变量的途径\r\n```javascript\r\n\"use strict\";\r\nfunction fun(a, b) {\r\n  \"use strict\";\r\n  var v = 12;\r\n  return arguments.caller; // 抛出类型错误\r\n}\r\nfun(1, 2); // 不会暴露 v（或者 a，或者 b）\r\n```\r\n\r\n## 4. 为未来的 ECMAScript 版本铺路\r\n未来版本的 ECMAScript 很有可能会引入新语法，严格模式对其有保护机制。\r\n\r\n- 一部分字符变成了保留的关键字。\r\n在严格模式下，你不能再用这些名字作为变量名或者形参名。\r\n\r\n关键字\r\n-- |\r\nimplements\r\ninterface\r\nlet\r\npackage\r\nprivate\r\nprotected\r\npublic\r\nstatic\r\nyield\r\n\r\n```javascript\r\nfunction package(protected) { // !!!\r\n  \"use strict\";\r\n  var implements; // !!!\r\n\r\n  interface: // !!!\r\n  while (true) {\r\n    break interface; // !!!\r\n  }\r\n\r\n  function private() { } // !!!\r\n}\r\nfunction fun(static) { 'use strict'; } // !!!\r\n```\r\n\r\n-  严格模式禁止了不在脚本或者函数层面上的函数声明\r\n```javascript\r\n\"use strict\";\r\nif (true) {\r\n  function f() { } // !!! 语法错误\r\n  f();\r\n}\r\n\r\nfor (var i = 0; i < 5; i++) {\r\n  function f2() { } // !!! 语法错误\r\n  f2();\r\n}\r\n\r\nfunction baz() { // 合法\r\n  function eit() { } // 同样合法\r\n}\r\n```\r\n这种禁止放到严格模式中并不是很合适，因为这样的函数声明方式从 ES5 中延伸出来的。但这是 ECMAScript 委员会推荐的做法，浏览器就实现了这一点。"}]},{"number":31,"title":"【Q031】cookie","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/31","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. cookie\r\n`Cookie` 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。\r\n通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。\r\n\r\n`Cookie` 主要用于以下三个方面：\r\n\r\n- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）\r\n- 个性化设置（如用户自定义设置、主题等）\r\n- 浏览器行为跟踪（如跟踪分析用户行为等）\r\n\r\n`Cookie` 曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。\r\n由于服务器指定 `Cookie` 后，浏览器的每次请求都会携带 `Cookie` 数据，会带来额外的性能开销（尤其是在移动环境下）。\r\n新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 `Web storage 或 `IndexedDB`。\r\n\r\n\r\n## 2. 设置cookie\r\n当服务器收到 HTTP 请求时，服务器可以在响应头里面添加一个 `Set-Cookie` 选项。\r\n浏览器收到响应后通常会保存下 `Cookie`，之后对该服务器每一次请求中都通过 `Cookie` 请求头部将 `Cookie` 信息发送给服务器。\r\n另外，`Cookie` 的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。\r\n\r\n```\r\nSet-Cookie: <cookie 名>=<cookie 值>\r\n```\r\n\r\n## 3.定义 Cookie 的生命周期\r\nCookie 的生命周期可以通过两种方式定义：\r\n\r\n- 会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。\r\n- 持久性 Cookie：生命周期取决于过期时间（Expires）或有效期（Max-Age）指定的一段时间。\r\n\r\n```\r\nSet-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;\r\n```\r\n\r\n## 4. 限制访问 Cookie\r\n有两种方法可以确保 Cookie 被安全发送，并且不会被意外的参与者或脚本访问：\r\n\r\n属性 | 效果 | 预防\r\n-- | -- | --\r\nSecure | 只通过 HTTPS 协议加密过的请求 |  `man-in-the-middle` 的攻击\r\nHttpOnly | 禁止 `document.cookie` 访问 Cookie | `XSS` 的攻击\r\n\r\n```\r\nSet-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly\r\n```\r\n\r\n## 5. Cookie 的作用域\r\n`Domain` 和 `Path` 标识定义了 Cookie 的*作用域：*即允许 Cookie 应该发送给哪些 URL。\r\n\r\n### Domain 属性\r\n`Domain` 指定了哪些主机可以接受 Cookie。如果不指定，默认为 **origin**，不包含子域名。\r\n如果指定了Domain，则一般包含子域名。因此，指定 `Domain` 比省略它的限制要少。\r\n但是，当子域需要共享有关用户的信息时，这可能会有所帮助。\r\n\r\n### Path 属性\r\n`Path` 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。\r\n以字符 %x2F (\"/\") 作为路径分隔符，子路径也会被匹配。\r\n\r\n例如，设置 Path=/docs，则以下地址都会匹配：\r\n\r\n- /docs\r\n- /docs/Web/\r\n- /docs/Web/HTTP"}]},{"number":32,"title":"【Q032】sessionStorage、localStorage","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/32","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. Web Storage\r\n`Web Strorage` 使浏览器能以一种比使用 Cookie 更直观的方式存储键/值对。\r\n\r\nWeb Storage 包含如下两种机制：\r\n\r\n- `sessionStorage` 为每一个给定的源（given origin）维持一个独立的存储区域，该存储区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。\r\n- `localStorage` 同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。\r\n\r\n## 2. sessionStorage\r\n`sessionStorage` 属性允许你访问一个，对应当前源的 **浏览器会议储存** 的对象。\r\n它的生命周期是 一次浏览器会话。\r\n\r\n```javascript\r\n// 保存数据到 sessionStorage\r\nsessionStorage.setItem('key', 'value');\r\n\r\n// 从 sessionStorage 获取数据\r\nlet data = sessionStorage.getItem('key');\r\n\r\n// 从 sessionStorage 删除保存的数据\r\nsessionStorage.removeItem('key');\r\n\r\n// 从 sessionStorage 删除所有保存的数据\r\nsessionStorage.clear();\r\n```\r\n## 3. localStorage\r\n`localStorage` 属性允许你访问一个，**Document源** 的对象。\r\n它的生命周期是长期，直到你手动清除。\r\n\r\n语法同 sessionStorage：\r\n```javascript\r\n// 保存 localStorage 项\r\nlocalStorage.setItem('myCat', 'Tom');\r\n\r\n// 读取 localStorage 项\r\nlet cat = localStorage.getItem('myCat');\r\n\r\n// 移除 localStorage 项\r\nlocalStorage.removeItem('myCat');\r\n\r\n// 移除所有的 localStorage 项\r\nlocalStorage.clear();\r\n```\r\n\r\n## 4. 区别\r\n\r\n- 生命周期：localStorage 是长久储存，sessionStorage 是一次浏览器会话。\r\n- 应用场景：localStorage 适合储存个性设置，sessionStorage 适合储存敏感信息（token等）。"}]},{"number":33,"title":"【Q032】IndexedDB","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/33","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. IndexedDB\r\nIndexedDB 用来在 **客户端存储** 大量的结构化数据（包括文件/二进制大型对象blobs）。\r\n该 API 使用索引实现对数据的高性能搜索。\r\n虽然 `Web Storage` 在存储较少量的数据很有用，但对于存储更大量的结构化数据来说力不从心。而 IndexedDB 提供了这种场景的解决方案。\r\n\r\n## 2. 关键概念和用法\r\nIndexedDB 是一个事务型数据库系统，类似于基于 SQL 的 RDBMS。\r\nIndexedDB 是一个面向对象数据库，允许您存储和检索用键索引的对象。\r\n您只需要指定数据库模式，打开与数据库的连接，然后检索和更新一系列事务。\r\n\r\n### 操作流程：\r\n\r\n1. 打开数据库。\r\n2. 在数据库中创建一个对象仓库（object store）。\r\n3. 启动一个事务，并发送一个请求来执行一些数据库操作，像增加或提取数据等。\r\n4. 通过监听正确类型的 DOM 事件以等待操作完成。\r\n5. 在操作结果上进行一些操作（可以在 request 对象中找到）\r\n\r\n```javascript\r\nconst dbName = \"the_name\"; // 数据库名称\r\nvar version = 1; // 数据库版本号\r\n\r\n// 打开数据库\r\nvar request = indexedDB.open(dbName, version);\r\n\r\nrequest.onerror = function(event) {\r\n  // 错误处理\r\n};\r\nrequest.onupgradeneeded = function(event) {\r\n  var db = event.target.result;\r\n\r\n  // 建立一个对象仓库来存储我们客户的相关信息，我们选择 ssn 作为键路径（key path）\r\n  // 因为 ssn 可以保证是不重复的\r\n  var objectStore = db.createObjectStore(\"customers\", { keyPath: \"ssn\" });\r\n\r\n  // 建立一个索引来通过姓名来搜索客户。名字可能会重复，所以我们不能使用 unique 索引\r\n  objectStore.createIndex(\"name\", \"name\", { unique: false });\r\n\r\n  // 使用邮箱建立索引，我们向确保客户的邮箱不会重复，所以我们使用 unique 索引\r\n  objectStore.createIndex(\"email\", \"email\", { unique: true });\r\n\r\n  // 使用事务的 oncomplete 事件确保在插入数据前对象仓库已经创建完毕\r\n  objectStore.transaction.oncomplete = function(event) {\r\n    // 将数据保存到新创建的对象仓库\r\n    var customerObjectStore = db.transaction(\"customers\", \"readwrite\").objectStore(\"customers\");\r\n    customerData.forEach(function(customer) {\r\n      customerObjectStore.add(customer);\r\n    });\r\n  };\r\n};\r\n```\r\n\r\n## 3. 同步还是异步\r\n使用 IndexedDB 执行的操作是异步执行的，以免阻塞应用程序。\r\n\r\n## 4. 储存限制和回收标准\r\n在不同浏览器中有所不同。\r\n\r\n## 5. 成熟的第三方包\r\n\r\n- [localForage](https://localforage.github.io/localForage/)：一个简单的 Polyfill，提供了简单的客户端数据存储的值语法。它在后台使用 IndexedDB，并在不支持 IndexedDB 的浏览器中回退到 WebSQL 或 localStorage。\r\n- [idb](https://www.npmjs.com/package/idb)：一个微小的（〜1.15k）库，大多 API 与 IndexedDB 类似，但做了一些小的改进，让数据库的可用性得到了大大的提升。"}]},{"number":34,"title":"【Q034】web worker","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/34","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. web worker\r\n`Web Worker`  为 Web 内容在后台线程中运行脚本提供了一种简单的方法。\r\nworker 可以与 js 互相通信，线程可以执行任务而不干扰用户界面。\r\n\r\n### 常用来做 耗时的计算，Service worker等后台任务\r\n\r\n## 2. worker的使用\r\n### 生成一个专用 worker\r\n```javascript\r\n// main.js\r\nvar myWorker = new Worker('worker.js');\r\n```\r\n\r\n### worker 中消息的接收和发送\r\n你可以通过 `postMessage()` 方法和 `onmessage` 事件处理函数触发 workers 的方法。\r\n\r\n主线程向 worker 发消息\r\n```javascript\r\n// main.js\r\nfirst.onchange = function() {\r\n  myWorker.postMessage([first.value,second.value]);\r\n  console.log('Message posted to worker');\r\n}\r\n\r\nsecond.onchange = function() {\r\n  myWorker.postMessage([first.value,second.value]);\r\n  console.log('Message posted to worker');\r\n}\r\n```\r\nworker接收消息的回调\r\n```javascript\r\n// worker.js\r\nonmessage = function(e) {\r\n  console.log('Message received from main script');\r\n  var workerResult = 'Result: ' + (e.data[0] * e.data[1]);\r\n  console.log('Posting message back to main script');\r\n  postMessage(workerResult);\r\n}\r\n```\r\n\r\n主线程响应 worker 回传的消息\r\n```javascript\r\n// main.js\r\nmyWorker.onmessage = function(e) {\r\n  result.textContent = e.data;\r\n  console.log('Message received from worker');\r\n}\r\n```\r\n\r\n### 终止 worker\r\n主线程调用 `terminate` 方法关闭\r\n```javascript\r\n// main.js\r\nmyWorker.terminate();\r\n```\r\n\r\nworker线程调用 `close` 方法关闭\r\n```javascript\r\n// worker.js\r\nclose();\r\n```\r\n\r\n### 处理错误\r\n当 worker 出现运行中错误时，它的 `onerror` 事件处理函数会被调用。\r\n该事件不会冒泡并且可以被取消；为了防止触发默认动作，worker 可以调用错误事件的 `preventDefault()` 方法。\r\n```javascript\r\n// worker.js\r\nonerror = function(err) {\r\n  console.log('错误消息：', err.message);\r\n  console.log('错误文件：', err.filename);\r\n  console.log('错误行数：', err.lineno);\r\n}\r\n```\r\n\r\n### 生成 subworker\r\nworker 能够生成更多的 worker。\r\n\r\n### 引入脚本与库\r\nWorker 线程能够访问一个全局函数 `importScripts()` 来引入脚本，该函数接受 0 个或者多个 URI 作为参数来引入资源。\r\n```javascript\r\nimportScripts();                        /* 什么都不引入 */\r\nimportScripts('foo.js');                /* 只引入 \"foo.js\" */\r\nimportScripts('foo.js', 'bar.js');      /* 引入两个脚本 */\r\n```\r\n\r\n浏览器加载并运行每个的脚本，脚本中的全局对象都能够被 worker 使用。\r\n如果脚本无法加载，将抛出 NETWORK_ERROR 异常，接下来的代码也无法执行，而之前执行的代码 **异步执行的代码** 依然能够运行。\r\nimportScripts() 之后的函数声明有效，因为函数提升。\r\n\r\n备注： 脚本的下载顺序不固定，但执行时会按照传入 importScripts() 中的文件名顺序进行。\r\n这个过程是同步完成的；直到所有脚本都下载并运行完毕，importScripts() 才会返回。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 3. pwa 渐进式 Web 应用\r\n`PWA`（Progressive Web Apps）运用现代的 Web API 以及传统的渐进式增强策略来创建跨平台 Web 应用程序。\r\n`PWA` 使 **web应用** 具有与 **原生应用** 相同的用户体验。\r\n\r\n## 4. 通过 Service workers 让 PWA 离线工作\r\n`Service Worker` 是浏览器和网络之间的虚拟代理。\r\n它解决决了如何正确 **缓存网站资源** 并使其在离线时可用的问题。\r\n\r\n### Service Worker 的生命周期\r\n注册sw后，sw.js 文件会自动下载、安装，然后激活。\r\n\r\n### 注册 Service Worker\r\n```javascript\r\nif('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.register('/pwa-examples/js13kpwa/sw.js');\r\n};\r\n```\r\n\r\n### 安装\r\n安装sw，并缓存文件\r\n```javascript\r\nvar cacheName = 'js13kPWA-v1'; // 缓存版本号\r\nvar appShellFiles = [\r\n  '/pwa-examples/js13kpwa/index.html',\r\n  '/pwa-examples/js13kpwa/app.js',\r\n  '/pwa-examples/js13kpwa/style.css',\r\n]; // 需要缓存的资源路径\r\n\r\nself.addEventListener('install', function(e) {\r\n  console.log('SW 安装');\r\n  // 等待缓存后再安装\r\n  e.waitUntil(\r\n    caches.open(cacheName).then(function(cache) {\r\n          console.log('SW 缓存资源');\r\n      return cache.addAll(appShellFiles);\r\n    })\r\n  );\r\n});\r\n```\r\n\r\n### 拦截请求\r\n缓存中查找资源是否被缓存：如果存在，将会返回缓存的资源；如果不存在，会转而从网络中请求数据，然后将它缓存起来。\r\n```javascript\r\nself.addEventListener('fetch', function(e) {\r\n  e.respondWith(\r\n    caches.match(e.request).then(function(r) {\r\n      console.log('SW 拦截到请求'+e.request.url);\r\n      return r || fetch(e.request).then(function(response) {\r\n                return caches.open(cacheName).then(function(cache) {\r\n          console.log('[Service Worker] Caching new resource: '+e.request.url);\r\n          cache.put(e.request, response.clone());\r\n          return response;\r\n        });\r\n      });\r\n    })\r\n  );\r\n});\r\n```\r\n\r\n### 更新\r\n当有资源变动时，更新版本号，会创新一个新sw缓存文件。\r\n```javascript\r\nappShellFiles.push('/pwa-examples/js13kpwa/icons/icon-32.png');\r\n\r\ncacheName = 'js13kPWA-v2';\r\n```\r\n旧的 Service Worker 仍然会正常运行，直到没有任何页面使用到它为止。\r\n\r\n\r\n### 激活\r\n用来清理不需要的缓存。\r\n```javascript\r\nself.addEventListener('activate', function(e) {\r\n  console.log('SW 激活');\r\n  e.waitUntil(\r\n    caches.keys().then(function(keyList) {\r\n      return Promise.all(keyList.map(function(key) {\r\n        if(cacheName.indexOf(key) === -1) {\r\n          return caches.delete(key);\r\n        }\r\n      }));\r\n    })\r\n  );\r\n});\r\n\r\n```"}]},{"number":35,"title":"【Q035】请解释什么是单页面应用","labels":["javascript"],"body":"请解释什么是单页面应用（single page app），以及如何使其对搜索引擎友好（SEO-friendly）","url":"https://github.com/kangyana/daily-question/issues/35","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 单页面应用 SPA\r\n单页面应用（single page app）加载单个html，切换 url 不会再去请求html。\r\n原理是JS会感知到url的变化，然后js会动态的将当前页面的内容清除掉，然后将下一个页面的内容挂载到当前的页面上。\r\n路由是由前端来控制，判断显示哪个页面。\r\n\r\n![Alt](https://img-blog.csdnimg.cn/20190109220800340.jpeg)\r\n\r\n### 优点\r\n\r\n- 有良好的交互体验，不会重新加载页面\r\n- 不请求html文件，减轻服务器压力\r\n- 前后端分离开发，后端接口可以通用开放给 多个客户端（web，小程序，app）。\r\n\r\n### 缺点\r\n\r\n- 首屏加载时间比较慢\r\n- SEO效果差"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. 优化方案\r\n\r\n### 优化首屏加载体验\r\n\r\n- 资源懒加载\r\n- 构建骨架屏\r\n\r\n### 优化SEO\r\n\r\n- 完善 `title` 和 `meta` 标签\r\n- 服务器端渲染（SSR）\r\n"}]},{"number":36,"title":"【Q036】可变对象和不可变对象","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/36","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 可变\r\n`可变` (Mutable)是一种可以更改的变量。 JS 中，只有 **对象和数组** 是可变的，原始值不可变。\r\n`可变对象` 是在创建后可以修改其状态的对象。\r\n`不可变对象` 一旦创建，其状态无法更改。\r\n\r\n![Alt](https://img-blog.csdnimg.cn/b847f40a83c04cf3b7e1b58bc58a6acf.png)\r\n\r\n## 2. 创建不可变对象\r\n\r\n### 不可扩展\r\n`Object.preventExtensions()` 可以使一个对象不可再添加新的属性，参数为目标对象，返回修改后的对象。\r\n```javascript\r\nvar obj = Object.preventExtensions({});\r\n\r\n// 直接定义新的属性会报错\r\nObject.defineProperty(obj, 'content', {\r\n  value: 'hello'\r\n}); // TypeError: Cannot define property:p, object is not extensible.\r\n\r\n// 非严格模式下通过点符号添加不会报错，但会静默失败，原对象仍然没有 content 属性\r\nobj.content = 'hello';\r\nobj.content; // undefined\r\n```\r\n\r\n对应的，Object.isExtensible() 可以判断一个对象是否可扩展，即是否可以添加新的属性。参数是目标对象，返回布尔值， true 代表可扩展，false 不可扩展。\r\n```javascript\r\nvar obj = new Object();\r\nObject.isExtensible(obj); // true\r\nObject.preventExtensions(obj);\r\nObject.isExtensible(obj); // false\r\n```\r\n\r\n### 密封\r\n`Object.seal()` 可以使一个对象无法添加新属性的同时，也无法删除旧属性。参数是目标对象，返回修改后的对象。\r\n\r\n其本质是通过修改属性的 configurable 为 false 来实现的。在属性描述对象里讲到，configurable 为 false 时，其他配置不可改变，writable 只能 true 变 false，且属性无法被删除。而由于只要 writable 或 configurable 其中之一为 true，则 value 可改，所以密封之后的对象还是可以改属性值的。\r\n```javascript\r\nvar obj = {content: 'hello'};\r\nObject.getOwnPropertyDescriptor(obj, 'content');\r\n// Object {\r\n//   value: \"hello\",\r\n//   writable: true,\r\n//   enumerable: true,\r\n//   configurable: true\r\n// }\r\nObject.seal(obj);\r\nObject.getOwnPropertyDescriptor(obj, 'content'); // seal 后 configurable 变为 false\r\n// Object {\r\n//   value: \"hello\",\r\n//   writable: true,\r\n//   enumerable: true,\r\n//   configurable: false\r\n// }\r\n```\r\n\r\n对应的，Object.isSealed() 可以检测一个对象是否密封，即是否可以增删属性。参数是目标对象，返回布尔值，true 代表被密封不可增删属性，false 代表没被密封可增删属性。\r\n```javascript\r\nvar obj = new Object();\r\nObject.isExtensible(obj); // true\r\nObject.isSealed(obj); // false\r\nObject.seal(obj);\r\nObject.isExtensible(obj); // false，注意 seal 后对象的 isExtensible() 也随之改变\r\nObject.isSealed(obj); // true\r\n```\r\n\r\n### 冻结\r\n`Object.freeze()` 可以使对象一个对象不能再添加新属性，也不可以删除旧属性，且不能修改属性的值。参数是目标对象，返回修改后的对象。\r\n```javascript\r\nvar obj = Object.freeze({name: 'example'});\r\n\r\n// 直接定义新的属性会报错\r\nObject.defineProperty(obj, 'content', {\r\n  value: 'hello'\r\n}); // TypeError: Cannot define property:p, object is not extensible.\r\n\r\n// 非严格模式下通过点符号添加不会报错，但会静默失败，原对象仍然没有 content 属性\r\nobj.content = 'hello';\r\nobj.content; // undefined\r\n\r\ndelete obj.name; // 删除失败，返回 false\r\n\r\nobj.name = 'hello';\r\nobj.name; // 仍然是 \"example\"\r\n```\r\n\r\n对应的，`Object.isFrozen()` 可以检测一个对象是否冻结，即是否可以增删改。参数是目标对象，返回布尔值，true 表示已经冻结不可再增删改，false 反之。\r\n```javascript\r\nvar obj = new Object();\r\nObject.isExtensible(obj); // true\r\nObject.isSealed(obj); // false\r\nObject.isFrozen(obj); // false\r\nObject.freeze(obj);\r\nObject.isExtensible(obj); // false，注意 freeze 后对象的 isExtensible() 也随之改变\r\nObject.isSealed(obj); // true，注意 freeze 后对象的 isSealed() 也随之改变\r\nObject.isFrozen(obj); // true\r\n```\r\n\r\n### 总结\r\n无论是不可扩展，密封，还是冻结，都是 **浅层控制** 的，即只控制对象本身属性的增删改。如果对象属性是一个引用类型，比如数组 subArr 或对象 subObj等，虽然subArr、subObj 的不可被删改，但subArr、subObj 的 **属性** 仍然可增删改。\r\n```javascript\r\nvar obj = Object.freeze({\r\n  content: {name: 'example'}\r\n});\r\nobj.content = new Object();\r\nobj.content; // {name: \"example\"}，content 本身不可改\r\nobj.content.name = 'test';\r\nobj.content; // {name: \"test\"}，但 content 的属性仍可改，因为冻结的是 obj 而不是 obj.content\r\n```\r\n\r\n由于每个对象都有一个属性 `__proto__`，该属性的值是该对象的原型对象，也是引用类型，由于冻结是浅层的所以原型对象并不会被连着冻结，仍然可以通过给对象的原型对象加属性达到给当前对象新增属性的效果。所以如果想进一步冻结还需要把原型对象也冻结上。\r\n```javascript\r\nvar obj = Object.freeze({});\r\nobj.content = 'hello';\r\nobj.content; // undefined，增加失败\r\n\r\nvar proto = Object.getPrototypeOf(obj);\r\nproto.content = 'hello';\r\nobj.content; // \"hello\"，增加成功\r\n\r\nObject.freeze(proto);\r\nproto.name = 'example';\r\nobj.name; // undefined，冻结原型之后增加失败\r\n```\r\n\r\n"}]},{"number":37,"title":"【Q037】什么是事件循环（event loop）","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/37","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 事件循环\r\n之所以称之为 `事件循环`，是因为它经常按照类似如下的方式来被实现：\r\n```javascript\r\nwhile (queue.waitForMessage()) {\r\n  queue.processNextMessage();\r\n}\r\n```\r\n`queue.waitForMessage()` 会同步地等待消息到达 (如果当前没有任何消息等待被处理)。\r\n\r\n### 执行至完成\r\n每一个消息完整地执行后，其它消息才会被执行。这为程序的分析提供了一些优秀的特性，包括：当一个函数执行时，它不会被抢占，只有在它运行完毕之后才会去运行任何其他的代码，才能修改这个函数操作的数据。这与 C 语言不同，例如，如果函数在线程中运行，它可能在任何位置被终止，然后在另一个线程中运行其他代码。\r\n\r\n这个模型的一个缺点在于当一个消息需要太长时间才能处理完毕时，Web 应用程序就无法处理与用户的交互，例如点击或滚动。为了缓解这个问题，浏览器一般会弹出一个“这个脚本运行时间过长”的对话框。一个良好的习惯是缩短单个消息处理时间，并在可能的情况下将一个消息裁剪成多个消息。\r\n\r\n### 添加消息\r\n在浏览器里，每当一个事件发生并且有一个事件监听器绑定在该事件上时，一个消息就会被添加进消息队列。如果没有事件监听器，这个事件将会丢失。所以当一个带有点击事件处理器的元素被点击时，就会像其他事件一样产生一个类似的消息。\r\n\r\n函数 `setTimeout` 接受两个参数：待加入队列的消息和一个时间值（可选，默认为 0）。这个时间值代表了消息被实际加入到队列的最小延迟时间。如果队列中没有其它消息并且栈为空，在这段延迟时间过去之后，消息会被马上处理。但是，如果有其它消息，`setTimeout` 消息必须等待其它消息处理完。因此第二个参数仅仅表示最少延迟时间，而非确切的等待时间。\r\n\r\n下面的例子演示了这个概念（`setTimeout` 并不会在计时器到期之后直接执行）：\r\n```javascript\r\nconst s = new Date().getSeconds();\r\n\r\nsetTimeout(function() {\r\n  // 输出 \"2\"，表示回调函数并没有在 500 毫秒之后立即执行\r\n  console.log(\"Ran after \" + (new Date().getSeconds() - s) + \" seconds\");\r\n}, 500);\r\n\r\nwhile(true) {\r\n  if(new Date().getSeconds() - s >= 2) {\r\n    console.log(\"Good, looped for 2 seconds\");\r\n    break;\r\n  }\r\n}\r\n```\r\n\r\n### 零延迟\r\n零延迟并不意味着回调会立即执行。以 0 为第二参数调用 setTimeout 并不表示在 0 毫秒后就立即调用回调函数。\r\n\r\n其等待的时间取决于队列里待处理的消息数量。在下面的例子中，\"这是一条消息\" 将会在回调获得处理之前输出到控制台，这是因为延迟参数是运行时处理请求所需的最小等待时间，但并不保证是准确的等待时间。\r\n\r\n基本上，`setTimeout` 需要等待当前队列中所有的消息都处理完毕之后才能执行，即使已经超出了由第二参数所指定的时间。\r\n```javascript\r\n(function() {\r\n\r\n  console.log('这是开始');\r\n\r\n  setTimeout(function cb() {\r\n    console.log('这是来自第一个回调的消息');\r\n  });\r\n\r\n  console.log('这是一条消息');\r\n\r\n  setTimeout(function cb1() {\r\n    console.log('这是来自第二个回调的消息');\r\n  }, 0);\r\n\r\n  console.log('这是结束');\r\n\r\n})();\r\n\r\n// \"这是开始\"\r\n// \"这是一条消息\"\r\n// \"这是结束\"\r\n// \"这是来自第一个回调的消息\"\r\n// \"这是来自第二个回调的消息\"\r\n```\r\n\r\n### 多个运行时互相通信\r\n一个 web worker 或者一个跨域的 `iframe` 都有自己的栈、堆和消息队列。两个不同的运行时只能通过 `postMessage` 方法进行通信。如果另一个运行时侦听 `message` 事件，则此方法会向该运行时添加消息。\r\n\r\n### 永不阻塞\r\nJavaScript 的事件循环模型与许多其他语言不同的一个非常有趣的特性是，它永不阻塞。处理 I/O 通常通过事件和回调来执行，所以当一个应用正等待一个 `IndexedDB` 请求返回时，它仍然可以处理其它事情，比如用户输入。\r\n\r\n由于历史原因有一些例外，如 `alert` 或者同步 XHR，但应该尽量避免使用它们。"}]},{"number":38,"title":"【Q038】创建对象有几种方法","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/38","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 通过{}创建对象\r\n```javascript\r\nvar obj = {};\r\n```\r\n\r\n如果对象不用重复创建，这种方式是比较方便的。\r\n\r\n## 2. 通过new Object()创建对象\r\n```javascript\r\nvar obj = new Object();\r\n```\r\n\r\n## 3. 使用字面量创建对象\r\n```javascript\r\nvar person = { name: 'zhang', age: 20 };\r\n\r\n// 等同于\r\nvar person = {};\r\nperson.name = 'zhang';\r\nperson.age = 20;\r\n```\r\n\r\n## 4. 使用工厂模式创建对象\r\n这种方式是使用一个函数来创建对象，减少重复代码，解决了前面三种方式的代码冗余的问题，但是方法不能共享的问题还是存在。\r\n```javascript\r\nfunction createObject(name){\r\n    var o = new Object();\r\n    o.name = name;\r\n    o.sayName = function(){\r\n        alert(this.name);\r\n    };\r\n    return o;\r\n}\r\n\r\nvar o1 = createObject('zhang');\r\nvar o2 = createObject('li');\r\n\r\n// 优点：解决了前面的代码重复的问题\r\n// 缺点：调用的还是不同的方法\r\nconsole.log(o1.sayName===o2.sayName); // false\r\n```\r\n\r\n## 5. 通过构造函数创建对象\r\n所谓构造函数，是首字母大写的函数。通过new 构造函数来创建对象。\r\n还是没有解决方法不能共享的问题。\r\n```javascript\r\nfunction Person(name){\r\n    this.name = name;\r\n    this.sayName = function(){\r\n        alert(this.name);\r\n    };\r\n}\r\n\r\nvar p1 = new Person('zhang');\r\nvar p2 = new Person('li');\r\n\r\nconsole.log(p1.constructor === p2.constructor); // true\r\nconsole.log(p1.constructor === Person); // true\r\nconsole.log(p1.sayName===p2.sayName); // false\r\n```\r\n\r\n## 6. 通过原型模式创建对象\r\n每个方法中都有一个原型（prototype），每个原型都有一个构造器（constructor），构造器又指向这个方法。\r\n```javascript\r\nfunction Animal(){}\r\nconsole.log(Animal.prototype.constructor === Animal); // true\r\n```\r\n\r\n原型创建对象：\r\n```javascript\r\nfunction Animal() { }\r\n\r\nAnimal.prototype.name = 'animal';\r\nAnimal.prototype.sayName = function () { alert(this.name); };\r\n\r\nvar a1 = new Animal();\r\nvar a2 = new Animal();\r\n\r\na1.sayName();\r\n\r\nconsole.log(a1.sayName === a2.sayName); // true\r\nconsole.log(Animal.prototype.constructor); // function Animal(){}\r\nconsole.log(Animal.prototype.constructor === Animal); // true\r\n```\r\n通过原型创建对象，把属性和方法绑定到prototype上，通过这种方式创建对象，方法是共享的，每个对象调用的是同一个方法。\r\n\r\n这种方式创建的对象会存在问题，假如原型中包含有引用类型的属性，那么如果某个对象修改了该属性的值，所有的该原型创建的对象访问的值都会改变。\r\n```javascript\r\nfunction Animal (){}\r\n\r\nAnimal.prototype = {\r\n    name: 'animal',\r\n    friends: ['dog','cat'],\r\n    sayName: function(){\r\n        alert(this.name);\r\n    }\r\n};\r\n\r\nvar a1 = new Animal();\r\nvar a2 = new Animal();\r\n\r\na2.friends.push('snake');\r\nconsole.log(a2.friends); // [dog,cat,snake]\r\nconsole.log(a1.friends); // [dog,cat,snake]\r\n```\r\n\r\n## 7. 通过原型 + 构造函数的方式创建对象\r\n这种方式结合了上面两种方式，解决了代码冗余，方法不能共享，引用类型改变值的问题。\r\n```javascript\r\nfunction Animal(name){\r\n    this.name = name;\r\n    this.friends = ['dog','cat'];\r\n}\r\n\r\nAnimal.prototype.sayName = function(){\r\n    alert(this.name);\r\n};\r\n\r\nvar a1 = new Animal('d');\r\nvar a2 = new Animal('c');\r\n\r\na1.friends.push('snake');\r\nconsole.log(a1.friends); // [dog,cat,snake]\r\nconsole.log(a2.friends); // [dog,cat]\r\n```"}]},{"number":39,"title":"【Q039】深拷贝和浅拷贝","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/39","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 浅拷贝\r\n如果属性是基本类型，拷贝的就是基本类型的值，\r\n如果属性是引用类型，拷贝的就是内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。\r\n\r\n### 赋值和浅拷贝的区别\r\n\r\n对原始数据的影响：\r\n\r\n  | 是否指向同一对象 | 改变基本数据类型 | 改变引用数据类型\r\n-- | -- | -- | --\r\n赋值 | √ | √ | √\r\n浅拷贝 | × | × | √\r\n\r\n## 2. 浅拷贝的实现\r\n### 展开运算符...\r\n```javascript\r\nvar obj2 = {...obj1};\r\n```\r\n\r\n### Object.assign()\r\n```javascript\r\nvar obj2 = Object.assign({}, obj1);\r\n```\r\n\r\n### Array.prototype.concat()\r\n此方法只对数组\r\n```javascript\r\nvar arr2 = arr1.concat([]);\r\n```\r\n\r\n### Array.prototype.slice()\r\n此方法只对数组\r\n```javascript\r\nvar arr2 = arr1.slice();\r\n```\r\n\r\n\r\n## 3. 深拷贝的实现\r\n深拷贝是将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象，且修改新对象不会影响原对象。\r\n\r\n### JSON.parse(JSON.stringify())\r\n```javascript\r\nvar obj2 = JSON.parse(JSON.stringify(obj1));\r\n```\r\n\r\n### 手写递归\r\n递归效果：遍历对象、数组直到里边都是基本数据类型，然后再去复制。\r\n```javascript\r\n// 检测数据类型的功能函数\r\nconst checkedType = (target) => Object.prototype.toString.call(target).replace(/\\[object (\\w+)\\]/, \"$1\").toLowerCase();\r\n// 实现深拷贝（Object/Array）\r\nconst cloneDeep = (target) => {\r\n    let result;\r\n    let type = checkedType(target);\r\n    if(type === 'object') result = {};\r\n    else if(type === 'array') result = [];\r\n    else  return target;\r\n    for (let key in target) {\r\n        if(checkedType(target[key]) === 'object' || checkedType(target[key]) === 'array') {\r\n            result[key] = clone(target[key]);\r\n        } else {\r\n            result[key] = target[key]; \r\n        }\r\n    }\r\n    return result;\r\n}\r\n```"}]},{"number":40,"title":"【Q040】网页各种高度","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/40","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 屏幕的宽高\r\n```javascript\r\nwindow.screen.width\r\nwindow.screen.height\r\n```\r\n\r\n## 2. 工作区的宽高\r\n```javascript\r\nwindow.screen.availWidth\r\nwindow.screen.availHeight\r\n```\r\n\r\n## 3. 文档的宽高\r\n```javascript\r\ndocument.body.scrollHeight\r\ndocument.body.scrollWidth\r\n```\r\n\r\n## 4. 滚动条卷出去的宽高\r\n```javascript\r\ndocument.body.scrollLeft\r\ndocument.body.scrollTop\r\n```\r\n\r\n## 5. 文档可见区域的宽高\r\n```javascript\r\ndocument.body.clientHeight\r\ndocument.body.clientWidth\r\n```\r\n\r\n## 6. 文档可见区域的宽高（加边距、边框、滚动条）\r\n```javascript\r\ndocument.body.offsetHeight\r\ndocument.body.offsetWidth\r\n```\r\n\r\n## 7. 窗口的宽高\r\n```javascript\r\ndocument.body.innerHeight\r\ndocument.body.innerWidth\r\n```"}]},{"number":41,"title":"【Q041】requestAnimationFrame","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/41","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. window.requestAnimationFrame\r\n`window.requestAnimationFrame()` 执行一个动画，并在浏览器下次重绘之前调用指定的回调函数更新动画。\r\n该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。\r\n\r\n一个向右侧移动的方块：\r\n```javascript\r\nfunction animationTest() {\r\n\tvar div = document.createElement('div');\r\n\tdiv.style.width = '100px'\r\n\tdiv.style.height = '100px'\r\n\tdiv.style.position = 'absolute'\r\n\tdiv.style.top = '0px';\r\n\tdiv.style.left = '0px';\r\n\tdiv.style.backgroundColor = '#f00'\r\n\tdiv.style.zIndex = '999999'\r\n\tdocument.body.appendChild(div);\r\n\t\r\n\tlet distance = 0;\r\n\tfunction move(){\r\n\t\tdistance++\r\n\t\tconsole.log(distance) // 打印当前帧，方块移动的距离\r\n\t\tdiv.style.left = distance + 'px'\r\n\t\trequestAnimationFrame(move); // 通知浏览器开始绘制下一帧的时候，继续执行move函数\r\n\t}\r\n\tmove();\r\n}\r\n\r\nanimationTest()\r\n```\r\n\r\n## 2. window.cancelAnimationFrame\r\n取消一个先前通过调用window.requestAnimationFrame()方法添加到计划中的动画帧请求。\r\n\r\n```javascript\r\nfunction animationTest(){\r\n\tlet animationId;\r\n\tconst button = document.createElement(\"button\");\r\n\tbutton.innerHTML = \"停止动画\"\r\n\tbutton.style.position = 'absolute'\r\n\tbutton.style.top = '150px';\r\n\tbutton.style.left = '0px';\r\n\tbutton.style.zIndex = '999999'\r\n\tbutton.onclick = () => {\r\n\t\tif(!!animationId){\r\n\t\t\twindow.cancelAnimationFrame(animationId);\r\n\t\t\tbutton.innerHTML = \"开始动画\"\r\n\t\t\tanimationId = void 0;\r\n\t\t}else{\r\n\t\t\tmove()\r\n\t\t\tbutton.innerHTML = \"停止动画\"\r\n\t\t}\r\n\t}\r\n\r\n\tconst div = document.createElement(\"div\");\r\n\tdiv.style.width = '100px'\r\n\tdiv.style.height = '100px'\r\n\tdiv.style.position = 'absolute'\r\n\tdiv.style.top = '0px';\r\n\tdiv.style.left = '0px';\r\n\tdiv.style.backgroundColor = '#f00'\r\n\tdiv.style.zIndex = '999999'\r\n\tdocument.body.appendChild(div);\r\n\tdocument.body.appendChild(button);\r\n\t\r\n\tlet distance = 0;\r\n\tfunction move(){\r\n\t\tdistance++\r\n\t\tconsole.log(distance) // 打印当前帧，方块移动的距离\r\n\t\tdiv.style.left = distance + 'px'\r\n\t\tanimationId = requestAnimationFrame(move); // 通知浏览器开始绘制下一帧的时候，继续执行move函数\r\n\t}\r\n\tmove();\r\n}\r\n\r\nanimationTest()\r\n```\r\n\r\n## 3. 应用\r\n### 可以用来替代mousemove的动画\r\nmousemove的触发频率很高，很多时候，我们不需要这么高的触发频率，常常为了优化性能，我们会写一个截流函数，来降低它触发的频率。\r\n如果你仅仅是为了让画面看起来更流畅，对频率没有特殊的需求。那么你可以直接使用requestAnimationFrame。\r\n\r\n```javascript\r\nfunction mousemoveTest(){\r\n\tdocument.addEventListener(\"mousemove\", move);\r\n\t\r\n\tfunction move(){\r\n\t\trequestAnimationFrame(() => {\r\n\t\t\t// todo 高性能消耗的代码\r\n\t\t\tconsole.log(\"move 函数执行了\")\r\n\t\t})\r\n\t}\r\n}\r\nmousemoveTest()\r\n```"}]},{"number":42,"title":"【Q042】requestIdleCallback","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/42","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. requestIdleCallback\r\n`window.requestIdleCallback()` 方法插入一个函数，这个函数将在浏览器空闲时期被调用。\r\n这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间timeout，则有可能为了在超时前执行函数而打乱执行顺序。\r\n\r\n你可以在空闲回调函数中调用 requestIdleCallback()，以便在下一次通过事件循环之前调度另一个回调。\r\n\r\n```javascript\r\n// 回调函数执行：当前帧有空闲时间，或者指定时间到了\r\nlet id = requestIdleCallback(function someHeavyComputation(deadline) {\r\n  while((deadline.timeRemaining() > 0 || deadline.didTimeout) && thereIsMoreWorkToDo) {\r\n    doWorkIfNeeded(); // 一定会在将来某个比较空闲的时间（或者在指定时间过期后）得到反复执行\r\n  }\r\n\r\n  if(thereIsMoreWorkToDo) {\r\n    id = requestIdleCallback(someHeavyComputation);\r\n  }\r\n}, { timeout: 1000 });\r\n\r\nwindow.cancelIdleCallback(id);\r\n```\r\n"}]},{"number":43,"title":"【Q043】webassembly","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/43","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. WebAssembly\r\n`Wasm` 是一种新的编码方式，可以在现代的网络浏览器中运行。\r\n它是一种低级的类汇编语言，具有紧凑的二进制格式，可以接近原生的性能运行，并为诸如 C / C ++等语言提供一个编译目标，以便它们可以在 Web 上运行。\r\n它也被设计为可以与 JavaScript 共存，允许两者一起工作。\r\n\r\n### 常用于需要 **安全稳定的** 运行程序的环境\r\n\r\n## 2. WebAssembly 实现\r\n根据所使用的语言，有四种方法可以在 Web 应用程序中实现 WebAssembly。\r\n\r\n- 使用 `Emscripten` 移植 C/C++ 应用程序。\r\n- 直接在程序集级别编写或生成 WebAssembly\r\n- 编写一个 `Rust` 应用程序并将 WebAssembly 作为其输出。\r\n- 使用编译为 WebAssembly 二进制文件的 AssemblyScript。\r\n\r\n## 3. WebAssembly 优势\r\nWebAssembly 正在迅速成为一种主流技术，它被所有主要的浏览器供应商采用，特别是因为接近原生的代码性能。除此之外 WebAssembly 还拥有以下优势：\r\n\r\n- **更好的性能**：WebAssembly 在两个方面提供了增强的性能，即启动速度和吞吐量。缩小的 JavaScript 需要被解析、解释、编译和优化。另一方面，wasm 更紧凑，并且由于其简洁的设计，二进制格式允许更快的解析和快速优化。\r\n- **便携且安全**：它独立于平台、独立于硬件和独立于语言，它不对设备或浏览器没有任何特殊要求，这增强了其便携性，代码在内存安全的沙盒环境中进行验证和执行，可以防止安全漏洞和数据损坏。\r\n- **集成遗留库**：如果应用程序使用 C/C++ 或任何其他兼容语言，WebAssembly 可以轻松地将代码或桌面应用程序可用于 Web。通常使用两个库；用于 Rust 的 wasm-pack 和用于 C/C++ 的 Emscripten。\r\n\r\n## 4. WebAssembly 局限性\r\n\r\n- **没有垃圾回收机制**：与采用垃圾回收的 JavaScript 不同，Wasm 使用平面/线性内存模型，在实例化时分配大量内存并且不会自动回收内存。\r\n- **不能直接访问DOM**：WebAssembly 无法访问文档对象模型 (DOM)，任何 DOM 操作都需要使用 JavaScript 间接完成。或者，在通过 JavaScript 胶水代码完成 DOM 操作的情况下，也可以使用任何工具链，例如 Emscripten。性能取决于所使用的库。\r\n- **旧浏览器不支持**：通常较旧的浏览器没有可用于实例化和加载 Wasm 模块的所需对象。\r\n\r\n## 5. WebAssembly 应用场景\r\nWebAssembly 通常用于需要高性能的计算密集型应用程序。这些包括元宇宙相关技术 AR/VR 实时开发、视频编辑、VPN、图像识别等。\r\n\r\n- 在 tensorflow.js 中加入 wasm 后端支持后，模型的性能提升了 10 倍左右。\r\n- 由于它最初是用 C++ 编写的，因此 Figma 使用 Emscripten 导出到 Asm.js，通过添加适当的 Emscripten 标志启动 WebAssembly 后，大概 3 倍的性能提升。\r\n- 切换到 WebAssembly 后，OpenCV Python 库的性能提升非常明显。 ResNet50 的推理时间增加了 15 倍，内核性能测试速度提高了 3.5 倍。\r\n- Unity 使用 Emscripten 输出 WebAssembly 为游戏导出网络播放器，传统上由于 JavaScript 速度变慢而无法导出到 Web 的游戏，在 Web 上获得了始终如一的良好性能。\r\n"}]},{"number":44,"title":"【Q044】垃圾回收","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/44","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 垃圾回收机制 Garbage Collection\r\n创建一个基本类型、对象、函数……都是需要占用内存的，但js会自动分配，不需要显式手动的去分配内存。\r\njs 也会自动回收，不需要手动的去回收。\r\n\r\n## 2. GC 策略\r\n在 JS 内存管理中有一个概念叫做 **可达性**，就是那些以某种方式可访问或者说可用的值，它们被保证存储在内存中，反之不可访问则需回收。\r\n至于如何回收，其实就是怎样发现这些不可达的垃圾它并给予清理的问题， JS 定期找出用不到的内存并释放。\r\n\r\n回收流程就涉及到了一些算法策略：\r\n"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 3. 标记清除算\r\n标记清除（Mark-Sweep），大多数浏览器的 JS 都在采用标记清除算法。\r\n此算法分为 **标记** 和 **清除** 两个阶段，标记阶段即为所有活动对象做上标记，清除阶段则把没有标记销毁。\r\n引擎在执行 GC 时，需要从出发点去遍历内存中所有的对象去打标。\r\n\r\n### 标记清除算法的流程：\r\n\r\n- GC 在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0\r\n- 然后从各个根对象开始遍历，把不是垃圾的节点改成1\r\n- 清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间\r\n- 最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收\r\n\r\n### 优点：\r\n简单，打标识只用二进制位（0和1）\r\n\r\n### 缺点：\r\n\r\n清除之后，剩余的对象内存位置是不变的，会导致空闲内存空间是不连续的，出现了 `内存碎片` （如下图）\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12247ac3d8f249a5ab85b9b40ba1147b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n这就牵扯出了内存分配的问题，新建对象分配内存时候，要找到尺寸符合的空块才能插入。\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb5107f04a3249ce8d37ec7cc5fd9668~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n## 4. 引用计数算法\r\n引用计数（Reference Counting），这其实是早先的一种垃圾回收算法，它把 对象是否不再需要 简化定义为 对象有没有其他对象引用到它，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收，目前很少使用这种算法了，因为它的问题很多，不过我们还是需要了解一下。\r\n\r\n### 它的策略是跟踪记录每个变量值被使用的次数：\r\n\r\n- 当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1\r\n- 如果同一个值又被赋给另一个变量，那么引用数加 1\r\n- 如果该变量的值被其他的值覆盖了，则引用次数减 1\r\n- 当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存\r\n\r\n```javascript\r\nlet a = new Object() \t// 此对象的引用计数为 1（a引用）\r\nlet b = a \t\t// 此对象的引用计数是 2（a,b引用）\r\na = null  \t\t// 此对象的引用计数为 1（b引用）\r\nb = null \t \t// 此对象的引用计数为 0（无引用）\r\n```\r\n\r\n当两个对象互相引用时，假如被多次调用，那么就会造成大量的内存不会被释放\r\n```javascript\r\nfunction test(){\r\n  let A = new Object()\r\n  let B = new Object()\r\n  \r\n  A.b = B\r\n  B.a = A\r\n}\r\n```\r\n\r\n### 优点：\r\n结构清晰，引用值为 0 时，也就是在变成垃圾的那一刻就会被回收，所以它可以立即回收垃圾。\r\n而标记清除算法需要每隔一段时间进行一次，那在应用程序（JS脚本）运行过程中线程就必须要暂停去执行一段时间的 GC，另外，标记清除算法需要遍历堆里的活动以及非活动对象来清除，而引用计数则只需要在引用时计数就可以了。\r\n\r\n### 缺点：\r\n首先它需要一个计数器，而此计数器需要占很大的位置，因为我们也不知道被引用数量的上限。\r\n还有就是无法解决循环引用无法回收的问题，这也是最严重的。\r\n\r\n## 5. V8对GC的优化\r\n\r\n### 分代式垃圾回收：\r\n分代式机制把一些新、小、存活时间短的对象作为新生代，采用一小块内存频率较高的快速清理，而一些大、老、存活时间长的对象作为老生代，使其很少接受检查，新老生代的回收机制及频率是不同的，可以说此机制的出现很大程度提高了垃圾回收机制的效率。\r\n\r\n**新生代** 的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1～8M 的容量。\r\n**老生代** 的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大。\r\nV8 整个堆内存的大小就等于新生代加上老生代的内存（如下图）\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abae5b06648a40d2aaa453b5d8a83939~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n### 新生代垃圾回收\r\n新生代对象是通过一个名为 Scavenge 的算法进行垃圾回收，在 Scavenge算法 的具体实现中，主要采用了一种复制式的方法即 Cheney算法。\r\n\r\nCheney算法 中将堆内存一分为二，一个是处于使用状态的空间我们暂且称之为 使用区，一个是处于闲置状态的空间我们称之为 空闲区，如下图所示\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa2d5ad1d89b4b7b919f20e4a5f8973a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作。\r\n\r\n当开始进行垃圾回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记完成之后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段，即将非活动对象占用的空间清理掉。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区。\r\n\r\n当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理。\r\n\r\n另外还有一种情况，如果复制一个对象到空闲区时，空闲区空间占用超过了 25%，那么这个对象会被直接晋升到老生代空间中，设置为 25% 的比例的原因是，当完成 Scavenge 回收后，空闲区将翻转成使用区，继续进行对象内存的分配，若占比过大，将会影响后续内存分配。\r\n\r\n### 老生代垃圾回收\r\n相比于新生代，老生代的垃圾回收就比较容易理解了，上面我们说过，对于大多数占用空间大、存活时间长的对象会被分配到老生代里，因为老生代中的对象通常比较大，如果再如新生代一般分区然后复制来复制去就会非常耗时，从而导致回收执行效率不高，所以老生代垃圾回收器来管理其垃圾回收执行，它的整个流程就采用的就是上文所说的标记清除算法了。\r\n\r\n首先是标记阶段，从一组根元素开始，递归遍历这组根元素，遍历过程中能到达的元素称为活动对象，没有到达的元素就可以判断为非活动对象。\r\n\r\n清除阶段老生代垃圾回收器会直接将非活动对象，也就是数据清理掉。\r\n\r\n前面我们也提过，标记清除算法在清除后会产生大量不连续的内存碎片，过多的碎片会导致大对象无法分配到足够的连续内存，而 V8 中就采用了我们上文中说的标记整理算法来解决这一问题来优化空间。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 6. 内存泄露\r\n虽然js引擎有内存回收，v8也做出了优化。\r\n我们的代码中依然要主动避免一些不利于引擎做垃圾回收操作，因为不是所有无用对象内存都可以被回收的，那当不再用到的内存，没有及时回收时，我们叫它 `内存泄漏`（Memory leak）。\r\n\r\n### 不正当的闭包\r\n```javascript\r\nfunction fn2(){\r\n  let test = new Array(1000).fill('isboyjc')\r\n  return function(){\r\n    console.log(test)\r\n    return test\r\n  }\r\n}\r\nlet fn2Child = fn2()\r\nfn2Child()\r\n\r\n// 解决方案：\r\nfn2Child = null\r\n```\r\n\r\n### 额外的全局变量\r\n```javascript\r\nfunction fn(){\r\n  // 没有声明从而制造了隐式全局变量test1\r\n  test1 = new Array(1000).fill('isboyjc1')\r\n  \r\n  // 函数内部this指向window，制造了隐式全局变量test2\r\n  this.test2 = new Array(1000).fill('isboyjc2')\r\n}\r\nfn()\r\n```\r\n\r\n### 游离DOM引用\r\n```javascript\r\nlet root = document.querySelector('#root')\r\nlet ul = document.querySelector('#ul')\r\nlet li3 = document.querySelector('#li3')\r\n\r\n// 由于ul变量存在，整个ul及其子元素都不能GC\r\nroot.removeChild(ul)\r\n\r\n// 虽置空了ul变量，但由于li3变量引用ul的子节点，所以ul元素依然不能被GC\r\nul = null\r\n\r\n// 已无变量引用，此时可以GC\r\nli3 = null\r\n```\r\n\r\n### 遗忘的定时器\r\n```javascript\r\n// 获取数据\r\nlet someResource = getData()\r\nsetInterval(() => {\r\n  const node = document.getElementById('Node')\r\n\tif(node) {\r\n    node.innerHTML = JSON.stringify(someResource))\r\n\t}\r\n}, 1000)\r\n```\r\n\r\n### 遗忘的事件监听器\r\n```javascript\r\nwindow.addEventListener(\"resize\", function() {})\r\n```\r\n\r\n### 遗忘的Map、Set对象\r\n当使用 `Map` 或 `Set` 存储对象时，同 `Object` 一致都是强引用，如果不将其主动清除引用，其同样会造成内存不自动进行回收。\r\n\r\n### 未清理的console输出\r\n\r\n## 7. 内存膨胀\r\n在短时间内内存占用极速上升到达一个峰值，想要避免需要使用技术手段减少对内存的占用。\r\n\r\n## 8. 频繁 GC\r\nGC 执行的特别频繁，一般出现在频繁使用大的临时变量导致新生代空间被装满的速度极快，而每次新生代装满时就会触发 GC，频繁 GC 同样会导致页面卡顿，想要避免的话就不要搞太多的临时变量，因为临时变量不用了就会被回收。"}]},{"number":45,"title":"【Q045】proxy","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/45","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. Proxy\r\n`Proxy` 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。\r\n\r\n```javascript\r\nconst handler = {\r\n    get: function(obj, prop) {\r\n        return prop in obj ? obj[prop] : 37;\r\n    }\r\n};\r\n\r\nconst p = new Proxy({}, handler);\r\np.a = 1;\r\np.b = undefined;\r\n\r\nconsole.log(p.a, p.b);      // 1, undefined\r\nconsole.log('c' in p, p.c); // false, 3\r\n```\r\n\r\n## 2. 用法\r\n\r\n### 无操作转发代理\r\n在以下例子中，我们使用了一个原生 JavaScript 对象，代理会将所有应用到它的操作转发到这个对象上。\r\n```javascript\r\nlet target = {};\r\nlet p = new Proxy(target, {});\r\n\r\np.a = 37;   // 操作转发到目标\r\n\r\nconsole.log(target.a);    // 37. 操作已经被正确地转发\r\n```\r\n\r\n### 验证\r\n通过代理，你可以轻松地验证向一个对象的传值。下面的代码借此展示了 `set handler` 的作用。\r\n```javascript\r\nlet validator = {\r\n  set: function(obj, prop, value) {\r\n    if (prop === 'age') {\r\n      if (!Number.isInteger(value)) {\r\n        throw new TypeError('The age is not an integer');\r\n      }\r\n      if (value > 200) {\r\n        throw new RangeError('The age seems invalid');\r\n      }\r\n    }\r\n\r\n    // The default behavior to store the value\r\n    obj[prop] = value;\r\n\r\n    // 表示成功\r\n    return true;\r\n  }\r\n};\r\n\r\nlet person = new Proxy({}, validator);\r\nperson.age = 100;\r\n\r\nconsole.log(person.age); // 100\r\nperson.age = 'young'; // Uncaught TypeError: The age is not an integer\r\nperson.age = 300; // Uncaught RangeError: The age seems invalid\r\n```\r\n\r\n### 扩展构造函数\r\n方法代理可以轻松地通过一个新构造函数来扩展一个已有的构造函数。这个例子使用了 `construct` 和 `apply`。\r\n```javascript\r\nfunction extend(sup, base) {\r\n  var descriptor = Object.getOwnPropertyDescriptor(\r\n    base.prototype, \"constructor\"\r\n  );\r\n  base.prototype = Object.create(sup.prototype);\r\n  var handler = {\r\n    construct: function(target, args) {\r\n      var obj = Object.create(base.prototype);\r\n      this.apply(target, obj, args);\r\n      return obj;\r\n    },\r\n    apply: function(target, that, args) {\r\n      sup.apply(that, args);\r\n      base.apply(that, args);\r\n    }\r\n  };\r\n  var proxy = new Proxy(base, handler);\r\n  descriptor.value = proxy;\r\n  Object.defineProperty(base.prototype, \"constructor\", descriptor);\r\n  return proxy;\r\n}\r\n\r\nvar Person = function (name) {\r\n  this.name = name\r\n};\r\n\r\nvar Boy = extend(Person, function (name, age) {\r\n  this.age = age;\r\n});\r\n\r\nBoy.prototype.sex = \"M\";\r\n\r\nvar Peter = new Boy(\"Peter\", 13);\r\nconsole.log(Peter.sex);  // \"M\"\r\nconsole.log(Peter.name); // \"Peter\"\r\nconsole.log(Peter.age);  // 13\r\n```\r\n\r\n## 互换 DOM 节点的属性\r\n有时，我们可能需要互换两个不同的元素的属性或类名。下面的代码以此为目标，展示了 `set handler` 的使用场景。\r\n```javascript\r\nlet view = new Proxy({\r\n  selected: null\r\n}, {\r\n  set: function(obj, prop, newval) {\r\n    let oldval = obj[prop];\r\n\r\n    if (prop === 'selected') {\r\n      if (oldval) {\r\n        oldval.setAttribute('aria-selected', 'false');\r\n      }\r\n      if (newval) {\r\n        newval.setAttribute('aria-selected', 'true');\r\n      }\r\n    }\r\n\r\n    // 默认行为是存储被传入 setter 函数的属性值\r\n    obj[prop] = newval;\r\n\r\n    // 表示操作成功\r\n    return true;\r\n  }\r\n});\r\n\r\nlet i1 = view.selected = document.getElementById('item-1');\r\nconsole.log(i1.getAttribute('aria-selected')); // 'true'\r\n\r\nlet i2 = view.selected = document.getElementById('item-2');\r\nconsole.log(i1.getAttribute('aria-selected')); // 'false'\r\nconsole.log(i2.getAttribute('aria-selected')); // 'true'\r\n```\r\n\r\n### 值修正及附加属性\r\n以下 `products` 代理会计算传值并根据需要转换为数组。这个代理对象同时支持一个叫做 `latestBrowser` 的附加属性，这个属性可以同时作为 getter 和 setter。\r\n```javascript\r\nlet products = new Proxy({\r\n  browsers: ['Internet Explorer', 'Netscape']\r\n}, {\r\n  get: function(obj, prop) {\r\n    // 附加一个属性\r\n    if (prop === 'latestBrowser') {\r\n      return obj.browsers[obj.browsers.length - 1];\r\n    }\r\n\r\n    // 默认行为是返回属性值\r\n    return obj[prop];\r\n  },\r\n  set: function(obj, prop, value) {\r\n    // 附加属性\r\n    if (prop === 'latestBrowser') {\r\n      obj.browsers.push(value);\r\n      return;\r\n    }\r\n\r\n    // 如果不是数组，则进行转换\r\n    if (typeof value === 'string') {\r\n      value = [value];\r\n    }\r\n\r\n    // 默认行为是保存属性值\r\n    obj[prop] = value;\r\n\r\n    // 表示成功\r\n    return true;\r\n  }\r\n});\r\n\r\nconsole.log(products.browsers); // ['Internet Explorer', 'Netscape']\r\nproducts.browsers = 'Firefox';  // 如果不小心传入了一个字符串\r\nconsole.log(products.browsers); // ['Firefox'] <- 也没问题，得到的依旧是一个数组\r\n\r\nproducts.latestBrowser = 'Chrome';\r\nconsole.log(products.browsers);      // ['Firefox', 'Chrome']\r\nconsole.log(products.latestBrowser); // 'Chrome'\r\n```"}]},{"number":46,"title":"【Q046】Object.defineProperty","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/46","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. Object.defineProperty\r\n`Object.defineProperty()` 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。\r\n\r\n备注： 应当直接在 `Object` 构造器对象上调用此方法，而不是在任意一个 Object 类型的实例上调用。\r\n\r\n### 参数\r\n- obj：要定义属性的对象。\r\n- prop：要定义或修改的属性的名称 。\r\n- descriptor：要定义或修改的属性描述符。\r\n\r\n```javascript\r\nconst object1 = {};\r\n\r\nObject.defineProperty(object1, 'property1', {\r\n  value: 42,\r\n  writable: false\r\n});\r\n\r\nobject1.property1 = 77; // 严格模式下报错\r\nconsole.log(object1.property1); // 42\r\n```\r\n\r\n### 该方法允许精确地添加或修改对象的属性。\r\n通过赋值操作添加的普通属性是可枚举的，可以改变这些属性的值，也可以 `delete` 这些属性。\r\n这个方法允许修改默认的额外选项。默认情况下，使用 `Object.defineProperty()` 添加的属性值是 **不可修改的**（immutable）。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. 属性描述符\r\n对象里目前存在的属性描述符有两种主要形式：\r\n\r\n- 数据描述符：是一个具有值的属性，该值可以是可写的，也可以是不可写的。\r\n- 存取描述符：是由 getter 函数和 setter 函数所描述的属性。一个描述符只能是这两者其中之一；不能同时是两者。\r\n\r\n这两种描述符都是对象。以下为可选键值：\r\n\r\n可选键 | 类型 | 描述 | 默认值\r\n-- | -- | -- | --\r\nconfigurable | 通用 | 当且仅当该属性的 configurable 键值为 true 时，<br />该属性的描述符才能够被改变，<br />同时该属性也能从对应的对象上被删除。| false\r\nenumerable | 通用 | 当且仅当该属性的 configurable 键值为 true 时，<br />该属性的描述符才能够被改变，<br />同时该属性也能从对应的对象上被删除。| false\r\nvalue | 数据描述符 | 该属性对应的值。可以是任何有效的 JS 值（数值，对象，函数等）。| undefined\r\nwritable | 数据描述符 | 当且仅当该属性的 writable 键值为 true 时，<br />属性的值（value）才能被直接赋值。 | false\r\nget | 存取描述符 | 属性的 getter 函数，如果没有 getter，则为 undefined。<br />当访问该属性时，会调用此函数。执行时会传入 this 对象。<br />该函数的返回值会被用作属性的值。| undefined\r\nset | 存取描述符 | 属性的 setter 函数，如果没有 setter，则为 undefined。<br />当属性值被修改时，会调用此函数。执行时会传入 this 对象。| undefined\r\n\r\n记住，这些选项不一定是自身属性，也要考虑继承来的属性。\r\n为了确认保留这些默认值，在设置之前，可能要冻结 `Object.prototype`，明确指定所有的选项，或者通过 `Object.create(null)` 将 `__proto__` 属性指向 `null`。\r\n\r\n```javascript\r\n// 使用 __proto__\r\nvar obj = {};\r\nvar descriptor = Object.create(null); // 没有继承的属性\r\n// 默认没有 enumerable，没有 configurable，没有 writable\r\ndescriptor.value = 'static';\r\nObject.defineProperty(obj, 'key', descriptor);\r\n\r\n// 显式\r\nObject.defineProperty(obj, \"key\", {\r\n  enumerable: false,\r\n  configurable: false,\r\n  writable: false,\r\n  value: \"static\"\r\n});\r\n\r\n// 循环使用同一对象\r\nfunction withValue(value) {\r\n  var d = withValue.d || (\r\n    withValue.d = {\r\n      enumerable: false,\r\n      writable: false,\r\n      configurable: false,\r\n      value: null\r\n    }\r\n  );\r\n  d.value = value;\r\n  return d;\r\n}\r\n// ... 并且 ...\r\nObject.defineProperty(obj, \"key\", withValue(\"static\"));\r\n\r\n// 如果 freeze 可用，防止后续代码添加或删除对象原型的属性\r\n// （value, get, set, enumerable, writable, configurable）\r\n(Object.freeze||Object)(Object.prototype);\r\n```\r\n"}]},{"number":47,"title":"【Q047】map set","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/47","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. Map\r\n`Map` 对象保存键值对，并且能够记住键的原始插入顺序。任何值都可以作为一个键或一个值。\r\n\r\n```javascript\r\nconst map1 = new Map();\r\n\r\nmap1.set('a', 1);\r\nmap1.set('b', 2);\r\nmap1.set('c', 3);\r\nconsole.log(map1.get('a')); // 1\r\n\r\nmap1.set('a', 97);\r\nconsole.log(map1.get('a')); // 97\r\nconsole.log(map1.size); // 3\r\n\r\nmap1.delete('b');\r\nconsole.log(map1.size); // 2\r\n```\r\n\r\n### 键的相等\r\n\r\n- 键的比较基于 `零值相等` 算法。\r\n- `NaN` 是与 NaN 相等的（虽然 NaN !== NaN），剩下所有其它的值是根据 === 运算符的结果判断是否相等。\r\n- 在目前的 ECMAScript 规范中，-0 和 +0 被认为是相等的。\r\n\r\n## 2. Object 和 Map 的比较\r\n`Object` 和 `Map` 类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值。\r\n因此 ES6 以前我们一直都把对象当成 `Map` 使用。\r\n\r\n不过 `Map` 和 `Object` 有一些重要的区别，在下列情况中使用 `Map` 会是更好的选择：\r\n\r\n  | Map | Object\r\n-- | -- | --\r\n意外的键 | 默认无键 | 原型链上的键可能会冲突\r\n键的类型 | 任何 | `String` \\| `Symbol`\r\n键的顺序 | 有序 | 不规则\r\n键值个数 | `size` | 手动计算\r\n迭代 | √ | ×\r\n性能 | 频繁操作下表现好 | 无优化\r\n序列化和解析 | × | √\r\n\r\n## 3. Set\r\n`Set` 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。\r\n`Set` 对象是值的集合，你可以按照插入的顺序迭代它的元素。Set 中的元素只会出现一次，即 Set 中的元素是唯一的。\r\n其他特性同 `Map`\r\n\r\n### 常用于数组去重\r\n```javascript\r\nconst numbers = [2,3,4,4,2,3,3,4,4,5,5,6,6,7,5,32,3,4,5]\r\nconsole.log([...new Set(numbers)]) // [2, 3, 4, 5, 6, 7, 32]\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 4. 对于Object 和 Map的使用取舍的知识点补充\r\n## HashMap\r\n基于哈希表的 Map，提供所有可选的映射操作。\r\n很多语言里有这个内置对象，例如java、php、rust...\r\njs 因为历史原因，es6才加入Map 内置对象。在此之前我们使用Object模拟 HashMap做映射效果。\r\n也是因为Map加入的很晚，大部分开发者没有对其充分利用，现代框架设计上对Map的支持度也不足（例如react hooks的deps）。\r\n\r\n下面，列举一些应该更多考虑使用 Map 的一些原因：\r\n\r\n## 为什么 Object 不符合 HashMap 的使用情况\r\n\r\n- 限制 **键的类型** 为 `String` 和 `Symbol`，其他类型的键都被 `toString` 转为 `String`。\r\n```javascript\r\nconst foo = []\r\nconst bar = {}\r\nconst obj = {[foo]: 'foo', [bar]: 'bar'}\r\n\r\nconsole.log(obj) // {\"\": 'foo', [object Object]: 'bar'}\r\n```\r\n- Object可能会存在继承到的键，这些 **意外的键** 可能会造成冲突。\r\n- Object **键的顺序** 在 js低版本下很混乱。ES6 新增了定义时的有序，ES11 新增了继承属性的有序。\r\n\r\n## 不必要的继承\r\n在ES6之前，获得 hash map 的唯一方法是创建一个空对象：\r\n```javascript\r\nvar hashMap = {}\r\n```\r\n\r\n然而，在创建时，这个对象不再是空的。\r\n尽管 hashMap 是用一个空的对象字面量创建的，但它自动继承了 `Object.prototype`。\r\n这就是为什么我们可以在 hashMap 上调用 `hasOwnProperty`、`toString`、`constructor` 等方法，尽管我们从未在该对象上明确定义这些方法。\r\n```javascript\r\nvar hashMap = {}\r\n\r\nconsole.log(hashMap.__proto__ === Object.prototype) // true\r\n```\r\n\r\n由于原型继承，我们现在有两种类型的属性被混淆了：存在于对象本身的属性，即它自己的属性，以及存在于原型链的属性，即继承的属性。\r\n\r\n因此，我们需要一个额外的检查（例如 `hasOwnProperty`）来确保一个给定的属性确实是用户提供的，而不是从原型继承的。\r\n```javascript\r\nvar hashMap = { name: 'zs' }\r\n\r\nconsole.log(hashMap.hasOwnProperty('name')) // true\r\nconsole.log(hashMap.hasOwnProperty('__proto__')) // false\r\n```\r\n\r\n除此之外，在运行时对 `Object.prototype` 的任何改变都会在所有对象中引起连锁反应。这就为原型污染攻击打开了大门，这对大型的 JS 应用程序来说是一个严重的安全问题。\r\n```javascript\r\nvar hashMap = {}\r\nObject.prototype.age = 18\r\n\r\nconsole.log(hashMap.age) // 18\r\n```\r\n\r\n不过，我们可以通过使用 es5的 `Object.create(null)` 来解决这个问题，它可以生成一个不继承 `Object.prototype` 的对象。\r\n```javascript\r\nvar hashMap = Object.create(null)\r\n\r\nconsole.log(hashMap) // undefined\r\n```\r\n\r\n### 键值冲突\r\n当一个对象自己的属性与它的原型上的属性有名称冲突时，它就会打破预期，从而使程序崩溃。\r\n\r\n`hasOwnProperty` 有一个风险，当对象里定义了hasOwnProperty属性会覆盖。\r\n```javascript\r\nvar hashMap = { name: 'zs' }\r\nconsole.log(hashMap.hasOwnProperty('name')) // true\r\n\r\nhashMap.hasOwnProperty = 1;\r\nconsole.log(hashMap.hasOwnProperty('name')) // hashMap.hasOwnProperty is not a function\r\n```\r\n\r\n可以做 **防御性编程** 来防止这种情况。例如，我们可以从 `Object.prototype` 中借用`hasOwnProperty` 来代替\r\n```javascript\r\nvar hashMap = { name: 'zs' }\r\nhashMap.hasOwnProperty = 1;\r\n\r\nconsole.log(Object.prototype.hasOwnProperty.call(hashMap, 'name')) // true\r\n```\r\n\r\n还有一个更简短的方法就是在一个对象的字面量上调用该方法，如`{}.hasOwnProperty.call` 和 ES2022 新出的方法 `Object.hasOwn`。\r\n\r\n### 次优的人机工程学\r\n`Object` 没有提供足够的人机工程学，不能作为 HashMap 使用，许多常见的任务不能直观地执行。\r\n\r\n#### size\r\nObject 并没有提供方便的API来获取 size，即属性的数量。而且，对于什么是一个对象的 size ，还有一些细微的差别：\r\n\r\n- 如果只关心字符串、可枚举的键，那么可以用 Object.keys() 将键转换为数组，并获得其length。\r\n- 如果k只想要不可枚举的字符串键，那么必须得使用 Object.getOwnPropertyNames 来获得一个键的列表并获得其 length。\r\n- 如果只对 symbol  键感兴趣，可以使用 getOwnPropertySymbols 来显示 symbol  键。或者可以使用 Reflect.ownKeys 来一次获得字符串键和 symbol  键，不管它是否是可枚举的。\r\n\r\n上述所有选项的运行时复杂度为 **O(n)**，因为我们必须先构造一个键的数组，然后才能得到其长度。\r\n\r\n#### iterate\r\n循环遍历对象也有类似的复杂性。\r\n我们可以使用 `for...in` 循环。但它会读取到继承的可枚举属性。\r\n```javascript\r\nObject.prototype.foo = 'bar'\r\n\r\nconst obj = {id: 1} \r\n\r\nfor (const key in obj) {\r\n\tconsole.log(key) // 'id', 'foo'\r\n}\r\n```\r\n\r\n我们不能对一个对象使用 `for ... of`，因为默认情况下它不是一个可迭代的对象，除非我们明确定义 `Symbol.iterator` 方法在它上面。\r\n```javascript\r\nObject.prototype.foo = 'bar'\r\n\r\nconst obj = {id: 1}\r\n\r\nobj[Symbol.iterator] = function*(){\r\n    var keys = Object.keys(obj);\r\n    for(var k of keys){\r\n        yield k\r\n    }\r\n};\r\n\r\nfor(var key of obj){\r\n    console.log(key) // 'id', 'foo'\r\n}\r\n```\r\n\r\n我们可以使用 `Object.keys`、`Object.values` 和 `Object.entry` 来获得一个可枚举的字符串键（或/和值）的列表，并通过该列表进行迭代，这引入了一个额外的开销步骤。\r\n```javascript\r\nObject.prototype.foo = 'bar'\r\n\r\nconst obj = {id: 1} \r\n\r\nfor (const key of Object.keys(obj)) {\r\n\tconsole.log(key) // 'id', 'foo'\r\n}\r\n```\r\n\r\n还有一个是 插入对象的键的顺序并不是按我们的顺序来的，这是一个很蛋疼的地方。在大多数浏览器中，整数键是按升序排序的，并优先于字符串键，即使字符串键是在整数键之前插入的：\r\n```javascript\r\nconst obj = {}\r\n\r\nobj.foo = 'first'\r\nobj[2] = 'second'\r\nobj[1] = 'last'\r\n\r\nconsole.log(obj) // {1: 'last', 2: 'second', foo: 'first'}\r\n```\r\n\r\n## clear\r\n没有简单的方法来删除一个对象的所有属性，我们必须用 `delete` 操作符一个一个地删除每个属性，这在历史上是众所周知的慢。\r\n```javascript\r\n// 对象删除所有属性\r\nconst obj = {id: 1, foo: 'bar'}\r\n\r\nfor (const key in obj) {\r\n\tdelete obj[key]\r\n}\r\n\r\n// HashMap删除所有属性\r\nconst map1 = new Map();\r\n\r\nmap1.clear();\r\n```\r\n\r\n## 检查属性是否存在\r\n我们不能依靠点/括号符号来检查一个属性的存在，因为值本身可能被设置为 undefined。相反，得使用 `Object.prototype.hasOwnProperty` 或 `Object.hasOwn`。\r\n```javascript\r\n// 对象检查属性\r\nconst obj = {a: undefined}\r\n\r\nObject.hasOwn(obj, 'a') // true\r\n\r\n// HashMap检查属性\r\nconst map1 = new Map();\r\nmap1.has('a') // false\r\n```\r\n\r\n## Map\r\nES6 为我们带来了 Map，首先，与只允许键值为 String 和 symbols 的 Object 不同，`Map` 支持任何数据类型的键。\r\n但更重要的是，Map 在用户定义的和内置的程序数据之间提供了一个干净的分离，代价是需要一个额外的 `Map.prototype.get` 来获取对应的项。\r\nMap 也提供了更好的人机工程学。Map 默认是一个可迭代的对象。这说明可以用 for ... of 轻松地迭代，并做一些事情，比如使用嵌套的解构来从 Map 中取出第一个项。\r\n```javascript\r\nconst [[firstKey, firstValue]] = map\r\n```\r\n\r\n与 Object 相比，Map 为各种常见任务提供了专门的方法：\r\nMap.prototype.has 检查一个给定的项是否存在，与必须在对象上使用Object.prototype.hasOwnProperty/Object.hasOwn 相比，不那么尴尬了。\r\n\r\n- `Map.prototype.has` 检查一个给定的项是否存在，与在对象上使用`Object.prototype.hasOwnProperty/Object.hasOwn` 相比要好。\r\n- `Map.prototype.get` 返回与提供的键相关的值。有的可能会觉得这比对象上的点符号或括号符号更笨重。不过，它提供了一个干净的用户数据和内置方法之间的分离。\r\n- `Map.prototype.size` 返回 Map 中的项的个数，与获取对象大小的操作相比，这明显好太多了。此外，它的速度也更快。\r\n- `Map.prototype.clear` 可以删除 Map 中的所有项，它比 delete 操作符快得多。\r\n\r\n### 性能差异\r\n在 JS 社区中，似乎有一个共同的信念，即在大多数情况下，Map 要比 Object 快。有些人声称通过从 Object 切换到 Map 可以看到明显的性能提升。\r\n我在 LeetCode 上也证实了这种想法，对于数据量大的 Object 会超时，但 Map 上则不会。\r\n\r\n### 内存使用情况\r\nMap 比 Object 消耗的内存少20%到50%，因为 Map 不像 Object 那样存储属性描述符，比如 writable/enumerable/configurable 。\r\n\r\n"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 5. 总结\r\n\r\n- Map 比 Object 快，除非有小的整数、数组索引的键，而且它更节省内存。\r\n- 如果你需要一个频繁更新的 HashMap，请使用 Map；如果你想一个固定的键值集合（即记录），请使用Object，并注意原型继承带来的陷阱。\r\n- 现代框架下的日常工作使用Object更利于维护。（例如react hooks的deps不检测Map/Set）。"}]},{"number":48,"title":"【Q048】null 和 undefined 的区别","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/48","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. null\r\n值 `null` 特指 **对象** 的值未设置。它是 JavaScript `基本类型` 之一，在布尔运算中被认为是 `falsy`。\r\n\r\n值 `null` 是一个字面量，不像 `undefined`，它不是全局对象的一个属性。\r\n`null` 是表示缺少的标识，指示变量未指向任何对象。\r\n把 `null` 作为尚未创建的对象，也许更好理解。在 API 中，`null` 常在返回类型应是一个对象，但没有关联的值的地方使用。\r\n\r\n```javascript\r\n// foo 不存在，它从来没有被定义过或者是初始化过：\r\nconsole.log(foo); // \"ReferenceError: foo is not defined\"\r\n\r\n// foo 现在已经是知存在的，但是它没有类型或者是值：\r\nvar foo = null;\r\nconsole.log(foo); // null\r\n```\r\n\r\n当检测 null 或 undefined 时，注意相等（==）与全等（===）两个操作符的区别，前者会执行类型转换：\r\n```javascript\r\ntypeof null        // \"object\" (因为一些以前的原因而不是'null')\r\ntypeof undefined   // \"undefined\"\r\nnull === undefined // false\r\nnull  == undefined // true\r\nnull === null // true\r\nnull == null // true\r\n!null //true\r\nisNaN(1 + null) // false\r\nisNaN(1 + undefined) // true\r\n```\r\n\r\n## 2. undefined\r\n`undefined` 是全局对象的一个属性。也就是说，它是全局作用域的一个变量。\r\n`undefined` 的最初值就是原始数据类型 `undefined`。\r\n一个没有被赋值的变量的类型是 `undefined`。如果方法或者是语句中操作的变量没有被赋值，则会返回 `undefined`。\r\n```javascript\r\nfunction test(a){\r\n    console.log(typeof a);    // undefined\r\n    return a;\r\n}\r\n\r\ntest();                       // 返回\"undefined\"\r\n```\r\n\r\n## 3. null 与 undefined 的相同点\r\n\r\n- 都是原始类型，保存在栈中变量本地\r\n- 转换布尔值都为 false\r\n- 转换成对象的时候，都会报错\r\n- 宽松相等(==) 判断是相等的\r\n\r\n## 4. null 与 undefined 的不同点\r\n\r\n- undefined 表示变量声明过但并未赋过值，null 表示一个变量将来可能指向一个对象。\r\n- typeof 检测时，undefined 类型是 undefined，null 类型是 object\r\n- 数值转换时，null 可以转化为0，undefined 无法参与计算\r\n- 手动释放内存，可以使用null\r\n\r\n\r\n"}]},{"number":49,"title":"【Q049】symbol","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/49","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. Symbol\r\n`symbol` 是一种基本数据类型。\r\n`Symbol()` 函数会返回 symbol 类型的值，该类型具有静态属性和静态方法。\r\n它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的 symbol 注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法：`new Symbol()`。\r\n\r\n每个从 `Symbol()` 返回的 symbol 值都是唯一的。一个 symbol 值能作为对象属性的标识符；这是该数据类型仅有的目的。\r\n\r\n```javascript\r\nvar sym1 = Symbol();\r\nvar sym2 = Symbol('foo');\r\nvar sym3 = Symbol('foo');\r\nvar sym4 = new Symbol(); // TypeError\r\n\r\nconsole.log(sym2 === sym3) // false\r\n```\r\n\r\n## 2. Symbol用法\r\n### 对 symbol 使用 typeof 运算符\r\n```javascript\r\nconsole.log(typeof Symbol()) // 'symbol'\r\nconsole.log(typeof Symbol('foo')) // 'symbol'\r\nconsole.log(typeof Symbol.iterator) // 'symbol'\r\n```\r\n\r\n### Symbol 类型转换\r\n当使用 symbol 值进行类型转换时需要注意一些事情：\r\n\r\n- 尝试将一个 symbol 值转换为一个 number 值时，会抛出一个 TypeError \r\n- 使用宽松相等时，Object(sym) == sym // true.\r\n- 这会阻止你从一个 symbol 值隐式地创建一个新的 string 类型的属性名。例如，Symbol(\"foo\") + \"bar\" 将抛出一个 TypeError\r\n\r\n### Symbols 与 for...in 迭代\r\nSymbols 在 `for...in` 迭代中不可枚举。\r\n另外，`Object.getOwnPropertyNames()` 不会返回 symbol 对象的属性，但是你能使用 `Object.getOwnPropertySymbols()` 得到它们。\r\n```javascript\r\nvar obj = {};\r\n\r\nobj[Symbol(\"a\")] = \"a\";\r\nobj[Symbol.for(\"b\")] = \"b\";\r\nobj[\"c\"] = \"c\";\r\nobj.d = \"d\";\r\n\r\nfor (var i in obj) {\r\n   console.log(i); // 'c', 'd'\r\n}\r\n```\r\n\r\n### Symbols 与 JSON.stringify()\r\n当使用 JSON.stringify() 时，以 symbol 值作为键的属性会被完全忽略：\r\n```javascript\r\nJSON.stringify({[Symbol(\"foo\")]: \"foo\"});\r\n// '{}'\r\n```\r\n\r\n### Symbol 包装器对象作为属性的键\r\n当一个 Symbol 包装器对象作为一个属性的键时，这个对象将被强制转换为它包装过的 symbol 值：\r\n```javascript\r\nvar sym = Symbol(\"foo\");\r\nvar obj = {[sym]: 1};\r\nobj[sym];            // 1\r\nobj[Object(sym)];    // 1\r\n```"}]},{"number":50,"title":"【Q050】Object.assign","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/50","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. Object.assign\r\n`Object.assign()` 方法将所有可枚举的自有属性从一个或多个源对象复制到目标对象，返回修改后的对象。\r\n如果目标对象与源对象具有相同的 **键**，则目标对象中的属性将被源对象中的属性覆盖，后面的源对象的属性将类似地覆盖前面的源对象的属性。\r\n\r\n```javascript\r\nconst target = { a: 1, b: 2 };\r\nconst source = { b: 4, c: 5 };\r\n\r\nconst returnedTarget = Object.assign(target, source);\r\n\r\nconsole.log(target); // { a: 1, b: 4, c: 5 }\r\nconsole.log(returnedTarget === target); // true\r\n```\r\n\r\n### 常用于合并对象\r\n\r\n## 2. 用法\r\n### 合并对象\r\n```javascript\r\nconst o1 = { a: 1 };\r\nconst o2 = { b: 2 };\r\nconst o3 = { c: 3 };\r\n\r\nconst obj = Object.assign(o1, o2, o3);\r\nconsole.log(obj); // { a: 1, b: 2, c: 3 }\r\nconsole.log(o1);  // { a: 1, b: 2, c: 3 }\r\n```\r\n\r\n### 复制对象\r\n```javascript\r\nconst obj = { a: 1 };\r\nconst copy = Object.assign({}, obj);\r\nconsole.log(copy); // { a: 1 }\r\n```\r\n\r\n### 浅拷贝\r\n针对 深拷贝，需要使用其他办法，因为 Object.assign() 只复制属性值。\r\n假如源对象是一个对象的引用，它仅仅会复制其引用值。\r\n```javascript\r\nlet obj1 = { a: 0 , b: { c: 0}};\r\nlet obj2 = Object.assign({}, obj1);\r\nconsole.log(JSON.stringify(obj2)); // { \"a\": 0, \"b\": { \"c\": 0}}\r\n\r\nobj1.a = 1;\r\nconsole.log(JSON.stringify(obj1)); // { \"a\": 1, \"b\": { \"c\": 0}}\r\nconsole.log(JSON.stringify(obj2)); // { \"a\": 0, \"b\": { \"c\": 0}}\r\n\r\nobj2.a = 2;\r\nconsole.log(JSON.stringify(obj1)); // { \"a\": 1, \"b\": { \"c\": 0}}\r\nconsole.log(JSON.stringify(obj2)); // { \"a\": 2, \"b\": { \"c\": 0}}\r\n\r\nobj2.b.c = 3;\r\nconsole.log(JSON.stringify(obj1)); // { \"a\": 1, \"b\": { \"c\": 3}}\r\nconsole.log(JSON.stringify(obj2)); // { \"a\": 2, \"b\": { \"c\": 3}}\r\n\r\n// Deep Clone\r\nobj1 = { a: 0 , b: { c: 0}};\r\nlet obj3 = JSON.parse(JSON.stringify(obj1));\r\nobj1.a = 4;\r\nobj1.b.c = 4;\r\nconsole.log(JSON.stringify(obj3)); // { \"a\": 0, \"b\": { \"c\": 0}}\r\n```\r\n\r\n### 拷贝 Symbol 类型属性\r\n```javascript\r\nconst o1 = { a: 1 };\r\nconst o2 = { [Symbol('foo')]: 2 };\r\n\r\nconst obj = Object.assign({}, o1, o2);\r\nconsole.log(obj); // { a : 1, [Symbol(\"foo\")]: 2 }\r\nObject.getOwnPropertySymbols(obj); // [Symbol(foo)]\r\n```\r\n\r\n### 原型链上的属性和不可枚举属性不能被复制\r\n```javascript\r\nconst obj = Object.create({ foo: 1 }, { // foo is on obj's prototype chain.\r\n  bar: {\r\n    value: 2  // bar is a non-enumerable property.\r\n  },\r\n  baz: {\r\n    value: 3,\r\n    enumerable: true  // baz is an own enumerable property.\r\n  }\r\n});\r\n\r\nconst copy = Object.assign({}, obj);\r\nconsole.log(copy); // { baz: 3 }\r\n```\r\n\r\n### 异常会打断后续拷贝任务\r\n```javascript\r\nconst target = Object.defineProperty({}, 'foo', {\r\n  value: 1,\r\n  writable: false\r\n}); // target.foo is a read-only property\r\n\r\nObject.assign(target, { bar: 2 }, { foo2: 3, foo: 3, foo3: 3 }, { baz: 4 });\r\n// TypeError: \"foo\" is read-only\r\n// The Exception is thrown when assigning target.foo\r\n\r\nconsole.log(target.bar);  // 2, the first source was copied successfully.\r\nconsole.log(target.foo2); // 3, the first property of the second source was copied successfully.\r\nconsole.log(target.foo);  // 1, exception is thrown here.\r\nconsole.log(target.foo3); // undefined, assign method has finished, foo3 will not be copied.\r\nconsole.log(target.baz);  // undefined, the third source will not be copied either.\r\n```"}]},{"number":51,"title":"【Q051】常见的 DOM 方法","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/51","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 0. DOM常见的操作主要分为\r\n- 创建节点\r\n- 查询节点\r\n- 更新节点\r\n- 添加节点\r\n- 删除节点\r\n\r\n## 1. 创建节点\r\n### createElement\r\n创建新元素，接受一个参数，即要创建元素的标签名\r\n```javascript\r\nconst divEl = document.createElement(\"div\");\r\n```\r\n\r\n### createTextNode\r\n创建一个文本节点\r\n```javascript\r\nconst textEl = document.createTextNode(\"content\");\r\n```\r\n\r\n### createDocumentFragment\r\n用来创建一个文档碎片，它表示一种轻量级的文档，主要是用来存储临时节点，然后把文档碎片的内容一次性添加到 `DOM` 中\r\n```javascript\r\nconst fragment = document.createDocumentFragment();\r\n```\r\n当请求把一个 `DocumentFragment` 节点插入文档树时，插入的不是 `DocumentFragment` 自身，而是它的所有子孙节点\r\n\r\n### createAttribute\r\n创建属性节点，可以是自定义属性\r\n```javascript\r\nconst dataAttribute = document.createAttribute('custom');\r\nconsle.log(dataAttribute);\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"\r\n\r\n## 2. 获取节点\r\n### querySelector\r\n传入任何有效的css 选择器，即可选中单个 DOM元素（首个）：\r\n```javascript\r\ndocument.querySelector('.element')\r\ndocument.querySelector('#element')\r\ndocument.querySelector('div')\r\ndocument.querySelector('[name=\"username\"]')\r\ndocument.querySelector('div + p > span')\r\n```\r\n如果页面上没有指定的元素时，返回 null\r\n\r\n### querySelectorAll\r\n返回一个包含节点子树内所有与之相匹配的Element节点列表，如果没有相匹配的，则返回一个空节点列表\r\n```javascript\r\nconst notLive = document.querySelectorAll(\"p\");\r\n```\r\n需要注意的是，该方法返回的是一个 `NodeList` 的静态实例，它是一个静态的快照，而非实时的查询\r\n\r\n### 其它\r\n```javascript\r\ndocument.getElementById('id属性值');返回拥有指定id的对象的引用\r\ndocument.getElementsByClassName('class属性值');返回拥有指定class的对象集合\r\ndocument.getElementsByTagName('标签名');返回拥有指定标签名的对象集合\r\ndocument.getElementsByName('name属性值'); 返回拥有指定名称的对象结合\r\ndocument/element.querySelector('CSS选择器');  仅返回第一个匹配的元素\r\ndocument/element.querySelectorAll('CSS选择器');   返回所有匹配的元素\r\ndocument.documentElement;  获取页面中的HTML标签\r\ndocument.body; 获取页面中的BODY标签\r\ndocument.all[''];  获取页面中的所有元素节点的对象集合型\r\n```\r\n\r\n除此之外，每个DOM元素还有 `parentNode`、`childNodes`、`firstChild`、`lastChild`、`nextSibling`、`previousSibling`属性，关系图如下图所示\r\n\r\n![Alt](https://static.vue-js.com/c100f450-7fdc-11eb-ab90-d9ae814b240d.png)"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 3. 更新节点\r\n### innerHTML\r\n不但可以修改一个 `DOM` 节点的文本内容，还可以直接通过 `HTML` 片段修改 `DOM 节点内部的子树\r\n```javascript\r\n// 获取<p id=\"p\">...</p >\r\nvar p = document.getElementById('p');\r\n// 设置文本为abc:\r\np.innerHTML = 'ABC'; // <p id=\"p\">ABC</p >\r\n// 设置HTML:\r\np.innerHTML = 'ABC <span style=\"color:red\">RED</span> XYZ';\r\n// <p>...</p >的内部结构已修改\r\n```\r\n\r\n### innerText、textContent\r\n自动对字符串进行 `HTML` 编码，保证无法设置任何 `HTML` 标签\r\n```javascript\r\n// 获取<p id=\"p-id\">...</p >\r\nvar p = document.getElementById('p-id');\r\n// 设置文本:\r\np.innerText = '<script>alert(\"Hi\")</script>';\r\n// HTML被自动编码，无法设置一个<script>节点:\r\n// <p id=\"p-id\">&lt;script&gt;alert(\"Hi\")&lt;/script&gt;</p >\r\n```\r\n两者的区别在于读取属性时，`innerText` 不返回隐藏元素的文本，而 `textContent` 返回所有文本\r\n\r\n### style\r\n`DOM` 节点的 `style` 属性对应所有的 `CSS`，可以直接获取或设置。遇到 `-` 需要转化为驼峰命名\r\n```javascript\r\n// 获取<p id=\"p-id\">...</p >\r\nconst p = document.getElementById('p-id');\r\n// 设置CSS:\r\np.style.color = '#ff0000';\r\np.style.fontSize = '20px'; // 驼峰命名\r\np.style.paddingTop = '2em';\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 4. 添加节点\r\n### innerHTML\r\n如果这个 `DOM` 节点是空的，例如，`<div></div>`，那么，直接使用 `innerHTML = '<span>child</span>'`就可以修改 `DOM` 节点的内容，相当于添加了新的 `DOM` 节点\r\n\r\n如果这个 `DOM` 节点不是空的，那就不能这么做，因为 `innerHTML` 会直接替换掉原来的所有子节点\r\n\r\n### appendChild\r\n把一个子节点添加到父节点的最后一个子节点\r\n```javascript\r\nconst js = document.getElementById('js')\r\njs.innerHTML = \"JavaScript\"\r\nconst list = document.getElementById('list');\r\nlist.appendChild(js);\r\n```\r\n\r\n### insertBefore\r\n把子节点插入到指定的位置，使用方法如下：\r\n```javascript\r\nparentElement.insertBefore(newElement, referenceElement)\r\n```\r\n子节点会插入到referenceElement之前\r\n\r\n### setAttribute\r\n在指定元素中添加一个属性节点，如果元素中已有该属性改变属性值\r\n```javascript\r\nconst div = document.getElementById('id')\r\ndiv.setAttribute('class', 'white');//第一个参数属性名，第二个参数属性值。\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 5. 删除节点\r\n删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的 `removeChild` 把自己删掉\r\n```javascript\r\n// 拿到待删除节点:\r\nconst self = document.getElementById('to-be-removed');\r\n// 拿到父节点:\r\nconst parent = self.parentElement;\r\n// 删除:\r\nconst removed = parent.removeChild(self);\r\nremoved === self; // true\r\n```\r\n删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置"}]}],"react":[{"number":52,"title":"【Q052】React 17、React 18新特性","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/52","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. React 17新特性\r\n北京时间8月11日凌晨，React团队发布了 `React17` 第一个RC版本。该版本的最大特性是“无新特性”。\r\n这次版本更迭确实有“新特性” —— 替换了内部使用的 `启发式更新算法`，这个特性对开发者是无感知的。\r\n\r\n### 为什么会出现启发式更新算法\r\nReact纯JS写法太过灵活，使他在 `编译时优化` 方面先天不足。\r\n所以，React的优化主要在 `运行时`。\r\n\r\n### React16的启发式更新算法\r\n`启发式` 指不通过 **显式的指派**，而是通过 **优先级** 调度更新。\r\n其中优先级来源于 `人机交互的研究成果`。\r\n\r\n例如：\r\n- 当用户在输入框输入内容时，希望输入的内容能实时响应在输入框\r\n- 当异步请求数据后，即使等待一会儿再显示内容，用户也是可以接受的\r\n\r\n基于此在React16中：输入框输入内容触发的更新优先级 > 请求数据返回后触发更新优先级\r\n\r\n### 算法实现\r\n在React16、17中，在组件内执行 this.setState后会在该组件对应的fiber节点内产生一种链表数据结构update。\r\n其中，update.expirationTimes为类似时间戳的字段，表示优先级。\r\nexpirationTimes从字面意义理解为过期时间。\r\n该值离当前时间越接近，该update 优先级越高。\r\n当update.expirationTimes超过当前时间，则代表该update过期，优先级变为最高（即同步）。\r\n一棵fiber树的多个fiber节点可能存在多个update。\r\n每次Fiber Reconciler调度更新时，会在所有fiber节点的所有update.expirationTimes中选择一个expirationTimes（一般选择最大的），作为本次更新的优先级。\r\n并从根fiber节点开始向下构建新的fiber树。\r\n构建过程中如果某个fiber节点包含update，且\r\n```javascript\r\nupdate.expirationTimes >= expirationTimes\r\n```\r\n则该update对应的state变化会体现在本次更新中。\r\n可以理解为：每次更新，都会选定一个优先级（expirationTimes），最终页面会渲染为该优先级对应update的快照。\r\n举个例子，我们有如图所示fiber树，当前还没有更新产生，所以没有构建中的fiber树。\r\n\r\n![Alt](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b2f73db7076434092e735bae2ae3d64~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n当在C创建一个低优先级update，调度更新，本次更新选择的优先级为低优先级。\r\n开始构建新的fiber树（图右侧）。\r\n\r\n![Alt](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a44bdcb3599d41adab5e3b22303bf2de~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n此时，我们在D创建一个高优先级update。\r\n这会中断进行中的低优先级更新，重新开始以高优先级生成一棵fiber树。\r\n由于之前的更新被中断，还没有任何渲染操作，此时视图中（左图）还没有任何变化。\r\n\r\n![Alt](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3aa2edacd0dd4481bc773d244c3a6a4d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n本次更新选定的优先级为高优先级，C的update（低优先级）会被跳过。\r\n更新完成后新的fiber树会被渲染到视图中。\r\n\r\n![Alt](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f2277de78b04fcc81a9310e06b9a48a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n由于C被跳过，所以不会在视图（左图）中体现。\r\n接下来我们在E触发一次高优先级update。\r\nC虽然包含低优先级update，但随着时间的推移，他的expirationTimes已经过期，变为高优先级。\r\n\r\n![Alt](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a67d1f46c524c3fb221fae04fd93954~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n所以本次更新会有C E两个fiber节点产生变化。\r\n最终完成更新后，视图如下：\r\n\r\n![Alt](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02806250332141338705f6e556d9b4dd~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n### 算法缺陷\r\n如果只考虑中断/继续这样的CPU操作，以expirationTimes大小作为衡量优先级依据的模型可以很好工作。\r\n但是expirationTimes模型不能满足IO操作（Suspense）。\r\n在该模型下，高优先级IO任务（Suspense）会中断低优先级CPU任务。\r\n还记得么，每次更新，都是以某一优先级作为整棵树的优先级更新标准，而不仅仅是某一组件，即使更新的源头（update）确实是某个组件产生的。\r\nexpirationTimes模型只能区分是否>=expirationTimes这种情况。\r\n为了拓展Concurrent Mode能力边界，需要一种更细粒度的启发式优先级更新算法。\r\n\r\n### React17启发式更新算法\r\n最理想的模型是：可以指定任意几个优先级，更新会以这些优先级对应update生成页面快照。\r\n但是现有架构下，该方案实现上有瓶颈。\r\n妥协之下，React17的解决方案是：指定一个连续的优先级区间，每次更新都会以区间内包含的优先级生成对应页面快照。\r\n这种优先级区间模型被称为lanes（车道模型）。\r\n具体做法是：使用一个31位的二进制代表31种可能性。\r\n\r\n- 其中每个bit被称为一个lane（车道），代表优先级\r\n- 某几个lane组成的二进制数被称为一个lanes，代表一批优先级\r\n\r\n可以从源码中看到，从蓝线一路划下去，每个bit都对应一个lane或lanes。\r\n\r\n![Alt](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba935553f49e48888fa4742f72e9591e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n当update产生，会根据React16同样的启发式方式，获得如下优先级的一种：\r\n```javascript\r\nexport const SyncLanePriority: LanePriority = 17;\r\nexport const SyncBatchedLanePriority: LanePriority = 16;\r\nexport const InputDiscreteLanePriority: LanePriority = 14;\r\nexport const InputContinuousLanePriority: LanePriority = 12;\r\nexport const DefaultLanePriority: LanePriority = 10;\r\nexport const TransitionShortLanePriority: LanePriority = 8;\r\nexport const TransitionLongLanePriority: LanePriority = 6;\r\n```\r\n\r\n其中值越高，优先级越大。比如：\r\n- 点击事件回调中触发this.setState产生的update会获得InputDiscreteLanePriority。\r\n- 同步的update会获得SyncLanePriority。\r\n\r\n接下来，update会以priority为线索寻找没被占用的lane。\r\n如果当前fiber树已经存在更新且更新的lanes包含了该lane，则update需要寻找其他lane。\r\n比如，InputDiscreteLanePriority对应的lanes为InputDiscreteLanes。\r\n```javascript\r\n// 第4、5位为1\r\nconst InputDiscreteLanes: Lanes = 0b0000000000000000000000000011000;\r\n```\r\n\r\n该lanes包含第4、5位2个bit位。\r\n如果其中\r\n```javascript\r\n// 第五位为1\r\n0b0000000000000000000000000010000\r\n```\r\n\r\n第五位的lane已经被占用，则该update可以尝试占有后一个，即\r\n```javascript\r\n// 第四位为1\r\n0b0000000000000000000000000001000\r\n```\r\n\r\n如果InputDiscreteLanes的两个lane都被占用，则该update的优先级会下降到InputContinuousLanePriority并继续寻找空余的lane。\r\n这个过程就像：购物中心每一层（不同优先级）都有一个露天停车场（lanes），停车场有多个车位（lane）。\r\n我们先开车到顶楼找车位（lane），如果没有车位就下一楼继续找。\r\n直到找到空余车位。\r\n由于lanes可以包含多个lane，可以很方便的区分IO操作（Suspense）与CPU操作。\r\n当构建fiber树进入构建Suspense子树时，会将Suspense的lane插入本次更新选定的lanes中。\r\n当构建离开Suspense子树时，会将Suspense lane从本次更新的lanes中移除。\r\n\r\n### 总结\r\nReact16的expirationTimes模型只能区分是否>=expirationTimes决定节点是否更新。\r\nReact17的lanes模型可以选定一个更新区间，并且动态的向区间中增减优先级，可以处理更细粒度的更新。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. React 18新特性\r\n### Render API\r\n为了更好的管理root节点，React 18 引入了一个新的 root API，新的 root API 还支持 new concurrent renderer（并发模式的渲染），它允许你进入concurrent mode（并发模式）。\r\n```tsx\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './App';\r\n\r\nconst root = document.getElementById('root')!;\r\n\r\n// React 17\r\nReactDOM.render(<App />, root);\r\n\r\n// React 18\r\nReactDOM.createRoot(root).render(<App />);\r\n```\r\n\r\n同时，在卸载组件时，我们也需要将 unmountComponentAtNode 升级为 root.unmount:\r\n```javascript\r\n// React 17\r\nReactDOM.unmountComponentAtNode(root);\r\n\r\n// React 18\r\nroot.unmount();\r\n```\r\n\r\n###  setState 自动批处理\r\n\r\n- 在 18 之前，只有在react事件处理函数中，才会自动执行批处理，其它情况会多次更新\r\n- 在 18 之后，任何情况都会自动执行批处理，多次更新始终合并为一次\r\n\r\n### flushSync\r\n批处理是一个破坏性改动，如果不想批量更新，你可以使用 flushSync：\r\n```tsx\r\nimport React, { useState } from 'react';\r\nimport { flushSync } from 'react-dom';\r\n\r\nconst App: React.FC = () => {\r\n  const [count1, setCount1] = useState(0);\r\n  const [count2, setCount2] = useState(0);\r\n  return (\r\n    <div\r\n      onClick={() => {\r\n        flushSync(() => {\r\n          setCount1(count => count + 1);\r\n        });\r\n        // 第一次更新\r\n        flushSync(() => {\r\n          setCount2(count => count + 1);\r\n        });\r\n        // 第二次更新\r\n      }}\r\n    >\r\n      <div>count1： {count1}</div>\r\n      <div>count2： {count2}</div>\r\n    </div>\r\n  );\r\n};\r\nexport default App;\r\n```"}]},{"number":53,"title":"【Q053】虚拟 DOM 是什么？以及 Diff 算法原理","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/53","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 虚拟 DOM\r\nJS的DOM操作非常消耗性能，而React把DOM转换成了 **JS对象**。这就是虚拟Dom（Virtual Dom）。\r\n\r\n每次数据更新后，重新计算虚拟Dom，并和上一次生成的虚拟dom进行对比，对发生变化的部分作批量更新。\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e8c8a3a50f44088b5409614d7ee8f3a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n当我们需要创建或更新元素时，React首先会让这个VitrualDom对象进行创建和更改，然后再将VitrualDom对象渲染成真实DOM；\r\n当我们需要对DOM进行事件监听时，首先对VitrualDom进行事件监听，VitrualDom会代理原生的DOM事件从而做出响应。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. Diff 算法\r\nReact需要同时维护两棵虚拟DOM树：一棵表示当前的DOM结构，另一棵在React状态变更将要重新渲染时生成。\r\nReact通过比较这两棵树的差异，决定是否需要修改DOM结构，以及如何修改。这种算法称作Diff算法。\r\n\r\n### Diff 算法过程\r\nDiff算法会对新旧两棵树做深度优先遍历，避免对两棵树做完全比较，因此算法复杂度可以达到O(n)。\r\n然后给每个节点生成一个唯一的标志。\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22e96efebcce4b14a679ec218c4a3efe~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n在遍历的过程中，每遍历到一个节点，就将新旧两棵树作比较，并且只对同一级别的元素进行比较。\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/319324b9cfa24c569f6c6f05300cd73f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n也就是只比较图中用虚线连接起来的部分，把前后差异记录下来。\r\n\r\n## 3.Diff 算法策略\r\n### ① tree diff\r\ntree diff主要针对的是React dom节点跨层级的操作。\r\n由于跨层级的DOM移动操作较少，所以React diff算法的tree diff没有针对此种操作进行深入比较，只是简单进行了删除和创建操作。\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e3e3c42eab447a7bd3ef46e9b748e69~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n由此可以发现，当出现节点跨层级移动时，并不会出现想象中的移动操作，而是以 A 为根节点的整个树被重新创建。这是一种影响 React 性能的操作，因此官方建议不要进行 DOM 节点跨层级的操作。\r\n\r\n#### 基于上述原因，在开发组件时，保持稳定的 DOM 结构会有助于性能的提升。例如，可以通过 CSS 隐藏或显示节点，而不是真正地移除或添加 DOM 节点。\r\n\r\n### ② component diff\r\ncomponent diff是专门针对更新前后的同一层级间的React组件比较的diff 算法：\r\n- 如果是同一类型的组件，按照原策略继续比较 Virtual DOM 树可。\r\n- 如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点，即销毁原组件，创建新组件。\r\n- 对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切知道这点，那么就可以节省大量的 diff 运算时间。因此，React 允许用户通过 shouldComponentUpdate()来判断该组件是否需要进行 diff 算法分析。\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/550916d92fc9467f8eb6e5edb20daa52~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n#### 虽然当两个组件是不同类型但结构相似时，diff 会影响性能，但正如 React 官网所言：不同类型的组件很少存在相似 DOM树的情况，因此这种极端因素很难在实际开发过程中造成重大的影响。\r\n\r\n### element diff\r\nelement diff是专门针对同一层级的所有节点的diff算法。\r\n当节点处于同一层级时，diff 提供了 3 种节点操作，分别为 `INSERT_MARKUP`（插入）、`MOVE_EXISTING`（移动）和 `REMOVE_NODE`（删除）。\r\n\r\n我们将虚拟dom树中欲比较的某同一层级的所有节点的集合分别称为新集合和旧集合，则有以下策略：\r\n\r\n- INSERT_MARKUP：新集合的某个类型组件或元素节点不存在旧集合里，即全新的节点，需要对新节点执行插入操作。\r\n- MOVE_EXISTING：新集合的某个类型组件或元素节点存在旧集合里，且 element 是可更新的类型，generateComponent-Children 已调用receiveComponent，这种情况下 prevChild=nextChild，就需要做移动操作，可以复用以前的 DOM 节点。\r\n- REMOVE_NODE：旧集合的某个组件或节点类型，在新集合里也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者旧组件或节点不在新集合里的，也需要执行删除操作。\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fedb1d9dec9b4c25ba106660fd2bb964~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)"}]},{"number":54,"title":"【Q054】key 是干什么的","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/54","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. key 的作用\r\n同一层级的某个节点添加了对于其他同级节点唯一的key属性，当它在当前层级的位置发生了变化后。\r\nreact diff算法通过新旧节点比较后，如果发现了key值相同的新旧节点，就会执行移动操作（然后依然按原策略深入节点内部的差异对比更新），而不会执行原策略的删除旧节点，创建新节点的操作。\r\n这无疑大大提高了React性能和渲染效率。\r\n\r\n## 2. key 的执行过程\r\n对新集合中的节点进行循环遍历，通过唯一的 key 判断新旧集合中是否存在相同的节点。\r\n如果存在相同节点，判断要移动的节点在旧集合中的位置不在最后一位，才进行移动操作。\r\n\r\n## 3. index 可以作为 key 吗？\r\n### React官方建议不要用遍历的index作为这种场景下的节点的key属性值。\r\n比如当前遍历的所有节点类型都相同，其内部文本不同，在用index作key的情况下，当我们对原始的数据list进行了某些元素的顺序改变操作，导致了新旧集合中在进行diff比较时，相同index所对应的新旧的节点其文本不一致了，就会出现一些节点需要更新渲染文本，而如果用了其他稳定的唯一标识符作为key，则只会发生位置顺序变化，无需更新渲染文本，提升了性能。\r\n\r\n## 4. key 的缺点\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce6eb05a24674c51943127fcde856d34~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作。\r\n\r\n## 5. key 使用注意事项\r\n- 如果遍历的列表子节是作为纯展示，而不涉及到列表元素顺序的动态变更，那使用index作为key还是没有问题的。\r\n- key只是针对同一层级的节点进行了diff比较优化，而跨层级的节点互相之间的key值没有影响。\r\n- 如果存在新旧集合中，相同的key值所对应的节点类型不同（比如从span变成div），这相当于完全替换了旧节点，删除了旧节点，创建了新节点。\r\n- key值在比较之前都会被执行toString()操作，所以尽量不要使用object类型的值作为key，会导致同一层级出现key值相同的节点。"}]},{"number":55,"title":"【Q055】Fiber","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/55","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 为什么需要Fiber\r\n在数据更新时，react生成了一棵更大的虚拟dom树，给diff带来了很大压力——我们想找到真正变化的部分，这需要花费更长的时间。\r\njs占据主线程去做比较，渲染线程便无法做其他工作，用户的交互得不到响应，所以便出现了 `Fiber`。\r\n\r\n### Fiber 是 React 16 中新的协调引擎。它的主要目的是使 Virtual DOM 可以进行增量式渲染。\r\n\r\n`Fiber` 没法让比较的时间缩短，但它使得diff的过程 **分割** 成小段，因为它有了“保存工作进度”的能力。\r\njs会比较一部分虚拟dom，然后让渡主线程，给浏览器去做其他工作，然后继续比较，依次往复，等到最后比较完成，一次性更新到视图上。\r\n\r\n## 2. Fiber 是一种新的数据结构\r\n模拟栈的链表\r\n\r\n## 3. Fiber 是纤程\r\n这种数据结构之所以被叫做 `Fiber`，翻译过来是纤程，它被认为是协程的一种实现形式。\r\n协程是比线程更小的调度单位：它的开启、暂停可以被程序员所控制。\r\n具体来说，`Fiber` 是通过 `requestIdleCallback` 去控制的组件渲染的“进度条”。\r\n\r\n`requesetIdleCallback` 是一个属于宏任务的回调，就像 `setTimeout` 一样。\r\n不同的是，`setTimeout` 的执行时机由我们传入的回调时间去控制，`requesetIdleCallback` 是受屏幕的刷新率去控制，每个16s调用一次。\r\n```javascript\r\nconst workLoop = (deadLine) => {\r\n    let shouldYield = false;// 是否该让出线程\r\n    while(!shouldYield){\r\n        console.log('working')\r\n        // 遍历节点等工作\r\n        shouldYield = deadLine.timeRemaining()<1;\r\n    }\r\n    requestIdleCallback(workLoop)\r\n}\r\nrequestIdleCallback(workLoop);\r\n```\r\n\r\n### 4. 总结\r\n`Fiber` 是React 16提出的一种更新机制，使用链表取代了树，将虚拟dom连接，使得组件更新的流程可以被中断恢复；\r\n它把组件渲染的工作分片，到时会主动让出渲染主线程。"}]},{"number":56,"title":"【Q056】React 事件机制和原生事件机制的关系","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/56","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. React 事件机制\r\nReact 实现了一套事件机制，包括事件注册、事件的合成、事件冒泡、事件派发。\r\n`React事件` 和 `原始事件` 是两套机制。 `React事件` 是基于 `原始事件机制` 下完成的。\r\n\r\n### 原生事件机制（捕获阶段-目标元素阶段-冒泡阶段）\r\n事件绑定在对应dom节点上，在合适时机触发。\r\n```javascript\r\ndocument.getElementById().addEventListener('click',()=>{\r\n // ...\r\n})\r\n```\r\n\r\n### React 重写事件处理机制\r\n\r\n- onClick | onInput | onFocus 等为React事件\r\n- 所有React 事件 都绑定在document上\r\n- React 事件是在冒泡阶段触发\r\n- React 事件触发时机后于原生事件\r\n\r\n## 2. 两者的关系\r\n\r\n- React 事件为合成事件（SyntheticEvent）基于原始事件（Event）。\r\n- 原始事件停止冒泡会阻止合成事件触发 ， 相反不会。\r\n- 不建议混用。 理解后可以得心应手。\r\n\r\n## 3. 响应顺序\r\n\r\n- 原生事件捕获阶段\r\n- 原生事件冒泡阶段\r\n- 原生事件冒泡到document ，开始React 事件执行 模拟冒泡"}]},{"number":57,"title":"【Q057】React 生命周期","labels":["react"],"body":"三个废弃的生命周期","url":"https://github.com/kangyana/daily-question/issues/57","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. React 生命周期\r\nReact 16.8+的生命周期分为三个阶段，分别是 `挂载阶段`、`更新阶段`、`卸载阶段`。\r\n\r\n![Alt](https://img-blog.csdnimg.cn/20210515113558981.png)\r\n\r\n## 2. 挂载阶段\r\n\r\n- constructor\r\n构造函数，最先被执行,我们通常在构造函数里初始化 `state` 对象或者给自定义方法绑定 `this`。\r\n- getDerivedStateFromProps\r\n`static getDerivedStateFromProps(nextProps, prevState)`，这是个静态方法，当我们接收到新的属性想去修改 `state`，可以使用 `getDerivedStateFromProps`。\r\n- render\r\n`render` 是纯函数，只返回需要渲染的东西，不应该包含其它的业务逻辑，可以返回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容。\r\n- componentDidMount\r\n组件装载之后调用，此时可以获取到DOM节点并操作，比如对canvas，svg的操作，服务器请求，订阅都可以写在这个里面。\r\n但是记得在`componentWillUnmount`中取消订阅。\r\n\r\n## 3. 更新阶段\r\n\r\n- getDerivedStateFromProps\r\n此方法在更新个挂载阶段都可能会调用。\r\n- shouldComponentUpdate\r\n`shouldComponentUpdate(nextProps, nextState)`，有两个参数 `nextProps` 和 `nextState`，表示新的属性和变化之后的 `state`。\r\n返回一个布尔值，true表示会触发重新渲染，false表示不会触发重新渲染，默认返回true。\r\n我们通常利用此生命周期来优化React程序性能。\r\n- render\r\n更新阶段也会触发此生命周期。\r\n- getSnapshotBeforeUpdate\r\n`getSnapshotBeforeUpdate(prevProps, prevState)`，这个方法在 `render` 之后，`componentDidUpdate` 之前调用。\r\n有两个参数 `prevProps` 和 `prevState`，表示之前的属性和之前的 `state`。\r\n这个函数有一个返回值，会作为第三个参数传给 `componentDidUpdate`，如果你不想要返回值，可以返回 `null`。\r\n此生命周期必须与 `componentDidUpdate` 搭配使用。\r\n- componentDidUpdate\r\n`componentDidUpdate(prevProps, prevState, snapshot)`，该方法在 `getSnapshotBeforeUpdate` 方法之后被调用。\r\n有三个参数 `prevProps`，`prevState`，`snapshot`，表示之前的 `props`，之前的 `state`，和 `snapshot`。\r\n第三个参数是 `getSnapshotBeforeUpdate` 返回的。\r\n如果触发某些回调函数时需要用到 DOM 元素的状态，则将对比或计算的过程迁移至 `getSnapshotBeforeUpdate`，然后在 `componentDidUpdate` 中统一触发回调或更新状态。\r\n\r\n## 4. 卸载阶段\r\n\r\n- componentWillUnmount\r\n当组件被卸载或者销毁了就会调用，我们可以在这个函数里去清除一些定时器，取消网络请求，清理无效的DOM元素等垃圾清理工作。\r\n\r\n## 5. 三个废弃的生命周期\r\nReact 16之后有三个生命周期被废弃：\r\n\r\n- componentWillMount\r\n- componentWillReceiveProps\r\n- componentWillUpdate\r\n\r\n因为这些 `生命周期` 方法容易被误解和滥用。\r\n\r\n### 为什么要废弃这三个生命周期钩子？它们有哪些问题呢？React 又是如何解决的呢？\r\n我们知道 React 的更新流程分为：`render阶段` 和 `commit阶段`。\r\n这三个生命周期钩子都是在 `render阶段` 执行的。\r\n\r\n在 `fiber` 架构被应用之后，低优先级任务的 `render阶段` 可以被高优先级任务打断。\r\n而这导致的问题就是：在 `render阶段` 执行的生命周期函数可能被执行多次，这三个方法也会被执行多次。\r\n\r\n用一个静态函数 `getDerivedStateFromProps` 来取代被废弃的几个生命周期函数，这样开发者就无法通过 `this` 获取到组件的实例，也不能发送网络请求以及调用 `this.setState`。\r\n它就是强制开发者在 `render` 之前只做无副作用的操作，间接强制我们无法进行这些不合理不规范的操作，从而避免对生命周期的滥用。"}]},{"number":58,"title":"【Q058】React 组件性能优化","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/58","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"React 组件性能优化的核心是减少渲染真实DOM 节点的频率，减少 Virtual DOM对比的频率。\r\n\r\n## 1. 组件卸载前进行清理操作\r\n在组件中为 window 注册的全局事件, 以及定时器, 在组件卸载前要清理掉, 防止组件卸载后继续执行影响应用性能。\r\n```javascript\r\nuseEffect(() => {\r\n  let timer = setInterval(() => {\r\n    console.log('timer is running...')\r\n  }, 1000)\r\n\r\n  return () => clearInterval(timer) // 负责执行清理操作\r\n}, [])\r\n```\r\n\r\n## 2. PureComponent 纯组件\r\n### 什么是纯组件\r\n纯组件会对组件输入数据进行浅层比较，如果当前输入数据和上次输入数据相同，组件不会重新渲染。\r\n\r\n### 什么是浅层比较\r\n比较引用数据类型在内存中的引用地址是否相同，比较基本数据类型的值是否相同。\r\n\r\n### 如何实现纯组件\r\n类组件继承 `PureComponent` 类，函数组件使用 `memo` 方法\r\n\r\n### 为什么不直接进行 diff 操作, 而是要先进行浅层比较，浅层比较难道没有性能消耗吗\r\n和进行 `diff` 比较操作相比，浅层比较将消耗更少的性能。\r\n`diff` 操作会重新遍历整颗 `virtualDOM` 树, 而浅层比较只操作当前组件的 `state` 和 `props`。\r\n\r\n## 3. shouldComponentUpdate\r\n纯组件只能进行浅层比较，要进行深层比较，使用 `shouldComponentUpdate`，它用于编写自定义比较逻辑。\r\n返回 `true` 重新渲染组件，返回 `false` 阻止重新渲染。\r\n函数的第一个参数为 `nextProps`, 第二个参数为 `nextState`。\r\n```javascript\r\nshouldComponentUpdate(nextProps, nextState) {\r\n  if (this.state.name !== nextState.name || this.state.age !== nextState.age) {\r\n    return true\r\n  }\r\n  return false\r\n}\r\n```\r\n\r\n## 4. React.memo\r\n### memo 基本使用\r\n将函数组件变为纯组件，将当前 `props` 和上一次的 `props` 进行浅层比较，如果相同就阻止组件重新渲染。\r\n\r\n### 为 memo 传递比较逻辑\r\n使用 `memo` 方法自定义比较逻辑，用于执行深层比较。\r\n比较函数的第一个参数为上一次的 `props` , 比较函数的第二个参数为下一次的 `props`, 比较函数返回 `true`, 不进行渲染, 比较函数返回 `false`, 组件重新渲染。\r\n\r\n## 5. 使用组件懒加载\r\n使用 `lazy`（组件懒加载）可以减少 bundle 文件大小, 加快组件呈递速度。\r\n```javascript\r\nimport React, { lazy } from 'react';\r\n\r\nconst Home = lazy(() => import(/* webpackChunkName: \"Home\" */ \"./Home\"))\r\n```\r\n\r\n## 6. 使用 Fragment 避免额外标记\r\nReact 组件中返回的 jsx 如果有多个同级元素, 多个同级元素必须要有一个共同的父级。\r\n```javascript\r\n<div>\r\n  <div>message a</div>\r\n  <div>message b</div>\r\n</div>\r\n```\r\n\r\n为了满足这个条件我们通常都会在最外层添加一个div, 但是这样的话就会多出一个无意义的标记, 如果每个组件都多出这样的一个无意义标记的话, 浏览器渲染引擎的负担就会加剧。\r\n为了解决这个问题, React 推出了 `fragment` 占位符标记. 使用占位符标记既满足了拥有共同父级的要求又不会多出额外的无意义标记。\r\n```javascript\r\n<>\r\n  <div>message a</div>\r\n  <div>message b</div>\r\n</>\r\n}\r\n```\r\n\r\n## 7. 减少使用内联函数定义\r\n在使用内联函数后, `render` 方法每次运行时都会创建该函数的新实例。\r\n导致 React 在进行 `Virtual DOM` 比对时, 新旧函数比对不相等，导致 React 总是为元素绑定新的函数实例, 而旧的函数实例又要交给垃圾回收器处理。\r\n```javascript\r\n<input onChange={e => this.setState({ inputValue: e.target.value })} />\r\n```\r\n\r\n正确的做法是在组件中单独定义函数, 将函数绑定给事件。\r\n```javascript\r\nsetInputValue = e => {\r\n  this.setState({ inputValue: e.target.value })\r\n}\r\n\r\n<input onChange={this.setInputValue} />\r\n```\r\n\r\n## 8. 在构造函数中进行函数this绑定\r\n在类组件中如果使用 fn() {} 这种方式定义函数, 函数 `this` 默认指向 `undefined`。\r\n也就是说函数内部的 `this` 指向需要被更正。\r\n\r\n可以在构造函数中对函数的 `this` 进行更正, 也可以在行内进行更正, 两者看起来没有太大区别, 但是对性能的影响是不同的。\r\n```javascript\r\nexport default class App extends React.Component {\r\n   constructor() {\r\n    super()\r\n     // 方式一\r\n     // 构造函数只执行一次, 所以函数 this 指向更正的代码也只执行一次.\r\n    this.handleClick = this.handleClick.bind(this)\r\n  }\r\n  handleClick() {\r\n    console.log(this)\r\n  }\r\n  render() {\r\n    // 方式二 \r\n    // 问题: render 方法每次执行时都会调用 bind 方法生成新的函数实例.\r\n    return <button onClick={this.handleClick.bind(this)}>按钮</button>\r\n  }\r\n}\r\n```\r\n\r\n## 9. 类组件中的箭头函数\r\n在类组件中使用箭头函数不会存在 `this` 指向问题, 因为箭头函数本身并不绑定 `this`。\r\n箭头函数在 `this` 指向问题上占据优势，但是同时也有不利的一面。\r\n\r\n当使用箭头函数时，该函数被添加为类的实例对象属性，而不是原型对象属性。\r\n如果组件被多次重用，每个组件实例对象中都将会有一个相同的函数实例，降低了函数实例的可重用性造成了资源浪费。\r\n\r\n综上所述，更正函数内部 `this` 指向的最佳做法仍是在构造函数中使用 `bind` 方法进行绑定。\r\n\r\n## 10. 避免使用内联样式属性\r\n当使用内联 style 为元素添加样式时, 内联 style 会被编译为 JS 代码。\r\n通过 JS 代码将样式规则映射到元素的身上, 浏览器就会花费更多的时间执行脚本和渲染 UI, 从而增加了组件的渲染时间。\r\n\r\n更好的办法是将 CSS 文件导入样式组件，能通过 CSS 直接做的事情就不要通过 JavaScript 去做，因为 JavaScript 操作 DOM 非常慢。\r\n\r\n## 11. 优化条件渲染\r\n频繁的挂载和卸载组件是一项耗性能的操作, 为了确保应用程序的性能, 应该减少组件挂载和卸载的次数。\r\n在 React 中我们经常会根据条件渲染不同的组件，条件渲染是一项必做的优化操作。\r\n```javascript\r\nif (true) {\r\n  return (\r\n    <>\r\n      <AdminHeader />\r\n      <Header />\r\n      <Content />\r\n    </>\r\n  )\r\n} else {\r\n  return (\r\n    <>\r\n      <Header />\r\n      <Content />\r\n    </>\r\n  )\r\n}\r\n\r\n// 改为\r\n\r\nreturn (\r\n  <>\r\n    {true && <AdminHeader />}\r\n    <Header />\r\n    <Content />\r\n  </>\r\n)\r\n```\r\n\r\n## 12. 避免重复无限渲染\r\n当应用程序状态发生更改时, React 会调用 `render` 方法。\r\n如果在 `render` 方法中继续更改应用程序状态, 就会发生 `render` 方法递归调用导致应用报错。\r\n```javascript\r\nrender() {\r\n  this.setState({name: \"李四\"})\r\n  return <div>{this.state.name}</div>\r\n}\r\n```\r\n与其他生命周期函数不同, `render` 方法应该被作为纯函数。\r\n这意味着, 在 `render` 方法中不要做以下事情：\r\n\r\n- 不要调用 `setState` 方法\r\n- 不要使用其他手段查询更改原生 DOM 元素\r\n- 以及其他更改应用程序的任何操作\r\n\r\n`render` 方法的执行要根据状态的改变, 这样可以保持组件的行为和渲染方式一致。\r\n\r\n## 13. 为组件创建错误边界\r\n默认情况下, 组件渲染错误会导致整个应用程序中断, 创建错误边界可确保在特定组件发生错误时应用程序不会中断。\r\n\r\n错误边界涉及到两个生命周期函数, 分别为 `getDerivedStateFromError` 和 `componentDidCatch`。\r\n\r\n## 14. 避免数据结构突变\r\n组件中 `props` 和 `state` 的数据结构应该保持一致, 数据结构突变会导致输出不一致。\r\n\r\n## 15. 依赖优化\r\n按需引入第三方依赖包。\r\n\r\n## 16. 为列表数据添加唯一标识key\r\n\r\n- 可以避免因元素变化而导致重新创建\r\n- 动态列表（排序、过滤、从中间或者顶部删除item）不建议用索引作为key\r\n\r\n## 17. 高阶组件是类组件之间共享逻辑，类中使用较多\r\n什么是高阶组件 Higher Order Component (HOC)\r\n\r\n- 高阶组件是React应用中共享代码、增加逻辑复用的一种方式，比如A组件和B组件都需要使用一个相同的逻辑。可以使用高阶组件将逻辑抽取到一个公共的地方使用。\r\n- 高阶组件的核心思想就是在组件的外层再包裹一层执行逻辑的组件，在外层组件中执行逻辑，再将逻辑执行的结果传递到内容组件。\r\n- 高阶组件由一个函数返回，函数接受组件作为参数，返回一个新的组件，参数组件就是要服用的组件，函数内部返回的新组件就是执行逻辑的组件，在新组件内部执行完逻辑以后再调用参数组件并将逻辑结果传递给参数组件。\r\n\r\n## 18、渲染属性和 Portal\r\n渲染属性类中使用较多 `Portal` 将元素渲染到任何根元素"}]},{"number":59,"title":"【Q059】React.memo","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/59","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. React.memo\r\n`React.memo` 为 `高阶组件`。\r\n`props` 不变的情况下渲染，可以使用 `memo` 将组件包起来，通过记忆组件渲染结果的方式来提高组件的性能表现。\r\n相当于，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。\r\n\r\n`memo` 仅检查 `props` 变更，如果有其他状态改变，它仍会重新渲染。\r\n\r\n默认情况下其只会对复杂对象做浅层对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。\r\n```javascript\r\nfunction MyComponent(props) {\r\n  /* 使用 props 渲染 */\r\n}\r\nexport default React.memo(MyComponent, (prevProps, nextProps) => {\r\n  /*\r\n  如果把 nextProps 传入 render 方法的返回结果与\r\n  将 prevProps 传入 render 方法的返回结果一致则返回 true，\r\n  否则返回 false\r\n  */\r\n});\r\n```\r\n\r\n### 此方法仅作为 **性能优化** 的方式而存在。但请不要依赖它来“阻止”渲染，因为这会产生 bug。\r\n\r\n## 2. 与 shouldComponentUpdate() 的区别\r\n`memo` 的第二个参数 areEqual 的返回值是`props` 判断相等，\r\n`shouldComponentUpdate` 的返回值恰好相反，是 `props` 判断不等。"}]},{"number":60,"title":"【Q060】props.children","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/60","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. props.children\r\n每个组件都可以获取到 `props.children`。它包含组件的开始标签和结束标签之间的内容。例如：\r\n```html\r\n<Welcome>Hello world!</Welcome>\r\n```\r\n\r\n在 Welcome 组件中获取 props.children，就可以得到字符串 Hello world!：\r\n```javascript\r\nfunction Welcome(props) {\r\n  return <p>{props.children}</p>;\r\n}\r\n```\r\n\r\n对于 class 组件，请使用 this.props.children 来获取：\r\n```javascript\r\nclass Welcome extends React.Component {\r\n  render() {\r\n    return <p>{this.props.children}</p>;\r\n  }\r\n}\r\n```\r\n\r\n## 2. props.children 的数据类型\r\n`props.children` 的值有三种可能：\r\n\r\n- 如果当前组件没有子节点，它就是 `undefined`；\r\n- 如果有一个子节点，数据类型是 `object`；\r\n- 如果有多个子节点，数据类型就是 `array`。\r\n\r\n### 判断数据类型\r\n使用 `isValidElement()` 可以判断是是否为 React元素(object)。\r\n```javascript\r\nReact.isValidElement(object)\r\n```\r\n\r\n## 3. React.Children 方法\r\nReact 提供了工具方法 `React.Children` 来处理 `props.children`。\r\n\r\n### React.Children.map\r\n在 `children` 里的每个直接子节点上调用一个函数，并将 `this` 设置为 `thisArg`。\r\n如果 `children` 是一个数组，它将被遍历并为数组中的每个子节点调用该函数。\r\n如果子节点为 `null` 或是 `undefined`，则此方法将返回 `null` 或是 `undefined`，而不会返回数组。\r\n```javascript\r\nReact.Children.map(children, function[(thisArg)])\r\n```\r\n\r\n### React.Children.forEach\r\n与 `React.Children.map()` 类似，但它不会返回一个数组。\r\n```javascript\r\nReact.Children.forEach(children, function[(thisArg)])\r\n```\r\n\r\n### React.Children.count\r\n返回 `children` 中的组件总数量，等同于通过 `map` 或 `forEach` 调用回调函数的次数。\r\n```javascript\r\nReact.Children.count(children)\r\n```\r\n\r\n### React.Children.only\r\n验证 `children` 是否只有一个子节点（一个 React 元素），如果有则返回它，否则此方法会抛出错误。\r\n```javascript\r\nReact.Children.only(children)\r\n```\r\n\r\n### React.Children.toArray\r\n将 `children` 这个复杂的数据结构以数组的方式扁平展开并返回，并为每个子节点分配一个 `key`。\r\n当你想要在渲染函数中操作子节点的集合时，它会非常实用，特别是当你想要在向下传递 `props.children` 之前对内容重新排序或获取子集时。\r\n```javascript\r\nReact.Children.toArray(children)\r\n```\r\n\r\n注意：此方法会重写 `key`，给 `key` 一个 `.$` 前缀。\r\n![Alt](https://raw.githubusercontent.com/kangyana/img-storage/master/toArray_key.png)"}]},{"number":61,"title":"【Q061】content","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/61","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. content\r\n`Context`（上下文） 提供了一个无需为每层组件手动添加 `props`，就能在组件树间进行数据传递的方法。\r\n\r\n## 2. 何时使用 Context\r\n`Context` 设计目的是为了共享那些对于一个组件树而言是 **全局的数据**，例如当前认证的用户、主题或首选语言。\r\n\r\n## 3. 使用 Context 之前的考虑\r\n`Context` 主要应用场景在于很多不同层级的组件需要访问同样一些的数据。请谨慎使用，因为这会使得组件的复用性变差。\r\n\r\n如果你只是想避免层层传递一些属性，`组件组合（component composition）` 有时候是一个比 context 更好的解决方案。\r\n\r\n## 4. Content 的API\r\n### React.createContext\r\n创建一个 `Context` 对象。\r\n当 React 渲染一个订阅了这个 `Context` 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 `Provider` 中读取到当前的 `context` 值。\r\n```javascript\r\nconst MyContext = React.createContext(defaultValue);\r\n```\r\n\r\n### Context.Provider\r\nProvider 接收一个 value 属性，传递给消费组件。\r\n当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。\r\n```javascript\r\n<MyContext.Provider value={/* 某个值 */}>\r\n```\r\n\r\n### Context.Consumer\r\n一个 React 组件，它可以订阅 `context` 的变更。\r\n此组件可以让你在 `函数式组件` 中可以订阅 `context`。\r\n```javascript\r\n<MyContext.Consumer>\r\n  {value => /* 基于 context 值进行渲染*/}\r\n</MyContext.Consumer>\r\n```\r\n\r\n### Context.displayName\r\n`context` 对象接受一个名为 `displayName` 的 属性，类型为字符串。\r\nReact DevTools 使用该字符串来确定 `context` 要显示的内容。\r\n```javascript\r\nconst MyContext = React.createContext(/* some value */);\r\nMyContext.displayName = 'MyDisplayName';\r\n\r\n<MyContext.Provider> // \"MyDisplayName.Provider\" 在 DevTools 中\r\n<MyContext.Consumer> // \"MyDisplayName.Consumer\" 在 DevTools 中\r\n```\r\n\r\n## 5. 注意事项\r\n`context` 根据 `value` 属性值的浅比较来决定何时进行渲染。\r\n当 `provider` 的父组件进行重渲染时，可能会在 `consumers` 组件中触发意外的渲染。\r\n\r\n当每一次 `Provider` 重渲染时，由于 `value` 属性总是被赋值为新的对象，以下的代码会重新渲染下面所有的 `consumers` 组件：\r\n```javascript\r\nclass App extends React.Component {\r\n  render() {\r\n    return (\r\n      <MyContext.Provider value={{something: 'something'}}>\r\n        <Toolbar />\r\n      </MyContext.Provider>\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n为了防止这种情况，将 `value` 状态提升到父节点的 `state` 里：\r\n```javascript\r\nclass App extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      value: {something: 'something'},\r\n    };\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <MyContext.Provider value={this.state.value}>\r\n        <Toolbar />\r\n      </MyContext.Provider>\r\n    );\r\n  }\r\n}\r\n```"}]},{"number":62,"title":"【Q062】setState 是同步还是异步？","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/62","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. setState 是同步还是异步？\r\n`setState` 是异步的，但不是 `setTimeout`、`Promise` 那种异步，只是指 `setState` 之后是否 `state` 马上变了，是否马上 `render`。\r\n`setState` 会创建 `update` 对象挂到 `fiber` 对象上，然后调度 `performSyncWorkOnRoot` 重新渲染。\r\n\r\n在 react17 中，`setState` 是批量执行的，因为执行前会设置 `executionContext`。\r\n但如果在 `setTimeout`、事件监听器等函数里，就不会设置 `executionContext` 了，这时候 `setState` 会同步执行。\r\n可以在外面包一层 `batchUpdates` 函数，手动设置下 `excutionContext` 来切换成异步批量执行。\r\n\r\n在 react18 里面，如果用 `createRoot` 的 api，就不会有这种问题了。\r\n`setState` 是同步还是异步这个问题等 react18 普及以后就不会再有了，因为所有的 `setState` 都是异步批量执行了。"}]},{"number":63,"title":"【Q063】setState 批更新","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/63","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. setState 同步更新还是异步更新？\r\n### React18 以前的版本\r\nreact 事件中，`setState` 是异步更新的。\r\n但是在 `setTimeout` 、`addEventListener` 添加的原生事件中，`setState` 则是同步的。\r\n\r\n```javascript\r\n// Legacy同步模式\r\n\r\nconst container = document.getElementById('root');\r\nReactDOM.render(<App />, container);\r\n```\r\n\r\n### React18 以后\r\n`setState` 的更新统一是异步的。\r\n```javascript\r\n// Concurrent异步模式，在这个模式下，任何情况下setState都是异步更新的。目前createRoot方法还在实验中\r\n\r\nconst container = document.getElementById('root');\r\nReactDOM.createRoot(container).render(<App />)\r\n```\r\n\r\n## 2. setState 批更新\r\n在 React 18 之前，如果在回调函数的异步调用中，执行 `setState`，由于丢失上下文，无法做合并处理。\r\n所以每次 `setState` 调用都会触发一次 **重新渲染**。\r\n```javascript\r\nfunction handleClick() {\r\n\t// React 18 之前的版本\r\n\t(/*...*/).then(() => {\r\n\t\tsetCount(c => c + 1); // 立刻重新渲染\r\n\t\tsetShow(show => !show); // 立刻重新渲染\r\n\t});\r\n}\r\n```\r\n\r\nReact 18中，任何情况下都可以合并渲染！\r\n如果仍然希望setState之后立即重新渲染，只需要使用 `flushSync` 包裹。\r\n```javascript\r\nfunction handleClick() {\r\n\t// React 18\r\n\tfecth(/*...*/).then(() => {\r\n\t\tReactDOM.flushSync(() => {\r\n\t\t\tsetCount(c => c + 1); // 立刻重新渲染\r\n\t\t\tsetFlag(f => !f);\r\n\t\t})\r\n\t})\r\n}\r\n```\r\n"}]},{"number":64,"title":"【Q064】组件通信","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/64","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 父组件向子组件通信\r\n**父组件** 通过 `props` 向 **子组件** 传递需要的信息。\r\n```javascript\r\n// 子组件\r\nconst Child = props =>{\r\n  return <p>{props.name}</p>\r\n}\r\n\r\n// 父组件\r\nconst Parent = ()=>{\r\n  return <Child name=\"zhangsan\" />\r\n}\r\n```\r\n\r\n## 2. 子组件向父组件通信\r\n`props` + 回调函数。\r\n```javascript\r\n// 子组件\r\nconst Child = props =>{\r\n  const hanleCb = () =>{\r\n    props.callback('Here is zhangsan!')\r\n  }\r\n  return (\r\n    <button onClick={hanleCb}>post message</button>\r\n  )\r\n}\r\n\r\n// 父组件\r\nconst Parent = () => {\r\n  const callback = (msg) => {\r\n    console.log(msg)\r\n  }\r\n  return (\r\n    <Child callback={callback} />\r\n  )\r\n}\r\n```\r\n\r\n## 3. 跨级组件通信\r\n即 **父组件** 向 **更深层子组件** 通信。有两种解决方案：\r\n\r\n- 使用 `props` 层层传递\r\n- 使用 `context`\r\n\r\n```javascript\r\n// context方式实现跨级组件通信 \r\n// Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据\r\n\r\nconst BatteryContext = createContext();\r\n\r\n//  子组件的子组件 \r\nclass GrandChild extends Component {\r\n    render(){\r\n        return (\r\n            <BatteryContext.Consumer>\r\n                {\r\n                    color => <h1 style={{\"color\":color}}>我是红色的:{color}</h1>\r\n                }\r\n            </BatteryContext.Consumer>\r\n        ) \r\n    }\r\n}\r\n\r\n//  子组件\r\nconst Child = () =>{\r\n    return (\r\n        <GrandChild/>\r\n    )\r\n}\r\n// 父组件\r\nclass Parent extends Component {\r\n      state = {\r\n          color:\"red\"\r\n      }\r\n      render(){\r\n          const {color} = this.state\r\n          return (\r\n          <BatteryContext.Provider value={color}>\r\n              <Child />\r\n          </BatteryContext.Provider> \r\n          )\r\n      }\r\n}\r\n```\r\n\r\n## 4. 非嵌套关系的组件通信\r\n即没有任何 **包含关系** 的组件。有三种解决方案：\r\n\r\n- 可以使用自定义事件通信（发布订阅模式）\r\n- 可以通过 `redux` 等状态库进行全局状态管理\r\n- 如果是 **兄弟组件** 通信，找到共同的父节点传递 `Props`。"}]},{"number":65,"title":"【Q065】高阶组件原理","labels":["react"],"body":"有哪些常见的高阶组件？","url":"https://github.com/kangyana/daily-question/issues/65","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 高阶组件 HOC\r\n`高阶组件`是 React 中用于 **复用组件逻辑** 的一种高级技巧。\r\n`HOC` 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的 **设计模式**。\r\n\r\n### 如何实现\r\n参数为组件，返回值为新组件的函数。\r\n```javascript\r\nconst EnhancedComponent = higherOrderComponent(WrappedComponent);\r\n```\r\n\r\n## 2. 使用 HOC 解决复用\r\n假设有一个 `CommentList` 组件，它订阅外部数据源，用以渲染评论列表：\r\n```javascript\r\n// 假设 \"DataSource\" 是个全局范围内的数据源变量\r\n\r\n// 评论列表组件\r\nconst CommentList = () => {\r\n  const [comments, setComments] = useState([]);\r\n  \r\n  const handleChange = () => {\r\n    setComments(DataSource.getComments());\r\n  }\r\n  \r\n  useEffect(() => {\r\n    // 订阅\r\n    DataSource.addChangeListener(handleChange);\r\n    \r\n    // 清除订阅\r\n    return () => {\r\n      DataSource.removeChangeListener(handleChange);\r\n    }\r\n  }, [])\r\n  \r\n  return <div>\r\n    {comments.map((item) => (\r\n      <Comment comment={item} key={item.id} />\r\n    ))}\r\n  </div>\r\n}\r\n```\r\n\r\n稍后，编写了一个用于订阅单个博客帖子的组件，该帖子遵循类似的模式：\r\n```javascript\r\n// 博客组件\r\nconst BlogPost = (props) => {\r\n  const { id } = props;\r\n  const [blog, setBlog] = useState();\r\n  \r\n  const handleChange = () => {\r\n    setComments(DataSource.getBlog(id));\r\n  }\r\n  \r\n  useEffect(() => {\r\n    // 订阅\r\n    DataSource.addChangeListener(handleChange);\r\n    \r\n    // 清除订阅\r\n    return () => {\r\n      DataSource.removeChangeListener(handleChange);\r\n    }\r\n  }, []) \r\n  \r\n  return <div>{blog?.title}</div>\r\n}\r\n```\r\n\r\n`CommentList` 和 `BlogPost` 有很多相同之处：\r\n\r\n- 在挂载时，向 `DataSource` 添加一个侦听器。\r\n- 在侦听器内部，当数据源发生变化时，调用 `setState`。\r\n- 在卸载时，清除侦听器。\r\n\r\n这时可以写一个 `HOC`：\r\n```javascript\r\nconst withSubscription = (WrappedComponent, selectData) => {\r\n  return (props) => {\r\n    const [data, setData] = useState();\r\n    \r\n    const handleChange = () => {\r\n      setData(selectData(DataSource, props));\r\n    }\r\n    \r\n    useEffect(() => {\r\n      // 订阅\r\n      DataSource.addChangeListener(handleChange);\r\n      \r\n      // 清除订阅\r\n      return () => {\r\n        DataSource.removeChangeListener(handleChange);\r\n      }\r\n    }, []) \r\n    \r\n    return <WrappedComponent data={data} {...props} />\r\n  }\r\n}\r\n```\r\n\r\n`CommentList` 和 `BlogPost` 组件可以把 **订阅相关代码** 删掉了，只需要套上 `withSubscription`：\r\n```javascript\r\nconst CommentListWithSubscription = withSubscription(\r\n  CommentList,\r\n  (DataSource) => DataSource.getComments()\r\n);\r\n\r\nconst BlogPostWithSubscription = withSubscription(\r\n  BlogPost,\r\n  (DataSource, props) => DataSource.getBlogPost(props.id)\r\n);\r\n```\r\n\r\n注意，`HOC` 不会修改传入的组件，也不会使用继承来复制其行为。\r\n相反，`HOC` 通过将组件包装在容器组件中来组成新组件。`HOC` 是纯函数，没有副作用。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 3. 不要改变原始组件，而应该使用组合。\r\n不要试图在 `HOC` 中修改 **组件原型**。\r\n\r\n错误示范：\r\n```javascript\r\nconst logProps = (InputComponent) => {\r\n  InputComponent.prototype.componentDidUpdate = function(prevProps) {\r\n    console.log('Current props: ', this.props);\r\n    console.log('Previous props: ', prevProps);\r\n  };\r\n\r\n  return InputComponent;\r\n}\r\n\r\n// 每次调用 logProps 时，增强组件都会有 log 输出。\r\nconst EnhancedComponent = logProps(InputComponent);\r\n```\r\n\r\n`HOC` 不应该修改传入组件，而应该使用 **组合** 的方式，通过将组件包装在容器组件中实现功能：\r\n```javascript\r\nfunction logProps(WrappedComponent) {\r\n  return class extends React.Component {\r\n    componentDidUpdate(prevProps) {\r\n      console.log('Current props: ', this.props);\r\n      console.log('Previous props: ', prevProps);\r\n    }\r\n    render() {\r\n      return <WrappedComponent {...this.props} />;\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n`HOC` 与 **容器组件模式** 之间有相似之处。\r\n**容器组件** 担任将高级和低级关注点分离的责任，由容器管理订阅和状态，并将 `prop` 传递给处理 UI 的组件。\r\n`HOC` 使用容器作为其实现的一部分，你可以将 `HOC` 视为 **参数化容器组件**。\r\n\r\n## 4. 约定：将不相关的 props 传递给被包裹的组件\r\n这种约定保证了 `HOC` 的 **灵活性**、**可复用性**、**纯净性**。\r\n```javascript\r\nconst testHoc = (WrappedComponent) => {\r\n  return (props) => {\r\n    const { msg, ...restProps } = props;\r\n    \r\n    console.log(msg);\r\n    \r\n    return <WrappedComponent  {...restProps} />\r\n  }\r\n}\r\n```\r\n\r\n## 5. 约定：最大化可组合性\r\n`HOC` 通常可以接收多个参数，最常见的 `HOC` 如下：\r\n```javascript\r\n// React Redux 的 `connect` 函数\r\nconst ConnectedComment = connect(commentSelector, commentActions)(CommentList);\r\n```\r\n\r\n看起来很消耗心智，拆开写法\r\n```javascript\r\n// connect 是一个函数，它的返回值为另外一个函数。\r\nconst enhance = connect(commentListSelector, commentListActions);\r\n// 返回值为 HOC，它会返回已经连接 Redux store 的组件\r\nconst ConnectedComment = enhance(CommentList);\r\n```\r\n\r\n由上可得，`connect` 是一个返回高阶组件的高阶函数。\r\n像 `connect` 函数返回的单参数 `HOC` 具有签名 `Component => Component`。 \r\n输出类型与输入类型相同的函数很容易组合在一起。\r\n```javascript\r\n// 不推荐如下写法...\r\nconst EnhancedComponent = withRouter(connect(commentSelector)(WrappedComponent))\r\n\r\n// ... 建议编写组合工具函数\r\nconst enhance = compose(\r\n  withRouter,\r\n  connect(commentSelector)\r\n)\r\nconst EnhancedComponent = enhance(WrappedComponent)\r\n```\r\n\r\n其中 `connect` 和其他 `HOC` 承担 **装饰器** 的角色。\r\n\r\n许多第三方库都提供了 `compose` 工具函数，包括 `lodash`  和 `Ramda`。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 6. 约定：包装显示名称以便轻松调试\r\n`HOC` 创建的容器组件会与任何其他组件一样，会显示在 `React Developer Tools` 中。\r\n为了方便调试，请选择一个显示名称，以表明它是 `HOC` 的产物。\r\n\r\n最常见的方式是用 `HOC` 包住被包装组件的显示名称。\r\n比如高阶组件名为 `withSubscription`，并且被包装组件的显示名称为 `CommentList`，\r\n显示名称应该为 `WithSubscription(CommentList)`\r\n```javascript\r\nfunction withSubscription(WrappedComponent) {\r\n  class WithSubscription extends React.Component {/* ... */}\r\n  WithSubscription.displayName = `WithSubscription(${getDisplayName(WrappedComponent)})`;\r\n  return WithSubscription;\r\n}\r\n\r\nfunction getDisplayName(WrappedComponent) {\r\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\r\n}\r\n```\r\n\r\n## 7. 注意事项\r\n### 不要在 render 方法中使用 HOC\r\n`render` 频繁 **重新挂载组件** 会导致该组件及其所有子组件的 **状态丢失**。\r\n```javascript\r\nrender() {\r\n  // 每次调用 render 函数都会创建一个新的 EnhancedComponent\r\n  const EnhancedComponent = enhance(MyComponent);\r\n  // 这将导致子树每次渲染都会进行卸载，和重新挂载的操作！\r\n  return <EnhancedComponent />;\r\n}\r\n```\r\n\r\n### 务必复制静态方法\r\n如果原始组件上有 **静态方法**，`HOC` 创建的新组件会丢失这些静态方法。\r\n```javascript\r\nWrappedComponent.staticMethod = () =>{};\r\n\r\nconst EnhancedComponent = enhance(WrappedComponent);\r\n\r\nconsole.log(EnhancedComponent.staticMethod); // undefined\r\n```\r\n\r\n以下是三种解决方案：\r\n\r\n- 手动拷贝静态方法。\r\n```javascript\r\nfunction enhance(WrappedComponent) {\r\n  class Enhance extends React.Component {/*...*/}\r\n  Enhance.staticMethod = WrappedComponent.staticMethod;\r\n  return Enhance;\r\n}\r\n```\r\n\r\n- 使用第三方库 `hoist-non-react-statics` 自动拷贝。\r\n```javascript\r\nimport hoistNonReactStatic from 'hoist-non-react-statics';\r\n\r\nfunction enhance(WrappedComponent) {\r\n  class Enhance extends React.Component {/*...*/}\r\n  hoistNonReactStatic(Enhance, WrappedComponent);\r\n  return Enhance;\r\n}\r\n```\r\n\r\n- 额外导出静态方法。\r\n```javascript\r\nMyComponent.someFunction = someFunction;\r\nexport default MyComponent;\r\nexport { someFunction };\r\n\r\n// 在要使用的组件中，import 它们\r\nimport MyComponent, { someFunction } from './MyComponent.js';\r\n```\r\n\r\n## 8. Refs 不会被传递\r\n虽然 `HOC` 的约定是将所有 `props` 传递给被包装组件，但这对于 `refs` 并不适用。\r\n因为 `ref` 并不是 `prop`，像 `key` 一样，它是由 React 专门处理的。\r\n如果将 `ref` 添加到 `HOC` 的返回组件中，则 `ref` 引用指向容器组件，而不是被包装组件。\r\n\r\n可以使用 `React.forwardRef API` 解决。\r\n```javascript\r\nfunction logProps(Component) {\r\n  class LogProps extends React.Component {\r\n\r\n    render() {\r\n      const {forwardedRef, ...rest} = this.props;\r\n      return <Component ref={forwardedRef} {...rest} />;\r\n    }\r\n  }\r\n\r\n  return React.forwardRef((props, ref) => {\r\n    return <LogProps {...props} forwardedRef={ref} />;\r\n  });\r\n}\r\n```"}]},{"number":66,"title":"【Q066】受控组件和非受控组件","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/66","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 受控组件\r\n行为受 React **状态**(state) 控制的表单组件。\r\n```javascript\r\nconst Input = (props) => {\r\n  const { value, onChange } = props;\r\n\r\n  return <input value={value} onChange={e => onChange(e.target.value)} />\r\n}\r\n```\r\n\r\n## 2. 非受控组件\r\n行为不受 React **状态** 控制的表单组件，行为完全由用户操作影响。\r\n```javacscript\r\nconst Input = () => {\r\n  const [value, setValue] = useState('');\r\n  \r\n  return <input value={value} onChange={e => setValue(e.target.value)} />\r\n}\r\n```\r\n\r\n## 3. 受控组件 和 非受控组件 的区别\r\n控制组件行为的 **状态** 是否由外部传入。\r\n\r\n![alt](https://pic4.zhimg.com/80/v2-7285ea005390e41d3245b960af384d73_720w.jpg)\r\n图中蓝色表示 **组件**，黄色表示 **状态**。\r\n\r\n## 4. 受控又非受控组件\r\n现代组件库，有非常多的组件需要做到既支持受控模式，又支持非受控模式。\r\n例如 `antd` 涉及 **输入值、切换、展开收起** 的组件，都需要做到。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 5. 如何实现 受控又非受控组件\r\n### 解决方案：内外两个状态，手动同步\r\n无论哪种模式都使用 **子组件状态** 。\r\n当 **受控模式** 时，将 **父组件状态** 同步给 **子组件状态**。\r\n![alt](https://pic1.zhimg.com/v2-1334f4d825c82890005508729e6ff6cc_r.jpg)\r\n\r\n```javascript\r\nconst Input = (props) => {\r\n  const { value: _value, onChange } = props;\r\n  const [value, setValue] = useState(_value);\r\n  \r\n  const isControlled =_value !== undefined; // 是否受控\r\n  \r\n  const handleChange = (e) => {\r\n    // 不受控才改变内部状态\r\n    if (!isControlled) setValue(e.target.value);\r\n    onChange(e.target.value);\r\n  }\r\n  \r\n  useEffect(() => {\r\n    // 外部值变化，手动同步内部状态\r\n    if (isControlled) setValue(_value);\r\n  }, [isControlled])\r\n  \r\n  return <input value={value} onChange={handleChange} />\r\n}\r\n```\r\n\r\n仔细看上面的代码，我们会发现在 **受控模式** 下存在两个问题：\r\n\r\n- 原子性：**子组件状态** 更新比 **父组件状态** 更新晚一个渲染周期。产生撕裂感（tearing）。\r\n- 性能：在 `useEffect` 使用 `setState`，会额外触发一次渲染。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 6. 解决原子性\r\n我们不需要 **子组件状态** 和 **父组件状态** 时刻统一。\r\n只需要判断，**受控模式** 下直接使用 **父组件状态** 就好了。\r\n\r\n![alt](https://pic2.zhimg.com/80/v2-c2148d954e3f4a85150928cc4a076bbd_720w.webp)\r\n\r\n这样即使状态的同步存在延迟，子组件使用的值也是最新的。\r\n```javascript\r\nconst Input = (props) => {\r\n  // ...同上面的\r\n  const finalValue = isControlled ? _value : value; // 真正使用的值\r\n  \r\n  return <input value={finalValue} onChange={handleChange} />\r\n}\r\n```\r\n\r\n## 7. 解决性能\r\n在 `useEffect` 使用 `setState`，会额外触发一次 **子组件** 的渲染。\r\n\r\n### 此处 `state` 的作用是什么？\r\n\r\n- 持久化存放数据\r\n- 更新会触发重渲染\r\n\r\n### 是否能绕过 `state` 机制?\r\n可以使用 `ref` + `forceUpdate` 的组合。\r\n\r\n![alt](https://pic2.zhimg.com/80/v2-fea0d9c628e4c7fc70fc5b4eb6249e39_720w.webp)\r\n图中的虚线浅色圆圈表示 `ref`，刷新图标表示 `forceUpdate` 函数。\r\n\r\n```javascript\r\nconst Input = (props) => {\r\n  const { value: _value, onChange } = props;\r\n  \r\n  const [flag, forceUpdate] = useReducer(v => v + 1, 0); // 触发渲染用的\r\n  \r\n  const isControlled =_value !== undefined; // 是否受控\r\n  \r\n  const stateRef = useRef(_value);\r\n  // 受控模式下，将外部的值同步给 Ref\r\n  if (isControlled) {\r\n    stateRef.current = _value;\r\n  }\r\n  \r\n  const handleChange = (e) => {\r\n    // 手动同步 Ref\r\n    stateRef.current = e.target.value;\r\n    // 手动触发渲染\r\n    forceUpdate();\r\n    onChange(e.target.value);\r\n  }\r\n  \r\n  return <input value={stateRef.current} onChange={handleChange} />\r\n}\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 7. 抽象与复用\r\n我们可以把 `受控又非受控组件` 的效果封装为 `Hook`，供其他表单组件使用。\r\n\r\n```javascript\r\nconst usePropsValue = (props) => {\r\n  const { value, onChange, defaultValue } = props;\r\n    \r\n  const [flag, forceUpdate] = useReducer(v => v + 1, 0); // 触发渲染用的\r\n  \r\n  const isControlled = useMemo(() => value !== undefined, [value]); // 是否受控\r\n  \r\n  const stateRef = useRef(isControlled ? value : defaultValue);\r\n  // 受控模式下，将外部的值同步给 Ref\r\n  if (isControlled) {\r\n    stateRef.current = value;\r\n  }\r\n\r\n  const setState = (nextValue) => {\r\n    if (nextValue === stateRef.current) return;\r\n    // 手动同步 Ref\r\n    stateRef.current = nextValue;\r\n    // 手动触发渲染\r\n    forceUpdate();\r\n    onChange?.(nextValue);\r\n  }\r\n  \r\n  return [stateRef.current, setState];\r\n}\r\n```"}]},{"number":67,"title":"【Q067】为什么要是用 React Hooks?","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/67","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 为什么使用 Hook？\r\n`Hook` 是 React16.8 的新增特性。\r\n`Hook` 可以让你不必写 `class` 组件也能使用 `state` 等 React 特性。\r\n\r\n`Hook` 解决了许多 **组件问题**：\r\n\r\n## 2. 在组件之间复用状态逻辑很难\r\nReact 没有提供将复用逻辑加到组件里的方案。\r\n`class` 组件的复用方案是 `render props` 和 `HOC`，这些方案需要你重写组件结构。\r\n在 `React DevTools` 中，由 `providers`，`consumers`，`HOC`，`render props` 等其他抽象层组成的组件会形成 **嵌套地狱**，非常不利于观摩。\r\n\r\n自定义 `Hook` 可以提取复用状态逻辑，使你无需修改组件结构即可使用复用。\r\n\r\n## 3. 复杂组件变得难以理解\r\n状态逻辑和副作用充斥，每个 `生命周期` 常常包含一些不相关的逻辑。\r\n例如，组件常常在 `componentDidMount` 和 `componentDidUpdate` 中获取数据。\r\n但是，在 `componentDidMount` 中可能需要处理其他逻辑，例如事件监听并在 `componentWillUnmount ` 中取消。\r\n完全不相关的代码放在同一个生命周期里，后续维护不那么明了。\r\n\r\n`Hook` 组件可以使用 `Effect` 将关联代码拆成更小的函数，并非是死板的 `生命周期`。\r\n\r\n## 4. 难以理解的 class\r\n你必须去理解 `this` 的工作方式，才能很好的使用 `class`。\r\n\r\n`Hook` 这种函数式组件，以很低的使用成本就可以写出好组件。"}]},{"number":68,"title":"【Q068】React Hooks 实现原理","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/68","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. useState / useReducer\r\n`useState` 和 `useReducer` 都是关于 **状态** 的获取和更新。\r\n`useState` 是 `useReducer` 的一个简化版，其背后用的都是同一套逻辑。\r\n\r\n### Hook 如何保存状态\r\n`Hook` 保存状态的位置其实与 `class` 的一致：\r\n\r\n- 两者的 **状态** 都被挂载在组件实例对象 `FiberNode` 的 `memoizedState` 属性中。\r\n- 两者保存 **状态** 的数据结构完全不同；\r\n`class` 直接把 `state` 对象保存在 `memoizedState` 中；\r\n`Hook` 用链表保存 **状态**，`memoizedState` 中保存的是链表的头指针。\r\n\r\n让我们看下链表的结构：\r\n```typescript\r\n// react-reconciler/src/ReactFiberHooks.js\r\n\r\nexport type Hook = {\r\n  memoizedState: any, // 最新的状态值\r\n  baseState: any, // 初始状态值\r\n  baseUpdate: Update<any, any> | null,\r\n  queue: UpdateQueue<any, any> | null, // 临时保存对状态值的操作，更准确来说是一个链表数据结构中的一个指针\r\n  next: Hook | null,  // 指向下一个链表节点\r\n};\r\n```\r\n\r\n官方文档一直强调 `Hook` 的调用只能放在 **函数组件/自定义Hook** 的顶部，\r\n因为只能通过 `Hook` 调用的顺序来与实际保存的数据结构来关联：\r\n\r\n![alt](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/1/17307e7bb3014026~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)\r\n\r\n### Hook 如何更新\r\n`useState` 和 `useReducer` 都返回了更新函数（dispatcher），`dispatcher` 的运行原理是怎样的呢？\r\n每次调用 `dispatcher`，不会立即更新 **状态**，而是创建一条修改操作。\r\n在对应 `Hook` 对象的 `queue` 属性挂载的链表上加一个新节点：\r\n\r\n![alt](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/1/17307e7f74c14584~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)\r\n\r\n在下次执行函数组件时，走到 `useState` 这步，链表才会计算最新的 **状态**。\r\n\r\n### 为什么把更新操作都保存到链表，保存最后一条更新操作不行吗？\r\n因为 `dispatcher` 还支持 **函数式更新**。 \r\n```javascript\r\nconst [name, setName] = useState('');\r\n\r\nsetName(name => name + 'a');\r\nsetName(name => name + 'b');\r\nsetName(name => name + 'c');\r\n\r\n// 下次渲染时\r\nconsole.log(name); // 'abc'\r\n```\r\n"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. useEffect\r\n`useEffect` 的保存也是以 **链表** 的形式挂载在 `FiberNode.updateQueue` 中。\r\n下面我们按组件 `生命周期` 中的  `mount` 和 `update` 来阐述 `useEffect` 的执行原理：\r\n \r\n### mount 阶段：mountEffect\r\n① 根据函数组件中依次调用的 `useEffect`，构建成一个链表并挂载在 `FiberNode.updateQueue` 中。\r\n链表节点的数据结构为：\r\n```typescript\r\n const effect: Effect = {\r\n    tag, // 用来标识依赖项有没有变动\r\n    create, // 用户使用useEffect传入的函数体\r\n    destroy, // 上述函数体执行后生成的用来清除副作用的函数\r\n    deps, // 依赖项列表\r\n    next: (null: any),\r\n};\r\n```\r\n\r\n② 组件完成渲染后，遍历链表执行。\r\n\r\n### update 阶段：updateEffect\r\n同样在依次调用 `useEffect` 时，判断此时传入的依赖列表，与链表节点 `Effect.deps` 中保存的做一次浅比较。\r\n如果一致，则在 `Effect.tag` 标记上 `NoHookEffect`。\r\n\r\n### 执行阶段\r\n在每次组件渲染完成后，就会进入 `useEffect` 的执行阶段：`commitHookEffectList()`。\r\n\r\n- 遍历链表\r\n- 如果遇到标签（tag）为 `NoHookEffect` 的节点则跳过\r\n- 如果有清除函数（destroy），先执行清除\r\n- 执行传入的函数（create）\r\n\r\n注意：先清除上一轮的副作用，然后再执行本轮的传入函数。\r\n\r\n## 3. 其它官方 Hook\r\n其它官方 `Hook` 也是相似原理：\r\n- 用链表数据结构来做全局状态保持\r\n- 判断依赖项决定是否要更新状态"}]},{"number":69,"title":"【Q069】React Hooks 使用原则，以及为什么","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/69","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. Hook 规则\r\n`Hook` 本质就是 **函数**，但是在使用它时需要遵循两条规则。\r\n官方提供了一个 [linter 插件](https://www.npmjs.com/package/eslint-plugin-react-hooks)来强制执行这些规则：\r\n\r\n## 2. 只在最顶层使用 Hook\r\n### 不要在循环，条件或嵌套函数中调用 `Hook`。\r\n确保总是在你的 React 函数的最顶层以及任何 `return` 之前调用他们。\r\n这样可以确保每次组件渲染 `Hook` 的调用顺序。\r\n\r\n### 原理分析：\r\nReact 怎么知道哪个 `state` 对应哪个 `useState`？靠链表上 `Hook` 调用的顺序。\r\n```javascript\r\n// 首次渲染\r\nuseState('Mary')           // 1. 使用 'Mary' 初始化变量名为 name 的 state\r\nuseEffect(persistForm)     // 2. 添加 effect 以保存 form 操作\r\nuseState('Poppins')        // 3. 使用 'Poppins' 初始化变量名为 surname 的 state\r\nuseEffect(updateTitle)     // 4. 添加 effect 以更新标题\r\n\r\n// 二次渲染\r\nuseState('Mary')           // 1. 读取变量名为 name 的 state（参数被忽略）\r\nuseEffect(persistForm)     // 2. 替换保存 form 的 effect\r\nuseState('Poppins')        // 3. 读取变量名为 surname 的 state（参数被忽略）\r\nuseEffect(updateTitle)     // 4. 替换更新标题的 effect\r\n```\r\n\r\n如果我们将一个 `Hook` 调用放到一个条件语句中会发生什么呢？\r\n```javascript\r\nif (name !== '') {\r\n  useEffect(function persistForm() {\r\n    localStorage.setItem('formData', name);\r\n  });\r\n}\r\n```\r\n\r\n组件渲染时，当条件判断为 true 时，会跳过这个 `Hook`。这可能会导致意料之外的 bug 产生。\r\n```javascript\r\nuseState('Mary')           // 1. 读取变量名为 name 的 state（参数被忽略）\r\n// useEffect(persistForm)  // 🔴 此 Hook 被忽略！\r\nuseState('Poppins')        // 🔴 2. 读取变量名为 surname 的 state 失败\r\nuseEffect(updateTitle)     // 🔴 3. 替换更新标题的 effect 失败\r\n```\r\n\r\n### 这就是为什么 Hook 需要在我们组件的最顶层调用。\r\n如果我们想要有条件地执行一个 `effect`，可以将判断放到 `Hook` 的内部：\r\n```javascript\r\nuseEffect(function persistForm() {\r\n  // 👍 将条件判断放置在 effect 中\r\n  if (name !== '') {\r\n    localStorage.setItem('formData', name);\r\n  }\r\n});\r\n```\r\n\r\n## 3. 只在 React 函数中调用 Hook\r\n\r\n调用环境 | 是否允许\r\n-- | --\r\nReact 函数组件 | ✅\r\n自定义 Hook | ✅\r\n普通 JS 函数 | ❌\r\n函数外 | ❌\r\n\r\n## 4. ESLint 插件\r\n使用 [eslint-plugin-react-hooks](https://www.npmjs.com/package/eslint-plugin-react-hooks) 可以有效的约束 `Hook` 错误的使用。\r\n```bash\r\nnpm install eslint-plugin-react-hooks --save-dev\r\n```\r\n\r\n```javascript\r\n// .eslintrc\r\n\r\n{\r\n  \"plugins\": [\r\n    \"react-hooks\"\r\n  ],\r\n  \"rules\": {\r\n    \"react-hooks/rules-of-hooks\": \"error\", // 检查 Hook 的规则\r\n    \"react-hooks/exhaustive-deps\": \"warn\" // 检查 effect 的依赖\r\n  }\r\n}\r\n```"}]},{"number":70,"title":"【Q070】React Hooks 使用中常见问题","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/70","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. useState 问题\r\n\r\n### 不要使用旧的状态\r\n先来看一个计数器的例子：\r\n```javascript\r\nconst Increaser = () => {\r\n  const [count, setCount] = useState(0);\r\n  \r\n  return (\r\n    <div>\r\n      <button onClick={() => setCount(count + 1)}>+</button>\r\n      <div>Counter: {count}</div>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n连续快速点击 **加号按钮**，很可能 `count` 没有达到预期的值。\r\n这是因为 `setState` 是异步的，状态在下一次渲染时才更新。\r\n此时的 `count` 就是旧值。正确用法是 **函数式更新**：\r\n\r\n```javascript\r\n<button onClick={() => setCount(_count => _count+ 1)}>+</button>\r\n```\r\n\r\n### 不要在不需要重新渲染时使用 useState\r\n看下面的例子：\r\n```javascript\r\nconst Counter = () => {\r\n  const [counter, setCounter] = useState(0);\r\n\r\n  return (\r\n    <div>\r\n      <button onClick={() =>  setCounter(_count => _count + 1)}>Counter</button>\r\n      <button onClick={() => console.log(counter)}>Counter Log</button>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n因为 `counter` 没有用在渲染，所以点击第一个按钮不会触发渲染，`setState` 也在等待更新。\r\n此时再点击第二个按钮，打印的 `counter` 为旧值。这与期待不符。\r\n\r\n解决方案是，用 `useRef` 替代 `useState`。\r\n```javascript\r\nconst counter = useRef(0);\r\n\r\n<button onClick={() =>  counter.current++}>Counter</button>\r\n<button onClick={() => console.log(counter.current)}>Counter Log</button>\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. useEffect 问题\r\n\r\n### 不要忘记清理副作用\r\n来看一个计数器的例子：\r\n```javascript\r\nconst DelayedIncreaser = () => {\r\n  const [count, setCount] = useState(0);\r\n  const [increase, setShouldIncrease] = useState(false);\r\n  \r\n  useEffect(() => {\r\n    if (increase) {\r\n      setInterval(() => {\r\n        setCount(count => count + 1)\r\n      }, 1000);\r\n    }\r\n  }, [increase]);\r\n  \r\n  return (\r\n    <div>\r\n      <button onClick={() => setShouldIncrease(true)}>+</button>\r\n      <div>Count: {count}</div>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n在点击按钮时，`count` 每秒会增加1。\r\n但是当卸载组件的时，就会报错。\r\n\r\n正确的用法是卸载前清理定时器：\r\n```javascript\r\nuseEffect(() => {\r\n    if (increase) {\r\n      const id = setInterval(() => {\r\n        setCount(count => count + 1)\r\n      }, 1000);\r\n      return () => clearInterval(id);\r\n    }\r\n}, [increase]);\r\n```\r\n\r\n### 不要使用 ref 作为 useEffect 的依赖\r\n```javascript\r\nconst count = useRef(0);\r\n\r\nuseEffect(() => {\r\n  console.log(count.current)\r\n}, [count.current])\r\n```\r\n\r\n`ref` 的更新不会引起组件的渲染，所以不会调用 `useEffect` 函数。\r\n\r\n## 3. Map数据\r\n不建议用 `useState` 保存 `Map`，也不建议用 `useEffect` 监听 `Map`。"}]},{"number":71,"title":"【Q071】官方自带的 Hooks","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/71","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. useState\r\n```javascript\r\nconst [state, setState] = useState(initialState);\r\n```\r\n返回一个 `state`，以及更新函数 `setState`。\r\n\r\n在初始渲染期间，返回的`state` 与传入的 `initialState` 值相同。\r\n\r\n`setState` 函数用于更新 `state`。它接收一个新的 `state` 值并将组件的一次重新渲染加入队列。\r\n```javascript\r\nsetState(newState);\r\n```\r\n在后续的重新渲染中，`useState` 返回的第一个值将始终是更新后最新的 `state`。\r\n\r\n#### 注意\r\nReact 会确保 `setState` 函数的标识是稳定的，并且不会在组件重新渲染时发生变化。\r\n这就是为什么可以安全地从 `useEffect` 或 `useCallback` 的依赖列表中省略 `setState`。\r\n\r\n### 函数式更新\r\n如果新的 `state` 需要通过使用先前的 `state` 计算得出，那么可以将函数传递给 `setState`。\r\n该函数将接收先前的 `state`，并返回一个更新后的值。\r\n下面的计数器组件示例展示了 `setState` 的两种用法：\r\n```javascript\r\nfunction Counter({initialCount}) {\r\n  const [count, setCount] = useState(initialCount);\r\n  return (\r\n    <>\r\n      Count: {count}\r\n      <button onClick={() => setCount(initialCount)}>Reset</button>\r\n      <button onClick={() => setCount(prevCount => prevCount - 1)}>-</button>\r\n      <button onClick={() => setCount(prevCount => prevCount + 1)}>+</button>\r\n    </>\r\n  );\r\n}\r\n```\r\n\r\n“+” 和 “-” 按钮采用函数式形式，因为被更新的 `state` 需要基于之前的 `state`。\r\n但是“重置”按钮则采用普通形式，因为它总是把 `count` 设置回初始值。\r\n\r\n如果你的更新函数返回值与当前 `state` 完全相同，则随后的重渲染会被完全跳过。\r\n\r\n#### 注意：\r\n与 `class` 组件中的 `setState` 方法不同，`useState` 不会自动合并更新对象。\r\n你可以用函数式的 `setState` 结合展开运算符来达到合并更新对象的效果。\r\n```javascript\r\nconst [state, setState] = useState({});\r\nsetState(prevState => {\r\n  // 也可以使用 Object.assign\r\n  return {...prevState, ...updatedValues};\r\n});\r\n```\r\n`useReducer` 是另一种可选方案，它更适合用于管理包含多个子值的 `state` 对象。\r\n\r\n### 惰性初始 state\r\n`initialState` 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。\r\n如果初始 `state` 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 `state`，此函数只在初始渲染时被调用：\r\n```javascript\r\nconst [state, setState] = useState(() => {\r\n  const initialState = someExpensiveComputation(props);\r\n  return initialState;\r\n});\r\n```\r\n\r\n### 跳过 state 更新\r\n如果你更新 `State Hook` 后的 `state` 与当前的 `state` 相同时，React 将跳过子组件的渲染并且不会触发 `effect` 的执行。\r\nReact 使用 **Object.is 比较算法** 来比较 `state`。\r\n\r\n需要注意的是，React 可能仍需要在跳过渲染前渲染该组件。\r\n不过由于 React 不会对组件树的“深层”节点进行不必要的渲染，所以大可不必担心。\r\n如果你在渲染期间执行了高开销的计算，则可以使用 `useMemo` 来进行优化。\r\n\r\n### state 的批更新\r\nReact 可能会将几个 `state` 更新分组到一个重新渲染中，以提高性能。\r\n通常情况下，这可以提高性能，且不影响你的应用程序的行为。\r\n\r\n在 React 18 之前，只有 React 事件处理程序内是批更新。\r\n从 React 18 开始，所有的更新都默认启用批处理。\r\n\r\n在较少的情况下，你需要强制渲染组件，你可以用 `flushSync`包裹 `setState`。\r\n然而，这可能会损害性能，所以只在需要时才这样做。\r\n```javascript\r\nimport { flushSync } from 'react-dom';\r\n\r\nflushSync(() => {\r\n  setCount(c => c + 1);\r\n  setFlag(f => !f);\r\n});\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. useEffect\r\n```javascript\r\nuseEffect(didUpdate);\r\n```\r\n该 `Hook` 接收一个包含命令式、且可能有副作用代码的函数。\r\n\r\n在函数组件主体内改变 DOM、添加订阅、设置定时器、记录日志以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性。\r\n\r\n使用 `useEffect` 完成副作用操作。\r\n赋值给 `useEffect` 的函数会在组件渲染到屏幕之后执行。\r\n你可以把 `effect` 看作从 React 的纯函数式世界通往命令式世界的逃生通道。\r\n\r\n默认情况下，`effect` 将在每轮渲染结束后执行，但你可以选择让它 **在只有某些值改变的时候** 才执行。\r\n\r\n### 清除 effect\r\n通常，组件卸载时需要清除 `effect` 创建的诸如订阅或计时器 ID 等资源。\r\n要实现这一点，`useEffect` 函数需返回一个清除函数。以下就是一个创建订阅的例子：\r\n```javascript\r\nuseEffect(() => {\r\n  const subscription = props.source.subscribe();\r\n  return () => {\r\n    // 清除订阅\r\n    subscription.unsubscribe();\r\n  };\r\n});\r\n```\r\n\r\n为防止内存泄漏，清除函数会在组件卸载前执行。\r\n另外，如果组件多次渲染，则 **在执行下一个 effect 之前，上一个 effect 就已被清除**。\r\n在上述示例中，意味着组件的每一次更新都会创建新的订阅。\r\n若想避免每次更新都触发 `effect` 的执行，请参阅下一小节。\r\n\r\n### effect 的执行时机\r\n与 `componentDidMount`、`componentDidUpdate` 不同的是，\r\n传给 `useEffect` 的函数会在浏览器完成布局与绘制之后，在一个延迟事件中被调用。\r\n这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因为绝大多数操作不应阻塞浏览器对屏幕的更新。\r\n\r\n然而，并非所有 `effect` 都可以被延迟执行。\r\n例如，一个对用户可见的 `DOM` 变更就必须在浏览器执行下一次绘制前被同步执行，这样用户才不会感觉到视觉上的不一致。\r\nReact 为此提供了一个额外的 `useLayoutEffect` 来处理这类 `effect`。\r\n它和 `useEffect` 的结构相同，区别只是调用时机不同。\r\n\r\n此外，从 React 18 开始，当它是离散的用户输入（如点击）的结果时，\r\n或者当它是由 `flushSync` 包装的更新结果时，传递给 `useEffect` 的函数将在屏幕布局和绘制之前同步执行。\r\n这种行为便于事件系统或 `flushSync` 的调用者观察该效果的结果。\r\n\r\n#### 注意\r\n这只影响传递给 `useEffect` 的函数被调用时 — 在这些 `effect` 中执行的更新仍会被推迟。\r\n这与 `useLayoutEffect` 不同，后者会立即启动该函数并处理其中的更新。\r\n\r\n即使在 `useEffect` 被推迟到浏览器绘制之后的情况下，它也能保证在任何新的渲染前启动。\r\nReact 在开始新的更新前，总会先刷新之前的渲染的 `effect`。\r\n\r\n### effect 的条件执行\r\n默认情况下，`effect` 会在每轮组件渲染完成后执行。\r\n这样的话，一旦 `effect` 的依赖发生变化，它就会被重新创建。\r\n\r\n然而，在某些场景下这么做可能会矫枉过正。\r\n比如，在上一章节的订阅示例中，我们不需要在每次组件更新时都创建新的订阅，而是仅需要在 `source prop` 改变时重新创建。\r\n\r\n要实现这一点，可以给 `useEffect` 传递第二个参数，它是 `effect` 所依赖的值数组。更新后的示例如下：\r\n```javascript\r\nuseEffect(\r\n  () => {\r\n    const subscription = props.source.subscribe();\r\n    return () => {\r\n      subscription.unsubscribe();\r\n    };\r\n  },\r\n  [props.source],\r\n);\r\n```\r\n此时，只有当 `props.source` 改变后才会重新创建订阅。\r\n\r\n#### 注意\r\n如果你要使用此优化方式，请确保数组中包含了所有 **外部作用域中会发生变化且在 `effect` 中使用的变量**，\r\n否则你的代码会引用到先前渲染中的旧变量。\r\n\r\n如果想执行只运行一次的 `effect`（仅在组件挂载和卸载时执行），可以传递一个空数组 `[]` 作为第二个参数。\r\n这就告诉 React 你的 `effect` 不依赖于 `props` 或 `state` 中的任何值，所以它永远都不需要重复执行。\r\n这并不属于特殊情况 —— 它依然遵循输入数组的工作方式。\r\n\r\n如果你传入了一个空数组 `[]`，`effect` 内部的 `props` 和 `state` 就会一直持有其初始值。\r\n尽管传入 `[]` 作为第二个参数有点类似于 `componentDidMount` 和 `componentWillUnmount` 的思维模式，\r\n但我们有 **更好的方式** 来避免过于频繁的重复调用 `effect`。\r\n除此之外，请记得 React 会 **等待浏览器完成画面渲染之后才会延迟调用** `useEffect`，因此会使得处理额外操作很方便。\r\n\r\n依赖项数组不会作为参数传给 `effect` 函数。\r\n虽然从概念上来说它表现为：所有 `effect` 函数中引用的值都应该出现在依赖项数组中。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 3. useContext\r\n```javascript\r\nconst value = useContext(MyContext);\r\n```\r\n\r\n接收一个 `context` 对象（`React.createContext` 的返回值）并返回该 `context` 的当前值。\r\n当前的 `context` 值由上层组件中距离当前组件最近的 `<MyContext.Provider>` 的 `value prop` 决定。\r\n\r\n当组件上层最近的 `<MyContext.Provider>` 更新时，该 `Hook` 会触发重渲染，\r\n并使用最新传递给 `MyContext provider` 的 `context value` 值。\r\n即使祖先使用 `React.memo` 或 `shouldComponentUpdate`，也会在组件本身使用 `useContext` 时重新渲染。\r\n\r\n别忘记 `useContext` 的参数必须是 `context` 对象本身：\r\n\r\n- ✔ useContext(MyContext)\r\n- ❌ useContext(MyContext.Consumer)\r\n- ❌ useContext(MyContext.Provider)\r\n\r\n调用了 `useContext` 的组件总会在 `context` 值变化时重新渲染。\r\n如果重渲染组件的开销较大，你可以通过使用 `memoization` 来优化。\r\n\r\n#### 提示\r\n如果你在接触 `Hook` 前已经对 `context API` 比较熟悉，那应该可以理解，\r\n`useContext(MyContext) 相当于 `class` 组件中的 `static contextType = MyContext` 或者 `<MyContext.Consumer>`。\r\n\r\n`useContext(MyContext)` 只是让你能够读取 `context` 的值以及订阅 `context` 的变化。\r\n你仍然需要在上层组件树中使用 `<MyContext.Provider>` 来为下层组件提供 `context`。\r\n\r\n### 和 Context.Provider 一起使用\r\n```javascript\r\nconst themes = {\r\n  light: {\r\n    foreground: \"#000000\",\r\n    background: \"#eeeeee\"\r\n  },\r\n  dark: {\r\n    foreground: \"#ffffff\",\r\n    background: \"#222222\"\r\n  }\r\n};\r\n\r\nconst ThemeContext = React.createContext(themes.light);\r\n\r\nfunction App() {\r\n  return (\r\n    <ThemeContext.Provider value={themes.dark}>\r\n      <Toolbar />\r\n    </ThemeContext.Provider>\r\n  );\r\n}\r\n\r\nfunction Toolbar(props) {\r\n  return (\r\n    <div>\r\n      <ThemedButton />\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction ThemedButton() {\r\n  const theme = useContext(ThemeContext);\r\n  return (\r\n    <button style={{ background: theme.background, color: theme.foreground }}>\r\n      I am styled by theme context!\r\n    </button>\r\n  );\r\n}\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 4. useReducer\r\n```javascript\r\nconst [state, dispatch] = useReducer(reducer, initialArg, init);\r\n```\r\n\r\n`useState` 的替代方案。它接收一个形如 `(state, action) => newState` 的 `reducer`，\r\n并返回当前的 `state` 以及与其配套的 `dispatch` 方法。\r\n\r\n在某些场景下，`useReducer` 会比 `useState` 更适用，例如 `state` 逻辑较复杂且包含多个子值，\r\n或者下一个 state 依赖于之前的 state 等。\r\n并且，使用 `useReducer` 还能给那些会触发深更新的组件做性能优化，因为 **你可以向子组件传递 dispatch 而不是回调函数**。\r\n\r\n以下是用 `reducer` 重写 `useState` 一节的计数器示例：\r\n```javascript\r\nconst initialState = {count: 0};\r\n\r\nfunction reducer(state, action) {\r\n  switch (action.type) {\r\n    case 'increment':\r\n      return {count: state.count + 1};\r\n    case 'decrement':\r\n      return {count: state.count - 1};\r\n    default:\r\n      throw new Error();\r\n  }\r\n}\r\n\r\nfunction Counter() {\r\n  const [state, dispatch] = useReducer(reducer, initialState);\r\n  return (\r\n    <>\r\n      Count: {state.count}\r\n      <button onClick={() => dispatch({type: 'decrement'})}>-</button>\r\n      <button onClick={() => dispatch({type: 'increment'})}>+</button>\r\n    </>\r\n  );\r\n}\r\n```\r\n\r\n#### 注意\r\nReact 会确保 `dispatch` 函数的标识是稳定的，并且不会在组件重新渲染时改变。\r\n这就是为什么可以安全地从 `useEffect` 或 `useCallback` 的依赖列表中省略 `dispatch`。\r\n\r\n### 指定初始 state\r\n有两种不同初始化 `state` 的方式，你可以根据使用场景选择其中的一种。\r\n将初始 `state` 作为第二个参数传入 `useReducer` 是最简单的方法：\r\n```javascript\r\n  const [state, dispatch] = useReducer(\r\n    reducer,\r\n    {count: initialCount}\r\n  );\r\n```\r\n\r\n#### 注意\r\nReact 不使用 `state = initialState` 这一由 `Redux` 推广开来的参数约定。\r\n有时候初始值依赖于 `props`，因此需要在调用 `Hook` 时指定。\r\n如果你特别喜欢上述的参数约定，可以通过调用 `useReducer(reducer, undefined, reducer)` 来模拟 `Redux` 的行为，\r\n但我们不鼓励你这么做。\r\n\r\n### 惰性初始化\r\n你可以选择惰性地创建初始 `state`。\r\n为此，需要将 `init` 函数作为 `useReducer` 的第三个参数传入，这样初始 `state` 将被设置为 `init(initialArg)`。\r\n\r\n这么做可以将用于计算 `state` 的逻辑提取到 `reducer` 外部，这也为将来对重置 `state` 的 `action` 做处理提供了便利：\r\n```javascript\r\nfunction init(initialCount) {\r\n  return {count: initialCount};\r\n}\r\n\r\nfunction reducer(state, action) {\r\n  switch (action.type) {\r\n    case 'increment':\r\n      return {count: state.count + 1};\r\n    case 'decrement':\r\n      return {count: state.count - 1};\r\n    case 'reset':\r\n      return init(action.payload);\r\n    default:\r\n      throw new Error();\r\n  }\r\n}\r\n\r\nfunction Counter({initialCount}) {\r\n  const [state, dispatch] = useReducer(reducer, initialCount, init);\r\n  return (\r\n    <>\r\n      Count: {state.count}\r\n      <button\r\n        onClick={() => dispatch({type: 'reset', payload: initialCount})}>\r\n        Reset\r\n      </button>\r\n      <button onClick={() => dispatch({type: 'decrement'})}>-</button>\r\n      <button onClick={() => dispatch({type: 'increment'})}>+</button>\r\n    </>\r\n  );\r\n}\r\n```\r\n\r\n### 跳过 dispatch\r\n如果 `Reducer` 的返回值与当前 `state` 相同，React 将跳过子组件的渲染及副作用的执行。\r\nReact 使用 **Object.is 比较算法** 来比较 state。\r\n\r\n需要注意的是，React 可能仍需要在跳过渲染前再次渲染该组件。\r\n不过由于 React 不会对组件树的“深层”节点进行不必要的渲染，所以大可不必担心。\r\n如果你在渲染期间执行了高开销的计算，则可以使用 `useMemo` 来进行优化。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 5. useCallback\r\n```javascript\r\nconst memoizedCallback = useCallback(\r\n  () => {\r\n    doSomething(a, b);\r\n  },\r\n  [a, b],\r\n);\r\n```\r\n\r\n返回一个 `memoized` 回调函数。\r\n\r\n把内联回调函数及依赖项数组作为参数传入 `useCallback`，\r\n它将返回该回调函数的 `memoized` 版本，该回调函数仅在某个依赖项改变时才会更新。\r\n当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 `shouldComponentUpdate`）的子组件时，它将非常有用。\r\n\r\n`useCallback(fn, deps)` 相当于 `useMemo(() => fn, deps)`。\r\n\r\n#### 注意\r\n依赖项数组不会作为参数传给回调函数。\r\n虽然从概念上来说它表现为：所有回调函数中引用的值都应该出现在依赖项数组中。\r\n\r\n### 6. useMemo\r\n```javascript\r\nconst memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\r\n```\r\n返回一个 `memoized` 值。\r\n\r\n把“创建”函数和依赖项数组作为参数传入 `useMemo`，它仅会在某个依赖项改变时才重新计算 `memoized` 值。\r\n这种优化有助于避免在每次渲染时都进行高开销的计算。\r\n\r\n记住，传入 `useMemo` 的函数会在渲染期间执行。\r\n请不要在这个函数内部执行不应该在渲染期间内执行的操作，\r\n诸如副作用这类的操作属于 `useEffect` 的适用范畴，而不是 `useMemo`。\r\n\r\n如果没有提供依赖项数组，`useMemo` 在每次渲染时都会计算新的值。\r\n\r\n### 你可以把 useMemo 作为性能优化的手段，但不要把它当成语义上的保证。\r\n将来，React 可能会选择“遗忘”以前的一些 `memoized` 值，并在下次渲染时重新计算它们，比如为离屏组件释放内存。\r\n先编写在没有 `useMemo` 的情况下也可以执行的代码 —— 之后再在你的代码中添加 `useMemo`，以达到优化性能的目的。\r\n\r\n#### 注意\r\n依赖项数组不会作为参数传给“创建”函数。\r\n虽然从概念上来说它表现为：所有“创建”函数中引用的值都应该出现在依赖项数组中。\r\n\r\n## 7. useRef\r\n```javascript\r\nconst refContainer = useRef(initialValue);\r\n```\r\n`useRef` 返回一个可变的 `ref` 对象，其 `.current` 属性被初始化为传入的参数 `initialValue`。\r\n返回的 `ref` 对象在组件的整个生命周期内持续存在。\r\n\r\n一个常见的用例便是命令式地访问子组件：\r\n```javascript\r\nfunction TextInputWithFocusButton() {\r\n  const inputEl = useRef(null);\r\n  const onButtonClick = () => {\r\n    // `current` 指向已挂载到 DOM 上的文本输入元素\r\n    inputEl.current.focus();\r\n  };\r\n  return (\r\n    <>\r\n      <input ref={inputEl} type=\"text\" />\r\n      <button onClick={onButtonClick}>Focus the input</button>\r\n    </>\r\n  );\r\n}\r\n```\r\n\r\n本质上，`useRef` 就像是可以在其 `.current` 属性中保存一个可变值的“盒子”。\r\n\r\n你应该熟悉 `ref` 这一种 **访问 DOM** 的主要方式。\r\n如果你将 `ref` 对象以 `<div ref={myRef} />` 形式传入组件，则无论该节点如何改变，\r\nReact 都会将 `ref` 对象的 `.current` 属性设置为相应的 `DOM` 节点。\r\n\r\n然而，`useRef()` 比 `ref` 属性更有用。\r\n它可以 **很方便地保存任何可变值**，其类似于在 `class` 中使用实例字段的方式。\r\n\r\n这是因为它创建的是一个普通 JS 对象。\r\n而 `useRef()` 和自建一个 `{current: ...}` 对象的唯一区别是，`useRef` 会在每次渲染时返回同一个 `ref` 对象。\r\n\r\n请记住，当 `ref` 对象内容发生变化时，`useRef` 并不会通知你。\r\n变更 `.current` 属性不会引发组件重新渲染。\r\n如果想要在 React 绑定或解绑 `DOM` 节点的 `ref` 时运行某些代码，则需要使用 **回调 ref** 来实现。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 8. useImperativeHandle\r\n```javascript\r\nuseImperativeHandle(ref, createHandle, [deps])\r\n```\r\n\r\n`useImperativeHandle` 可以让你在使用 `ref` 时自定义暴露给父组件的实例值。\r\n在大多数情况下，应当避免使用 `ref` 这样的命令式代码。\r\n`useImperativeHandle` 应当与 `forwardRef` 一起使用：\r\n\r\n```javascript\r\nfunction FancyInput(props, ref) {\r\n  const inputRef = useRef();\r\n  useImperativeHandle(ref, () => ({\r\n    focus: () => {\r\n      inputRef.current.focus();\r\n    }\r\n  }));\r\n  return <input ref={inputRef} ... />;\r\n}\r\nFancyInput = forwardRef(FancyInput);\r\n```\r\n\r\n在本例中，渲染 `<FancyInput ref={inputRef} />` 的父组件可以调用 `inputRef.current.focus()`。\r\n\r\n## 9. useLayoutEffect\r\n其函数签名与 `useEffect` 相同，但它会在所有的 `DOM` 变更之后同步调用 `effect`。\r\n可以使用它来读取 `DOM` 布局并同步触发重渲染。在浏览器执行绘制之前，`useLayoutEffect` 内部的更新计划将被同步刷新。\r\n\r\n尽可能使用标准的 `useEffect` 以避免阻塞视觉更新。\r\n\r\n#### 提示\r\n如果你正在将代码从 `class` 组件迁移到使用 `Hook` 的函数组件，\r\n则需要注意 `useLayoutEffect` 与 `componentDidMount`、`componentDidUpdate` 的调用阶段是一样的。\r\n但是，我们推荐你一开始先用 `useEffect`，只有当它出问题的时候再尝试使用 `useLayoutEffect`。\r\n\r\n如果你使用服务端渲染，请记住，无论 `useLayoutEffect` 还是 `useEffect` 都无法在 JS 代码加载完成之前执行。\r\n这就是为什么在服务端渲染组件中引入 `useLayoutEffect` 代码时会触发 React 告警。\r\n解决这个问题，需要将代码逻辑移至 `useEffect` 中（如果首次渲染不需要这段逻辑的情况下），\r\n或是将该组件延迟到客户端渲染完成后再显示（如果直到 `useLayoutEffect` 执行之前 HTML 都显示错乱的情况下）。\r\n\r\n若要从服务端渲染的 HTML 中排除依赖布局 `effect` 的组件，可以通过使用 `showChild && <Child />` 进行条件渲染，\r\n并使用 `useEffect(() => { setShowChild(true); }, [])` 延迟展示组件。\r\n这样，在客户端渲染完成之前，UI 就不会像之前那样显示错乱了。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 10. useDebugValue\r\n```javascript\r\nuseDebugValue(value)\r\n```\r\n\r\n`useDebugValue` 可用于在 React 开发者工具中显示自定义 `hook` 的标签。\r\n\r\n例如，名为 `useFriendStatus` 的自定义 `Hook`：\r\n```javascript\r\nfunction useFriendStatus(friendID) {\r\n  const [isOnline, setIsOnline] = useState(null);\r\n\r\n  // 在开发者工具中的这个 Hook 旁边显示标签\r\n  // e.g. \"FriendStatus: Online\"\r\n  useDebugValue(isOnline ? 'Online' : 'Offline');\r\n\r\n  return isOnline;\r\n}\r\n```\r\n\r\n#### 提示\r\n我们不推荐你向每个自定义 `Hook` 添加 `debug` 值。\r\n当它作为共享库的一部分时才最有价值。\r\n\r\n### 延迟格式化 debug 值\r\n在某些情况下，格式化值的显示可能是一项开销很大的操作。\r\n除非需要检查 `Hook`，否则没有必要这么做。\r\n\r\n因此，`useDebugValue` 接受一个格式化函数作为可选的第二个参数。\r\n该函数只有在 `Hook` 被检查时才会被调用。\r\n它接受 `debug` 值作为参数，并且会返回一个格式化的显示值。\r\n\r\n例如，一个返回 `Date` 值的自定义 `Hook` 可以通过格式化函数来避免不必要的 `toDateString` 函数调用：\r\n```javascript\r\nuseDebugValue(date, date => date.toDateString());\r\n```\r\n\r\n## 11. useDeferredValue\r\n```javascript\r\nconst deferredValue = useDeferredValue(value);\r\n```\r\n\r\n`useDeferredValue` 接受一个值，并返回该值的新副本，该副本将推迟到更紧急地更新之后。\r\n如果当前渲染是一个紧急更新的结果，比如用户输入，React 将返回之前的值，然后在紧急渲染完成后渲染新的值。\r\n\r\n该 `hook` 与使用防抖和节流去延迟更新的用户空间 `hooks` 类似。\r\n使用 `useDeferredValue` 的好处是，React 将在其他工作完成（而不是等待任意时间）后立即进行更新，\r\n并且像 `startTransition` 一样，延迟值可以暂停，而不会触发现有内容的意外降级。\r\n\r\n### 缓存子组件\r\n`useDeferredValue` 仅延迟你传递给它的值。\r\n如果你想要在紧急更新期间防止子组件重新渲染，则还必须使用 `memo` 或 `useMemo` 缓存该子组件：\r\n```javascript\r\nfunction Typeahead() {\r\n  const query = useSearchQuery('');\r\n  const deferredQuery = useDeferredValue(query);\r\n\r\n  // Memoizing 告诉 React 仅当 deferredQuery 改变，\r\n  // 而不是 query 改变的时候才重新渲染\r\n  const suggestions = useMemo(() =>\r\n    <SearchSuggestions query={deferredQuery} />,\r\n    [deferredQuery]\r\n  );\r\n\r\n  return (\r\n    <>\r\n      <SearchInput query={query} />\r\n      <Suspense fallback=\"Loading results...\">\r\n        {suggestions}\r\n      </Suspense>\r\n    </>\r\n  );\r\n}\r\n```\r\n\r\n缓存该子组件告诉 React 它仅当 `deferredQuery` 改变而不是 `query` 改变的时候才需要去重新渲染。\r\n这个限制不是 `useDeferredValue` 独有的，它和使用防抖或节流的 `hooks` 使用的相同模式。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 12. useTransition\r\n```javascript\r\nconst [isPending, startTransition] = useTransition();\r\n```\r\n\r\n返回一个状态值表示过渡任务的等待状态，以及一个启动该过渡任务的函数。\r\n\r\n`startTransition` 允许你通过标记更新将提供的回调函数作为一个过渡任务：\r\n```javascript\r\nstartTransition(() => {\r\n  setCount(count + 1);\r\n})\r\n```\r\n\r\n`isPending` 指示过渡任务何时活跃以显示一个等待状态：\r\n```javascript\r\nfunction App() {\r\n  const [isPending, startTransition] = useTransition();\r\n  const [count, setCount] = useState(0);\r\n  \r\n  function handleClick() {\r\n    startTransition(() => {\r\n      setCount(c => c + 1);\r\n    })\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      {isPending && <Spinner />}\r\n      <button onClick={handleClick}>{count}</button>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n#### 注意\r\n过渡任务中触发的更新会让更紧急地更新先进行，比如点击。\r\n\r\n过渡任务中的更新将不会展示由于再次挂起而导致降级的内容。\r\n这个机制允许用户在 React 渲染更新的时候继续与当前内容进行交互。\r\n\r\n## 13. useId\r\n```javascript\r\nconst id = useId();\r\n```\r\n`useId` 是一个用于生成横跨服务端和客户端的稳定的唯一 ID 的同时避免 `hydration` 不匹配的 `hook`。\r\n\r\n#### 注意\r\n`useId` 不用于在列表中生成 `key`。`key` 应该从你的数据中生成。\r\n\r\n一个最简单的例子，直接传递 `id` 给需要它的元素：\r\n```javascript\r\nfunction Checkbox() {\r\n  const id = useId();\r\n  return (\r\n    <>\r\n      <label htmlFor={id}>Do you like React?</label>\r\n      <input id={id} type=\"checkbox\" name=\"react\"/>\r\n    </>\r\n  );\r\n};\r\n```\r\n\r\n对于同一组件中的多个 ID，使用相同的 `id` 并添加后缀：\r\n\r\n```javascript\r\nfunction NameFields() {\r\n  const id = useId();\r\n  return (\r\n    <div>\r\n      <label htmlFor={id + '-firstName'}>First Name</label>\r\n      <div>\r\n        <input id={id + '-firstName'} type=\"text\" />\r\n      </div>\r\n      <label htmlFor={id + '-lastName'}>Last Name</label>\r\n      <div>\r\n        <input id={id + '-lastName'} type=\"text\" />\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n#### 注意\r\n`useId` 生成一个包含 `:` 的字符串 token。\r\n这有助于确保 token 是唯一的，但在 CSS 选择器或 `querySelectorAll` 等 API 中不受支持。\r\n\r\n`useId` 支持 `identifierPrefix` 以防止在多个根应用的程序中发生冲突。 "}]},{"number":72,"title":"【Q072】useEffect 和 useLayoutEffect 的区别","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/72","comments":[]},{"number":73,"title":"【Q073】useMemo 和 useCallback 的区别","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/73","comments":[]},{"number":74,"title":"【Q074】如何自己封装一个 Hooks","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/74","comments":[]},{"number":75,"title":"【Q075】Suspense","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/75","comments":[]},{"number":76,"title":"【Q076】Concurrent","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/76","comments":[]},{"number":77,"title":"【Q077】startTransition","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/77","comments":[]},{"number":78,"title":"【Q078】Server Component","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/78","comments":[]},{"number":79,"title":"【Q079】componentDidCatch","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/79","comments":[]},{"number":80,"title":"【Q080】SSR","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/80","comments":[]},{"number":81,"title":"【Q081】为什么需要用 redux","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/81","comments":[]},{"number":82,"title":"【Q082】react-redux 是干什么的","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/82","comments":[]},{"number":83,"title":"【Q083】react-redux content 实现原理","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/83","comments":[]},{"number":84,"title":"【Q084】redux 工作流程及原理","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/84","comments":[]},{"number":85,"title":"【Q085】有没有用过其它状态管理器？以及原理","labels":["react"],"body":"mobx","url":"https://github.com/kangyana/daily-question/issues/85","comments":[]},{"number":86,"title":"【Q086】react-router 路由实现原理","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/86","comments":[]},{"number":87,"title":"【Q087】react-router 有几种路由类型？","labels":["react"],"body":"每种路由类型实现原理","url":"https://github.com/kangyana/daily-question/issues/87","comments":[]},{"number":88,"title":"【Q088】项目本地开发完成后部署到服务器后报 404","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/88","comments":[]}],"webpack":[{"number":89,"title":"【Q089】为什么需要 webpack","labels":["webpack"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/89","comments":[]},{"number":90,"title":"【Q090】webpack 5 新特性","labels":["webpack"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/90","comments":[]},{"number":91,"title":"【Q091】loader","labels":["webpack"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/91","comments":[]},{"number":92,"title":"【Q092】plugin","labels":["webpack"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/92","comments":[]},{"number":93,"title":"【Q093】tree shaking","labels":["webpack"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/93","comments":[]},{"number":94,"title":"【Q094】常见的配置项","labels":["webpack"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/94","comments":[]},{"number":95,"title":"【Q095】publicPath 是干什么的","labels":["webpack"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/95","comments":[]},{"number":96,"title":"【Q096】打包很慢，怎么解决","labels":["webpack"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/96","comments":[]},{"number":97,"title":"【Q097】打包出来的文件很大，怎么解决？","labels":["webpack"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/97","comments":[]},{"number":98,"title":"【Q098】模块联邦","labels":["webpack"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/98","comments":[]},{"number":99,"title":"【Q099】HMR 原理","labels":["webpack"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/99","comments":[]},{"number":100,"title":"【Q100】有了解过现在流行的 bundless 构建工具吗？","labels":["webpack"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/100","comments":[]}]}