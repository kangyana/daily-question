# 【Q100】有了解过现在流行的 bundleless 构建工具吗？


::: tip Issue
欢迎在 Gtihub Issue 中回答此问题: [Issue 100](https://github.com/kangyana/daily-question/issues/100)
:::

::: tip Author
回答者: [kangyana](https://github.com/kangyana)
:::
## 1. bundle-less
随着项目的规模发展，webpack 的构建速度越来越慢。

- 项目冷启动时必须递归打包整个项目的依赖树，
- Nodejs 语言本身(解释执行、单线程执行)的限制，导致构建性能遇到瓶颈。

因此，`Bundleless` 构建工具应运而生，诸如 `Snowpack`、`Vite`。

和 Webpack 这种传统的打包工具相比，Vite 主要有两大主要优势:

- 利用浏览器内置 ES Module 的支持。
(script 标签加上属性 type="module" 即可)，浏览器直接向 dev server 逐个请求各个模块，而不需要提前把所有文件打包。
- 借助 esbuild 超快的编译速度把第三方库进行 **预构建**。
一方面将零散的文件打到一起，减少网络请求，另一方面全面转换为 ESM 模块语法，以适配浏览器内置的 ESM 支持。
::: tip Author
回答者: [kangyana](https://github.com/kangyana)
:::
## 2. bundle-less 做了什么？
- **拆包**。
弱化传统意义上的打包概念，由单 bundle 拆分为数十或者上百个 bundle，这样可以更好地利用 HTTP2 的多路复用优势和提升缓存命中率。
- **对源代码不进行打包**。
在开发阶段可以省略 bundle 的开销，如 Vite、Snowpack、WMR。
- **依赖产物的模块化分发**。
对于庞大的外部依赖，一方面打包成本比较高，另一方面文件数量可能非常多，打包几乎是一个必选项，甚至需要多个 NPM 包合并打包。
因此，针对依赖的打包也是非常重要的优化点，一般可以通过预打包 + 模块化缓存来进行优化，
目前也有一些优化案例，如 Vite 中基于 Esbuild 的预打包器、基于 ESM 的 CDN 服务，如 Skypack、esm.sh、jspm 等。

### 拆多少包更合适？
打的包太多或者太少都可能出现加载性能的问题。
比如过多的嵌套 `import` 导致网络瀑布流的产生、bundle 太少不能充分利用 HTTP2 下并发请求的优势。

针对这个问题，我们曾做过一系列的性能测试，最后得出的结论如下：

- 对于总产物资源大小相同的情况，资源加载分成的 chunk 数量在 10 - 25 之间进行并行加载性能最佳。
- 一次资源加载需要的依赖引用深度尽量等于 1 时加载性能最好。
- 由于不打包的情况下项目的请求数量和请求深度问题都不可控，因此不适合在生产构建中采用 no-bundle 方案。

### no-bundle 服务
#### 代表方案 Vite
在开发环境中，Vite 主要做了两件事情:

- 基于 esbuild 打包外部依赖。
- 创建 HTTP Server 以响应浏览器中 `<script type="module">` 所发起的一系列模块请求。

而生产环境下直接使用 `Rollup` 进行打包。
Vite 整体的优势是在于开发阶段，服务启动快、热更新快，明显地优化了开发者体验。

#### 劣势及解决方案
no-bundle 方案虽然省去了 bundle 的开销，但仍然需要进行单文件的编译(如 TS、JSX、Less、Sass)，编译的时长仍然可能会比较长(某些业务项目编译要 20 s 左右)。
Vite 在二次请求时会采用 Etag 标识返回协商缓存的内容，可以跳过编译消耗的时间，但服务重启后仍然需要进行全量的编译，体验不太好。
对此，一个比较好的解决方法是在服务退出时将 ModuleGraph 的内容缓存到本地，然后重启的时候激活缓存(hydrate)，那么二次启动时仍然会使用协商缓存，达到比较快的首屏加载效果。

#### 海量请求的加载性能问题
