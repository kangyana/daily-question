# 【Q044】垃圾回收


::: tip Issue
欢迎在 Gtihub Issue 中回答此问题: [Issue 44](https://github.com/kangyana/daily-question/issues/44)
:::

::: tip Author
回答者: [kangyana](https://github.com/kangyana)
:::
## 1. 垃圾回收机制 Garbage Collection
创建一个基本类型、对象、函数……都是需要占用内存的，但js会自动分配，不需要显式手动的去分配内存。
js 也会自动回收，不需要手动的去回收。

## 2. GC 策略
在 JS 内存管理中有一个概念叫做 **可达性**，就是那些以某种方式可访问或者说可用的值，它们被保证存储在内存中，反之不可访问则需回收。
至于如何回收，其实就是怎样发现这些不可达的垃圾它并给予清理的问题， JS 定期找出用不到的内存并释放。

回收流程就涉及到了一些算法策略：

::: tip Author
回答者: [kangyana](https://github.com/kangyana)
:::
## 3. 标记清除算
标记清除（Mark-Sweep），大多数浏览器的 JS 都在采用标记清除算法。
此算法分为 **标记** 和 **清除** 两个阶段，标记阶段即为所有活动对象做上标记，清除阶段则把没有标记销毁。
引擎在执行 GC 时，需要从出发点去遍历内存中所有的对象去打标。

### 标记清除算法的流程：

- GC 在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0
- 然后从各个根对象开始遍历，把不是垃圾的节点改成1
- 清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间
- 最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收

### 优点：
简单，打标识只用二进制位（0和1）

### 缺点：

清除之后，剩余的对象内存位置是不变的，会导致空闲内存空间是不连续的，出现了 `内存碎片` （如下图）

![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12247ac3d8f249a5ab85b9b40ba1147b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

这就牵扯出了内存分配的问题，新建对象分配内存时候，要找到尺寸符合的空块才能插入。

![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb5107f04a3249ce8d37ec7cc5fd9668~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

## 4. 引用计数算法
引用计数（Reference Counting），这其实是早先的一种垃圾回收算法，它把 对象是否不再需要 简化定义为 对象有没有其他对象引用到它，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收，目前很少使用这种算法了，因为它的问题很多，不过我们还是需要了解一下。

### 它的策略是跟踪记录每个变量值被使用的次数：

- 当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1
- 如果同一个值又被赋给另一个变量，那么引用数加 1
- 如果该变量的值被其他的值覆盖了，则引用次数减 1
- 当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存

```javascript
let a = new Object() 	// 此对象的引用计数为 1（a引用）
let b = a 		// 此对象的引用计数是 2（a,b引用）
a = null  		// 此对象的引用计数为 1（b引用）
b = null 	 	// 此对象的引用计数为 0（无引用）
```

当两个对象互相引用时，假如被多次调用，那么就会造成大量的内存不会被释放
```javascript
function test(){
  let A = new Object()
  let B = new Object()
  
  A.b = B
  B.a = A
}
```

### 优点：
结构清晰，引用值为 0 时，也就是在变成垃圾的那一刻就会被回收，所以它可以立即回收垃圾。
而标记清除算法需要每隔一段时间进行一次，那在应用程序（JS脚本）运行过程中线程就必须要暂停去执行一段时间的 GC，另外，标记清除算法需要遍历堆里的活动以及非活动对象来清除，而引用计数则只需要在引用时计数就可以了。

### 缺点：
首先它需要一个计数器，而此计数器需要占很大的位置，因为我们也不知道被引用数量的上限。
还有就是无法解决循环引用无法回收的问题，这也是最严重的。

## 5. V8对GC的优化

### 分代式垃圾回收：
分代式机制把一些新、小、存活时间短的对象作为新生代，采用一小块内存频率较高的快速清理，而一些大、老、存活时间长的对象作为老生代，使其很少接受检查，新老生代的回收机制及频率是不同的，可以说此机制的出现很大程度提高了垃圾回收机制的效率。

**新生代** 的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1～8M 的容量。
**老生代** 的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大。
V8 整个堆内存的大小就等于新生代加上老生代的内存（如下图）

![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abae5b06648a40d2aaa453b5d8a83939~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

### 新生代垃圾回收
新生代对象是通过一个名为 Scavenge 的算法进行垃圾回收，在 Scavenge算法 的具体实现中，主要采用了一种复制式的方法即 Cheney算法。

Cheney算法 中将堆内存一分为二，一个是处于使用状态的空间我们暂且称之为 使用区，一个是处于闲置状态的空间我们称之为 空闲区，如下图所示

![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa2d5ad1d89b4b7b919f20e4a5f8973a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作。

当开始进行垃圾回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记完成之后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段，即将非活动对象占用的空间清理掉。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区。

当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理。

另外还有一种情况，如果复制一个对象到空闲区时，空闲区空间占用超过了 25%，那么这个对象会被直接晋升到老生代空间中，设置为 25% 的比例的原因是，当完成 Scavenge 回收后，空闲区将翻转成使用区，继续进行对象内存的分配，若占比过大，将会影响后续内存分配。

### 老生代垃圾回收
相比于新生代，老生代的垃圾回收就比较容易理解了，上面我们说过，对于大多数占用空间大、存活时间长的对象会被分配到老生代里，因为老生代中的对象通常比较大，如果再如新生代一般分区然后复制来复制去就会非常耗时，从而导致回收执行效率不高，所以老生代垃圾回收器来管理其垃圾回收执行，它的整个流程就采用的就是上文所说的标记清除算法了。

首先是标记阶段，从一组根元素开始，递归遍历这组根元素，遍历过程中能到达的元素称为活动对象，没有到达的元素就可以判断为非活动对象。

清除阶段老生代垃圾回收器会直接将非活动对象，也就是数据清理掉。

前面我们也提过，标记清除算法在清除后会产生大量不连续的内存碎片，过多的碎片会导致大对象无法分配到足够的连续内存，而 V8 中就采用了我们上文中说的标记整理算法来解决这一问题来优化空间。
::: tip Author
回答者: [kangyana](https://github.com/kangyana)
:::
## 6. 内存泄露
虽然js引擎有内存回收，v8也做出了优化。
我们的代码中依然要主动避免一些不利于引擎做垃圾回收操作，因为不是所有无用对象内存都可以被回收的，那当不再用到的内存，没有及时回收时，我们叫它 `内存泄漏`（Memory leak）。

### 不正当的闭包
```javascript
function fn2(){
  let test = new Array(1000).fill('isboyjc')
  return function(){
    console.log(test)
    return test
  }
}
let fn2Child = fn2()
fn2Child()

// 解决方案：
fn2Child = null
```

### 额外的全局变量
```javascript
function fn(){
  // 没有声明从而制造了隐式全局变量test1
  test1 = new Array(1000).fill('isboyjc1')
  
  // 函数内部this指向window，制造了隐式全局变量test2
  this.test2 = new Array(1000).fill('isboyjc2')
}
fn()
```

### 游离DOM引用
```javascript
let root = document.querySelector('#root')
let ul = document.querySelector('#ul')
let li3 = document.querySelector('#li3')

// 由于ul变量存在，整个ul及其子元素都不能GC
root.removeChild(ul)

// 虽置空了ul变量，但由于li3变量引用ul的子节点，所以ul元素依然不能被GC
ul = null

// 已无变量引用，此时可以GC
li3 = null
```

### 遗忘的定时器
```javascript
// 获取数据
let someResource = getData()
setInterval(() => {
  const node = document.getElementById('Node')
	if(node) {
    node.innerHTML = JSON.stringify(someResource))
	}
}, 1000)
```

### 遗忘的事件监听器
```javascript
window.addEventListener("resize", function() {})
```

### 遗忘的Map、Set对象
当使用 `Map` 或 `Set` 存储对象时，同 `Object` 一致都是强引用，如果不将其主动清除引用，其同样会造成内存不自动进行回收。

### 未清理的console输出

## 7. 内存膨胀
在短时间内内存占用极速上升到达一个峰值，想要避免需要使用技术手段减少对内存的占用。

## 8. 频繁 GC
GC 执行的特别频繁，一般出现在频繁使用大的临时变量导致新生代空间被装满的速度极快，而每次新生代装满时就会触发 GC，频繁 GC 同样会导致页面卡顿，想要避免的话就不要搞太多的临时变量，因为临时变量不用了就会被回收。
