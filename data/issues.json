{"javascript":[{"number":1,"title":"【Q001】js 有几种基本的数据类型","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/1","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"### 6种基本数据类型。\r\n\r\n- String 字符串\r\n- Number 数字\r\n- Boolean 布尔值\r\n- Null 空\r\n- Undefined 未定义\r\n- Symbol （es6新增）\r\n\r\n### 5种引用数据\r\n\r\n- Object 对象\r\n- Array 数组\r\n- Function 函数\r\n- RegExp 正则\r\n- Date 日期"}]},{"number":2,"title":"【Q002】如何判断 js 数据类型","labels":["javascript"],"body":"基础类型和复杂类型","url":"https://github.com/kangyana/daily-question/issues/2","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"### typeof用于判断基本数据类型，无法区分object、array、null\r\n```javascript\r\n    typeof 1 // 'number'\r\n    typeof \"1\" // 'string'\r\n    typeof undefined // 'undefined'\r\n    \r\n    typeof null // 'object'\r\n    typeof [] // 'object'\r\n    typeof {} // 'object'\r\n    typeof function() {} // 'function'\r\n```\r\n\r\n### 区分object和array，可以使用`Array.isArray()`\r\n```javascript\r\n    Array.isArray([1, 2, 3]); // true\r\n    Array.isArray({foo: 123}); // false\r\n    Array.isArray(\"foobar\"); // false\r\n    Array.isArray(undefined); // false\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"一条友善的评论"}]},{"number":3,"title":"【Q003】typeof和instanceof的区别","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/3","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 一、typeof\r\n`typeof`操作符返回一个字符串，表示未经计算的操作数的类型。\r\n\r\n语法：\r\n```javascript\r\ntypeof operand\r\n```\r\n\r\n|类型 | 结果 |\r\n| ---- | ---- |\r\n| undefined | `\"undefined\"` |\r\n| boolean | `\"boolean\"` |\r\n| string | `\"string\"` |\r\n| symbol | `\"symbol\"` |\r\n| bigInt | `\"bigint\"` |\r\n| function | `\"function\"` |\r\n| object \\| array \\| null | `\"object\"` |\r\n\r\n由上表可得知，`typeof`是无法区分`object` | `array` | `null`类型的。\r\n\r\n## 二、instanceof\r\n`instanceof` 运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。\r\n\r\n语法：\r\n```javascript\r\nobject instanceof constructor\r\n```\r\n\r\n只能用于构造函数，无法用于基础类型。\r\n\r\n## 三、总结区别\r\n`typeof`与`instanceof`都是判断数据类型的方法，区别如下：\r\n\r\n- `typeof`会返回一个变量的基本类型，instanceof返回的是一个布尔值。\r\n- `instanceof` 可以准确地判断复杂引用数据类型，但是无法判断基本类型。\r\n- `typeof`无法判断除了`function`外的引用类型。\r\n"}]},{"number":4,"title":"【Q004】如何判断一个变量是不是Array","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/4","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. instanceof 判断\r\n```javascript\r\nvar arr = [1,2,3];\r\narr instanceof Array; // true\r\narr instanceof Object; // false\r\n\r\nvar obj = {id:1};\r\nobj instanceof Array; // false\r\nobj instanceof Object; // true\r\n```\r\n\r\n## 2. 构造函数 判断\r\n```javascript\r\nvar arr = [1,2,3];\r\narr.__proto__.constructor === Array; //  true\r\n\r\nvar obj = {id:1};\r\nobj.__proto__.constructor === Object; // true\r\n```\r\n\r\n## 3. toString() 判断\r\n```javascript\r\nvar arr = [1,2,3];\r\nObject.prototype.toString.call(arr);  // [object Array]\r\n\r\nvar obj = {id:1};\r\nObject.prototype.toString.call(obj); // [object Object]\r\n```\r\n\r\n## 4. Array.isArray() 判断\r\n```javascript\r\nvar arr = [1,2,3];\r\nArray.isArray(arr); //  true\r\n\r\nvar obj = {id:1};\r\nArray.isArray(obj); // false\r\n```"}]},{"number":5,"title":"【Q005】==和===有什么不同","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/5","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. ==\r\n等于运算符 `==` 检查其两个操作数是否相等，并返回 `Boolean` 结果。\r\n同时会尝试强制类型转换。\r\n\r\n隐式转换：\r\n`string` 和 `number` 比较时，会自动转换为 `number` 类型。\r\n\r\n## 2. ===\r\n全等运算符 `===` 检查其两个操作数是否相等，并返回 `Boolean` 结果。\r\n它总是认为不同类型的操作数是不同的。\r\n\r\n## 3. 区别\r\n\r\n- `==` 不会比较数据类型，`===` 会检查类型\r\n- `==`会隐式转换"}]},{"number":6,"title":"【Q006】事件机制","labels":["javascript"],"body":"事件循环","url":"https://github.com/kangyana/daily-question/issues/6","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"JavaScript 有一个基于 **事件循环** 的并发模型，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。\r\n\r\n## 1. 可视化描述\r\n![Alt](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop/the_javascript_runtime_environment_example.svg)\r\n\r\n## 2. 栈（stack)\r\n栈是由多个 **函数调用** 形成的 **帧** 组成\r\n\r\n```javascript\r\nfunction foo(b) {\r\n  let a = 10;\r\n  return a + b + 11;\r\n}\r\n\r\nfunction bar(x) {\r\n  let y = 3;\r\n  return foo(x * y);\r\n}\r\n\r\nconsole.log(bar(7)); // 42\r\n```\r\n\r\n当调用 `bar` 时，第一个帧被创建并压入栈中，帧中包含了 `bar` 的参数和局部变量。\r\n当 `bar` 调用 `foo` 时，第二个帧被创建并被压入栈中，放在第一个帧之上，帧中包含 `foo` 的参数和局部变量。\r\n当 `foo` 执行完毕然后返回时，第二个帧就被弹出栈（剩下 `bar` 函数的调用帧 ）。\r\n当 `bar` 也执行完毕然后返回时，第一个帧也被弹出，栈就被清空了。\r\n\r\n## 3. 堆（heap）\r\n堆是放 **object** 的 **内存区域**\r\n\r\n## 4. 队列（queue）\r\n队列是 **待处理消息的消息队列**，每一个消息都关联着一个用以处理这个消息的回调函数。\r\n\r\n在 **事件循环** 期间的某个时刻，运行时会从最先进入队列的消息开始处理队列中的消息。\r\n被处理的消息会被移出队列，并作为输入参数来调用与之关联的函数。\r\n正如前面所提到的，调用一个函数总是会为其创造一个新的栈帧。\r\n\r\n函数的处理会一直进行到执行栈再次为空为止；然后事件循环将会处理队列中的下一个消息。\r\n\r\n## 5. 事件循环（event loop）\r\n之所以称之为 **事件循环**，是因为它经常按照类似如下的方式来被实现：\r\n\r\n```javascript\r\nwhile (queue.waitForMessage()) {\r\n  queue.processNextMessage();\r\n}\r\n```\r\n\r\n`queue.waitForMessage()` 会同步地等待消息到达 "}]},{"number":7,"title":"【Q007】事件委托","labels":["javascript"],"body":"事件流、事件冒泡","url":"https://github.com/kangyana/daily-question/issues/7","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 事件委托\r\n将事件侦听器添加到一个父级元素上。\r\n这样就只用添加一次事件侦听器，可以避免向很多 DOM 节点添加多个事件侦听器。\r\n\r\n## 2. 事件冒泡\r\n事件委托的实现是利用 **事件冒泡** 的机制。\r\n事件流：事件的触发会从最底层的 DOM 元素开始发生，一直向上传播，直到 document 对象。\r\n\r\n## 3. 优点\r\n\r\n- 减少了内存消耗，优化程序性能\r\n- 动态绑定事件，减少重复工作"}]},{"number":8,"title":"【Q008】e.preventDefault()是干什么的","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/8","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"- **e.preventDefault()** 取消默认事件\r\n- **e.stopPropagation()** 防止冒泡和捕获 \r\n"}]},{"number":9,"title":"【Q009】JS中this是如何工作的","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/9","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"**this** 永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。\r\n\r\n## 1. 全局环境中\r\n`this` 指向全局对象\r\n\r\n```javascript\r\n// 在浏览器中\r\nconsole.log(this === window); // true\r\n\r\n// 在 Node 中\r\nconsole.log(this === globalThis); // true\r\n```\r\n## 2. 函数内部\r\n`this` 的值取决于函数被调用的方式。\r\n\r\n非严格模式下，`this` 的值默认指向全局对象\r\n```javascript\r\nfunction f1(){\r\n  return this;\r\n}\r\n\r\nf1() === window;   // true\r\n```\r\n\r\n严格模式下，如果进入执行环境时没有设置 `this` 的值，`this` 会保持为 `undefined`\r\n```javascript\r\nfunction f2(){\r\n  \"use strict\";\r\n  return this;\r\n}\r\n\r\nf2() === undefined; // true\r\n```\r\n\r\n如果要想把 `this` 的值从一个环境传到另一个，就要用 `call` 或者 `apply` 方法\r\n\r\n## 3. 类内部\r\n`this` 在 `类` 中的表现与在函数中类似，因为类本质上也是函数，但也有一些区别和注意事项\r\n\r\n在类的构造函数中，this 是一个常规对象。类中所有 **非静态的方法** 都会被添加到 `this` 的原型中\r\n```javascript\r\nclass Example {\r\n  constructor() {\r\n    const proto = Object.getPrototypeOf(this);\r\n    console.log(Object.getOwnPropertyNames(proto));\r\n  }\r\n  first(){}\r\n  second(){}\r\n  static third(){}\r\n}\r\n\r\nnew Example(); // ['constructor', 'first', 'second']\r\n```\r\n## 4. 派生类内部\r\n派生类的构造函数没有初始的 `this` 绑定，在调用 super() 之前引用 `this` 会报错\r\n\r\n## 5. bind()后\r\n`this` 的值指向绑定的参数\r\n```javascript\r\nfunction f(){\r\n  return this.a;\r\n}\r\n\r\nvar g = f.bind({a:\"azerty\"});\r\nconsole.log(g()); // azerty\r\n```\r\n\r\n## 6. 箭头函数内部\r\n`this` 的值指向外部环境，相当于传递了 `this`"}]},{"number":10,"title":"【Q010】apply、call、bind的区别，及源码实现","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/10","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. apply()\r\n`apply()` 方法调用一个具有给定 `this` 值的函数，以及以一个数组的形式提供的参数\r\n```javascript\r\nconst numbers = [5, 6, 2, 3, 7];\r\n\r\nconst max = Math.max.apply(null, numbers); // 7\r\n```\r\n\r\n源码实现\r\n```javascript\r\nFunction.prototype.myApply = function (context, args) {\r\n    context = context || window;\r\n    let fn = Symbol();\r\n    context[fn] = this;\r\n    return context[fn](...args);\r\n}\r\n```\r\n\r\n## 2. call()\r\n`call` 方法使用一个指定的 `this` 值和单独给出的一个或多个参数来调用一个函数\r\n\r\n可以用来实现 **继承**\r\n```javascript\r\nfunction Product(name, price) {\r\n  this.name = name;\r\n  this.price = price;\r\n}\r\n\r\nfunction Food(name, price) {\r\n  Product.call(this, name, price);\r\n  this.category = 'food';\r\n}\r\n\r\nconsole.log(new Food('cheese', 5).name); // cheese\r\n```\r\n\r\n源码实现，与apply区别只有参数变化\r\n```javascript\r\nFunction.prototype.myCall = function (context, ...args) {\r\n    context = context || window;\r\n    let fn = Symbol();\r\n    context[fn] = this;\r\n    return context[fn](...args);\r\n}\r\n```\r\n\r\n## 3. bind()\r\n`bind()` 方法创建一个新的函数，在 ·bind()· 被调用时，这个新函数的 this 被指定为 `bind()` 的第一个参数，而其余参数将作为新函数的参数\r\n\r\n```javascript\r\nconst module = {\r\n  x: 42,\r\n  getX: function() {\r\n    return this.x;\r\n  }\r\n};\r\n\r\nconst unboundGetX = module.getX;\r\nconsole.log(unboundGetX()); // undefined（函数内this指向全局）\r\n\r\nconst boundGetX = unboundGetX.bind(module);\r\nconsole.log(boundGetX()); // 42\r\n```\r\n\r\n源码实现\r\n```javascript\r\n\r\nFunction.prototype.myBind = function (context) {\r\n    const self = this\r\n    const args = Array.from(arguments).slice(1)\r\n \r\n    return function F() {\r\n        const newArgs = args.concat([...arguments])\r\n        if (this instanceof F) {\r\n            return new self(...newArgs)\r\n        } else {\r\n            return self.apply(context, newArgs)\r\n        }\r\n    }\r\n```\r\n\r\n## 4. 区别\r\n\r\n- `apply` 与 `call` 非常相似，`call` 接受一个参数列表，而 `apply` 接受一个参数的单数组\r\n- `call`、`apply` 是直接调用，`bind` 是返回某个函数，等待某个状态触发再执行\r\n\r\n"}]},{"number":11,"title":"【Q011】js中new关键字原理","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/11","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## new原理\r\n`new` 操作符用来创建构造函数的实例，以这种方式调用构造函数会执行如下操作：\r\n\r\n- 在内存中创建一个新对象；\r\n- 这个对象内部的[[Prototype]]特性被复制为构造函数的prototype属性;\r\n- 构造函数内部的this被复制为这个新对象（即this指向新对象）；\r\n- 执行构造函数内部的代码（给新对象添加属性）；\r\n- 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新实例。\r\n\r\n## 代码实现\r\n\r\n1. 使用Object.create继承prototype属性\r\n```javascript\r\nfunction myNew (constructor, ...args) {\r\n    var obj = Object.create(constructor.prototype);\r\n    var result = constructor.apply(obj, args);\r\n    return typeof result === 'object' ? result : obj;\r\n}\r\n```\r\n\r\n2. 重写新对象的__proto__属性\r\n```javascript\r\nfunction myNew (constructor, ...args) {\r\n    var obj = new Object();\r\n    obj.__proto__  = constructor.prototype;\r\n    var result = constructor.apply(obj, args);\r\n    return typeof result === 'object' ? result : obj;\r\n}\r\n```"}]},{"number":12,"title":"【Q012】JS 中继承是如何实现的","labels":["javascript"],"body":"7种方法","url":"https://github.com/kangyana/daily-question/issues/12","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 原型链\r\n让一个 **构造函数** 的原型是另一个类型的实例，`new` 出来的实例\r\n```javascript\r\nfunction Person () {\r\n  this.name = 'zs';\r\n}\r\n\r\nfunction Man () {};\r\nMan.prototype = new Person();\r\n\r\nnew Man().name // 'zs'\r\n```\r\n\r\n优点：写法方便简洁，容易理解\r\n缺点：对象实例共享所有继承的属性和方法。传教子类型实例的时候，不能传递参数，因为这个对象是一次性创建的（没办法定制化）\r\n\r\n## 2. 借用构造函数继承\r\n在子类型构造函数的内部调用父类型构造函数；使用 apply() 或 call() 方法将父对象的构造函数绑定在子对象上\r\n```javascript\r\nfunction Person (name) {\r\n  this.name = name;\r\n}\r\n\r\nfunction Man (name) {\r\n  Person.call(this, name)\r\n};\r\n```\r\n\r\n优点：解决了原型链实现继承的不能传参的问题和父类的原型共享的问题\r\n缺点：借用构造函数的缺点是方法都在构造函数中定义，因此无法实现函数复用。在父类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式\r\n\r\n## 3. 组合继承（经典继承）\r\n将 `原型链` 和 `借用构造函数` 的组合到一块。\r\n使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。\r\n\r\n```javascript\r\nfunction Person (name) {\r\n  this.name = name;\r\n}\r\nPerson.prototype.sayName = function () {\r\n  console.log('My name is ' + this.name);\r\n}\r\n\r\nfunction Man (name) {\r\n  Person.call(this, name)\r\n};\r\nMan.prototype = new Person();\r\n\r\nnew Man('zs').sayName  // 'My name is zs'\r\n```\r\n\r\n优点: 解决了原型链继承和借用构造函数继承造成的影响\r\n缺点: 无论在什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部\r\n\r\n## 4. 原型式继承\r\n创建一个新对象，挂到新建对象的原型上\r\n```javascript\r\nfunction Person () {\r\n  this.name = 'zs';\r\n}\r\n\r\nvar man = Object.create(Person);\r\n\r\nman.name // 'zs'\r\n```\r\n优点是：不需要单独创建构造函数\r\n缺点是：属性中包含的引用值始终会在相关对象间共享，子类实例不能向父类传参\r\n\r\n## 5. 寄生式继承\r\n寄生式继承的思路与(寄生) `原型式继承` 和 `工厂模式` 似, 即创建一个仅用于封装继承过程的函数,该函数在内部以某种方式来增强对象,最后再像真的是它做了所有工作一样返回对象\r\n\r\n```javascrip\r\nfunction objectCopy(obj) {\r\n  function Fun() { };\r\n  Fun.prototype = obj;\r\n  return new Fun();\r\n}\r\n\r\nfunction createAnother(obj) {\r\n  let clone = objectCopy(obj);\r\n  clone.sayName = function () {\r\n    console.log('My name is ' + this.name);\r\n  };\r\n  return clone;\r\n}\r\n\r\nvar person = { name: 'zs' };\r\n\r\ncreateAnother(person).sayName(); // 'My name is zs'\r\n```\r\n\r\n优点：写法简单，不需要单独创建构造函数\r\n缺点：通过寄生式继承给对象添加函数会导致函数难以复用\r\n\r\n## 6. 寄生组合式继承\r\n通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型\r\n\r\n```javascript\r\n// ...\r\nfunction inheritPrototype(child, parent) {\r\n  let prototype = objectCopy(parent.prototype);\r\n  prototype.constructor = child;\r\n  Child.prototype = prototype;\r\n}\r\n```\r\n优点是：高效率只调用一次父构造函数，并且因此避免了在子原型上面创建不必要，多余的属性。与此同时，原型链还能保持不变\r\n缺点是：代码复杂\r\n\r\n# 7. Class实现继承\r\n优点：语法简单易懂,操作更方便\r\n缺点：并不是所有的浏览器都支持class关键字\r\n"}]},{"number":13,"title":"【Q013】JS 原型和原型链","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/13","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 原型\r\n每个函数都有一个特殊的属性叫作 `原型（prototype）`\r\n每个对象都有一个属性叫作 `__proto__`，这个属性会指向该对象的原型\r\n每个原型都有一个 `constructor` 属性指向关联的构造函数\r\n\r\n## 2. 原型链\r\n当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止\r\n这种原型组成的链状结构就是 `原型链`"}]},{"number":14,"title":"【Q014】闭包与作用域链","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/14","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 作用域\r\n`作用域` 是指程序源代码中 **定义变量** 的区域\r\n作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限\r\n\r\n## 2. 作用域链\r\n当访问一个变量时，解释器会首先在当前作用域查找，如果没有找到，就去父作用域找，直到找到该变量或者不在父作用域中，这就是 `作用域链`\r\n\r\n## 3. 闭包\r\n`闭包` 是指有权访问另外一个函数作用域中的变量的 `函数`\r\n闭包是将函数内部和函数外部连接起来的桥梁\r\n\r\n优点：\r\n\r\n- 闭包里的变量不会污染全局，因为变量被封在闭包里\r\n- 所有变量都在闭包里保证了隐私性和私有性\r\n- 可以让这些局部变量保存在内存中，实现变量数据共享\r\n\r\n缺点：\r\n形成闭包即要把一个函数当成值传递，而且该函数还引用这另一个函数的作用域链使得被引用的函数不能被回收，使用不当容易造成内存泄漏\r\n"}]},{"number":15,"title":"【Q015】let、const、var的区别","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/15","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. var\r\n`var` 语句 用于声明一个函数范围或全局范围的变量，并可将其初始化为一个值（可选）。\r\n\r\n用 `var` 声明的变量的作用域是它当前的执行上下文及其闭包（嵌套函数），或者对于声明在任何函数外的变量来说是全局。\r\n`var` 声明的变量，会提升到该作用域的最顶部。\r\n\r\n## 2. let\r\n`let` 语句声明一个块级作用域的局部变量，并可以初始化为一个值（可选）。\r\n\r\n与 `var` 关键字不同的是，`var` 声明的变量作用域是全局或者整个函数块的。\r\n`var` 和 `let` 的另一个重要区别，`let` 声明的变量不会在作用域中被提升，它是在编译时才初始化。\r\n\r\n## 3. const\r\n常量是块级范围的，非常类似用 `let`。但常量的值是无法（通过重新赋值）改变的，也不能被重新声明。\r\n\r\n`const` 声明创建一个值的只读引用。变量标识符不能重新分配，但改变对象的内容。\r\n\r\n## 4. 区别\r\n\r\n- `var` 在全局作用域声明的变量会变成全局变量，例如浏览器环境下挂载在window对象上。`var`和 `let` 不会。\r\n- `var`和 `let` 声明的变量可以重新赋值，`const` 声明的变量只能改变对象的内容。\r\n"}]},{"number":16,"title":"【Q016】JS 中变量声明提升","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/16","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 变量提升\r\n`var` 声明的 **变量** 和 **函数声明** ，会在代码执行前移动到全局代码的开头位置。\r\n```javascript\r\nbla = 2\r\nvar bla;\r\n\r\n// 可以隐式地（implicitly）将以上代码理解为：\r\n\r\nvar bla;\r\nbla = 2;\r\n```\r\n\r\n因此，建议始终在作用域顶部声明变量（全局代码的顶部和函数代码的顶部），这可以清楚知道哪些变量是函数作用域，哪些变量在作用域链上解决。\r\n\r\n重要的是，提升将影响变量声明，而不会影响其值的初始化。仅在运行到赋值语句时初始化变量的值。在此之前，变量的值始终为 `undefined` 。\r\n```javascript\r\nfunction do_something() {\r\n  console.log(bar); // undefined\r\n  var bar = 111;\r\n  console.log(bar); // 111\r\n}\r\n\r\n// 可以隐式地将以上代码理解为：\r\n\r\nfunction do_something() {\r\n  var bar;\r\n  console.log(bar); // undefined\r\n  bar = 111;\r\n  console.log(bar); // 111\r\n}\r\n```"}]},{"number":17,"title":"【Q017】JS 模块化","labels":["javascript"],"body":"理解模块化发展过程，理解 CommonJS，AMD，CMD，UMD，ES6 模块化","url":"https://github.com/kangyana/daily-question/issues/17","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 原生js的模块化\r\n原生js有几个问题：\r\n\r\n- 代码复用\r\n- 全局作用域污染\r\n- 可维护性\r\n\r\n为了解决这些问题，出现了 `命名空间`  和 `匿名闭包 IIFE 模式`，对代码进行封装，并通过提供外部方法来对它们进行访问。\r\n```javascript\r\n// 命名空间\r\nvar namespace = {}\r\nnamespace.add = function(a, b) {\r\n    console.log(a + b)\r\n}\r\nnamespace.add(1, 2)\r\n\r\n// IIEF\r\nvar utils = (function() {\r\n    var module = {}\r\n    module.multiply = function(a, b) {\r\n        console.log(a * b)\r\n    }\r\n    return module\r\n}())\r\nutils.multiply(1,2)\r\n```\r\n\r\n## 2. CommonJS\r\n09年 `CommonJS`（或者称作 CJS）规范推出，在 **NodeJS** 中实现。主要方法是 **exports** 和 **require**。\r\n```javascript\r\n// utils.js 文件\r\nfunction add(a, b) {\r\n    console.log(a + b)\r\n}\r\nmodule.exports.add = add\r\n\r\n// main.js 文件\r\nvar add = require('./utils').add\r\nadd(1, 2)\r\n```\r\n`CJS` 出来以后，服务端的模块概念已经形成，很自然地，大家就想要客户端模块。\r\n但是 `CJS` 是同步的，服务端读取本地硬盘可以很快同步加载完成，但是浏览器同步读取服务器端的模块可能需要很长的时间，浏览器将会处于”假死”状态。\r\n所以出现异步加载 js 文件的 AMD。\r\n\r\n## 3. AMD\r\n`AMD` 是异步模块定义（Asynchronous Module Definition）。\r\n它采用异步方式加载模块，模块的加载不影响它后面语句的运行。\r\n所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。\r\n\r\n```javascript\r\n// utils.js 文件\r\ndefine([], function() {\r\n    return {\r\n        add: function(a, b) {\r\n            console.log(a + b)\r\n        }\r\n    }\r\n})\r\n\r\n// main.js 文件\r\nrequire(['./utils'], function(utils) {\r\n    utils.add(1, 2)\r\n})\r\n```\r\n\r\n由于原生js不支持，使用 `AMD` 规范进行开发需要用到对应的库函数：`RequireJS`。\r\n`requireJS` 主要解决两个问题：\r\n\r\n- 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器\r\n- js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长\r\n\r\n## 4. CMD\r\n\r\n`CMD`（Common Module Definition）是玉伯在开发 `SeaJS` 的时候提出来的，`SeaJS` 要解决的问题和 `RequireJS` 一样。\r\n不同于 AMD 的依赖前置，CMD 是就近依赖。\r\n\r\n```javascript\r\n// AMD\r\nrequire(['./utils', 'a', 'b'], function(utils) {\r\n    console.log(1)\r\n    // 还没有用到 utils a b 等模块，但是 AMD 已经初始化了所有模块\r\n    console.log(2)\r\n    utils.add(1, 2)\r\n})\r\n\r\n// CMD\r\ndefine(function(require, exports, module){\r\n    console.log(1)\r\n    if(false) {\r\n        var utils = require('./utils') // 需要时再 require，不执行就不会加载\r\n        utils.add(1, 2)\r\n    }\r\n})\r\n```\r\n\r\n但是在 `AMD` 也是支持依赖就近，也就是 `CMD` 这样的写法的，所以，`RequireJS` 中，以上两种方式都能执行。\r\n不过，`RequireJS` 官方文档中，默认都是采用依赖前置的写法。\r\n\r\n## 5. UMD\r\n`UMD` 通用模块定义（Universal Module Definition），同时兼容服务端（CJS）和客户端（AMD）的模块化。\r\n\r\n```javascript\r\n// utils.js 文件同上\r\n(function(root, factory) {\r\n    if (typeof define === 'function' && define.amd) {\r\n        //AMD\r\n        define(['utils'], factory)\r\n    } else if (typeof exports === 'object') {\r\n        //CommonJS\r\n        var utils = require('utils')\r\n        module.exports = factory(utils)\r\n    } else {\r\n        root.result = factory(root.utils)\r\n    }\r\n}(this, function(utils) {\r\n    utils.add(1, 2)\r\n}))\r\n```\r\n\r\n## 6. ES6 模块化\r\n`ES6`（ES2015）自带的模块化，使用 **import** 和 **export** 关键字来导入和导出模块。\r\n\r\n```javascript\r\n// utils.js 文件\r\nexport const utils = {\r\n    add: function(a, b) {\r\n        console.log(a + b)\r\n    }\r\n}\r\n\r\n// main.js 文件\r\nimport { utils } from \"./utils\"\r\nutils.add(1, 2)\r\n```\r\n\r\n## 7. CommonJS 和 ES6 的区别\r\n`CommonJS` 模块输出的是一个值的拷贝，`ES6` 模块输出的是值的引用。\r\n`CommonJS` 模块是运行时加载，`ES6` 模块是编译时输出接口。"}]},{"number":18,"title":"【Q018】IIFE 立即执行函数","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/18","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. IIFE 立即调用函数表达式\r\n`IIFE` (Immediately Invoked Function Expression)是一个在定义时就会立即执行的函数。\r\n\r\n```javascript\r\n(function () {\r\n    // to something...\r\n})();\r\n```\r\n这是一个被称为 **自执行匿名函数** 的设计模式，主要包含两部分。\r\n第一部分是包围在 **圆括号运算符** 里的一个匿名函数，这个匿名函数拥有独立的词法作用域。\r\n这不仅避免了外界访问此 `IIFE` 中的变量，而且又不会污染全局作用域。\r\n\r\n## 2. IIFE 的优点\r\n\r\n- `IIFE` 中定义的任何变量和函数，都会在执行结束时被销毁。适合做初始化工作。\r\n- 创建 **块级作用域** ，避免了向全局作用域中添加变量和函数，因此也避免了多人开发中全局变量和函数的命名冲突。\r\n- `IIFE` 中定义的任何变量和函数，都会在执行结束时被销毁。这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了。"}]},{"number":19,"title":"【Q019】匿名函数","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/19","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 什么是匿名函数\r\n\r\n- `匿名函数`，即没有名称的函数\r\n- 如果单独只写一个匿名函数，此时是不符合语法要求的会报错。需要给 `匿名函数` 包裹一个括号，使之成为 **表达式**\r\n- 被小括号包裹的内容会被js识别为一个函数表达式\r\n\r\n## 2. 创建方式\r\n\r\n```javascript\r\n(function () {\r\n      // to something...\r\n}());\r\n```\r\n"}]},{"number":20,"title":"【Q020】箭头函数","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/20","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 箭头函数\r\n`箭头函数表达式` 的语法比 `函数表达式` 更简洁，并且没有自己的 this、arguments、super或new.target。\r\n`箭头函数表达式` 更适用于那些本来需要 `匿名函数` 的地方，并且它不能用作 `构造函数`。\r\n\r\n```javascript\r\nconst materials = [\r\n  'Hydrogen',\r\n  'Helium',\r\n  'Lithium',\r\n  'Beryllium'\r\n];\r\n\r\nconsole.log(materials.map(material => material.length)); // [8, 6, 7, 9]\r\n```\r\n\r\n## 更短的函数\r\n```javascript\r\nvar elements = [\r\n  'Hydrogen',\r\n  'Helium',\r\n  'Lithium',\r\n  'Beryllium'\r\n];\r\n\r\nelements.map(function(element) {\r\n  return element.length;\r\n}); // [8, 6, 7, 9]\r\n\r\n// 上面的普通函数可以改写成如下的箭头函数\r\nelements.map((element) => {\r\n  return element.length;\r\n});\r\n\r\n// 当箭头函数只有一个参数时，可以省略参数的圆括号\r\nelements.map(element => {\r\n return element.length;\r\n});\r\n\r\n// 当箭头函数的函数体只有一个 `return` 语句时，可以省略 `return` 关键字和方法体的花括号\r\nelements.map(element => element.length);\r\n```\r\n\r\n## 没有单独的this\r\n`箭头函数` 不会创建自己的this，它只会从自己的作用域链的上一层继承 `this`。\r\n```javascript\r\nfunction Person(){\r\n  this.age = 0;\r\n\r\n  setInterval(() => {\r\n    this.age++; // this 正确地指向 p 实例\r\n  }, 1000);\r\n}\r\n\r\nvar p = new Person();\r\n```\r\n\r\n## 与严格模式的关系\r\n鉴于 `this` 是词法层面上的，`严格模式` 中与 `this` 相关的规则都将被忽略。\r\n```javascript\r\nvar f = () => { 'use strict'; return this; };\r\nf() === window; // true\r\n```\r\n\r\n## 通过 call 或 apply 调用\r\n由于 `箭头函数` 没有自己的 `this` 指针，通过 call() 、apply()、bind() 方法调用一个函数时，只能传递参数，他们的第一个参数会被忽略。\r\n```javascript\r\nvar adder = {\r\n  base : 1,\r\n\r\n  add : function(a) {\r\n    var f = v => v + this.base;\r\n    return f(a);\r\n  },\r\n\r\n  addThruCall: function(a) {\r\n    var f = v => v + this.base;\r\n    var b = {\r\n      base : 2\r\n    };\r\n\r\n    return f.call(b, a);\r\n  }\r\n};\r\n\r\nconsole.log(adder.add(1));         // 输出 2\r\nconsole.log(adder.addThruCall(1)); // 仍然输出 2\r\n```\r\n\r\n## 不绑定arguments\r\n`箭头函数` 不绑定Arguments 对象。因此，在本示例中，arguments只是引用了封闭作用域内的 arguments：\r\n```javascript\r\nvar arguments = [1, 2, 3];\r\nvar arr = () => arguments[0];\r\n\r\narr(); // 1\r\n\r\nfunction foo(n) {\r\n  var f = () => arguments[0] + n; // 隐式绑定 foo 函数的 arguments 对象. arguments[0] 是 n，即传给 foo 函数的第一个参数\r\n  return f();\r\n}\r\n\r\nfoo(1); // 2\r\nfoo(2); // 4\r\nfoo(3); // 6\r\nfoo(3,2);//6\r\n```\r\n\r\n## 使用 new 操作符\r\n`箭头函数` 不能用作构造器，和 `new` 一起用会抛出错误。\r\n```javascript\r\nvar Foo = () => {};\r\nvar foo = new Foo(); // TypeError: Foo is not a constructor\r\n```\r\n\r\n## 使用prototype属性\r\n箭头函数没有 `prototype` 属性。\r\n```javascript\r\nvar Foo = () => {};\r\nconsole.log(Foo.prototype); // undefined\r\n```\r\n\r\n## 使用 yield 关键字\r\n`yield` 关键字通常不能在 `箭头函数` 中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作函数生成器。\r\n\r\n## 返回对象字面量\r\n记住用 `params => {object:literal}` 这种简单的语法 **返回对象字面量** 是行不通的。\r\n```javascript\r\nvar func = () => { foo: 1 };\r\n// Calling func() returns undefined!\r\n\r\nvar func = () => { foo: function() {} };\r\n// SyntaxError: function statement requires a name\r\n```\r\n\r\n这是因为花括号（`{}`）里面的代码被解析为一系列语句（即 `foo` 被认为是一个标签，而非对象字面量的组成部分）\r\n所以，记得用圆括号把对象字面量包起来：\r\n\r\n```javascript\r\nvar func = () => ({foo: 1});\r\n```\r\n"}]},{"number":21,"title":"【Q021】函数柯里化","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/21","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 柯里化（Currying）\r\n[柯里化（Currying）](https://en.wikipedia.org/wiki/Currying)是一种关于函数的高阶技术。它不仅被用于 JavaScript，还被用于其他编程语言。\r\n`柯里化` 是一种函数的 **转换** ，它是指将一个函数从可调用的 f(a, b, c) 转换为可调用的 f(a)(b)(c)。\r\n`柯里化` 不会调用函数，它只是对函数进行转换。\r\n\r\n```javascript\r\n// 柯里化函数\r\nfunction curry(f) {\r\n  return function(a) {\r\n    return function(b) {\r\n      return f(a, b);\r\n    };\r\n  };\r\n}\r\n\r\n// 求和函数\r\nfunction sum(a, b) {\r\n  return a + b;\r\n}\r\n\r\nconsole.log(curry(sum)(1)(2)) // 3\r\n```\r\n正如你所看到的，实现非常简单：只有两个包装器（wrapper）。\r\n\r\n- curry(func) 的结果就是一个包装器 function(a)。\r\n- 当它被像 curriedSum(1) 这样调用时，它的参数会被保存在词法环境中，然后返回一个新的包装器 function(b)。\r\n- 然后这个包装器被以 2 为参数调用，并且，它将该调用传递给原始的 sum 函数。\r\n\r\n柯里化更高级的实现，例如 lodash 库的 [_.curry](https://lodash.com/docs#curry)，会返回一个包装器，该包装器允许函数被正常调用或者以偏函数（partial）的方式调用：\r\n```javascript\r\nfunction sum(a, b) {\r\n  return a + b;\r\n}\r\n\r\nvar curriedSum = _.curry(sum); // 使用来自 lodash 库的 _.curry\r\nconsole.log(curriedSum(1, 2)); // 3，仍可正常调用\r\nconsole.log(curriedSum(1)(2)); // 3，以偏函数的方式调用\r\n```\r\n\r\n## 2. 柯里化的目的\r\n要了解它的好处，我们需要一个实际中的例子。\r\n\r\n例如，我们有一个用于格式化和输出信息的日志（logging）函数 `log(date, importance, message)`。\r\n在实际项目中，此类函数具有很多有用的功能，例如通过网络发送日志（log）：\r\n```javascript\r\nfunction log(date, importance, message) {\r\n  console.log(`[${date.getHours()}:${date.getMinutes()}] [${importance}] ${message}`);\r\n}\r\n```\r\n\r\n柯里化之后，log 仍正常运行，也可以以柯里化形式运行：\r\n```javascript\r\nlog = _.curry(log);\r\n\r\nlog(new Date(), \"DEBUG\", \"some debug\"); // log(a, b, c)\r\n\r\nlog(new Date())(\"DEBUG\")(\"some debug\"); // log(a)(b)(c)\r\n```\r\n\r\n现在可以轻松地为当前日志创建便捷函数：\r\n```javascript\r\n// logNow 会是带有固定第一个参数的日志的偏函数\r\nvar logNow = log(new Date());\r\n\r\n// 使用它\r\nlogNow(\"INFO\", \"message\"); // [HH:mm] INFO message\r\n```\r\n\r\n现在，logNow 是具有固定第一个参数的 log，换句话说，就是更简短的“偏应用函数（partially applied function）”或“偏函数（partial）”。\r\n\r\n可以更进一步，为当前的调试日志（debug log）提供便捷函数：\r\n```javascript\r\nvar debugNow = logNow(\"DEBUG\");\r\n\r\ndebugNow(\"message\"); // [HH:mm] DEBUG message\r\n```\r\n\r\n总结：\r\n\r\n- 柯里化之后，我们没有丢失任何东西：log 依然可以被正常调用。\r\n- 我们可以轻松地生成偏函数，例如用于生成今天的日志的偏函数。\r\n\r\n## 3. 柯里化的实现\r\n```javascript\r\nfunction curry(func) {\r\n  return function curried(...args) {\r\n    if (args.length >= func.length) {\r\n      return func.apply(this, args);\r\n    } else {\r\n      return function(...args2) {\r\n        return curried.apply(this, args.concat(args2));\r\n      }\r\n    }\r\n  };\r\n}\r\n```\r\n\r\n## 4. 总结\r\n\r\n- `柯里化` 是一种转换，将 f(a,b,c) 转换为可以被以 f(a)(b)(c) 的形式进行调用。JavaScript 实现通常都保持该函数可以被正常调用，并且如果参数数量不足，则返回偏函数。\r\n- `柯里化` 让我们能够更容易地获取偏函数。就像我们在日志记录示例中看到的那样，普通函数 log(date, importance, message) 在被柯里化之后，当我们调用它的时候传入一个参数（如 log(date)）或两个参数（log(date, importance)）时，它会返回偏函数。"}]},{"number":22,"title":"【Q022】Promise","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/22","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. promise\r\n`Promise` 对象用于表示一个异步操作的最终完成（或失败）及其结果值。\r\n异步方法并不会立即返回最终的值，而是会返回一个 promise，以便在未来某个时候把值交给使用者。\r\n\r\n一个 Promise 必然处于以下几种状态之一：\r\n\r\n- 待定（pending）：初始状态，既没有被兑现，也没有被拒绝。\r\n- 已兑现（fulfilled）：意味着操作成功完成。\r\n- 已拒绝（rejected）：意味着操作失败。\r\n\r\n## 2. Promise 的链式调用\r\n因为 `Promise.prototype.then`、`Promise.prototype.catch` 和 `Promise.prototype.finally`方法返回的是 promise，所以它们可以被链式调用。\r\n![Alt](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/promises.png)\r\n\r\n我们用 promise 的 `then` 方法排列起来的相关处理程序就会被调用。\r\n`.then()` 方法需要两个参数，第一个参数作为处理已兑现状态的回调函数，而第二个参数则作为处理已拒绝状态的回调函数。\r\n```javascript\r\nconst myPromise = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    resolve('foo');\r\n  }, 300);\r\n});\r\n\r\nmyPromise\r\n  .then(handleResolvedA, handleRejectedA)\r\n  .then(handleResolvedB, handleRejectedB)\r\n  .then(handleResolvedC, handleRejectedC);\r\n```\r\n\r\n当 `.then()` 中缺少能够返回 promise 对象的函数时，链式调用就直接继续进行下一环操作。\r\n因此，链式调用可以在最后一个 `.catch()` 之前把所有的处理已拒绝状态的回调函数都省略掉。\r\n```javascript\r\nmyPromise\r\n  .then(handleResolvedA)\r\n  .then(handleResolvedB)\r\n  .then(handleResolvedC)\r\n  .catch(handleRejectedAny);\r\n```\r\n\r\n## 3. finally清理\r\n如果你想在 promise 执行完毕后无论其结果怎样都做一些处理或清理时，`.finally()` 方法可能是有用的。\r\n\r\n`.finally()` 虽然与 `.then(onFinally, onFinally)` 类似，它们不同的是：\r\n\r\n- 调用内联函数时，不需要多次声明该函数或为该函数创建一个变量保存它。\r\n- 由于无法知道 promise 的最终状态，所以 finally 的回调函数中不接收任何参数，它仅用于无论最终结果如何都要执行的情况。"}]},{"number":23,"title":"【Q023】async/await","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/23","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. async 函数\r\n`async` 函数是使用 **async关键字** 声明的函数。`async` 函数是 `AsyncFunction` 构造函数的实例， 并且其中允许使用 **await关键字**。\r\n**async和await关键字** 让我们可以用一种更简洁的方式写出基于`Promise` 的异步行为，而无需刻意地链式调用 `promise`。\r\n\r\n在函数前面的 **async关键字** 做了一件事情：使用函数始终返回一个 promise。其他值将自动被包装在一个 resolved 的 promise 中。\r\n```javascript\r\nasync function f() {\r\n  return 1;\r\n}\r\n\r\nasync function f2() {\r\n  return Promise.resolve(1);\r\n}\r\n\r\nf().then(console.log); // 1\r\nf2().then(console.log); // 1\r\n```\r\n\r\n## 2. await 关键字\r\n`await` 让 JavaScript 引擎等待直到 promise 完成（settle）并返回结果。\r\n```javascript\r\nasync function f() {\r\n  var promise = new Promise((resolve, reject) => {\r\n    setTimeout(() => resolve(\"done!\"), 1000)\r\n  });\r\n\r\n  var result = await promise; // 等待，直到 promise resolve (*)\r\n  console.log(result); // \"done!\"\r\n}\r\n\r\nf();\r\n```\r\n这个函数在执行的时候，“暂停”在了` (*)` 那一行，并在 promise settle 时，拿到 `result` 作为结果继续往下执行。\r\n所以上面这段代码在一秒后显示 “done!”。\r\n\r\n强调一下：await 实际上会暂停函数的执行，直到 promise 状态变为 settled，然后以 promise 的结果继续执行。\r\n这个行为不会耗费任何 CPU 资源，因为 JavaScript 引擎可以同时处理其他任务：执行其他脚本，处理事件等。\r\n\r\n相比于 promise.then，它只是获取 promise 的结果的一个更优雅的语法，并且也更易于读写。\r\n\r\n## 3. Error 处理\r\n如果一个 promise 正常 resolve，`await promise` 返回的就是其结果。\r\n但是如果 promise 被 reject，它将 throw 这个 error，就像在这一行有一个 `throw` 语句那样。\r\n\r\n可以在函数调用后面添加 .catch 来处理这个 error：\r\n```javascript\r\nasync function f() {\r\n  var response = await fetch('http://no-such-url/');\r\n}\r\n\r\n// f() 变成了一个 rejected 的 promise\r\nf().catch(console.log); // TypeError: failed to fetch // (*)\r\n```\r\n\r\n## 4. 总结\r\n函数前面的关键字 async 有两个作用：\r\n\r\n- 让这个函数总是返回一个 promise。\r\n- 允许在该函数内使用 await。\r\n\r\nPromise 前的关键字 await 使 JavaScript 引擎等待该 promise settle，然后有两种情况：\r\n\r\n- 如果有 error，就会抛出异常 —— 就像那里调用了 throw error 一样。\r\n- 否则，就返回结果。\r\n\r\n"}]},{"number":24,"title":"【Q024】Generator","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/24","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. function* 生成器函数\r\n`function*` 这种声明方式会定义一个 **生成器函数** (generator function)，它返回一个 `Generator对象`。\r\n```javascript\r\nfunction* generator(i) {\r\n  yield i;\r\n  yield i + 10;\r\n}\r\n\r\nconst gen = generator(10);\r\nconsole.log(gen.next().value); // 10\r\nconsole.log(gen.next().value); // 20\r\n```\r\n\r\n**生成器函数** 在执行时能暂停，后面又能从暂停处继续执行。\r\n\r\n调用一个生成器函数并不会马上执行它里面的语句，而是返回一个这个生成器的 **迭代器（iterator）对象**。\r\n当这个迭代器的 `next()` 方法被调用时，其内的语句会执行到后续出现 `yield` 的位置为止，`yield` 后紧跟迭代器要返回的值。\r\n或者如果用的是 `yield*`，则表示将执行权移交给另一个生成器函数（当前生成器暂停执行）。\r\n\r\n调用 `next()` 方法时，如果传入了参数，那么这个参数会传给**上一条执行的 yield 语句左边的变量**，例如下面例子中的x：\r\n```javascript\r\nfunction *gen(){\r\n    yield 10;\r\n    x = yield 'foo';\r\n    yield x;\r\n}\r\n\r\nvar gen_obj = gen();\r\nconsole.log(gen_obj.next());// 执行 yield 10，返回 10\r\nconsole.log(gen_obj.next());// 执行 yield 'foo'，返回 'foo'\r\nconsole.log(gen_obj.next(100));// 将 100 赋给上一条 yield 'foo' 的左值，即执行 x=100，返回 100\r\nconsole.log(gen_obj.next());// 执行完毕，value 为 undefined，done 为 true\r\n\r\n```\r\n\r\nyield* 的示例：\r\n```javascript\r\nfunction* anotherGenerator(i) {\r\n  yield i + 1;\r\n  yield i + 2;\r\n  yield i + 3;\r\n}\r\n\r\nfunction* generator(i){\r\n  yield i;\r\n  yield* anotherGenerator(i);// 移交执行权\r\n  yield i + 10;\r\n}\r\n\r\nvar gen = generator(10);\r\nconsole.log(gen.next().value); // 10\r\nconsole.log(gen.next().value); // 11\r\nconsole.log(gen.next().value); // 12\r\nconsole.log(gen.next().value); // 13\r\nconsole.log(gen.next().value); // 20\r\n```\r\n\r\n## 2. Generator对象\r\n`生成器对象` 是由一个 `generator function` 返回的。\r\n```javascript\r\nfunction* gen() {\r\n  yield 1;\r\n  yield 2;\r\n  yield 3;\r\n}\r\n\r\nlet g = gen(); // \"Generator { }\"\r\n```\r\n\r\n## 3. 迭代器对象 iterator\r\n挖坑ing"}]},{"number":25,"title":"【Q025】对象遍历 和 数组遍历","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/25","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"# 一. 对象遍历\r\n## 1. for...in\r\n`for...in` 语句以任意顺序迭代一个对象的除[Symbol](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol)以外的[可枚举](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties)属性，包括继承的可枚举属性。\r\n\r\n```javascript\r\nvar obj = {a:1, b:2, c:3};\r\n\r\nfor (var prop in obj) {\r\n  console.log(\"obj.\" + prop + \" = \" + obj[prop]);\r\n}\r\n\r\n// \"obj.a = 1\"\r\n// \"obj.b = 2\"\r\n// \"obj.c = 3\"\r\n```\r\n\r\n`for...in` 还会获取到**原型链上的可枚举属性**，不过可以使用 `hasOwnProperty()` 方法过滤掉。\r\n```javascript\r\nvar triangle = {a: 1, b: 2, c: 3};\r\n\r\nfunction ColoredTriangle() {\r\n  this.color = 'red';\r\n}\r\n\r\nColoredTriangle.prototype = triangle;\r\n\r\nvar obj = new ColoredTriangle();\r\n\r\nfor (var prop in obj) {\r\n  if (obj.hasOwnProperty(prop)) {\r\n    console.log(`obj.${prop} = ${obj[prop]}`);\r\n  }\r\n}\r\n\r\n// \"obj.color = red\"\r\n```\r\n\r\n### 为什么用 for ... in?\r\n\r\n它最常用的地方应该是用于调试，可以更方便的去检查对象属性。\r\n你在处理有key-value数据，需要检查其中的任何键是否为某值的情况时，推荐用 `for...in`。\r\n\r\n## 2. for...of\r\n`for...of`语句在 **可迭代对象**（包括Array，Map，Set，String，TypedArray，arguments） 上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。\r\n\r\n如果使用 `for...of` 遍历对象，需要给对象的原型一个迭代器方法：\r\n```javascript\r\nvar obj = {\r\n    a:1,\r\n    b:2,\r\n    c:3\r\n};\r\n\r\nobj[Symbol.iterator] = function*(){\r\n    var keys = Object.keys(obj);\r\n    for(var k of keys){\r\n        yield k\r\n    }\r\n};\r\n\r\nfor(var k of obj){\r\n    console.log(k, obj[k]);\r\n}\r\n\r\n// 'a' 1\r\n// 'b' 2\r\n// 'c' 3\r\n```\r\n\r\n### for...of与for...in的区别?\r\n\r\n无论是 `for...in` 还是 `for...of` 语句都是迭代一些东西。它们之间的主要区别在于它们的迭代方式。\r\n- `for...in` 可以迭代Object。\r\n- `for...of` 可以迭代Array等其他 **可迭代对象** ，想迭代Object要给一个迭代器属性。\r\n- `for...in` 还会获取到**原型链上的可枚举属性**\r\n\r\n## 3. Object.keys()\r\n`Object.keys()` 方法会返回一个由一个给定对象的自身可枚举 **属性名（key）组成的数组**，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致。\r\n\r\n```javascript\r\nconst object1 = {\r\n  a: 'somestring',\r\n  b: 42,\r\n  c: false\r\n};\r\n\r\nconsole.log(Object.keys(object1)); //  [\"a\", \"b\", \"c\"]\r\n```\r\n注意：\r\n\r\n- 在 ES5 中，如果此方法的参数不是对象（而是一个原始值），那么它会抛出 **TypeError**。\r\n- 在 ES6 中，非对象的参数将被强制转换为一个对象。\r\n\r\n## 4. Object.getOwnPropertyNames()\r\n`Object.getOwnPropertyNames()` 方法返回一个由指定对象的所有自身属性的 **属性名（key）组成的数组**（属性名 包括不可枚举属性但不包括 `Symbol` 值作为名称的属性）。\r\n\r\n```javascript\r\n// 数组对象\r\nvar arr = [\"a\", \"b\", \"c\"];\r\nconsole.log(Object.getOwnPropertyNames(arr).sort()); // [\"0\", \"1\", \"2\", \"length\"]\r\n\r\n// 类数组对象\r\nvar obj = { 0: \"a\", 1: \"b\", 2: \"c\"};\r\nconsole.log(Object.getOwnPropertyNames(obj).sort()); // [\"0\", \"1\", \"2\"]\r\n\r\n//不可枚举属性\r\nvar my_obj = Object.create({}, {\r\n  getFoo: {\r\n    value: function() { return this.foo; },\r\n    enumerable: false\r\n  }\r\n});\r\nmy_obj.foo = 1;\r\nconsole.log(Object.getOwnPropertyNames(my_obj).sort()); // [\"foo\", \"getFoo\"]\r\n```\r\n\r\n### 如果你只要获取到可枚举属性，请使用 `Object.keys` 或用 `for...in` 循环。\r\n\r\n## 5. Object.getOwnPropertySymbols()\r\n`Object.getOwnPropertySymbols()` 方法返回一个给定对象自身的所有 `Symbol` 属性的数组。\r\n\r\n```javascript\r\nvar obj = {};\r\nvar a = Symbol(\"a\");\r\nvar b = Symbol.for(\"b\");\r\n\r\nobj[a] = \"localSymbol\";\r\nobj[b] = \"globalSymbol\";\r\n\r\nvar objectSymbols = Object.getOwnPropertySymbols(obj);\r\n\r\nconsole.log(objectSymbols.length); // 2\r\nconsole.log(objectSymbols)         // [Symbol(a), Symbol(b)]\r\nconsole.log(objectSymbols[0])      // Symbol(a)\r\n```\r\n\r\n### 与 `Object.getOwnPropertyNames()` 类似，您可以将给定对象的所有符号属性作为 `Symbol` 数组获取。\r\n请注意，`Object.getOwnPropertyNames()` 本身不包含对象的 `Symbol` 属性，只包含字符串属性。\r\n\r\n因为所有的对象在初始化的时候不会包含任何的 `Symbol`，除非你在对象上赋值了 `Symbol` 否则Object.getOwnPropertySymbols()只会返回一个空的数组。\r\n\r\n## 6. Reflect.ownKeys()\r\n`Reflect.ownKeys()` 返回一个由目标对象自身的**属性键（key）组成的数组**。\r\n```javascript\r\nconst object1 = {\r\n  property1: 42,\r\n  property2: 13\r\n};\r\n\r\nconst array1 = [];\r\n\r\nconsole.log(Reflect.ownKeys(object1)); // [\"property1\", \"property2\"]\r\nconsole.log(Reflect.ownKeys(array1)); //  [\"length\"]\r\n```\r\n\r\n### Reflect.ownKeys 方法返回一个由目标对象自身的属性键组成的数组。它的返回值等同于`Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))`。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"# 二、数组遍历\r\n## 1. for 循环\r\n`for循环` 很古老，它在 ECMAScript 1 中就已经存在了。for 循环记录 arr 每个元素的索引和值：\r\n```javascript\r\nconst arr = ['a', 'b', 'c'];\r\narr.prop = 'property value';\r\n\r\nfor (let index=0; index < arr.length; index++) {\r\n  const elem = arr[index];\r\n  console.log(index, elem);\r\n}\r\n\r\n// 0, 'a'\r\n// 1, 'b'\r\n// 2, 'c'\r\n```\r\n\r\n### for 循环的优缺点是什么？\r\n\r\n- 优：它用途广泛。\r\n- 缺：但是当我们要遍历数组时也很麻烦。\r\n- 优：如果我们不想从第一个数组元素开始循环时它仍然很有用，用其他的循环机制很难做到这一点。\r\n\r\n## 2. for-in循环\r\n`for-in循环` 与 `for循环` 一样古老，同样在 ECMAScript 1中就存在了。下面的代码用 for-in 循环输出 arr 的 key：\r\n```javascript\r\nconst arr = ['a', 'b', 'c'];\r\narr.prop = 'property value';\r\n\r\nfor (const key in arr) {\r\n  console.log(key);\r\n}\r\n\r\n// '0'\r\n// '1'\r\n// '2'\r\n// 'prop'\r\n```\r\n\r\n### for-in 不是循环遍历数组的好方法：\r\n\r\n- 它访问的是属性键（key），而不是值（value）。\r\n- 作为属性键（key），数组元素的索引是字符串，而不是数字。\r\n- 它访问的是所有可枚举的属性键（自己的和继承的），而不仅仅是 `Array` 元素的那些。\r\n\r\n### for-in 访问继承属性的实际用途是：遍历对象的所有可枚举属性。\r\n\r\n## 3. 数组方法 .forEach()\r\n鉴于 `for` 和 `for-in` 都不特别适合在数组上循环，因此在 ECMAScript 5 中引入了一个辅助方法：Array.prototype.forEach()：\r\n```javascript\r\nconst arr = ['a', 'b', 'c'];\r\narr.prop = 'property value';\r\n\r\narr.forEach((elem, index) => {\r\n  console.log(elem, index);\r\n});\r\n\r\n// 'a', 0\r\n// 'b', 1\r\n// 'c', 2\r\n```\r\n\r\n### forEach 循环的优缺点是什么？\r\n\r\n- 优：它使我们无需执行大量操作就能够可访问数组元素和索引。\r\n- 缺：不能在它的循环体中使用 `await`。\r\n- 缺：不能提前退出 `forEach()循环`。而在 `for循环` 中可以使用 `break`。\r\n\r\n### 中止 .forEach() 的解决方法\r\n\r\n## 4. 数组方法 .some()\r\n如果想要中止 `.forEach()` 之类的循环，建议使用：`.some()` \r\n`.some()` 还会循环遍历所有数组元素，并在其回调返回真值时停止。\r\n```javascript\r\nconst arr = ['red', 'green', 'blue'];\r\narr.some((elem, index) => {\r\n  if (index >= 2) {\r\n    return true; // 中止循环\r\n  }\r\n  console.log(elem);\r\n  //此回调隐式返回 `undefined`，这\r\n  //是一个伪值。 因此，循环继续。\r\n});\r\n\r\n// 'red'\r\n// 'green'\r\n```\r\n\r\n## 5. for-of 循环\r\nfor-of 循环在 ECMAScript 6 开始支持：\r\n\r\n```javascript\r\nconst arr = ['a', 'b', 'c'];\r\narr.prop = 'property value';\r\n\r\nfor (const elem of arr) {\r\n  console.log(elem);\r\n}\r\n\r\n// 'a'\r\n// 'b'\r\n// 'c'\r\n```\r\n\r\n### for-of 在循环遍历数组时非常有效：\r\n\r\n- 用来遍历数组元素。\r\n- 可以使用 `await`。\r\n- 可以将 `break` 和 `continue` 用于外部作用域。\r\n\r\n## 6. 总结\r\n`for-of` 循环的可用性比 `for`，`for-in` 和 `.forEach()` 更好。\r\n\r\n通常四种循环机制之间的性能差异应该是无关紧要。\r\n如果你要做一些运算量很大的事，还是切换到 `WebAssembly` 更好一些。\r\n\r\n"}]},{"number":26,"title":"【Q026】常见的数组方法","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/26","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"# 一、数组遍历相关\r\n## 1. Array.prototype.entries()\r\n`entries()` 方法返回一个新的 **Array Iterator** 对象，该对象包含数组中每个索引的键/值对。\r\n```javascript\r\nconst array1 = ['a', 'b', 'c'];\r\nconst iterator1 = array1.entries();\r\n\r\nconsole.log(iterator1.next().value); // [0, \"a\"]\r\nconsole.log(iterator1.next().value); // [1, \"b\"]\r\n```\r\n\r\n### 常用于与 `for...of` 构成数组遍历：\r\n```javascript\r\nconst a = [\"a\", \"b\", \"c\"];\r\n\r\nfor (const [index, element] of a.entries()) {\r\n    console.log(index, element);\r\n}\r\n\r\n// 0 'a'\r\n// 1 'b'\r\n// 2 'c'\r\n```\r\n\r\n## 2. Array.prototype.every()\r\n`every()` 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。\r\n\r\n备注： 若收到一个空数组，此方法在任何情况下都会返回 true。\r\n\r\n```javascript\r\nconst array1 = [1, 30, 39, 29, 10, 13];\r\n\r\nconst flag = array1.every((item) => item < 40);\r\nconsole.log(flag); // true\r\n```\r\n\r\n### 常用于判断每一项都符合条件\r\n\r\n## 3. Array.prototype.filter()\r\n`filter()` 方法创建给定数组一部分的 `浅拷贝`，其包含通过所提供函数实现的测试的所有元素。\r\n```javascript\r\nconst words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];\r\n\r\nconst result = words.filter(word => word.length > 6);\r\nconsole.log(result); // [\"exuberant\", \"destruction\", \"present\"]\r\n```\r\n\r\n### 常用于筛选数组\r\n\r\n## 4. Array.prototype.flat()\r\n`flat()` 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。\r\n\r\n根据参数提取嵌套数组的结构深度，默认值为 1：\r\n```javascript\r\nconst arr1 = [0, 1, 2, [3, 4], [[5, 6]]];\r\n\r\nconsole.log(arr1.flat()); // [0, 1, 2, 3, 4, [5, 6]]\r\nconsole.log(arr1.flat(2)); // [0, 1, 2, 3, 4, 5, 6]\r\n```\r\n\r\n还可以移除数组中的空项：\r\n```javascript\r\nvar arr4 = [1, 2, , 4, 5];\r\n\r\nconsole.log(arr4.flat()); // [1, 2, 4, 5]\r\n````\r\n\r\n### 常用于数组降维\r\n\r\n## 5. Array.prototype.flatMap()\r\n`flatMap()` 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。\r\n它与 `map` 连着深度值为 1 的 `flat` 的效果几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些。\r\n\r\n```javascript\r\nconst arr1 = [1, 2, [3], [4, 5], 6, []];\r\n\r\nconsole.log(arr1.flatMap(num => num)); // [1, 2, 3, 4, 5, 6]\r\n// 效果等同于\r\nconsole.log(arr1.map(num => num).flat()) // [1, 2, 3, 4, 5, 6]\r\n```\r\n\r\n### 可用于 需要在 `map()` 时 **插入/减少** 某一项\r\n```javascript\r\nvar a = [5, 4, -3, 20, 17, -33, -4, 18]\r\n\r\na.flatMap((n) => {\r\n  if (n < 0) return [];\r\n  if (n % 2 == 0) return [n];\r\n  return [n-1, 1]\r\n})\r\n\r\nconsole.log(a); // [4, 1, 4, 20, 16, 1, 18]\r\n```\r\n\r\n替代方案（低效，不推荐）：\r\n\r\n`reduce()` 加 `concat()`\r\n```javascript\r\nvar arr = [1, 2, 3, 4];\r\n\r\narr.flatMap(x => [x, x * 2]); // [1, 2, 2, 4, 3, 6, 4, 8]\r\n// \r\narr.reduce((acc, x) => acc.concat([x, x * 2]), []); // [1, 2, 2, 4, 3, 6, 4, 8]\r\n```\r\n\r\n## 6. Array.prototype.forEach()\r\n`forEach()` 方法对数组的每个元素执行一次给定的函数。\r\n```javascript\r\nconst array1 = ['a', 'b', 'c'];\r\n\r\narray1.forEach(element => console.log(element));\r\n\r\n// \"a\"\r\n// \"b\"\r\n// \"c\"\r\n```\r\n\r\n`forEach` 不会直接改变调用它的对象，但是那个对象可能会被 `callbackFn` 函数改变。\r\n\r\n备注：除了抛出异常以外，没有办法中止或跳出 forEach() 循环。\r\n\r\n若你需要提前终止循环，你可以使用：\r\n\r\n- for循环\r\n- for...in/for...of 循环\r\n- Array.prototype.every()\r\n- Array.prototype.some()\r\n- Array.prototype.find()\r\n- Array.prototype.findIndex()\r\n\r\n最后四个方法，甚至可以对数组元素判断，以便确定是否需要继续遍历。\r\n\r\n### 常用于 *不需要异步* 且 *不需要提前跳出* 的数组循环。\r\n\r\n## 7. Array.prototype.keys()\r\n`keys()` 方法返回一个包含数组中每个索引键的 `Array Iterator` 对象。\r\n```javascript\r\nconst array1 = ['a', 'b', 'c'];\r\nconst iterator = array1.keys();\r\n\r\nfor (const key of iterator) {\r\n  console.log(key);\r\n}\r\n\r\n// 0\r\n// 1\r\n// 2\r\n```\r\n\r\n### 此方法很少使用\r\n\r\n## 8. Array.prototype.map()\r\n`map()` 方法 **创建一个新数组**，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。\r\n```javascript\r\nconst array1 = [1, 4, 9, 16];\r\n\r\nconsole.log(array1.map(x => x * 2)); // [2, 8, 18, 32]\r\n```\r\n\r\n若你不想返回的新数组，请使用 `forEach()` 或 `for...of`。\r\n\r\n### 常用于 遍历修改某一项 且 创建新数组。\r\n\r\n### 经典八股文：\r\n```javascript\r\n[\"1\", \"2\", \"3\"].map(parseInt); \r\n```\r\n我们期望输出 [1, 2, 3], 而实际结果是 [1, NaN, NaN]\r\n\r\n`parseInt` 经常被带着一个参数使用，但是这里接受两个。\r\n第一个参数是一个表达式而第二个是回调函数的基，`Array.prototype.map` 传递 3 个参数：element，index，array\r\n\r\n第三个参数被 `parseInt` 忽视了，但不是第二个。因此可能出现混淆。\r\n下面是迭代步骤的拆解：\r\n```javascript\r\nparseInt(\"1\", 0); // 1\r\nparseInt(\"2\", 1); // NaN\r\nparseInt(\"3\", 2); // NaN\r\n```\r\n\r\n## 9. Array.prototype.reduce()\r\n`reduce()` 方法对数组中的每个元素按序执行一个由您提供的 **reducer** 函数。\r\n每一次运行 **reducer** 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。\r\n```javascript\r\nconst array1 = [1, 2, 3, 4];\r\n\r\n// 求和\r\nconst initialValue = 0;\r\nconst sum = array1.reduce((prev, cur) => prev + cur, initialValue);\r\n\r\nconsole.log(sum); // 10\r\n```\r\n\r\n### 常用于累加对象数组里的值，例如求和\r\n\r\n数组去重\r\n```javascript\r\nvar arrary1 = ['a', 'b', 'a', 'b', 'c', 'e', 'e', 'c', 'd', 'd', 'd', 'd']\r\n\r\nvar array2 = arrary1.reduce((prev, cur) => {\r\n  if (prev.indexOf(cur) === -1) prev.push(cur)\r\n  return prev\r\n}, [])\r\n\r\nconsole.log(array2); // ['a', 'b', 'c', 'e', 'd']\r\n```\r\n\r\n对象数组分组\r\n```javascript\r\nvar array1 = [\r\n  { type: 'fruit', name: 'apple' },\r\n  { type: 'vegetable', name: 'tomato' },\r\n  { type: 'fruit', name: 'mango' },\r\n]\r\n\r\nconst dictionary = {};\r\n\r\narray1.reduce((prev, cur) => {\r\n  if (prev[cur.type]) {\r\n    prev[cur.type].push(cur)\r\n  } else {\r\n    prev[cur.type] = [cur]\r\n  }\r\n  return prev\r\n}, dictionary)\r\n\r\nconsole.log(dictionary); // {fruit: Array(2), vegetable: Array(1)}\r\n```\r\n\r\n## 10. Array.prototype.reduceRight()\r\n`reduceRight()` 方法接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。\r\n```javascript\r\nconst array1 = [[0, 1], [2, 3], [4, 5]];\r\n\r\nconst result = array1.reduceRight((acc, cur) => acc.concat(cur));\r\nconsole.log(result); // [4, 5, 2, 3, 0, 1]\r\n```\r\n\r\n### `reduce` 与 `reduceRight` 之间的区别：正序遍历和倒序遍历\r\n```javascript\r\nvar a = ['1', '2', '3', '4', '5'];\r\nvar left  = a.reduce((prev, cur) => prev + cur);\r\nvar right = a.reduceRight((prev, cur) => prev + cur);\r\n\r\nconsole.log(left);  // \"12345\"\r\nconsole.log(right); // \"54321\"\r\n```\r\n\r\n## 11. Array.prototype.some()\r\n`some()` 方法测试数组中是不是至少有 1 个元素通过了被提供的函数测试。它返回的是一个 `Boolean` 类型的值。\r\n```javascript\r\nconst array = [1, 2, 3, 4, 5];\r\n\r\nconsole.log(array.some((item) => item % 2 === 0)); // true\r\n```\r\n\r\n备注： 如果用一个空数组进行测试，在任何情况下它返回的都是false。\r\n\r\n### 常用于检查数组是否存在不符合条件的值。（性能推荐，找到第一个值就跳出循环）\r\n\r\n## 12. Array.prototype.values()\r\n`values()` 方法返回一个新的 `Array Iterator` 对象，该对象包含数组每个索引的值。\r\n```javascript\r\nconst array1 = ['a', 'b', 'c'];\r\nconst iterator = array1.values();\r\n\r\nfor (const value of iterator) {\r\n  console.log(value);\r\n}\r\n\r\n// \"a\"\r\n// \"b\"\r\n// \"c\"\r\n```\r\n\r\n### 与 `key()` 方法一样很少被使用\r\n\r\n## 13. Array.prototype[@@iterator]()\r\n`@@iterator` 和 `values()` 的初始值是同一个函数对象。\r\n\r\n### 同 `values()` 方法使用"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"# 二、数组增删改\r\n## 1. Array.prototype.concat()\r\n`concat()` 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。\r\n```javascript\r\nconst array1 = ['a', 'b', 'c'];\r\nconst array2 = ['d', 'e', 'f'];\r\nconst array3 = array1.concat(array2);\r\n\r\nconsole.log(array3); // [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]\r\n```\r\n\r\n### 常用于合并数组\r\n\r\n使用 Symbol.isConcatSpreadable 合并类数组对象\r\n`concat` 默认情况下不会将类数组对象视作数组——仅在 `Symbol.isConcatSpreadable` 被设置为真值（例如，true）时才会将类数组对象视作数组。\r\n```javascript\r\nconst obj1 = { 0: 1, 1: 2, 2: 3, length: 3 };\r\nconst obj2 = { 0: 1, 1: 2, 2: 3, length: 3, [Symbol.isConcatSpreadable]: true };\r\n\r\nconsole.log([0].concat(obj1, obj2)); // [ 0, { '0': 1, '1': 2, '2': 3, length: 3 }, 1, 2, 3 ]\r\n```\r\n\r\n## 2. Array.prototype.copyWithin()\r\n`copyWithin()` 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。\r\n```javascript\r\nconst array1 = ['a', 'b', 'c', 'd', 'e'];\r\n\r\nconsole.log(array1.copyWithin(0, 3, 4)); // [\"d\", \"b\", \"c\", \"d\", \"e\"]\r\nconsole.log(array1.copyWithin(1, 3)); // [\"d\", \"d\", \"e\", \"d\", \"e\"]\r\n```\r\n\r\n### `copyWithin` 就像 C 和 C++ 的 `memcpy` 函数一样，且它是用来移动 `Array` 或者 `TypedArray` 数据的一个高性能的方法。\r\n复制以及粘贴序列这两者是为一体的操作;即使复制和粘贴区域重叠，粘贴的序列也会有拷贝来的值。\r\n\r\n## 3. Array.prototype.fill()\r\n`fill()` 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。\r\n```javascript\r\nconst array1 = [1, 2, 3, 4];\r\n\r\nconsole.log(array1.fill(0, 2, 4)); // [1, 2, 0, 0]\r\nconsole.log(array1.fill(5, 1)); // [1, 5, 5, 5]\r\nconsole.log(array1.fill(6)); // [6, 6, 6, 6]\r\n```\r\n\r\n### 常用于快速填充数组\r\n\r\n## 4. Array.prototype.pop()\r\n`pop()` 方法从数组中删除最后一个元素，并返回该元素的值。此方法会更改数组的长度。\r\n```javascript\r\nconst plants = ['broccoli', 'cauliflower', 'cabbage', 'kale', 'tomato'];\r\n\r\nconsole.log(plants.pop()); // \"tomato\"\r\nconsole.log(plants); // [\"broccoli\", \"cauliflower\", \"cabbage\", \"kale\"]\r\n\r\nplants.pop();\r\nconsole.log(plants); // [\"broccoli\", \"cauliflower\", \"cabbage\"]\r\n```\r\n\r\n### 常用于删除掉数组的最后一位\r\n\r\n## 5. Array.prototype.push()\r\n`push()` 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。\r\n```javascript\r\nconst animals = ['pigs', 'goats', 'sheep'];\r\n\r\nconst count = animals.push('cows');\r\nconsole.log(count); // 4\r\nconsole.log(animals); // [\"pigs\", \"goats\", \"sheep\", \"cows\"]\r\n\r\nanimals.push('chickens', 'cats', 'dogs');\r\nconsole.log(animals); // [\"pigs\", \"goats\", \"sheep\", \"cows\", \"chickens\", \"cats\", \"dogs\"]\r\n```\r\n\r\n### 常用于给数组添加元素\r\n\r\n合并两个数组\r\n```javascript\r\nvar vegetables = ['parsnip', 'potato'];\r\nvar moreVegs = ['celery', 'beetroot'];\r\n\r\n// 相当于 vegetables.push(...moreVegs);\r\nArray.prototype.push.apply(vegetables, moreVegs);\r\n\r\nconsole.log(vegetables); // ['parsnip', 'potato', 'celery', 'beetroot']\r\n```\r\n\r\n像数组一样使用对象\r\n`push` 是特意设计为通用的，我们可以使用它来获得便利。\r\n```javascript\r\nvar obj = {\r\n    length: 0,\r\n\r\n    addElem: function addElem (elem) {\r\n        // obj.length is automatically incremented\r\n        // every time an element is added.\r\n        [].push.call(this, elem);\r\n    }\r\n};\r\n\r\nobj.addElem({});\r\nobj.addElem({});\r\n\r\nconsole.log(obj.length); // 2\r\nconsole.log(obj); // {0: {}, 1: {}, length: 2, addElem: ƒ}\r\n```\r\n\r\n## 6. Array.prototype.shift()\r\n`shift()` 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。\r\n```javascript\r\nconst array1 = [1, 2, 3];\r\n\r\nconst firstElement = array1.shift();\r\n\r\nconsole.log(array1); // [2, 3]\r\nconsole.log(firstElement); // 1\r\n```\r\n\r\n### 常用于删除数组中第一位\r\n\r\n## 7. Array.prototype.slice()\r\n`slice()` 方法返回一个新的数组对象，这一对象是一个由 `begin` 和 `end` 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。\r\n```javascript\r\nconst animals = ['ant', 'bison', 'camel', 'duck', 'elephant'];\r\n\r\nconsole.log(animals.slice(2)); // [\"camel\", \"duck\", \"elephant\"]\r\nconsole.log(animals.slice(2, 4)); // [\"camel\", \"duck\"]\r\nconsole.log(animals.slice(1, 5)); // [\"bison\", \"camel\", \"duck\", \"elephant\"]\r\nconsole.log(animals.slice(-2)); // [\"duck\", \"elephant\"]\r\nconsole.log(animals.slice(2, -1)); // [\"camel\", \"duck\"]\r\nconsole.log(animals.slice()); // [\"ant\", \"bison\", \"camel\", \"duck\", \"elephant\"]\r\n```\r\n\r\n### 常用于截取数组\r\n\r\n类数组对象转数组\r\n```javascript\r\nfunction list() {\r\n  return Array.prototype.slice.call(arguments);\r\n}\r\n\r\nvar list1 = list(1, 2, 3); // [1, 2, 3]\r\n```\r\n除了使用 `Array.prototype.slice.call(arguments)`，你也可以简单的使用 `[].slice.call(arguments) 来代替`。另外，你可以使用 `bind` 来简化该过程。\r\n```javascript\r\nfunction list() {\r\n  return Function.prototype.call.bind(Array.prototype.slice)(arguments);\r\n}\r\n\r\nvar list1 = list(1, 2, 3); // [1, 2, 3]\r\n```\r\n\r\n## 8. Array.prototype.splice()\r\n`splice()` 方法通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容。此方法会改变原数组。\r\n```javascript\r\nconst months = ['Jan', 'March', 'April', 'June'];\r\nmonths.splice(1, 0, 'Feb');\r\n\r\nconsole.log(months); // [\"Jan\", \"Feb\", \"March\", \"April\", \"June\"]\r\n\r\nmonths.splice(4, 1, 'May');\r\n\r\nconsole.log(months); // [\"Jan\", \"Feb\", \"March\", \"April\", \"May\"]\r\n```\r\n\r\n### 常用于替换数组中某一段\r\n\r\n## 9. Array.prototype.unshift()\r\n`unshift()` 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度。\r\n```javascript\r\nconst array1 = [1, 2, 3];\r\n\r\nconsole.log(array1.unshift(4, 5)); // 5\r\nconsole.log(array1); // [4, 5, 1, 2, 3]\r\n```\r\n\r\n### 常用于添加多个元素到数组开头"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"# 3. 数组查询\r\n## 1. Array.prototype.at()\r\n`at()` 方法接收一个整数值并返回该索引的项目，允许正数和负数。负整数从数组中的最后一个项目开始倒数。\r\n```javascript\r\nconst array1 = [5, 12, 8, 130, 44];\r\n\r\nlet index = 2;\r\nconsole.log(`${index}: ${array1.at(index)}`); // \"2: 8\"\r\n\r\nindex = -2;\r\nconsole.log(`${index}: ${array1.at(index)}`); // \"-2: 130\"\r\n```\r\n\r\n### 常用于快速寻找数组最后一个值\r\n\r\n比较不同的数组方法\r\n这个例子比较了选择 `Array` 中倒数第二项的不同方法，凸显了 `at()` 方法的简洁性和可读性。\r\n```javascript\r\n// 数组及数组元素。\r\nconst colors = ['red', 'green', 'blue'];\r\n\r\n// 使用长度属性。\r\nconst lengthWay = colors[colors.length-2];\r\nconsole.log(lengthWay); // 'green'\r\n\r\n// 使用 slice() 方法。注意会返回一个数组。\r\nconst sliceWay = colors.slice(-2, -1);\r\nconsole.log(sliceWay[0]); // 'green'\r\n\r\n// 使用 at() 方法。\r\nconst atWay = colors.at(-2);\r\nconsole.log(atWay); // 'green'\r\n```\r\n\r\n## 2. Array.prototype.find()\r\n`find()` 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 `undefined`。\r\n```javascript\r\nconst array1 = [5, 12, 8, 130, 44];\r\n\r\nconst found = array1.find(element => element > 10);\r\nconsole.log(found); // 12\r\n```\r\n\r\n### 常用于 用对象的属性查找数组里的对象\r\n```javascript\r\nconst inventory = [\r\n  {name: 'apples', quantity: 2},\r\n  {name: 'bananas', quantity: 0},\r\n  {name: 'cherries', quantity: 5}\r\n];\r\n\r\nvar item = inventory.find(item => item.name === 'cherries');\r\nconsole.log(item); // { name: 'cherries', quantity: 5 }\r\n```\r\n\r\n## 3. Array.prototype.findIndex()\r\n`findIndex()` 方法返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1。\r\n```javascript\r\nconst array1 = [5, 12, 8, 130, 44];\r\n\r\nconst index = array1.findIndex(element => element > 13);\r\nconsole.log(index); // 3\r\n```\r\n\r\n### 常用于 查找数组中第一个匹配元素的索引。\r\n\r\n## 4. Array.prototype.findLast()\r\n`findLast()` 方法返回数组中满足提供的测试函数条件的最后一个元素的值。如果没有找到对应元素，则返回 `undefined`。\r\n```javascript\r\nconst array1 = [5, 12, 8, 130, 44];\r\n\r\nconst item = array1.findLast(element => element > 13);\r\nconsole.log(item); // 44\r\n```\r\n\r\n### 常用于 查找数组中最后一个匹配元素。\r\n\r\n## 5. Array.prototype.findLastIndex()\r\n`findLastIndex()` 方法返回数组中满足提供的测试函数条件的最后一个元素的索引。若没有找到对应元素，则返回 -1。\r\n```javascript\r\nconst array1 = [5, 12, 8, 130, 44];\r\n\r\nconst item = array1.findLastIndex(element => element > 13);\r\nconsole.log(item); // 4\r\n```\r\n\r\n### 常用于 查找数组中最后一个匹配元素的索引。\r\n\r\n## 6. Array.prototype.includes()\r\n`includes()` 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 `true`，否则返回 `false`。\r\n```javascript\r\nconst array1 = [1, 2, 3];\r\n\r\nconsole.log(array1.includes(2)); // true\r\n\r\nconst pets = ['cat', 'dog', 'bat'];\r\n\r\nconsole.log(pets.includes('cat')); // true\r\nconsole.log(pets.includes('at')); // false\r\n```\r\n\r\n`includes()` 方法有意设计为通用方法。它不要求this值是数组对象，所以它可以被用于其他类型的对象 (比如类数组对象)。\r\n```javascript\r\n(function() {\r\n  console.log([].includes.call(arguments, 'a')); // true\r\n  console.log([].includes.call(arguments, 'd')); // false\r\n})('a','b','c');\r\n···\r\n\r\n### 常用于 快速查找一个值是否包含在该数组中。\r\n\r\n## 7. Array.prototype.indexOf()\r\n`indexOf()` 方法返回在数组中可以找到给定元素的第一个索引，如果不存在，则返回 -1。\r\n```javascript\r\nconst beasts = ['ant', 'bison', 'camel', 'duck', 'bison'];\r\n\r\nconsole.log(beasts.indexOf('bison')); // 1\r\nconsole.log(beasts.indexOf('bison', 2)); // 4\r\nconsole.log(beasts.indexOf('giraffe')); // -1\r\n```\r\n\r\n### 常用于 快速查找数组中第一个匹配元素的索引。\r\n\r\n## 8. Array.prototype.lastIndexOf()\r\n`lastIndexOf()` 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。\r\n从数组的后面向前查找，从 `fromIndex` 处开始。\r\n```javascript\r\nconst animals = ['Dodo', 'Tiger', 'Penguin', 'Dodo'];\r\n\r\nconsole.log(animals.lastIndexOf('Dodo')); // 3\r\nconsole.log(animals.lastIndexOf('Tiger')); // 1\r\n```\r\n\r\n### 常用于 快速查找数组中最后一个匹配元素的索引。\r\n\r\n## 9. 总结\r\n如果你需要查找的方法：\r\n\r\n- 第一个匹配的元素，使用 `find()`。\r\n- 最后一个匹配的元素，使用 `findLast()`。\r\n- 第一个匹配元素的索引，使用 `findIndex()`。\r\n- 最后一个匹配元素的索引，使用 `findLastIndex()`。\r\n- 纯粹查第一个匹配的索引，使用 `indexOf()`。它类似于 `findIndex()`，但是会检查每个元素是否和值相等，而不是使用一个测试函数。\r\n- 纯粹查最后一个匹配的索引，使用 `lastIndexOf()`。\r\n- 一个值是否包含在该数组中，使用 `includes()`。同样地，它检查每个元素是否和值相等，而不是使用一个测试函数。\r\n- 是否有任意一个元素满足提供的测试函数，使用 `some()`。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"# 4. 数组创建\r\n## 1. Array.of()\r\n`Array.of()` 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。\r\n\r\n### `Array.of()` 和 `Array` 构造函数之间的区别在于处理整数参数：\r\nArray.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个长度为 7 的空数组。\r\n```javascrpt\r\nArray.of(7); // [7]\r\nArray(7); // [empty × 7]\r\n\r\nArray.of(1, 2, 3); // [1, 2, 3]\r\nArray(1, 2, 3);    // [1, 2, 3]\r\n```\r\n\r\n## 2. Array.from()\r\n`Array.from()` 方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。\r\n```javascript\r\nconsole.log(Array.from('foo')); // [\"f\", \"o\", \"o\"]\r\n\r\nconsole.log(Array.from([1, 2, 3], x => x + x)); // [2, 4, 6]\r\n```\r\n\r\n### 常用于 根据指定数据创建数组\r\n\r\n数组去重合并\r\n```javascript\r\nfunction combine(){\r\n    let arr = [].concat.apply([], arguments);  // 没有去重复的新数组\r\n    return Array.from(new Set(arr));\r\n}\r\n\r\nvar m = [1, 2, 2];\r\nvar n = [2, 3, 3];\r\nconsole.log(combine(m,n)); // [1, 2, 3]\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"# 5. 其他\r\n## 1. Array.isArray()\r\n`Array.isArray()` 用于确定传递的值是否是一个 `Array`。\r\n```javascript\r\nArray.isArray([1, 2, 3]);  // true\r\nArray.isArray({foo: 123}); // false\r\nArray.isArray('foobar');   // false\r\nArray.isArray(undefined);  // false\r\n```\r\n\r\n### `Array.isArray()` 和 `instanceof` 的区别\r\n当检测 `Array` 实例时，`Array.isArray` 优于 `instanceof`，因为 `Array.isArray` 能检测 `iframes`。\r\n```javascript\r\nconst iframe = document.createElement('iframe');\r\ndocument.body.appendChild(iframe);\r\nxArray = window.frames[window.frames.length-1].Array;\r\nconst arr = new xArray(1,2,3); // [1,2,3]\r\n\r\n// 正确检查 Array\r\nArray.isArray(arr);  // true\r\n// Considered harmful, because doesn't work through iframes\r\narr instanceof Array; // false\r\n```\r\n\r\n### 常用于 精准的判断数据类型是否为数组\r\n\r\n## 2. Array.prototype.join()\r\n`join()` 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。\r\n如果数组只有一个项目，那么将返回该项目而不使用分隔符。\r\n```javascript\r\nconst elements = ['Fire', 'Air', 'Water'];\r\n\r\nconsole.log(elements.join()); // \"Fire,Air,Water\"\r\nconsole.log(elements.join('')); // \"FireAirWater\"\r\nconsole.log(elements.join('-')); // \"Fire-Air-Water\"\r\n```\r\n\r\n警告： 如果一个元素为 `undefined` 或 `null`，它会被转换为空字符串。\r\n\r\n### 常用于拼接字符串\r\n\r\n## 3. Array.prototype.reverse()\r\n`reverse()` 方法将数组中元素的位置颠倒，并返回该数组。\r\n该方法会改变原数组。\r\n```javascript\r\nconst array1 = ['one', 'two', 'three'];\r\n\r\nconst reversed = array1.reverse();\r\nconsole.log('reversed:', reversed); // [\"three\", \"two\", \"one\"]\r\nconsole.log('array1:', array1); // [\"three\", \"two\", \"one\"]\r\n```\r\n\r\n### 常用于数组反转排序\r\n\r\n## 4. Array.prototype.sort()\r\n`sort()` 方法用[原地算法](https://zh.wikipedia.org/wiki/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)对数组的元素进行排序，并返回数组。\r\n默认排序顺序是在将元素转换为字符串，然后比较它们的 UTF-16 代码单元值序列时构建的。\r\n```javascript\r\nconst months = ['March', 'Jan', 'Feb', 'Dec'];\r\n\r\nconsole.log(months.sort()); // [\"Dec\", \"Feb\", \"Jan\", \"March\"]\r\n\r\nconst array1 = [1, 30, 4, 21, 100000];\r\n\r\nconsole.log(array1.sort()); // [1, 100000, 21, 30, 4]\r\n```\r\n\r\n比较函数的基本用法：\r\n```javascript\r\nfunction compareFn(a, b) {\r\n  if (在某些排序规则中，a 小于 b) {\r\n    return -1;\r\n  }\r\n  if (在这一排序规则下，a 大于 b) {\r\n    return 1;\r\n  }\r\n  // a 一定等于 b\r\n  return 0;\r\n}\r\n```\r\n\r\n比较数字（升序排列）\r\n```javascript\r\nfunction compareNumbers(a, b) {\r\n  return a - b;\r\n}\r\n```\r\n\r\n对非 ASCII 字符排序\r\n当排序非 ASCII 字符的字符串（如包含类似 e, é, è, a, ä 等字符的字符串）。\r\n一些非英语语言的字符串需要使用 `String.localeCompare`。\r\n```javascript\r\nvar items = ['réservé', 'premier', 'cliché', 'communiqué', 'café', 'adieu'];\r\nitems.sort((a, b) =>  a.localeCompare(b));\r\n\r\nconsole.log(items); //  ['adieu', 'café', 'cliché', 'communiqué', 'premier', 'réservé']\r\n```\r\n\r\n### 常用于数组手动排序\r\n\r\n## 5. Array.prototype.toLocaleString()\r\n`toLocaleString()` 返回一个字符串表示数组中的元素。\r\n数组中的元素将使用各自的 `toLocaleString` 方法转成字符串，这些字符串将使用一个特定语言环境的字符串（例如逗号）隔开。\r\n```javascript\r\nconst array1 = [1, 'a', new Date('21 Dec 1997 14:12:00 UTC')];\r\nconst localeString = array1.toLocaleString('en', { timeZone: 'UTC' });\r\n\r\nconsole.log(localeString); // \"1,a,12/21/1997, 2:12:00 PM\"\r\n```\r\n\r\n数组中的元素将会使用各自的 `toLocaleString` 方法：\r\n\r\n- Object: Object.prototype.toLocaleString()\r\n- Number: Number.prototype.toLocaleString()\r\n- Date: Date.prototype.toLocaleString()\r\n\r\n### 用于数字货币转换：\r\n```javascript\r\nvar prices = ['￥7', 500, 8123, 12];\r\n\r\nprices.toLocaleString('ja-JP', { style: 'currency', currency: 'JPY' }); // \"￥7,￥500,￥8,123,￥12\"\r\n```\r\n\r\n## 6. Array.prototype.toString()\r\n`toString()` 方法返回一个字符串，表示指定的数组及其元素。\r\n```javascript\r\nconst array1 = [1, 2, 'a', '1a'];\r\n\r\nconsole.log(array1.toString()); // \"1,2,a,1a\"\r\n```\r\n\r\n`Array` 对象覆盖了 `Object` 的 `toString` 方法。\r\n对于数组对象，`toString` 方法在内部调用 `join()` 方法拼接数组中的元素并返回一个字符串，其中包含用逗号分隔的每个数组元素。\r\n如果 `join` 方法不可用，或者它不是一个函数，将使用 `Object.prototype.toString` 代替，返回 `[object Array]`。\r\n\r\n备注：当一个数组被作为文本值或者进行字符串拼接操作时，将会自动调用其 `toString` 方法。\r\n\r\n### 经典八股文：\r\n`Object.prototype.toString` 和 `Object.toString` 是一回事吗？\r\n\r\n不是。 \r\n因为 `Object.toString` 是 `Object.__proto__.toString`，也就是去上一级的原型中拿的方法，是 `Function.prototype.toString`。\r\n同理 `Number`，`String`，`Array` 里的 `toString` 也和 `Object.prototype.toString` 不一样，而且它们也都被重写了 `toString` 方法。\r\n"}]},{"number":27,"title":"【Q027】Ajax 工作原理","labels":["javascript"],"body":"着重理解，XMLHttpRequest","url":"https://github.com/kangyana/daily-question/issues/27","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 什么是Ajax？\r\n`AJAX`（Asynchronous JavaScript And XML）是使用 `XMLHttpRequest` 对象与服务器通信。\r\n它可以使用 JSON，XML，HTML 和 text 文本等格式发送和接收数据。\r\n`AJAX` 最吸引人的就是它的“异步”特性，也就是说它可以在不重新刷新页面的情况下与服务器通信，交换数据，或更新页面。\r\n\r\n你可以使用 AJAX 最主要的两个特性做下列事：\r\n\r\n- 在不重新加载页面的情况下发送请求给服务器。\r\n- 接受并使用从服务器发来的数据。\r\n\r\n### 如何发送 http 请求\r\n使用 `XMLHttpRequest` 方法建立一个请求：\r\n```javascript\r\nif (window.XMLHttpRequest) { // Mozilla, Safari, IE7+ ...\r\n    httpRequest = new XMLHttpRequest();\r\n} else if (window.ActiveXObject) { // IE 6 and older\r\n    httpRequest = new ActiveXObject(\"Microsoft.XMLHTTP\");\r\n}\r\n```\r\n\r\n请求响应的回调函数：\r\n```javascript\r\nhttpRequest.onreadystatechange = function(){\r\n    if (httpRequest.readyState === XMLHttpRequest.DONE) {\r\n        // Everything is good, the response was received.\r\n    } else {\r\n        // Not ready yet.\r\n    }\r\n};\r\n```\r\n\r\n发送一个实际的请求：\r\n```javascript\r\nhttpRequest.open('GET', 'http://www.example.org/some.file', true);\r\nhttpRequest.send();\r\n```\r\n\r\n可以在 `send` 调用之前设置请求头：\r\n```javascript\r\nhttpRequest.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. Ajax 工作原理\r\n\r\n![Alt](https://raw.githubusercontent.com/kangyana/img-storage/master/xhr_process.png)\r\n\r\n1. 浏览器调用xhr去请求服务器。\r\n2. 浏览器继续做其他工作。\r\n3. xhr请求服务器。\r\n4. 服务器响应xhr。\r\n5. xhr通知浏览器响应的数据。\r\n6. 浏览器利用xhr收到的数据渲染页面。"}]},{"number":28,"title":"【Q028】fetch","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/28","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. fetch\r\n`fetch`API 用于访问和操纵 HTTP 管道的一些具体部分，例如请求和响应。\r\n\r\n这种功能以前是使用 `XMLHttpRequest` 实现的，`Fetch` 提供了一个更理想的替代方案。\r\n```javascript\r\nfetch('http://example.com/movies.json')\r\n  .then(response => response.json())\r\n  .then(data => console.log(data));\r\n```\r\n\r\n### `fetch` 与 `jQuery.ajax()` 的区别：\r\n\r\n- 当接收到一个代表错误的 HTTP 状态码时，从 fetch() 返回的 Promise 不会被标记为 reject，即使响应的 HTTP 状态码是 404 或 500。\r\n相反，它会将 Promise 状态标记为 resolve（如果响应的 HTTP 状态码不在 200 - 299 的范围内，则设置 resolve 返回值的 ok 属性为 false），仅当网络故障时或请求被阻止时，才会标记为 reject。\r\n- fetch 不会发送跨域 cookie，除非你使用了 credentials 的 初始化选项。"}]},{"number":29,"title":"【Q029】同源策略（same-origin policy）","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/29","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 同源策略\r\n`同源策略` 是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。\r\n\r\n## 2. 同源的定义\r\n如果两个 URL 的 protocol (如果有指定的话) 和 host 都相同的话，则这两个 URL 是同源。\r\n这个方案也被称为“协议/主机/端口元组”，或者直接是“元组”。（“元组”是指一组项目构成的整体，双重/三重/四重/五重/等的通用形式）。\r\n\r\n下表给出了与 URL `http://store.company.com/dir/page.html` 的源进行对比的示例：\r\n\r\nURL | 结果 | 原因\r\n-- | -- | --\r\nhttp://store.company.com/dir2/other.html | 同源 | 只有路径不同\r\nhttp://store.company.com/dir/inner/another.html | 同源 | 只有路径不同\r\nhttps://store.company.com/secure.html | 失败 | 协议不同\r\nhttp://store.company.com:81/dir/etc.html | 失败 | 端口不同 ( http:// 默认端口是 80)\r\nhttp://news.company.com/dir/other.html | 失败 | 主机不同\r\n\r\n## 3. 源的继承\r\n在页面中通过 `about:blank` 或 `javascript: URL` 执行的脚本会继承打开该 URL 的文档的源，因为这些类型的 URLs 没有包含源服务器的相关信息。\r\n\r\n## 4. 源的更改\r\n满足某些限制条件的情况下，页面是可以修改它的源。脚本可以将 `document.domain` 的值设置为其当前域或其当前域的父域。如果将其设置为其当前域的父域，则这个较短的父域将用于后续源检查。\r\n\r\n例如：假设 http://store.company.com/dir/other.html 文档中的一个脚本执行以下语句：\r\n```javascript\r\ndocument.domain = \"company.com\";\r\n```\r\n\r\n## 5. 跨源网络访问\r\n同源策略控制不同源之间的交互，例如在使用 `XMLHttpRequest` 或 `<img>` 标签时则会受到同源策略的约束。这些交互通常分为三类：\r\n\r\n- 跨源写操作（Cross-origin writes）一般是被允许的。例如链接（links），重定向以及表单提交。特定少数的 HTTP 请求需要添加 预检请求。\r\n- 跨源资源嵌入（Cross-origin embedding）一般是被允许（后面会举例说明）。\r\n- 跨源读操作（Cross-origin reads）一般是不被允许的，但常可以通过内嵌资源来巧妙的进行读取访问。例如，你可以读取嵌入图片的高度和宽度，调用内嵌脚本的方法，或 availability of an embedded resource。\r\n\r\n以下是可能嵌入跨源的资源的一些示例：\r\n\r\n- <script src=\"...\"></script> 标签嵌入跨源脚本。语法错误信息只能被同源脚本中捕捉到。\r\n- <link rel=\"stylesheet\" href=\"...\"> 标签嵌入 CSS。由于 CSS 的 松散的语法规则，CSS 的跨源需要一个设置正确的 HTTP 头部 Content-Type 。不同浏览器有不同的限制。\r\n- 通过 <img> 展示的图片。支持的图片格式包括 PNG,JPEG,GIF,BMP,SVG,...\r\n- 通过 <video> 播放的多媒体资源。\r\n- 通过 <object> 和 <applet>  嵌入的插件。\r\n- 通过 @font-face 引入的字体。一些浏览器允许跨源字体（cross-origin fonts），一些需要同源字体（same-origin fonts）。\r\n- 通过 <iframe> 载入的任何资源。站点可以使用 X-Frame-Options 消息头来阻止这种形式的跨源交互。\r\n\r\n### 总结：资源和脚本可能会跨域。\r\n\r\n如何允许跨源访问：\r\n可以使用 `CORS` 来允许跨源访问。CORS 是 `HTTP` 的一部分，它允许服务端来指定哪些主机可以从这个服务端加载资源。\r\n\r\n如何阻止跨源访问：\r\n\r\n- 阻止跨源写操作，只要检测请求中的一个不可推测的标记 (CSRF token) 即可，这个标记被称为 Cross-Site Request Forgery (CSRF) 标记。你必须使用这个标记来阻止页面的跨源读操作。\r\n- 阻止资源的跨源读取，需要保证该资源是不可嵌入的。阻止嵌入行为是必须的，因为嵌入资源通常向其暴露信息。\r\n- 阻止跨源嵌入，需要确保你的资源不能通过以上列出的可嵌入资源格式使用。浏览器可能不会遵守 Content-Type 头部定义的类型。例如，如果您在 HTML 文档中指定 <script> 标记，则浏览器将尝试将标签内部的 HTML 解析为 JavaScript。当您的资源不是您网站的入口点时，您还可以使用 CSRF 令牌来防止嵌入。\r\n\r\n## 6. 跨源脚本 API 访问\r\n\r\n允许以下对 Window 属性的跨源访问：\r\n\r\n方法\r\n-- | \r\nwindow.blur\r\nwindow.close\r\nwindow.focus\r\nwindow.postMessage\r\n\r\n属性 | 权限\r\n-- | --\r\nwindow.closed | 只读\r\nwindow.frames | 只读\r\nwindow.length | 只读\r\nwindow.location | 读/写\r\nwindow.opener | 只读\r\nwindow.parent | 只读\r\nwindow.self | 只读\r\nwindow.top | 只读\r\nwindow.window | 只读\r\n\r\n允许以下对 Location 属性的跨源访问：\r\n\r\n方法\r\n-- | \r\nlocation.replace\r\n\r\n属性 | 权限\r\n-- | --\r\nHTMLAnchorElement.href | 只写\r\n\r\n某些浏览器允许访问除上述外更多的属性。\r\n\r\n## 7. 跨源数据存储访问\r\n访问存储在浏览器中的数据，如 `localStorage` 和 `IndexedDB`，是以源进行分割。\r\n每个源都拥有自己单独的存储空间，一个源中的 JavaScript 脚本不能对属于其它源的数据进行读写操作。\r\n\r\n`Cookies`使用不同的源定义方式。\r\n一个页面可以为本域和其父域设置 cookie，只要是父域不是公共后缀（public suffix）即可。\r\nFirefox 和 Chrome 使用 `Public Suffix List` 检测一个域是否是公共后缀（public suffix）。\r\nInternet Explorer 使用其内部的方法来检测域是否是公共后缀。\r\n不管使用哪个协议（HTTP/HTTPS）或端口号，浏览器都允许给定的域以及其任何子域名 (sub-domains) 访问 cookie。\r\n当你设置 cookie 时，你可以使用 Domain、Path、Secure、和 HttpOnly 标记来限定其无障碍。\r\n当你读取 cookie 时，你无法知道它是在哪里被设置的。\r\n即使您只使用安全的 https 连接，您看到的任何 cookie 都有可能是使用不安全的连接进行设置的。"}]},{"number":30,"title":"【Q030】JS strict模式","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/30","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 严格模式（strict mode）\r\n**ECMAScript 5**的 `严格模式` 是采用具有限制性 JavaScript 变体的一种方式，从而使代码隐式地脱离“马虎模式/稀松模式/懒散模式“（sloppy mode）。\r\n\r\n`严格模式` 的效果：\r\n\r\n- 严格模式通过抛出错误来消除了一些原有静默错误。\r\n- 严格模式修复了一些导致 JavaScript 引擎难以执行优化的缺陷：有时候，相同的代码，严格模式可以比非严格模式下运行得更快。\r\n- 严格模式禁用了在 ECMAScript 的未来版本中可能会定义的一些语法。\r\n\r\n## 2. 开启严格模式\r\n`严格模式` 可以应用到整个脚本或个别函数中，下表给出了应用范围：\r\n\r\n环境 | 结果\r\n-- | --\r\neva | ✅\r\nFunction | ✅\r\n内联事件处理属性 | ✅\r\nWindowTimers.setTimeout()| ✅\r\n块级作用域 {} | ❌\r\n\r\n### 为脚本开启严格模式\r\n// 整个脚本都开启严格模式的语法\r\n```javascript\r\n\"use strict\";\r\nvar v = \"Hi!  I'm a strict mode script!\";\r\n```\r\n\r\n### 为函数开启严格模式\r\n```javascript\r\nfunction strict() {\r\n  // 函数级别严格模式语法\r\n  'use strict';\r\n  function nested() {\r\n    return \"And so am I!\";\r\n  }\r\n  return \"Hi!  I'm a strict mode function!  \" + nested();\r\n}\r\n\r\nfunction notStrict() {\r\n  return \"I'm not strict.\";\r\n}\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 3. 严格模式的效果\r\n\r\n### 1. 将过失错误转成异常\r\n\r\n- 不行允许意外直接创建全局变量\r\n```javascript\r\n\"use strict\";\r\n                       // 假如有一个全局变量叫做mistypedVariable\r\nmistypedVaraible = 17; // 因为变量名拼写错误\r\n                       // 这一行代码就会抛出 ReferenceError\r\n```\r\n\r\n- 静默失败，只读属性不允许赋值\r\n```javascript\r\n\"use strict\";\r\n\r\n// 给不可写属性赋值\r\nvar obj1 = {};\r\nObject.defineProperty(obj1, \"x\", { value: 42, writable: false });\r\nobj1.x = 9; // 抛出 TypeError 错误\r\n\r\n// 给只读属性赋值\r\nvar obj2 = { get x() { return 17; } };\r\nobj2.x = 5; // 抛出 TypeError 错误\r\n\r\n// 给不可扩展对象的新属性赋值\r\nvar fixed = {};\r\nObject.preventExtensions(fixed);\r\nfixed.newProp = \"ohai\"; // 抛出 TypeError 错误\r\n```\r\n- 不允许删除不可删除的属性\r\n```javascript\r\n\"use strict\";\r\ndelete Object.prototype; // 抛出 TypeError 错误\r\n```\r\n- 不允许重名属性\r\n```javascript\r\n\"use strict\";\r\nvar o = { p: 1, p: 2 }; // !!! 语法错误\r\n```\r\n- 不允许参数重名\r\n```javascript\r\nfunction sum(a, a, c) { // !!! 语法错误\r\n  \"use strict\";\r\n  return a + a + c; // 代码运行到这里会出错\r\n}\r\n```\r\n- 禁止八进制数字语法\r\n```javascript\r\nvar a = 0o10; // ES6: 八进制\r\n```\r\n- 禁止设置 `primitive` 值的属性\r\n```javascript\r\n(function() {\r\n  \"use strict\";\r\n\r\n  false.true = \"\";              //TypeError\r\n  (14).sailing = \"home\";        //TypeError\r\n  \"with\".you = \"far away\";      //TypeError\r\n})();\r\n```\r\n\r\n### 2. 简化变量的使用\r\n\r\n- 禁用 `with` 语法\r\n```javascript\r\n\"use strict\";\r\nvar x = 17;\r\nwith (obj) { // !!! 语法错误\r\n  // 如果没有开启严格模式，with 中的这个 x 会指向 with 上面的那个 x，还是 obj.x？\r\n  // 如果不运行代码，我们无法知道，因此，这种代码让引擎无法进行优化，速度也就会变慢。\r\n  x;\r\n}\r\n```\r\n- 限制 `eval` 的作用域，避免影响到上层\r\n```javascript\r\nvar x = 17;\r\nvar evalX = eval(\"'use strict'; var x = 42; x\");\r\nconsole.assert(x === 17);\r\nconsole.assert(evalX === 42);\r\n```\r\n- 禁止删除变量 delete name\r\n```javascript\r\n\"use strict\";\r\n\r\nvar x;\r\ndelete x; // !!! 语法错误\r\n\r\neval(\"var y; delete y;\"); // !!! 语法错误\r\n```\r\n\r\n### 3. 让eval和arguments变的简单\r\n\r\n- 名称 `eval` 和 `arguments` 不能通过程序语法被绑定或赋值\r\n```javascript\r\n\"use strict\";\r\neval = 17;\r\narguments++;\r\n++eval;\r\nvar obj = { set p(arguments) { } };\r\nvar eval;\r\ntry { } catch (arguments) { }\r\nfunction x(eval) { }\r\nfunction arguments() { }\r\nvar y = function eval() { };\r\nvar f = new Function(\"arguments\", \"'use strict'; return 17;\");\r\n```\r\n\r\n- 参数的值不会随 arguments 对象的值的改变而变化\r\n```javascript\r\nfunction f(a) {\r\n  \"use strict\";\r\n  a = 42;\r\n  return [a, arguments[0]];\r\n}\r\nvar pair = f(17);\r\nconsole.assert(pair[0] === 42);\r\nconsole.assert(pair[1] === 17);\r\n```\r\n\r\n- 不再支持 `arguments.callee`\r\n```javascript\r\n\"use strict\";\r\nvar f = function() { return arguments.callee; };\r\nf(); // 抛出类型错误\r\n```\r\n\r\n### 4. 严格模式下更安全\r\n\r\n- 在严格模式下通过this传递给一个函数的值不会被强制转换为一个对象。\r\n```javascript\r\n\"use strict\";\r\nfunction fun() { return this; }\r\nconsole.assert(fun() === undefined);\r\nconsole.assert(fun.call(2) === 2);\r\nconsole.assert(fun.apply(null) === null);\r\nconsole.assert(fun.call(undefined) === undefined);\r\nconsole.assert(fun.bind(true)() === true);\r\n```\r\n\r\n- 函数内禁止使用 `fun.caller 和 `fun.arguments` 进行拓展\r\n```javascript\r\nfunction restricted() {\r\n  \"use strict\";\r\n  restricted.caller;    // 抛出类型错误\r\n  restricted.arguments; // 抛出类型错误\r\n}\r\n\r\nfunction privilegedInvoker() {\r\n  return restricted();\r\n}\r\n\r\nprivilegedInvoker();\r\n```\r\n\r\n- arguments不会再提供访问与调用这个函数相关的变量的途径\r\n```javascript\r\n\"use strict\";\r\nfunction fun(a, b) {\r\n  \"use strict\";\r\n  var v = 12;\r\n  return arguments.caller; // 抛出类型错误\r\n}\r\nfun(1, 2); // 不会暴露 v（或者 a，或者 b）\r\n```\r\n\r\n## 4. 为未来的 ECMAScript 版本铺路\r\n未来版本的 ECMAScript 很有可能会引入新语法，严格模式对其有保护机制。\r\n\r\n- 一部分字符变成了保留的关键字。\r\n在严格模式下，你不能再用这些名字作为变量名或者形参名。\r\n\r\n关键字\r\n-- |\r\nimplements\r\ninterface\r\nlet\r\npackage\r\nprivate\r\nprotected\r\npublic\r\nstatic\r\nyield\r\n\r\n```javascript\r\nfunction package(protected) { // !!!\r\n  \"use strict\";\r\n  var implements; // !!!\r\n\r\n  interface: // !!!\r\n  while (true) {\r\n    break interface; // !!!\r\n  }\r\n\r\n  function private() { } // !!!\r\n}\r\nfunction fun(static) { 'use strict'; } // !!!\r\n```\r\n\r\n-  严格模式禁止了不在脚本或者函数层面上的函数声明\r\n```javascript\r\n\"use strict\";\r\nif (true) {\r\n  function f() { } // !!! 语法错误\r\n  f();\r\n}\r\n\r\nfor (var i = 0; i < 5; i++) {\r\n  function f2() { } // !!! 语法错误\r\n  f2();\r\n}\r\n\r\nfunction baz() { // 合法\r\n  function eit() { } // 同样合法\r\n}\r\n```\r\n这种禁止放到严格模式中并不是很合适，因为这样的函数声明方式从 ES5 中延伸出来的。但这是 ECMAScript 委员会推荐的做法，浏览器就实现了这一点。"}]},{"number":31,"title":"【Q031】cookie","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/31","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. cookie\r\n`Cookie` 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。\r\n通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。\r\n\r\n`Cookie` 主要用于以下三个方面：\r\n\r\n- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）\r\n- 个性化设置（如用户自定义设置、主题等）\r\n- 浏览器行为跟踪（如跟踪分析用户行为等）\r\n\r\n`Cookie` 曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。\r\n由于服务器指定 `Cookie` 后，浏览器的每次请求都会携带 `Cookie` 数据，会带来额外的性能开销（尤其是在移动环境下）。\r\n新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 `Web storage 或 `IndexedDB`。\r\n\r\n\r\n## 2. 设置cookie\r\n当服务器收到 HTTP 请求时，服务器可以在响应头里面添加一个 `Set-Cookie` 选项。\r\n浏览器收到响应后通常会保存下 `Cookie`，之后对该服务器每一次请求中都通过 `Cookie` 请求头部将 `Cookie` 信息发送给服务器。\r\n另外，`Cookie` 的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。\r\n\r\n```\r\nSet-Cookie: <cookie 名>=<cookie 值>\r\n```\r\n\r\n## 3.定义 Cookie 的生命周期\r\nCookie 的生命周期可以通过两种方式定义：\r\n\r\n- 会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。\r\n- 持久性 Cookie：生命周期取决于过期时间（Expires）或有效期（Max-Age）指定的一段时间。\r\n\r\n```\r\nSet-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;\r\n```\r\n\r\n## 4. 限制访问 Cookie\r\n有两种方法可以确保 Cookie 被安全发送，并且不会被意外的参与者或脚本访问：\r\n\r\n属性 | 效果 | 预防\r\n-- | -- | --\r\nSecure | 只通过 HTTPS 协议加密过的请求 |  `man-in-the-middle` 的攻击\r\nHttpOnly | 禁止 `document.cookie` 访问 Cookie | `XSS` 的攻击\r\n\r\n```\r\nSet-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly\r\n```\r\n\r\n## 5. Cookie 的作用域\r\n`Domain` 和 `Path` 标识定义了 Cookie 的*作用域：*即允许 Cookie 应该发送给哪些 URL。\r\n\r\n### Domain 属性\r\n`Domain` 指定了哪些主机可以接受 Cookie。如果不指定，默认为 **origin**，不包含子域名。\r\n如果指定了Domain，则一般包含子域名。因此，指定 `Domain` 比省略它的限制要少。\r\n但是，当子域需要共享有关用户的信息时，这可能会有所帮助。\r\n\r\n### Path 属性\r\n`Path` 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。\r\n以字符 %x2F (\"/\") 作为路径分隔符，子路径也会被匹配。\r\n\r\n例如，设置 Path=/docs，则以下地址都会匹配：\r\n\r\n- /docs\r\n- /docs/Web/\r\n- /docs/Web/HTTP"}]},{"number":32,"title":"【Q032】sessionStorage、localStorage","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/32","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. Web Storage\r\n`Web Strorage` 使浏览器能以一种比使用 Cookie 更直观的方式存储键/值对。\r\n\r\nWeb Storage 包含如下两种机制：\r\n\r\n- `sessionStorage` 为每一个给定的源（given origin）维持一个独立的存储区域，该存储区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。\r\n- `localStorage` 同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。\r\n\r\n## 2. sessionStorage\r\n`sessionStorage` 属性允许你访问一个，对应当前源的 **浏览器会议储存** 的对象。\r\n它的生命周期是 一次浏览器会话。\r\n\r\n```javascript\r\n// 保存数据到 sessionStorage\r\nsessionStorage.setItem('key', 'value');\r\n\r\n// 从 sessionStorage 获取数据\r\nlet data = sessionStorage.getItem('key');\r\n\r\n// 从 sessionStorage 删除保存的数据\r\nsessionStorage.removeItem('key');\r\n\r\n// 从 sessionStorage 删除所有保存的数据\r\nsessionStorage.clear();\r\n```\r\n## 3. localStorage\r\n`localStorage` 属性允许你访问一个，**Document源** 的对象。\r\n它的生命周期是长期，直到你手动清除。\r\n\r\n语法同 sessionStorage：\r\n```javascript\r\n// 保存 localStorage 项\r\nlocalStorage.setItem('myCat', 'Tom');\r\n\r\n// 读取 localStorage 项\r\nlet cat = localStorage.getItem('myCat');\r\n\r\n// 移除 localStorage 项\r\nlocalStorage.removeItem('myCat');\r\n\r\n// 移除所有的 localStorage 项\r\nlocalStorage.clear();\r\n```\r\n\r\n## 4. 区别\r\n\r\n- 生命周期：localStorage 是长久储存，sessionStorage 是一次浏览器会话。\r\n- 应用场景：localStorage 适合储存个性设置，sessionStorage 适合储存敏感信息（token等）。"}]},{"number":34,"title":"【Q034】web worker","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/34","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. web worker\r\n`Web Worker`  为 Web 内容在后台线程中运行脚本提供了一种简单的方法。\r\nworker 可以与 js 互相通信，线程可以执行任务而不干扰用户界面。\r\n\r\n### 常用来做 耗时的计算，Service worker等后台任务\r\n\r\n## 2. worker的使用\r\n### 生成一个专用 worker\r\n```javascript\r\n// main.js\r\nvar myWorker = new Worker('worker.js');\r\n```\r\n\r\n### worker 中消息的接收和发送\r\n你可以通过 `postMessage()` 方法和 `onmessage` 事件处理函数触发 workers 的方法。\r\n\r\n主线程向 worker 发消息\r\n```javascript\r\n// main.js\r\nfirst.onchange = function() {\r\n  myWorker.postMessage([first.value,second.value]);\r\n  console.log('Message posted to worker');\r\n}\r\n\r\nsecond.onchange = function() {\r\n  myWorker.postMessage([first.value,second.value]);\r\n  console.log('Message posted to worker');\r\n}\r\n```\r\nworker接收消息的回调\r\n```javascript\r\n// worker.js\r\nonmessage = function(e) {\r\n  console.log('Message received from main script');\r\n  var workerResult = 'Result: ' + (e.data[0] * e.data[1]);\r\n  console.log('Posting message back to main script');\r\n  postMessage(workerResult);\r\n}\r\n```\r\n\r\n主线程响应 worker 回传的消息\r\n```javascript\r\n// main.js\r\nmyWorker.onmessage = function(e) {\r\n  result.textContent = e.data;\r\n  console.log('Message received from worker');\r\n}\r\n```\r\n\r\n### 终止 worker\r\n主线程调用 `terminate` 方法关闭\r\n```javascript\r\n// main.js\r\nmyWorker.terminate();\r\n```\r\n\r\nworker线程调用 `close` 方法关闭\r\n```javascript\r\n// worker.js\r\nclose();\r\n```\r\n\r\n### 处理错误\r\n当 worker 出现运行中错误时，它的 `onerror` 事件处理函数会被调用。\r\n该事件不会冒泡并且可以被取消；为了防止触发默认动作，worker 可以调用错误事件的 `preventDefault()` 方法。\r\n```javascript\r\n// worker.js\r\nonerror = function(err) {\r\n  console.log('错误消息：', err.message);\r\n  console.log('错误文件：', err.filename);\r\n  console.log('错误行数：', err.lineno);\r\n}\r\n```\r\n\r\n### 生成 subworker\r\nworker 能够生成更多的 worker。\r\n\r\n### 引入脚本与库\r\nWorker 线程能够访问一个全局函数 `importScripts()` 来引入脚本，该函数接受 0 个或者多个 URI 作为参数来引入资源。\r\n```javascript\r\nimportScripts();                        /* 什么都不引入 */\r\nimportScripts('foo.js');                /* 只引入 \"foo.js\" */\r\nimportScripts('foo.js', 'bar.js');      /* 引入两个脚本 */\r\n```\r\n\r\n浏览器加载并运行每个的脚本，脚本中的全局对象都能够被 worker 使用。\r\n如果脚本无法加载，将抛出 NETWORK_ERROR 异常，接下来的代码也无法执行，而之前执行的代码 **异步执行的代码** 依然能够运行。\r\nimportScripts() 之后的函数声明有效，因为函数提升。\r\n\r\n备注： 脚本的下载顺序不固定，但执行时会按照传入 importScripts() 中的文件名顺序进行。\r\n这个过程是同步完成的；直到所有脚本都下载并运行完毕，importScripts() 才会返回。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 3. pwa 渐进式 Web 应用\r\n`PWA`（Progressive Web Apps）运用现代的 Web API 以及传统的渐进式增强策略来创建跨平台 Web 应用程序。\r\n`PWA` 使 **web应用** 具有与 **原生应用** 相同的用户体验。\r\n\r\n## 4. 通过 Service workers 让 PWA 离线工作\r\n`Service Worker` 是浏览器和网络之间的虚拟代理。\r\n它解决决了如何正确 **缓存网站资源** 并使其在离线时可用的问题。\r\n\r\n### Service Worker 的生命周期\r\n注册sw后，sw.js 文件会自动下载、安装，然后激活。\r\n\r\n### 注册 Service Worker\r\n```javascript\r\nif('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.register('/pwa-examples/js13kpwa/sw.js');\r\n};\r\n```\r\n\r\n### 安装\r\n安装sw，并缓存文件\r\n```javascript\r\nvar cacheName = 'js13kPWA-v1'; // 缓存版本号\r\nvar appShellFiles = [\r\n  '/pwa-examples/js13kpwa/index.html',\r\n  '/pwa-examples/js13kpwa/app.js',\r\n  '/pwa-examples/js13kpwa/style.css',\r\n]; // 需要缓存的资源路径\r\n\r\nself.addEventListener('install', function(e) {\r\n  console.log('SW 安装');\r\n  // 等待缓存后再安装\r\n  e.waitUntil(\r\n    caches.open(cacheName).then(function(cache) {\r\n          console.log('SW 缓存资源');\r\n      return cache.addAll(appShellFiles);\r\n    })\r\n  );\r\n});\r\n```\r\n\r\n### 拦截请求\r\n缓存中查找资源是否被缓存：如果存在，将会返回缓存的资源；如果不存在，会转而从网络中请求数据，然后将它缓存起来。\r\n```javascript\r\nself.addEventListener('fetch', function(e) {\r\n  e.respondWith(\r\n    caches.match(e.request).then(function(r) {\r\n      console.log('SW 拦截到请求'+e.request.url);\r\n      return r || fetch(e.request).then(function(response) {\r\n                return caches.open(cacheName).then(function(cache) {\r\n          console.log('[Service Worker] Caching new resource: '+e.request.url);\r\n          cache.put(e.request, response.clone());\r\n          return response;\r\n        });\r\n      });\r\n    })\r\n  );\r\n});\r\n```\r\n\r\n### 更新\r\n当有资源变动时，更新版本号，会创新一个新sw缓存文件。\r\n```javascript\r\nappShellFiles.push('/pwa-examples/js13kpwa/icons/icon-32.png');\r\n\r\ncacheName = 'js13kPWA-v2';\r\n```\r\n旧的 Service Worker 仍然会正常运行，直到没有任何页面使用到它为止。\r\n\r\n\r\n### 激活\r\n用来清理不需要的缓存。\r\n```javascript\r\nself.addEventListener('activate', function(e) {\r\n  console.log('SW 激活');\r\n  e.waitUntil(\r\n    caches.keys().then(function(keyList) {\r\n      return Promise.all(keyList.map(function(key) {\r\n        if(cacheName.indexOf(key) === -1) {\r\n          return caches.delete(key);\r\n        }\r\n      }));\r\n    })\r\n  );\r\n});\r\n\r\n```"}]},{"number":35,"title":"【Q035】请解释什么是单页面应用","labels":["javascript"],"body":"请解释什么是单页面应用（single page app），以及如何使其对搜索引擎友好（SEO-friendly）","url":"https://github.com/kangyana/daily-question/issues/35","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 单页面应用 SPA\r\n单页面应用（single page app）加载单个html，切换 url 不会再去请求html。\r\n原理是JS会感知到url的变化，然后js会动态的将当前页面的内容清除掉，然后将下一个页面的内容挂载到当前的页面上。\r\n路由是由前端来控制，判断显示哪个页面。\r\n\r\n![Alt](https://img-blog.csdnimg.cn/20190109220800340.jpeg)\r\n\r\n### 优点\r\n\r\n- 有良好的交互体验，不会重新加载页面\r\n- 不请求html文件，减轻服务器压力\r\n- 前后端分离开发，后端接口可以通用开放给 多个客户端（web，小程序，app）。\r\n\r\n### 缺点\r\n\r\n- 首屏加载时间比较慢\r\n- SEO效果差"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. 优化方案\r\n\r\n### 优化首屏加载体验\r\n\r\n- 资源懒加载\r\n- 构建骨架屏\r\n\r\n### 优化SEO\r\n\r\n- 完善 `title` 和 `meta` 标签\r\n- 服务器端渲染（SSR）\r\n"}]}]}