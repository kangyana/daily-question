# 【Q090】webpack 5 新特性


::: tip Issue
欢迎在 Gtihub Issue 中回答此问题: [Issue 90](https://github.com/kangyana/daily-question/issues/90)
:::

::: tip Author
回答者: [kangyana](https://github.com/kangyana)
:::
## 1. webpack 5 新特性
重点：

- 尝试用持久性缓存来提高构建性能。
- 尝试用更好的算法和默认值来改进长期缓存。
- 尝试用更好的 Tree Shaking 和代码生成来改善包大小。
- 尝试改善与网络平台的兼容性。
- 尝试在不引入任何破坏性变化的情况下，清理那些在实现 v4 功能时处于奇怪状态的内部结构。
- 试图通过现在引入突破性的变化来为未来的功能做准备，使其能够尽可能长时间地保持在 v5 版本上。
::: tip Author
回答者: [kangyana](https://github.com/kangyana)
:::
## 2. 新特性详情
### 长期缓存
确定的 Chunk、模块 ID 和导出名称。
新增了长期缓存的算法。这些算法在生产模式下是默认启用的。

`chunkIds: "deterministic"` `moduleIds: "deterministic"` `mangleExports: "deterministic"`

该算法以确定性的方式为模块和分块分配短的（3 或 5 位）数字 ID， 这是包大小和长期缓存之间的一种权衡。

### 命名代码块 ID
在开发模式下，默认启用的新命名代码块 ID 算法为模块（和文件名）提供了人类可读的名称。 
模块 ID 由其路径决定，相对于 `context`。 代码块 ID 由代码块的内容决定。

所以你不再需要使用 `import(/* webpackChunkName: "name" */ "module")` 来调试。
但如果你想控制生产环境的文件名，还是有意义的。
 
可以在生产环境中使用 `chunkIds: "named"` 在生产环境中使用，但要确保不要不小心暴露模块名的敏感信息。

### 模块联邦
Webpack 5 增加了一个新的功能 "模块联邦"，它允许多个 webpack 构建一起工作。
从运行时的角度来看，多个构建的模块将表现得像一个巨大的连接模块图。
从开发者的角度来看，模块可以从指定的远程构建中导入，并以最小的限制来使用。

### 异步模块
Webpack 5 支持所谓的 "异步模块"。 这些模块并不是同步解析的，而是基于异步和 Promise 的。

通过 `import` 导入它们会被自动处理，不需要额外的语法，而且几乎看不出区别。
通过 `require()` 导入它们会返回一个解析到导出的 Promise。

在 webpack 中，有多种方式来拥有异步模块：

-  异步的外部资源(async externals)。
- 新规范中的 WebAssembly 模块。
- 使用顶层 Await 的 ECMAScript 模块。

### 外部资源
Webpack 5 增加了更多的外部类型来覆盖更多的应用：

- **promise**: 一个评估为 Promise 的表达式。外部模块是一个异步模块，解析值作为模块导出使用。
- **import**：原生的 `import()` 用于加载指定的请求，外部模块是一个异步模块，解析值作为模块导出。外部模块是一个异步模块。
- **module**: 尚未实现，但计划通过 `import x from "..."` 加载模块。
- **script**: 通过 `<script>` 标签加载一个 url，并从一个全局变量（以及它的可选属性）中获取输出。外部模块是一个异步模块。

### 嵌套的 tree-shaking
Webpack 现在能够跟踪对导出的嵌套属性的访问。
这可以改善重新导出命名空间对象时的 Tree Shaking（清除未使用的导出和混淆导出）。
```javascript
// inner.js
export const a = 1;
export const b = 2;

// module.js
export * as inner from './inner';
// 或 import * as inner from './inner'; export { inner };

// user.js
import * as module from './module';
console.log(module.inner.a);
```

在这个例子中，可以在生产模式下删除导出的b。

### 内部模块 tree-shaking
Webpack 4 没有分析模块的导出和引用之间的依赖关系。
webpack 5 有一个新的选项 `optimization.innerGraph`，在生产模式下是默认启用的，它可以对模块中的标志进行分析，找出导出和引用之间的依赖关系。

在这样的模块中：

```javascript
import { something } from './something';

function usingSomething() {
  return something;
}

export function test() {
  return usingSomething();
}
```

内部依赖图算法会找出 `something` 只有在使用 `test` 导出时才会使用。
这允许将更多的出口标记为未使用，并从代码包中省略更多的代码。

当设置 `"sideEffects": false` 时，可以省略更多的模块。
在这个例子中，当 `test` 导出未被使用时，`./something` 将被省略。

要获得未使用的导出信息，需要使用 `optimization.usedExports`。
要删除无副作用的模块，需要使用 `optimization.sideEffects`。

可以分析以下标记：

- 函数声明
- 类声明
- 默认导出export default 或定义变量以下的：
  - 函数表达式
  - 类表达式
  - 顺序表达式
  - /*#__PURE__*/ 表达式
  - 局部变量
  - 引入的捆绑(bindings)
  
注意：使用 `eval()` 将为一个模块放弃这个优化，因为经过 `eval` 的代码可以引用范围内的任何标记。
这种优化也被称为深度范围分析。

