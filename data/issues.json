{"javascript":[{"number":1,"title":"【Q001】js 有几种基本的数据类型","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/1","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"### 6种基本数据类型。\r\n\r\n- String 字符串\r\n- Number 数字\r\n- Boolean 布尔值\r\n- Null 空\r\n- Undefined 未定义\r\n- Symbol （es6新增）\r\n\r\n### 5种引用数据\r\n\r\n- Object 对象\r\n- Array 数组\r\n- Function 函数\r\n- RegExp 正则\r\n- Date 日期"}]},{"number":2,"title":"【Q002】如何判断 js 数据类型","labels":["javascript"],"body":"基础类型和复杂类型","url":"https://github.com/kangyana/daily-question/issues/2","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"### typeof用于判断基本数据类型，无法区分object、array、null\r\n```javascript\r\n    typeof 1 // 'number'\r\n    typeof \"1\" // 'string'\r\n    typeof undefined // 'undefined'\r\n    \r\n    typeof null // 'object'\r\n    typeof [] // 'object'\r\n    typeof {} // 'object'\r\n    typeof function() {} // 'function'\r\n```\r\n\r\n### 区分object和array，可以使用`Array.isArray()`\r\n```javascript\r\n    Array.isArray([1, 2, 3]); // true\r\n    Array.isArray({foo: 123}); // false\r\n    Array.isArray(\"foobar\"); // false\r\n    Array.isArray(undefined); // false\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"一条友善的评论"}]},{"number":3,"title":"【Q003】typeof和instanceof的区别","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/3","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 一、typeof\r\n`typeof`操作符返回一个字符串，表示未经计算的操作数的类型。\r\n\r\n语法：\r\n```javascript\r\ntypeof operand\r\n```\r\n\r\n|类型 | 结果 |\r\n| ---- | ---- |\r\n| undefined | `\"undefined\"` |\r\n| boolean | `\"boolean\"` |\r\n| string | `\"string\"` |\r\n| symbol | `\"symbol\"` |\r\n| bigInt | `\"bigint\"` |\r\n| function | `\"function\"` |\r\n| object \\| array \\| null | `\"object\"` |\r\n\r\n由上表可得知，`typeof`是无法区分`object` | `array` | `null`类型的。\r\n\r\n## 二、instanceof\r\n`instanceof` 运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。\r\n\r\n语法：\r\n```javascript\r\nobject instanceof constructor\r\n```\r\n\r\n只能用于构造函数，无法用于基础类型。\r\n\r\n## 三、总结区别\r\n`typeof`与`instanceof`都是判断数据类型的方法，区别如下：\r\n\r\n- `typeof`会返回一个变量的基本类型，instanceof返回的是一个布尔值。\r\n- `instanceof` 可以准确地判断复杂引用数据类型，但是无法判断基本类型。\r\n- `typeof`无法判断除了`function`外的引用类型。\r\n"}]},{"number":4,"title":"【Q004】如何判断一个变量是不是Array","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/4","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. instanceof 判断\r\n```javascript\r\nvar arr = [1,2,3];\r\narr instanceof Array; // true\r\narr instanceof Object; // false\r\n\r\nvar obj = {id:1};\r\nobj instanceof Array; // false\r\nobj instanceof Object; // true\r\n```\r\n\r\n## 2. 构造函数 判断\r\n```javascript\r\nvar arr = [1,2,3];\r\narr.__proto__.constructor === Array; //  true\r\n\r\nvar obj = {id:1};\r\nobj.__proto__.constructor === Object; // true\r\n```\r\n\r\n## 3. toString() 判断\r\n```javascript\r\nvar arr = [1,2,3];\r\nObject.prototype.toString.call(arr);  // [object Array]\r\n\r\nvar obj = {id:1};\r\nObject.prototype.toString.call(obj); // [object Object]\r\n```\r\n\r\n## 4. Array.isArray() 判断\r\n```javascript\r\nvar arr = [1,2,3];\r\nArray.isArray(arr); //  true\r\n\r\nvar obj = {id:1};\r\nArray.isArray(obj); // false\r\n```"}]},{"number":5,"title":"【Q005】==和===有什么不同","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/5","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. ==\r\n等于运算符 `==` 检查其两个操作数是否相等，并返回 `Boolean` 结果。\r\n同时会尝试强制类型转换。\r\n\r\n隐式转换：\r\n`string` 和 `number` 比较时，会自动转换为 `number` 类型。\r\n\r\n## 2. ===\r\n全等运算符 `===` 检查其两个操作数是否相等，并返回 `Boolean` 结果。\r\n它总是认为不同类型的操作数是不同的。\r\n\r\n## 3. 区别\r\n\r\n- `==` 不会比较数据类型，`===` 会检查类型\r\n- `==`会隐式转换"}]},{"number":6,"title":"【Q006】事件机制","labels":["javascript"],"body":"事件循环","url":"https://github.com/kangyana/daily-question/issues/6","comments":[]},{"number":7,"title":"【Q007】事件委托","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/7","comments":[]},{"number":8,"title":"【Q008】e.preventDefault()是干什么的","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/8","comments":[]},{"number":9,"title":"【Q009】JS中this是如何工作的","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/9","comments":[]},{"number":10,"title":"【Q010】apply、call、bind的区别，及源码实现","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/10","comments":[]},{"number":11,"title":"【Q011】js中new关键字原理","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/11","comments":[]},{"number":12,"title":"【Q012】JS 中继承是如何实现的","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/12","comments":[]},{"number":13,"title":"【Q013】JS 原型和原型链","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/13","comments":[]},{"number":14,"title":"【Q014】闭包与作用域链","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/14","comments":[]},{"number":15,"title":"【Q015】let、const、var的区别","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/15","comments":[]},{"number":16,"title":"【Q016】JS 中变量声明提升","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/16","comments":[]},{"number":17,"title":"【Q017】JS 模块化","labels":["javascript"],"body":"理解模块化发展过程，理解 commonJS，AMD，CMD，UMD，ES6 模块化","url":"https://github.com/kangyana/daily-question/issues/17","comments":[]},{"number":18,"title":"【Q018】IIFE 立即执行函数","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/18","comments":[]}]}