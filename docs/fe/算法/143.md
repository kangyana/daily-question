# 【Q143】阿里笔试

::: tip 更多描述
一面
:::

::: tip Issue
欢迎在 Gtihub Issue 中回答此问题: [Issue 143](https://github.com/kangyana/daily-question/issues/143)
:::

::: tip Author
回答者: [kangyana](https://github.com/kangyana)
:::
## 1. 实现 queryParse 函数，完成解析 URL 参数的功能
> 用法：
```javascript
const href = 'https://a.b.c?name=abc&age=24&code=%E6%B5%8B%E8%AF%95#main';
const params = queryParse(href);
console.log(params); // {name: 'abc', age: 24, ...等 }
```

### 解析：此题考查 URL 结构 和 字符串操作

```javascript
/**
 * 问题：实现 queryParse 函数，完成解析 URL 参数的功能
 * @param url
 * @returns object
 */
function queryParse(url) {
  // 对 url 解码
  const decodeUrl = decodeURIComponent(url);
  // 取 ? 后面的字符串
  const afterStr = decodeUrl.split("?")[1] || "";
  // 去掉 hash 值
  const paramStr = afterStr.split("#")[0];
  // 对象数组转对象
  const result = {};
  paramStr.split("&").reduce((prev, cur) => {
    const [key, value] = cur.split("=");
    prev[key] = value;
    return prev;
  }, result);
  return result;
}

// 测试用例
console.log(queryParse("https://a.b.c?name=abc&age=24&code=%E6%B5%8B%E8%AF%95#main"));
```
::: tip Author
回答者: [kangyana](https://github.com/kangyana)
:::
## 2. 请实现对二叉树节点的遍历访问函数，并按要求输出log。
> 示例：使得二叉树如下时：
输入数据：[1, [2], [3, [4, [5], [6]], [7]]]
```
   1
  / \
 2   3
    / \
   4   7
  / \
 5   6
```
> console.log 输出的顺序为：
```bash
1
2
3
4
5
6
7
```

### 解析：此题考查 实现二叉树 和 遍历算法。此处以 `中序遍历` 为例：
```javascript
function binaryTreeAccess(arr) {
  // 创建二叉树
  var binaryTree = new BinaryTree();
  // 扁平化，遍历插入节点
  arr.flat(Infinity).forEach((item) => {
    binaryTree.insert(item);
  });
  // 遍历访问节点，并打印
  binaryTree.inOrderTraverse(console.log);
}


// 节点类
class Node {
  constructor(key) {
    this.key = key;
    this.left = null;
    this.right = null;
  }
}

// 二叉树类
class BinaryTree {
  constructor() {
    this.root = null;
  }

  // 插入
  insert(key) {
    const node = new Node(key);
    if (this.root === null) {
      this.root = node;
      return;
    }
    insertNode(this.root, node);
  }

  // 遍历
  inOrderTraverse(callback) {
    // 传 root 是因为要从根节点开始。
    inOrderTraverseNode(this.root, callback);
  }
}

// 插入节点
function insertNode(node, newNode) {
  if (newNode.key < node.key) {
    if (node.left === null) {
      node.left = newNode;
    } else {
      insertNode(node.left, newNode);
    }
  } else {
    if (node.right === null) {
      node.right = newNode;
    } else {
      insertNode(node.right, newNode);
    }
  }
}

// 中序遍历
function inOrderTraverseNode(node, callback) {
  if (node === null) return;
  inOrderTraverseNode(node.left, callback);
  callback(node.key);
  inOrderTraverseNode(node.right, callback);
}

// 测试用例;
binaryTreeAccess([1, [2], [3, [4, [5], [6]], [7]]]);
```
::: tip Author
回答者: [kangyana](https://github.com/kangyana)
:::
## 3. 实现一个分组批量执行的任务调度函数 shipTasks
> 使得任务队列里面的N条任务以每组 3 条异步并发执行，任务先进先出，每个分组依次串行执行
注意：（后一组等前一组异步任务执行完之后才执行）

### 解析：此题考查 `Promise.all`

```javascript
function mockTaskFn(task) {
  // 假设这里做了网络请求
  return Promise.resolve({
    name: task.name,
    data: {
      status: 200,
      x: Math.random(),
    },
  });
}

const mockTaskPool = [
  { name: "task1" },
  { name: "task2" },
  { name: "task3" },
  { name: "task4" },
  { name: "task5" },
  { name: "task6" },
  { name: "task7" },
  { name: "task8" },
  { name: "task9" },
  { name: "task10" },
];

async function shipTasks(tasks, amount = 3) {
  const result = [];
  // step 为 3
  for (let i = 0; i < tasks.length; i += amount) {
    await Promise.all(tasks.slice(i, i + amount))
      .then((res) => {
        console.log("批次成功：", res);
        result.push([...res]);
      })
      .catch((err) => {
        console.log("加载失败：", err);
      });
  }
  return result;
}

// 输出任务mock返回值数组
const testFn = async () => {
  const result = await shipTasks(mockTaskPool);
  console.log("全部完毕：", result);
};

// 测试用例
testFn();
```
