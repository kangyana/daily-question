{"react":[{"number":52,"title":"【Q052】React 17、React 18新特性","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/52","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. React 17新特性\r\n北京时间8月11日凌晨，React团队发布了 `React17` 第一个RC版本。该版本的最大特性是“无新特性”。\r\n这次版本更迭确实有“新特性” —— 替换了内部使用的 `启发式更新算法`，这个特性对开发者是无感知的。\r\n\r\n### 为什么会出现启发式更新算法\r\nReact纯JS写法太过灵活，使他在 `编译时优化` 方面先天不足。\r\n所以，React的优化主要在 `运行时`。\r\n\r\n### React16的启发式更新算法\r\n`启发式` 指不通过 **显式的指派**，而是通过 **优先级** 调度更新。\r\n其中优先级来源于 `人机交互的研究成果`。\r\n\r\n例如：\r\n- 当用户在输入框输入内容时，希望输入的内容能实时响应在输入框\r\n- 当异步请求数据后，即使等待一会儿再显示内容，用户也是可以接受的\r\n\r\n基于此在React16中：输入框输入内容触发的更新优先级 > 请求数据返回后触发更新优先级\r\n\r\n### 算法实现\r\n在React16、17中，在组件内执行 this.setState后会在该组件对应的fiber节点内产生一种链表数据结构update。\r\n其中，update.expirationTimes为类似时间戳的字段，表示优先级。\r\nexpirationTimes从字面意义理解为过期时间。\r\n该值离当前时间越接近，该update 优先级越高。\r\n当update.expirationTimes超过当前时间，则代表该update过期，优先级变为最高（即同步）。\r\n一棵fiber树的多个fiber节点可能存在多个update。\r\n每次Fiber Reconciler调度更新时，会在所有fiber节点的所有update.expirationTimes中选择一个expirationTimes（一般选择最大的），作为本次更新的优先级。\r\n并从根fiber节点开始向下构建新的fiber树。\r\n构建过程中如果某个fiber节点包含update，且\r\n```javascript\r\nupdate.expirationTimes >= expirationTimes\r\n```\r\n则该update对应的state变化会体现在本次更新中。\r\n可以理解为：每次更新，都会选定一个优先级（expirationTimes），最终页面会渲染为该优先级对应update的快照。\r\n举个例子，我们有如图所示fiber树，当前还没有更新产生，所以没有构建中的fiber树。\r\n\r\n![Alt](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b2f73db7076434092e735bae2ae3d64~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n当在C创建一个低优先级update，调度更新，本次更新选择的优先级为低优先级。\r\n开始构建新的fiber树（图右侧）。\r\n\r\n![Alt](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a44bdcb3599d41adab5e3b22303bf2de~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n此时，我们在D创建一个高优先级update。\r\n这会中断进行中的低优先级更新，重新开始以高优先级生成一棵fiber树。\r\n由于之前的更新被中断，还没有任何渲染操作，此时视图中（左图）还没有任何变化。\r\n\r\n![Alt](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3aa2edacd0dd4481bc773d244c3a6a4d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n本次更新选定的优先级为高优先级，C的update（低优先级）会被跳过。\r\n更新完成后新的fiber树会被渲染到视图中。\r\n\r\n![Alt](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f2277de78b04fcc81a9310e06b9a48a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n由于C被跳过，所以不会在视图（左图）中体现。\r\n接下来我们在E触发一次高优先级update。\r\nC虽然包含低优先级update，但随着时间的推移，他的expirationTimes已经过期，变为高优先级。\r\n\r\n![Alt](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a67d1f46c524c3fb221fae04fd93954~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n所以本次更新会有C E两个fiber节点产生变化。\r\n最终完成更新后，视图如下：\r\n\r\n![Alt](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02806250332141338705f6e556d9b4dd~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n### 算法缺陷\r\n如果只考虑中断/继续这样的CPU操作，以expirationTimes大小作为衡量优先级依据的模型可以很好工作。\r\n但是expirationTimes模型不能满足IO操作（Suspense）。\r\n在该模型下，高优先级IO任务（Suspense）会中断低优先级CPU任务。\r\n还记得么，每次更新，都是以某一优先级作为整棵树的优先级更新标准，而不仅仅是某一组件，即使更新的源头（update）确实是某个组件产生的。\r\nexpirationTimes模型只能区分是否>=expirationTimes这种情况。\r\n为了拓展Concurrent Mode能力边界，需要一种更细粒度的启发式优先级更新算法。\r\n\r\n### React17启发式更新算法\r\n最理想的模型是：可以指定任意几个优先级，更新会以这些优先级对应update生成页面快照。\r\n但是现有架构下，该方案实现上有瓶颈。\r\n妥协之下，React17的解决方案是：指定一个连续的优先级区间，每次更新都会以区间内包含的优先级生成对应页面快照。\r\n这种优先级区间模型被称为lanes（车道模型）。\r\n具体做法是：使用一个31位的二进制代表31种可能性。\r\n\r\n- 其中每个bit被称为一个lane（车道），代表优先级\r\n- 某几个lane组成的二进制数被称为一个lanes，代表一批优先级\r\n\r\n可以从源码中看到，从蓝线一路划下去，每个bit都对应一个lane或lanes。\r\n\r\n![Alt](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba935553f49e48888fa4742f72e9591e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n当update产生，会根据React16同样的启发式方式，获得如下优先级的一种：\r\n```javascript\r\nexport const SyncLanePriority: LanePriority = 17;\r\nexport const SyncBatchedLanePriority: LanePriority = 16;\r\nexport const InputDiscreteLanePriority: LanePriority = 14;\r\nexport const InputContinuousLanePriority: LanePriority = 12;\r\nexport const DefaultLanePriority: LanePriority = 10;\r\nexport const TransitionShortLanePriority: LanePriority = 8;\r\nexport const TransitionLongLanePriority: LanePriority = 6;\r\n```\r\n\r\n其中值越高，优先级越大。比如：\r\n- 点击事件回调中触发this.setState产生的update会获得InputDiscreteLanePriority。\r\n- 同步的update会获得SyncLanePriority。\r\n\r\n接下来，update会以priority为线索寻找没被占用的lane。\r\n如果当前fiber树已经存在更新且更新的lanes包含了该lane，则update需要寻找其他lane。\r\n比如，InputDiscreteLanePriority对应的lanes为InputDiscreteLanes。\r\n```javascript\r\n// 第4、5位为1\r\nconst InputDiscreteLanes: Lanes = 0b0000000000000000000000000011000;\r\n```\r\n\r\n该lanes包含第4、5位2个bit位。\r\n如果其中\r\n```javascript\r\n// 第五位为1\r\n0b0000000000000000000000000010000\r\n```\r\n\r\n第五位的lane已经被占用，则该update可以尝试占有后一个，即\r\n```javascript\r\n// 第四位为1\r\n0b0000000000000000000000000001000\r\n```\r\n\r\n如果InputDiscreteLanes的两个lane都被占用，则该update的优先级会下降到InputContinuousLanePriority并继续寻找空余的lane。\r\n这个过程就像：购物中心每一层（不同优先级）都有一个露天停车场（lanes），停车场有多个车位（lane）。\r\n我们先开车到顶楼找车位（lane），如果没有车位就下一楼继续找。\r\n直到找到空余车位。\r\n由于lanes可以包含多个lane，可以很方便的区分IO操作（Suspense）与CPU操作。\r\n当构建fiber树进入构建Suspense子树时，会将Suspense的lane插入本次更新选定的lanes中。\r\n当构建离开Suspense子树时，会将Suspense lane从本次更新的lanes中移除。\r\n\r\n### 总结\r\nReact16的expirationTimes模型只能区分是否>=expirationTimes决定节点是否更新。\r\nReact17的lanes模型可以选定一个更新区间，并且动态的向区间中增减优先级，可以处理更细粒度的更新。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. React 18新特性\r\n### Render API\r\n为了更好的管理root节点，React 18 引入了一个新的 root API，新的 root API 还支持 new concurrent renderer（并发模式的渲染），它允许你进入concurrent mode（并发模式）。\r\n```tsx\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './App';\r\n\r\nconst root = document.getElementById('root')!;\r\n\r\n// React 17\r\nReactDOM.render(<App />, root);\r\n\r\n// React 18\r\nReactDOM.createRoot(root).render(<App />);\r\n```\r\n\r\n同时，在卸载组件时，我们也需要将 unmountComponentAtNode 升级为 root.unmount:\r\n```javascript\r\n// React 17\r\nReactDOM.unmountComponentAtNode(root);\r\n\r\n// React 18\r\nroot.unmount();\r\n```\r\n\r\n###  setState 自动批处理\r\n\r\n- 在 18 之前，只有在react事件处理函数中，才会自动执行批处理，其它情况会多次更新\r\n- 在 18 之后，任何情况都会自动执行批处理，多次更新始终合并为一次\r\n\r\n### flushSync\r\n批处理是一个破坏性改动，如果不想批量更新，你可以使用 flushSync：\r\n```tsx\r\nimport React, { useState } from 'react';\r\nimport { flushSync } from 'react-dom';\r\n\r\nconst App: React.FC = () => {\r\n  const [count1, setCount1] = useState(0);\r\n  const [count2, setCount2] = useState(0);\r\n  return (\r\n    <div\r\n      onClick={() => {\r\n        flushSync(() => {\r\n          setCount1(count => count + 1);\r\n        });\r\n        // 第一次更新\r\n        flushSync(() => {\r\n          setCount2(count => count + 1);\r\n        });\r\n        // 第二次更新\r\n      }}\r\n    >\r\n      <div>count1： {count1}</div>\r\n      <div>count2： {count2}</div>\r\n    </div>\r\n  );\r\n};\r\nexport default App;\r\n```"}]},{"number":53,"title":"【Q053】虚拟 DOM 是什么？以及 Diff 算法原理","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/53","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 虚拟 DOM\r\nJS的DOM操作非常消耗性能，而React把DOM转换成了 **JS对象**。这就是虚拟Dom（Virtual Dom）。\r\n\r\n每次数据更新后，重新计算虚拟Dom，并和上一次生成的虚拟dom进行对比，对发生变化的部分作批量更新。\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e8c8a3a50f44088b5409614d7ee8f3a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n当我们需要创建或更新元素时，React首先会让这个VitrualDom对象进行创建和更改，然后再将VitrualDom对象渲染成真实DOM；\r\n当我们需要对DOM进行事件监听时，首先对VitrualDom进行事件监听，VitrualDom会代理原生的DOM事件从而做出响应。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. Diff 算法\r\nReact需要同时维护两棵虚拟DOM树：一棵表示当前的DOM结构，另一棵在React状态变更将要重新渲染时生成。\r\nReact通过比较这两棵树的差异，决定是否需要修改DOM结构，以及如何修改。这种算法称作Diff算法。\r\n\r\n### Diff 算法过程\r\nDiff算法会对新旧两棵树做深度优先遍历，避免对两棵树做完全比较，因此算法复杂度可以达到O(n)。\r\n然后给每个节点生成一个唯一的标志。\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22e96efebcce4b14a679ec218c4a3efe~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n在遍历的过程中，每遍历到一个节点，就将新旧两棵树作比较，并且只对同一级别的元素进行比较。\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/319324b9cfa24c569f6c6f05300cd73f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n也就是只比较图中用虚线连接起来的部分，把前后差异记录下来。\r\n\r\n## 3.Diff 算法策略\r\n### ① tree diff\r\ntree diff主要针对的是React dom节点跨层级的操作。\r\n由于跨层级的DOM移动操作较少，所以React diff算法的tree diff没有针对此种操作进行深入比较，只是简单进行了删除和创建操作。\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e3e3c42eab447a7bd3ef46e9b748e69~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n由此可以发现，当出现节点跨层级移动时，并不会出现想象中的移动操作，而是以 A 为根节点的整个树被重新创建。这是一种影响 React 性能的操作，因此官方建议不要进行 DOM 节点跨层级的操作。\r\n\r\n#### 基于上述原因，在开发组件时，保持稳定的 DOM 结构会有助于性能的提升。例如，可以通过 CSS 隐藏或显示节点，而不是真正地移除或添加 DOM 节点。\r\n\r\n### ② component diff\r\ncomponent diff是专门针对更新前后的同一层级间的React组件比较的diff 算法：\r\n- 如果是同一类型的组件，按照原策略继续比较 Virtual DOM 树可。\r\n- 如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点，即销毁原组件，创建新组件。\r\n- 对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切知道这点，那么就可以节省大量的 diff 运算时间。因此，React 允许用户通过 shouldComponentUpdate()来判断该组件是否需要进行 diff 算法分析。\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/550916d92fc9467f8eb6e5edb20daa52~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n#### 虽然当两个组件是不同类型但结构相似时，diff 会影响性能，但正如 React 官网所言：不同类型的组件很少存在相似 DOM树的情况，因此这种极端因素很难在实际开发过程中造成重大的影响。\r\n\r\n### element diff\r\nelement diff是专门针对同一层级的所有节点的diff算法。\r\n当节点处于同一层级时，diff 提供了 3 种节点操作，分别为 `INSERT_MARKUP`（插入）、`MOVE_EXISTING`（移动）和 `REMOVE_NODE`（删除）。\r\n\r\n我们将虚拟dom树中欲比较的某同一层级的所有节点的集合分别称为新集合和旧集合，则有以下策略：\r\n\r\n- INSERT_MARKUP：新集合的某个类型组件或元素节点不存在旧集合里，即全新的节点，需要对新节点执行插入操作。\r\n- MOVE_EXISTING：新集合的某个类型组件或元素节点存在旧集合里，且 element 是可更新的类型，generateComponent-Children 已调用receiveComponent，这种情况下 prevChild=nextChild，就需要做移动操作，可以复用以前的 DOM 节点。\r\n- REMOVE_NODE：旧集合的某个组件或节点类型，在新集合里也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者旧组件或节点不在新集合里的，也需要执行删除操作。\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fedb1d9dec9b4c25ba106660fd2bb964~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)"}]},{"number":54,"title":"【Q054】key 是干什么的","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/54","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. key 的作用\r\n同一层级的某个节点添加了对于其他同级节点唯一的key属性，当它在当前层级的位置发生了变化后。\r\nreact diff算法通过新旧节点比较后，如果发现了key值相同的新旧节点，就会执行移动操作（然后依然按原策略深入节点内部的差异对比更新），而不会执行原策略的删除旧节点，创建新节点的操作。\r\n这无疑大大提高了React性能和渲染效率。\r\n\r\n## 2. key 的执行过程\r\n对新集合中的节点进行循环遍历，通过唯一的 key 判断新旧集合中是否存在相同的节点。\r\n如果存在相同节点，判断要移动的节点在旧集合中的位置不在最后一位，才进行移动操作。\r\n\r\n## 3. index 可以作为 key 吗？\r\n### React官方建议不要用遍历的index作为这种场景下的节点的key属性值。\r\n比如当前遍历的所有节点类型都相同，其内部文本不同，在用index作key的情况下，当我们对原始的数据list进行了某些元素的顺序改变操作，导致了新旧集合中在进行diff比较时，相同index所对应的新旧的节点其文本不一致了，就会出现一些节点需要更新渲染文本，而如果用了其他稳定的唯一标识符作为key，则只会发生位置顺序变化，无需更新渲染文本，提升了性能。\r\n\r\n## 4. key 的缺点\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce6eb05a24674c51943127fcde856d34~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作。\r\n\r\n## 5. key 使用注意事项\r\n- 如果遍历的列表子节是作为纯展示，而不涉及到列表元素顺序的动态变更，那使用index作为key还是没有问题的。\r\n- key只是针对同一层级的节点进行了diff比较优化，而跨层级的节点互相之间的key值没有影响。\r\n- 如果存在新旧集合中，相同的key值所对应的节点类型不同（比如从span变成div），这相当于完全替换了旧节点，删除了旧节点，创建了新节点。\r\n- key值在比较之前都会被执行toString()操作，所以尽量不要使用object类型的值作为key，会导致同一层级出现key值相同的节点。"}]},{"number":55,"title":"【Q055】Fiber","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/55","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 为什么需要Fiber\r\n在数据更新时，react生成了一棵更大的虚拟dom树，给diff带来了很大压力——我们想找到真正变化的部分，这需要花费更长的时间。\r\njs占据主线程去做比较，渲染线程便无法做其他工作，用户的交互得不到响应，所以便出现了 `Fiber`。\r\n\r\n### Fiber 是 React 16 中新的协调引擎。它的主要目的是使 Virtual DOM 可以进行增量式渲染。\r\n\r\n`Fiber` 没法让比较的时间缩短，但它使得diff的过程 **分割** 成小段，因为它有了“保存工作进度”的能力。\r\njs会比较一部分虚拟dom，然后让渡主线程，给浏览器去做其他工作，然后继续比较，依次往复，等到最后比较完成，一次性更新到视图上。\r\n\r\n## 2. Fiber 是一种新的数据结构\r\n模拟栈的链表\r\n\r\n## 3. Fiber 是纤程\r\n这种数据结构之所以被叫做 `Fiber`，翻译过来是纤程，它被认为是协程的一种实现形式。\r\n协程是比线程更小的调度单位：它的开启、暂停可以被程序员所控制。\r\n具体来说，`Fiber` 是通过 `requestIdleCallback` 去控制的组件渲染的“进度条”。\r\n\r\n`requesetIdleCallback` 是一个属于宏任务的回调，就像 `setTimeout` 一样。\r\n不同的是，`setTimeout` 的执行时机由我们传入的回调时间去控制，`requesetIdleCallback` 是受屏幕的刷新率去控制，每个16s调用一次。\r\n```javascript\r\nconst workLoop = (deadLine) => {\r\n    let shouldYield = false;// 是否该让出线程\r\n    while(!shouldYield){\r\n        console.log('working')\r\n        // 遍历节点等工作\r\n        shouldYield = deadLine.timeRemaining()<1;\r\n    }\r\n    requestIdleCallback(workLoop)\r\n}\r\nrequestIdleCallback(workLoop);\r\n```\r\n\r\n### 4. 总结\r\n`Fiber` 是React 16提出的一种更新机制，使用链表取代了树，将虚拟dom连接，使得组件更新的流程可以被中断恢复；\r\n它把组件渲染的工作分片，到时会主动让出渲染主线程。"}]},{"number":56,"title":"【Q056】React 事件机制和原生事件机制的关系","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/56","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. React 事件机制\r\nReact 实现了一套事件机制，包括事件注册、事件的合成、事件冒泡、事件派发。\r\n`React事件` 和 `原始事件` 是两套机制。 `React事件` 是基于 `原始事件机制` 下完成的。\r\n\r\n### 原生事件机制（捕获阶段-目标元素阶段-冒泡阶段）\r\n事件绑定在对应dom节点上，在合适时机触发。\r\n```javascript\r\ndocument.getElementById().addEventListener('click',()=>{\r\n // ...\r\n})\r\n```\r\n\r\n### React 重写事件处理机制\r\n\r\n- onClick | onInput | onFocus 等为React事件\r\n- 所有React 事件 都绑定在document上\r\n- React 事件是在冒泡阶段触发\r\n- React 事件触发时机后于原生事件\r\n\r\n## 2. 两者的关系\r\n\r\n- React 事件为合成事件（SyntheticEvent）基于原始事件（Event）。\r\n- 原始事件停止冒泡会阻止合成事件触发 ， 相反不会。\r\n- 不建议混用。 理解后可以得心应手。\r\n\r\n## 3. 响应顺序\r\n\r\n- 原生事件捕获阶段\r\n- 原生事件冒泡阶段\r\n- 原生事件冒泡到document ，开始React 事件执行 模拟冒泡"}]},{"number":57,"title":"【Q057】React 生命周期","labels":["react"],"body":"三个废弃的生命周期","url":"https://github.com/kangyana/daily-question/issues/57","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. React 生命周期\r\nReact 16.8+的生命周期分为三个阶段，分别是 `挂载阶段`、`更新阶段`、`卸载阶段`。\r\n\r\n![Alt](https://img-blog.csdnimg.cn/20210515113558981.png)\r\n\r\n## 2. 挂载阶段\r\n\r\n- constructor\r\n构造函数，最先被执行,我们通常在构造函数里初始化 `state` 对象或者给自定义方法绑定 `this`。\r\n- getDerivedStateFromProps\r\n`static getDerivedStateFromProps(nextProps, prevState)`，这是个静态方法，当我们接收到新的属性想去修改 `state`，可以使用 `getDerivedStateFromProps`。\r\n- render\r\n`render` 是纯函数，只返回需要渲染的东西，不应该包含其它的业务逻辑，可以返回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容。\r\n- componentDidMount\r\n组件装载之后调用，此时可以获取到DOM节点并操作，比如对canvas，svg的操作，服务器请求，订阅都可以写在这个里面。\r\n但是记得在`componentWillUnmount`中取消订阅。\r\n\r\n## 3. 更新阶段\r\n\r\n- getDerivedStateFromProps\r\n此方法在更新个挂载阶段都可能会调用。\r\n- shouldComponentUpdate\r\n`shouldComponentUpdate(nextProps, nextState)`，有两个参数 `nextProps` 和 `nextState`，表示新的属性和变化之后的 `state`。\r\n返回一个布尔值，true表示会触发重新渲染，false表示不会触发重新渲染，默认返回true。\r\n我们通常利用此生命周期来优化React程序性能。\r\n- render\r\n更新阶段也会触发此生命周期。\r\n- getSnapshotBeforeUpdate\r\n`getSnapshotBeforeUpdate(prevProps, prevState)`，这个方法在 `render` 之后，`componentDidUpdate` 之前调用。\r\n有两个参数 `prevProps` 和 `prevState`，表示之前的属性和之前的 `state`。\r\n这个函数有一个返回值，会作为第三个参数传给 `componentDidUpdate`，如果你不想要返回值，可以返回 `null`。\r\n此生命周期必须与 `componentDidUpdate` 搭配使用。\r\n- componentDidUpdate\r\n`componentDidUpdate(prevProps, prevState, snapshot)`，该方法在 `getSnapshotBeforeUpdate` 方法之后被调用。\r\n有三个参数 `prevProps`，`prevState`，`snapshot`，表示之前的 `props`，之前的 `state`，和 `snapshot`。\r\n第三个参数是 `getSnapshotBeforeUpdate` 返回的。\r\n如果触发某些回调函数时需要用到 DOM 元素的状态，则将对比或计算的过程迁移至 `getSnapshotBeforeUpdate`，然后在 `componentDidUpdate` 中统一触发回调或更新状态。\r\n\r\n## 4. 卸载阶段\r\n\r\n- componentWillUnmount\r\n当组件被卸载或者销毁了就会调用，我们可以在这个函数里去清除一些定时器，取消网络请求，清理无效的DOM元素等垃圾清理工作。\r\n\r\n## 5. 三个废弃的生命周期\r\nReact 16之后有三个生命周期被废弃：\r\n\r\n- componentWillMount\r\n- componentWillReceiveProps\r\n- componentWillUpdate\r\n\r\n因为这些 `生命周期` 方法容易被误解和滥用。\r\n\r\n### 为什么要废弃这三个生命周期钩子？它们有哪些问题呢？React 又是如何解决的呢？\r\n我们知道 React 的更新流程分为：`render阶段` 和 `commit阶段`。\r\n这三个生命周期钩子都是在 `render阶段` 执行的。\r\n\r\n在 `fiber` 架构被应用之后，低优先级任务的 `render阶段` 可以被高优先级任务打断。\r\n而这导致的问题就是：在 `render阶段` 执行的生命周期函数可能被执行多次，这三个方法也会被执行多次。\r\n\r\n用一个静态函数 `getDerivedStateFromProps` 来取代被废弃的几个生命周期函数，这样开发者就无法通过 `this` 获取到组件的实例，也不能发送网络请求以及调用 `this.setState`。\r\n它就是强制开发者在 `render` 之前只做无副作用的操作，间接强制我们无法进行这些不合理不规范的操作，从而避免对生命周期的滥用。"}]},{"number":58,"title":"【Q058】React 组件性能优化","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/58","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"React 组件性能优化的核心是减少渲染真实DOM 节点的频率，减少 Virtual DOM对比的频率。\r\n\r\n## 1. 组件卸载前进行清理操作\r\n在组件中为 window 注册的全局事件, 以及定时器, 在组件卸载前要清理掉, 防止组件卸载后继续执行影响应用性能。\r\n```javascript\r\nuseEffect(() => {\r\n  let timer = setInterval(() => {\r\n    console.log('timer is running...')\r\n  }, 1000)\r\n\r\n  return () => clearInterval(timer) // 负责执行清理操作\r\n}, [])\r\n```\r\n\r\n## 2. PureComponent 纯组件\r\n### 什么是纯组件\r\n纯组件会对组件输入数据进行浅层比较，如果当前输入数据和上次输入数据相同，组件不会重新渲染。\r\n\r\n### 什么是浅层比较\r\n比较引用数据类型在内存中的引用地址是否相同，比较基本数据类型的值是否相同。\r\n\r\n### 如何实现纯组件\r\n类组件继承 `PureComponent` 类，函数组件使用 `memo` 方法\r\n\r\n### 为什么不直接进行 diff 操作, 而是要先进行浅层比较，浅层比较难道没有性能消耗吗\r\n和进行 `diff` 比较操作相比，浅层比较将消耗更少的性能。\r\n`diff` 操作会重新遍历整颗 `virtualDOM` 树, 而浅层比较只操作当前组件的 `state` 和 `props`。\r\n\r\n## 3. shouldComponentUpdate\r\n纯组件只能进行浅层比较，要进行深层比较，使用 `shouldComponentUpdate`，它用于编写自定义比较逻辑。\r\n返回 `true` 重新渲染组件，返回 `false` 阻止重新渲染。\r\n函数的第一个参数为 `nextProps`, 第二个参数为 `nextState`。\r\n```javascript\r\nshouldComponentUpdate(nextProps, nextState) {\r\n  if (this.state.name !== nextState.name || this.state.age !== nextState.age) {\r\n    return true\r\n  }\r\n  return false\r\n}\r\n```\r\n\r\n## 4. React.memo\r\n### memo 基本使用\r\n将函数组件变为纯组件，将当前 `props` 和上一次的 `props` 进行浅层比较，如果相同就阻止组件重新渲染。\r\n\r\n### 为 memo 传递比较逻辑\r\n使用 `memo` 方法自定义比较逻辑，用于执行深层比较。\r\n比较函数的第一个参数为上一次的 `props` , 比较函数的第二个参数为下一次的 `props`, 比较函数返回 `true`, 不进行渲染, 比较函数返回 `false`, 组件重新渲染。\r\n\r\n## 5. 使用组件懒加载\r\n使用 `lazy`（组件懒加载）可以减少 bundle 文件大小, 加快组件呈递速度。\r\n```javascript\r\nimport React, { lazy } from 'react';\r\n\r\nconst Home = lazy(() => import(/* webpackChunkName: \"Home\" */ \"./Home\"))\r\n```\r\n\r\n## 6. 使用 Fragment 避免额外标记\r\nReact 组件中返回的 jsx 如果有多个同级元素, 多个同级元素必须要有一个共同的父级。\r\n```javascript\r\n<div>\r\n  <div>message a</div>\r\n  <div>message b</div>\r\n</div>\r\n```\r\n\r\n为了满足这个条件我们通常都会在最外层添加一个div, 但是这样的话就会多出一个无意义的标记, 如果每个组件都多出这样的一个无意义标记的话, 浏览器渲染引擎的负担就会加剧。\r\n为了解决这个问题, React 推出了 `fragment` 占位符标记. 使用占位符标记既满足了拥有共同父级的要求又不会多出额外的无意义标记。\r\n```javascript\r\n<>\r\n  <div>message a</div>\r\n  <div>message b</div>\r\n</>\r\n}\r\n```\r\n\r\n## 7. 减少使用内联函数定义\r\n在使用内联函数后, `render` 方法每次运行时都会创建该函数的新实例。\r\n导致 React 在进行 `Virtual DOM` 比对时, 新旧函数比对不相等，导致 React 总是为元素绑定新的函数实例, 而旧的函数实例又要交给垃圾回收器处理。\r\n```javascript\r\n<input onChange={e => this.setState({ inputValue: e.target.value })} />\r\n```\r\n\r\n正确的做法是在组件中单独定义函数, 将函数绑定给事件。\r\n```javascript\r\nsetInputValue = e => {\r\n  this.setState({ inputValue: e.target.value })\r\n}\r\n\r\n<input onChange={this.setInputValue} />\r\n```\r\n\r\n## 8. 在构造函数中进行函数this绑定\r\n在类组件中如果使用 fn() {} 这种方式定义函数, 函数 `this` 默认指向 `undefined`。\r\n也就是说函数内部的 `this` 指向需要被更正。\r\n\r\n可以在构造函数中对函数的 `this` 进行更正, 也可以在行内进行更正, 两者看起来没有太大区别, 但是对性能的影响是不同的。\r\n```javascript\r\nexport default class App extends React.Component {\r\n   constructor() {\r\n    super()\r\n     // 方式一\r\n     // 构造函数只执行一次, 所以函数 this 指向更正的代码也只执行一次.\r\n    this.handleClick = this.handleClick.bind(this)\r\n  }\r\n  handleClick() {\r\n    console.log(this)\r\n  }\r\n  render() {\r\n    // 方式二 \r\n    // 问题: render 方法每次执行时都会调用 bind 方法生成新的函数实例.\r\n    return <button onClick={this.handleClick.bind(this)}>按钮</button>\r\n  }\r\n}\r\n```\r\n\r\n## 9. 类组件中的箭头函数\r\n在类组件中使用箭头函数不会存在 `this` 指向问题, 因为箭头函数本身并不绑定 `this`。\r\n箭头函数在 `this` 指向问题上占据优势，但是同时也有不利的一面。\r\n\r\n当使用箭头函数时，该函数被添加为类的实例对象属性，而不是原型对象属性。\r\n如果组件被多次重用，每个组件实例对象中都将会有一个相同的函数实例，降低了函数实例的可重用性造成了资源浪费。\r\n\r\n综上所述，更正函数内部 `this` 指向的最佳做法仍是在构造函数中使用 `bind` 方法进行绑定。\r\n\r\n## 10. 避免使用内联样式属性\r\n当使用内联 style 为元素添加样式时, 内联 style 会被编译为 JS 代码。\r\n通过 JS 代码将样式规则映射到元素的身上, 浏览器就会花费更多的时间执行脚本和渲染 UI, 从而增加了组件的渲染时间。\r\n\r\n更好的办法是将 CSS 文件导入样式组件，能通过 CSS 直接做的事情就不要通过 JavaScript 去做，因为 JavaScript 操作 DOM 非常慢。\r\n\r\n## 11. 优化条件渲染\r\n频繁的挂载和卸载组件是一项耗性能的操作, 为了确保应用程序的性能, 应该减少组件挂载和卸载的次数。\r\n在 React 中我们经常会根据条件渲染不同的组件，条件渲染是一项必做的优化操作。\r\n```javascript\r\nif (true) {\r\n  return (\r\n    <>\r\n      <AdminHeader />\r\n      <Header />\r\n      <Content />\r\n    </>\r\n  )\r\n} else {\r\n  return (\r\n    <>\r\n      <Header />\r\n      <Content />\r\n    </>\r\n  )\r\n}\r\n\r\n// 改为\r\n\r\nreturn (\r\n  <>\r\n    {true && <AdminHeader />}\r\n    <Header />\r\n    <Content />\r\n  </>\r\n)\r\n```\r\n\r\n## 12. 避免重复无限渲染\r\n当应用程序状态发生更改时, React 会调用 `render` 方法。\r\n如果在 `render` 方法中继续更改应用程序状态, 就会发生 `render` 方法递归调用导致应用报错。\r\n```javascript\r\nrender() {\r\n  this.setState({name: \"李四\"})\r\n  return <div>{this.state.name}</div>\r\n}\r\n```\r\n与其他生命周期函数不同, `render` 方法应该被作为纯函数。\r\n这意味着, 在 `render` 方法中不要做以下事情：\r\n\r\n- 不要调用 `setState` 方法\r\n- 不要使用其他手段查询更改原生 DOM 元素\r\n- 以及其他更改应用程序的任何操作\r\n\r\n`render` 方法的执行要根据状态的改变, 这样可以保持组件的行为和渲染方式一致。\r\n\r\n## 13. 为组件创建错误边界\r\n默认情况下, 组件渲染错误会导致整个应用程序中断, 创建错误边界可确保在特定组件发生错误时应用程序不会中断。\r\n\r\n错误边界涉及到两个生命周期函数, 分别为 `getDerivedStateFromError` 和 `componentDidCatch`。\r\n\r\n## 14. 避免数据结构突变\r\n组件中 `props` 和 `state` 的数据结构应该保持一致, 数据结构突变会导致输出不一致。\r\n\r\n## 15. 依赖优化\r\n按需引入第三方依赖包。\r\n\r\n## 16. 为列表数据添加唯一标识key\r\n\r\n- 可以避免因元素变化而导致重新创建\r\n- 动态列表（排序、过滤、从中间或者顶部删除item）不建议用索引作为key\r\n\r\n## 17. 高阶组件是类组件之间共享逻辑，类中使用较多\r\n什么是高阶组件 Higher Order Component (HOC)\r\n\r\n- 高阶组件是React应用中共享代码、增加逻辑复用的一种方式，比如A组件和B组件都需要使用一个相同的逻辑。可以使用高阶组件将逻辑抽取到一个公共的地方使用。\r\n- 高阶组件的核心思想就是在组件的外层再包裹一层执行逻辑的组件，在外层组件中执行逻辑，再将逻辑执行的结果传递到内容组件。\r\n- 高阶组件由一个函数返回，函数接受组件作为参数，返回一个新的组件，参数组件就是要服用的组件，函数内部返回的新组件就是执行逻辑的组件，在新组件内部执行完逻辑以后再调用参数组件并将逻辑结果传递给参数组件。\r\n\r\n## 18、渲染属性和 Portal\r\n渲染属性类中使用较多 `Portal` 将元素渲染到任何根元素"}]},{"number":59,"title":"【Q059】React.memo","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/59","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. React.memo\r\n`React.memo` 为 `高阶组件`。\r\n`props` 不变的情况下渲染，可以使用 `memo` 将组件包起来，通过记忆组件渲染结果的方式来提高组件的性能表现。\r\n相当于，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。\r\n\r\n`memo` 仅检查 `props` 变更，如果有其他状态改变，它仍会重新渲染。\r\n\r\n默认情况下其只会对复杂对象做浅层对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。\r\n```javascript\r\nfunction MyComponent(props) {\r\n  /* 使用 props 渲染 */\r\n}\r\nexport default React.memo(MyComponent, (prevProps, nextProps) => {\r\n  /*\r\n  如果把 nextProps 传入 render 方法的返回结果与\r\n  将 prevProps 传入 render 方法的返回结果一致则返回 true，\r\n  否则返回 false\r\n  */\r\n});\r\n```\r\n\r\n### 此方法仅作为 **性能优化** 的方式而存在。但请不要依赖它来“阻止”渲染，因为这会产生 bug。\r\n\r\n## 2. 与 shouldComponentUpdate() 的区别\r\n`memo` 的第二个参数 areEqual 的返回值是`props` 判断相等，\r\n`shouldComponentUpdate` 的返回值恰好相反，是 `props` 判断不等。"}]},{"number":60,"title":"【Q060】props.children","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/60","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. props.children\r\n每个组件都可以获取到 `props.children`。它包含组件的开始标签和结束标签之间的内容。例如：\r\n```html\r\n<Welcome>Hello world!</Welcome>\r\n```\r\n\r\n在 Welcome 组件中获取 props.children，就可以得到字符串 Hello world!：\r\n```javascript\r\nfunction Welcome(props) {\r\n  return <p>{props.children}</p>;\r\n}\r\n```\r\n\r\n对于 class 组件，请使用 this.props.children 来获取：\r\n```javascript\r\nclass Welcome extends React.Component {\r\n  render() {\r\n    return <p>{this.props.children}</p>;\r\n  }\r\n}\r\n```\r\n\r\n## 2. props.children 的数据类型\r\n`props.children` 的值有三种可能：\r\n\r\n- 如果当前组件没有子节点，它就是 `undefined`；\r\n- 如果有一个子节点，数据类型是 `object`；\r\n- 如果有多个子节点，数据类型就是 `array`。\r\n\r\n### 判断数据类型\r\n使用 `isValidElement()` 可以判断是是否为 React元素(object)。\r\n```javascript\r\nReact.isValidElement(object)\r\n```\r\n\r\n## 3. React.Children 方法\r\nReact 提供了工具方法 `React.Children` 来处理 `props.children`。\r\n\r\n### React.Children.map\r\n在 `children` 里的每个直接子节点上调用一个函数，并将 `this` 设置为 `thisArg`。\r\n如果 `children` 是一个数组，它将被遍历并为数组中的每个子节点调用该函数。\r\n如果子节点为 `null` 或是 `undefined`，则此方法将返回 `null` 或是 `undefined`，而不会返回数组。\r\n```javascript\r\nReact.Children.map(children, function[(thisArg)])\r\n```\r\n\r\n### React.Children.forEach\r\n与 `React.Children.map()` 类似，但它不会返回一个数组。\r\n```javascript\r\nReact.Children.forEach(children, function[(thisArg)])\r\n```\r\n\r\n### React.Children.count\r\n返回 `children` 中的组件总数量，等同于通过 `map` 或 `forEach` 调用回调函数的次数。\r\n```javascript\r\nReact.Children.count(children)\r\n```\r\n\r\n### React.Children.only\r\n验证 `children` 是否只有一个子节点（一个 React 元素），如果有则返回它，否则此方法会抛出错误。\r\n```javascript\r\nReact.Children.only(children)\r\n```\r\n\r\n### React.Children.toArray\r\n将 `children` 这个复杂的数据结构以数组的方式扁平展开并返回，并为每个子节点分配一个 `key`。\r\n当你想要在渲染函数中操作子节点的集合时，它会非常实用，特别是当你想要在向下传递 `props.children` 之前对内容重新排序或获取子集时。\r\n```javascript\r\nReact.Children.toArray(children)\r\n```\r\n\r\n注意：此方法会重写 `key`，给 `key` 一个 `.$` 前缀。\r\n![Alt](https://raw.githubusercontent.com/kangyana/img-storage/master/toArray_key.png)"}]},{"number":61,"title":"【Q061】content","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/61","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. content\r\n`Context`（上下文） 提供了一个无需为每层组件手动添加 `props`，就能在组件树间进行数据传递的方法。\r\n\r\n## 2. 何时使用 Context\r\n`Context` 设计目的是为了共享那些对于一个组件树而言是 **全局的数据**，例如当前认证的用户、主题或首选语言。\r\n\r\n## 3. 使用 Context 之前的考虑\r\n`Context` 主要应用场景在于很多不同层级的组件需要访问同样一些的数据。请谨慎使用，因为这会使得组件的复用性变差。\r\n\r\n如果你只是想避免层层传递一些属性，`组件组合（component composition）` 有时候是一个比 context 更好的解决方案。\r\n\r\n## 4. Content 的API\r\n### React.createContext\r\n创建一个 `Context` 对象。\r\n当 React 渲染一个订阅了这个 `Context` 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 `Provider` 中读取到当前的 `context` 值。\r\n```javascript\r\nconst MyContext = React.createContext(defaultValue);\r\n```\r\n\r\n### Context.Provider\r\nProvider 接收一个 value 属性，传递给消费组件。\r\n当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。\r\n```javascript\r\n<MyContext.Provider value={/* 某个值 */}>\r\n```\r\n\r\n### Context.Consumer\r\n一个 React 组件，它可以订阅 `context` 的变更。\r\n此组件可以让你在 `函数式组件` 中可以订阅 `context`。\r\n```javascript\r\n<MyContext.Consumer>\r\n  {value => /* 基于 context 值进行渲染*/}\r\n</MyContext.Consumer>\r\n```\r\n\r\n### Context.displayName\r\n`context` 对象接受一个名为 `displayName` 的 属性，类型为字符串。\r\nReact DevTools 使用该字符串来确定 `context` 要显示的内容。\r\n```javascript\r\nconst MyContext = React.createContext(/* some value */);\r\nMyContext.displayName = 'MyDisplayName';\r\n\r\n<MyContext.Provider> // \"MyDisplayName.Provider\" 在 DevTools 中\r\n<MyContext.Consumer> // \"MyDisplayName.Consumer\" 在 DevTools 中\r\n```\r\n\r\n## 5. 注意事项\r\n`context` 根据 `value` 属性值的浅比较来决定何时进行渲染。\r\n当 `provider` 的父组件进行重渲染时，可能会在 `consumers` 组件中触发意外的渲染。\r\n\r\n当每一次 `Provider` 重渲染时，由于 `value` 属性总是被赋值为新的对象，以下的代码会重新渲染下面所有的 `consumers` 组件：\r\n```javascript\r\nclass App extends React.Component {\r\n  render() {\r\n    return (\r\n      <MyContext.Provider value={{something: 'something'}}>\r\n        <Toolbar />\r\n      </MyContext.Provider>\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n为了防止这种情况，将 `value` 状态提升到父节点的 `state` 里：\r\n```javascript\r\nclass App extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      value: {something: 'something'},\r\n    };\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <MyContext.Provider value={this.state.value}>\r\n        <Toolbar />\r\n      </MyContext.Provider>\r\n    );\r\n  }\r\n}\r\n```"}]},{"number":62,"title":"【Q062】setState 是同步还是异步？","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/62","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. setState 是同步还是异步？\r\n`setState` 是异步的，但不是 `setTimeout`、`Promise` 那种异步，只是指 `setState` 之后是否 `state` 马上变了，是否马上 `render`。\r\n`setState` 会创建 `update` 对象挂到 `fiber` 对象上，然后调度 `performSyncWorkOnRoot` 重新渲染。\r\n\r\n在 react17 中，`setState` 是批量执行的，因为执行前会设置 `executionContext`。\r\n但如果在 `setTimeout`、事件监听器等函数里，就不会设置 `executionContext` 了，这时候 `setState` 会同步执行。\r\n可以在外面包一层 `batchUpdates` 函数，手动设置下 `excutionContext` 来切换成异步批量执行。\r\n\r\n在 react18 里面，如果用 `createRoot` 的 api，就不会有这种问题了。\r\n`setState` 是同步还是异步这个问题等 react18 普及以后就不会再有了，因为所有的 `setState` 都是异步批量执行了。"}]},{"number":63,"title":"【Q063】setState 批更新","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/63","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. setState 同步更新还是异步更新？\r\n### React18 以前的版本\r\nreact 事件中，`setState` 是异步更新的。\r\n但是在 `setTimeout` 、`addEventListener` 添加的原生事件中，`setState` 则是同步的。\r\n\r\n```javascript\r\n// Legacy同步模式\r\n\r\nconst container = document.getElementById('root');\r\nReactDOM.render(<App />, container);\r\n```\r\n\r\n### React18 以后\r\n`setState` 的更新统一是异步的。\r\n```javascript\r\n// Concurrent异步模式，在这个模式下，任何情况下setState都是异步更新的。目前createRoot方法还在实验中\r\n\r\nconst container = document.getElementById('root');\r\nReactDOM.createRoot(container).render(<App />)\r\n```\r\n\r\n## 2. setState 批更新\r\n在 React 18 之前，如果在回调函数的异步调用中，执行 `setState`，由于丢失上下文，无法做合并处理。\r\n所以每次 `setState` 调用都会触发一次 **重新渲染**。\r\n```javascript\r\nfunction handleClick() {\r\n\t// React 18 之前的版本\r\n\t(/*...*/).then(() => {\r\n\t\tsetCount(c => c + 1); // 立刻重新渲染\r\n\t\tsetShow(show => !show); // 立刻重新渲染\r\n\t});\r\n}\r\n```\r\n\r\nReact 18中，任何情况下都可以合并渲染！\r\n如果仍然希望setState之后立即重新渲染，只需要使用 `flushSync` 包裹。\r\n```javascript\r\nfunction handleClick() {\r\n\t// React 18\r\n\tfecth(/*...*/).then(() => {\r\n\t\tReactDOM.flushSync(() => {\r\n\t\t\tsetCount(c => c + 1); // 立刻重新渲染\r\n\t\t\tsetFlag(f => !f);\r\n\t\t})\r\n\t})\r\n}\r\n```\r\n"}]},{"number":64,"title":"【Q064】组件通信","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/64","comments":[]},{"number":65,"title":"【Q065】高阶组件原理","labels":["react"],"body":"有哪些常见的高阶组件？","url":"https://github.com/kangyana/daily-question/issues/65","comments":[]},{"number":66,"title":"【Q066】受控组件和非受控组件","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/66","comments":[]},{"number":67,"title":"【Q067】为什么要是用 React Hooks?","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/67","comments":[]},{"number":68,"title":"【Q068】React Hooks 实现原理","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/68","comments":[]},{"number":69,"title":"【Q069】React Hooks 使用原则，以及为什么","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/69","comments":[]},{"number":70,"title":"【Q070】React Hooks 使用中常见问题","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/70","comments":[]},{"number":71,"title":"【Q071】官方自带的 Hooks","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/71","comments":[]},{"number":72,"title":"【Q072】useEffect 和 useLayoutEffect 的区别","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/72","comments":[]},{"number":73,"title":"【Q073】useMemo 和 useCallback 的区别","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/73","comments":[]},{"number":74,"title":"【Q074】如何自己封装一个 Hooks","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/74","comments":[]},{"number":75,"title":"【Q075】Suspense","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/75","comments":[]},{"number":76,"title":"【Q076】Concurrent","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/76","comments":[]},{"number":77,"title":"【Q077】startTransition","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/77","comments":[]},{"number":78,"title":"【Q078】Server Component","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/78","comments":[]},{"number":79,"title":"【Q079】componentDidCatch","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/79","comments":[]},{"number":80,"title":"【Q080】SSR","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/80","comments":[]},{"number":81,"title":"【Q081】为什么需要用 redux","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/81","comments":[]},{"number":82,"title":"【Q082】react-redux 是干什么的","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/82","comments":[]},{"number":83,"title":"【Q083】react-redux content 实现原理","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/83","comments":[]},{"number":84,"title":"【Q084】redux 工作流程及原理","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/84","comments":[]},{"number":85,"title":"【Q085】有没有用过其它状态管理器？以及原理","labels":["react"],"body":"mobx","url":"https://github.com/kangyana/daily-question/issues/85","comments":[]},{"number":86,"title":"【Q086】react-router 路由实现原理","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/86","comments":[]},{"number":87,"title":"【Q087】react-router 有几种路由类型？","labels":["react"],"body":"每种路由类型实现原理","url":"https://github.com/kangyana/daily-question/issues/87","comments":[]},{"number":88,"title":"【Q088】项目本地开发完成后部署到服务器后报 404","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/88","comments":[]}]}