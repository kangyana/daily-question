{"javascript":[{"number":1,"title":"【Q001】js 有几种基本的数据类型","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/1","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"### 6种基本数据类型。\r\n\r\n- String 字符串\r\n- Number 数字\r\n- Boolean 布尔值\r\n- Null 空\r\n- Undefined 未定义\r\n- Symbol （es6新增）\r\n\r\n### 5种引用数据\r\n\r\n- Object 对象\r\n- Array 数组\r\n- Function 函数\r\n- RegExp 正则\r\n- Date 日期"}]},{"number":2,"title":"【Q002】如何判断 js 数据类型","labels":["javascript"],"body":"基础类型和复杂类型","url":"https://github.com/kangyana/daily-question/issues/2","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"### typeof用于判断基本数据类型，无法区分object、array、null\r\n```javascript\r\n    typeof 1 // 'number'\r\n    typeof \"1\" // 'string'\r\n    typeof undefined // 'undefined'\r\n    \r\n    typeof null // 'object'\r\n    typeof [] // 'object'\r\n    typeof {} // 'object'\r\n    typeof function() {} // 'function'\r\n```\r\n\r\n### 区分object和array，可以使用`Array.isArray()`\r\n```javascript\r\n    Array.isArray([1, 2, 3]); // true\r\n    Array.isArray({foo: 123}); // false\r\n    Array.isArray(\"foobar\"); // false\r\n    Array.isArray(undefined); // false\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"一条友善的评论"}]},{"number":3,"title":"【Q003】typeof和instanceof的区别","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/3","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 一、typeof\r\n`typeof`操作符返回一个字符串，表示未经计算的操作数的类型。\r\n\r\n语法：\r\n```javascript\r\ntypeof operand\r\n```\r\n\r\n|类型 | 结果 |\r\n| ---- | ---- |\r\n| undefined | `\"undefined\"` |\r\n| boolean | `\"boolean\"` |\r\n| string | `\"string\"` |\r\n| symbol | `\"symbol\"` |\r\n| bigInt | `\"bigint\"` |\r\n| function | `\"function\"` |\r\n| object \\| array \\| null | `\"object\"` |\r\n\r\n由上表可得知，`typeof`是无法区分`object` | `array` | `null`类型的。\r\n\r\n## 二、instanceof\r\n`instanceof` 运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。\r\n\r\n语法：\r\n```javascript\r\nobject instanceof constructor\r\n```\r\n\r\n只能用于构造函数，无法用于基础类型。\r\n\r\n## 三、总结区别\r\n`typeof`与`instanceof`都是判断数据类型的方法，区别如下：\r\n\r\n- `typeof`会返回一个变量的基本类型，instanceof返回的是一个布尔值。\r\n- `instanceof` 可以准确地判断复杂引用数据类型，但是无法判断基本类型。\r\n- `typeof`无法判断除了`function`外的引用类型。\r\n"}]},{"number":4,"title":"【Q004】如何判断一个变量是不是Array","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/4","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. instanceof 判断\r\n```javascript\r\nvar arr = [1,2,3];\r\narr instanceof Array; // true\r\narr instanceof Object; // false\r\n\r\nvar obj = {id:1};\r\nobj instanceof Array; // false\r\nobj instanceof Object; // true\r\n```\r\n\r\n## 2. 构造函数 判断\r\n```javascript\r\nvar arr = [1,2,3];\r\narr.__proto__.constructor === Array; //  true\r\n\r\nvar obj = {id:1};\r\nobj.__proto__.constructor === Object; // true\r\n```\r\n\r\n## 3. toString() 判断\r\n```javascript\r\nvar arr = [1,2,3];\r\nObject.prototype.toString.call(arr);  // [object Array]\r\n\r\nvar obj = {id:1};\r\nObject.prototype.toString.call(obj); // [object Object]\r\n```\r\n\r\n## 4. Array.isArray() 判断\r\n```javascript\r\nvar arr = [1,2,3];\r\nArray.isArray(arr); //  true\r\n\r\nvar obj = {id:1};\r\nArray.isArray(obj); // false\r\n```"}]},{"number":5,"title":"【Q005】==和===有什么不同","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/5","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. ==\r\n等于运算符 `==` 检查其两个操作数是否相等，并返回 `Boolean` 结果。\r\n同时会尝试强制类型转换。\r\n\r\n隐式转换：\r\n`string` 和 `number` 比较时，会自动转换为 `number` 类型。\r\n\r\n## 2. ===\r\n全等运算符 `===` 检查其两个操作数是否相等，并返回 `Boolean` 结果。\r\n它总是认为不同类型的操作数是不同的。\r\n\r\n## 3. 区别\r\n\r\n- `==` 不会比较数据类型，`===` 会检查类型\r\n- `==`会隐式转换"}]},{"number":6,"title":"【Q006】事件机制","labels":["javascript"],"body":"事件循环","url":"https://github.com/kangyana/daily-question/issues/6","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"JavaScript 有一个基于 **事件循环** 的并发模型，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。\r\n\r\n## 1. 可视化描述\r\n![Alt](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop/the_javascript_runtime_environment_example.svg)\r\n\r\n## 2. 栈（stack)\r\n栈是由多个 **函数调用** 形成的 **帧** 组成\r\n\r\n```javascript\r\nfunction foo(b) {\r\n  let a = 10;\r\n  return a + b + 11;\r\n}\r\n\r\nfunction bar(x) {\r\n  let y = 3;\r\n  return foo(x * y);\r\n}\r\n\r\nconsole.log(bar(7)); // 42\r\n```\r\n\r\n当调用 `bar` 时，第一个帧被创建并压入栈中，帧中包含了 `bar` 的参数和局部变量。\r\n当 `bar` 调用 `foo` 时，第二个帧被创建并被压入栈中，放在第一个帧之上，帧中包含 `foo` 的参数和局部变量。\r\n当 `foo` 执行完毕然后返回时，第二个帧就被弹出栈（剩下 `bar` 函数的调用帧 ）。\r\n当 `bar` 也执行完毕然后返回时，第一个帧也被弹出，栈就被清空了。\r\n\r\n## 3. 堆（heap）\r\n堆是放 **object** 的 **内存区域**\r\n\r\n## 4. 队列（queue）\r\n队列是 **待处理消息的消息队列**，每一个消息都关联着一个用以处理这个消息的回调函数。\r\n\r\n在 **事件循环** 期间的某个时刻，运行时会从最先进入队列的消息开始处理队列中的消息。\r\n被处理的消息会被移出队列，并作为输入参数来调用与之关联的函数。\r\n正如前面所提到的，调用一个函数总是会为其创造一个新的栈帧。\r\n\r\n函数的处理会一直进行到执行栈再次为空为止；然后事件循环将会处理队列中的下一个消息。\r\n\r\n## 5. 事件循环（event loop）\r\n之所以称之为 **事件循环**，是因为它经常按照类似如下的方式来被实现：\r\n\r\n```javascript\r\nwhile (queue.waitForMessage()) {\r\n  queue.processNextMessage();\r\n}\r\n```\r\n\r\n`queue.waitForMessage()` 会同步地等待消息到达 "}]},{"number":7,"title":"【Q007】事件委托","labels":["javascript"],"body":"事件流、事件冒泡","url":"https://github.com/kangyana/daily-question/issues/7","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 事件委托\r\n将事件侦听器添加到一个父级元素上。\r\n这样就只用添加一次事件侦听器，可以避免向很多 DOM 节点添加多个事件侦听器。\r\n\r\n## 2. 事件冒泡\r\n事件委托的实现是利用 **事件冒泡** 的机制。\r\n事件流：事件的触发会从最底层的 DOM 元素开始发生，一直向上传播，直到 document 对象。\r\n\r\n## 3. 优点\r\n\r\n- 减少了内存消耗，优化程序性能\r\n- 动态绑定事件，减少重复工作"}]},{"number":8,"title":"【Q008】e.preventDefault()是干什么的","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/8","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"- **e.preventDefault()** 取消默认事件\r\n- **e.stopPropagation()** 防止冒泡和捕获 \r\n"}]},{"number":9,"title":"【Q009】JS中this是如何工作的","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/9","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"**this** 永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。\r\n\r\n## 1. 全局环境中\r\n`this` 指向全局对象\r\n\r\n```javascript\r\n// 在浏览器中\r\nconsole.log(this === window); // true\r\n\r\n// 在 Node 中\r\nconsole.log(this === globalThis); // true\r\n```\r\n## 2. 函数内部\r\n`this` 的值取决于函数被调用的方式。\r\n\r\n非严格模式下，`this` 的值默认指向全局对象\r\n```javascript\r\nfunction f1(){\r\n  return this;\r\n}\r\n\r\nf1() === window;   // true\r\n```\r\n\r\n严格模式下，如果进入执行环境时没有设置 `this` 的值，`this` 会保持为 `undefined`\r\n```javascript\r\nfunction f2(){\r\n  \"use strict\";\r\n  return this;\r\n}\r\n\r\nf2() === undefined; // true\r\n```\r\n\r\n如果要想把 `this` 的值从一个环境传到另一个，就要用 `call` 或者 `apply` 方法\r\n\r\n## 3. 类内部\r\n`this` 在 `类` 中的表现与在函数中类似，因为类本质上也是函数，但也有一些区别和注意事项\r\n\r\n在类的构造函数中，this 是一个常规对象。类中所有 **非静态的方法** 都会被添加到 `this` 的原型中\r\n```javascript\r\nclass Example {\r\n  constructor() {\r\n    const proto = Object.getPrototypeOf(this);\r\n    console.log(Object.getOwnPropertyNames(proto));\r\n  }\r\n  first(){}\r\n  second(){}\r\n  static third(){}\r\n}\r\n\r\nnew Example(); // ['constructor', 'first', 'second']\r\n```\r\n## 4. 派生类内部\r\n派生类的构造函数没有初始的 `this` 绑定，在调用 super() 之前引用 `this` 会报错\r\n\r\n## 5. bind()后\r\n`this` 的值指向绑定的参数\r\n```javascript\r\nfunction f(){\r\n  return this.a;\r\n}\r\n\r\nvar g = f.bind({a:\"azerty\"});\r\nconsole.log(g()); // azerty\r\n```\r\n\r\n## 6. 箭头函数内部\r\n`this` 的值指向外部环境，相当于传递了 `this`"}]},{"number":10,"title":"【Q010】apply、call、bind的区别，及源码实现","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/10","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. apply()\r\n`apply()` 方法调用一个具有给定 `this` 值的函数，以及以一个数组的形式提供的参数\r\n```javascript\r\nconst numbers = [5, 6, 2, 3, 7];\r\n\r\nconst max = Math.max.apply(null, numbers); // 7\r\n```\r\n\r\n源码实现\r\n```javascript\r\nFunction.prototype.myApply = function (context, args) {\r\n    context = context || window;\r\n    let fn = Symbol();\r\n    context[fn] = this;\r\n    return context[fn](...args);\r\n}\r\n```\r\n\r\n## 2. call()\r\n`call` 方法使用一个指定的 `this` 值和单独给出的一个或多个参数来调用一个函数\r\n\r\n可以用来实现 **继承**\r\n```javascript\r\nfunction Product(name, price) {\r\n  this.name = name;\r\n  this.price = price;\r\n}\r\n\r\nfunction Food(name, price) {\r\n  Product.call(this, name, price);\r\n  this.category = 'food';\r\n}\r\n\r\nconsole.log(new Food('cheese', 5).name); // cheese\r\n```\r\n\r\n源码实现，与apply区别只有参数变化\r\n```javascript\r\nFunction.prototype.myCall = function (context, ...args) {\r\n    context = context || window;\r\n    let fn = Symbol();\r\n    context[fn] = this;\r\n    return context[fn](...args);\r\n}\r\n```\r\n\r\n## 3. bind()\r\n`bind()` 方法创建一个新的函数，在 ·bind()· 被调用时，这个新函数的 this 被指定为 `bind()` 的第一个参数，而其余参数将作为新函数的参数\r\n\r\n```javascript\r\nconst module = {\r\n  x: 42,\r\n  getX: function() {\r\n    return this.x;\r\n  }\r\n};\r\n\r\nconst unboundGetX = module.getX;\r\nconsole.log(unboundGetX()); // undefined（函数内this指向全局）\r\n\r\nconst boundGetX = unboundGetX.bind(module);\r\nconsole.log(boundGetX()); // 42\r\n```\r\n\r\n源码实现\r\n```javascript\r\n\r\nFunction.prototype.myBind = function (context) {\r\n    const self = this\r\n    const args = Array.from(arguments).slice(1)\r\n \r\n    return function F() {\r\n        const newArgs = args.concat([...arguments])\r\n        if (this instanceof F) {\r\n            return new self(...newArgs)\r\n        } else {\r\n            return self.apply(context, newArgs)\r\n        }\r\n    }\r\n```\r\n\r\n## 4. 区别\r\n\r\n- `apply` 与 `call` 非常相似，`call` 接受一个参数列表，而 `apply` 接受一个参数的单数组\r\n- `call`、`apply` 是直接调用，`bind` 是返回某个函数，等待某个状态触发再执行\r\n\r\n"}]},{"number":11,"title":"【Q011】js中new关键字原理","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/11","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## new原理\r\n`new` 操作符用来创建构造函数的实例，以这种方式调用构造函数会执行如下操作：\r\n\r\n- 在内存中创建一个新对象；\r\n- 这个对象内部的[[Prototype]]特性被复制为构造函数的prototype属性;\r\n- 构造函数内部的this被复制为这个新对象（即this指向新对象）；\r\n- 执行构造函数内部的代码（给新对象添加属性）；\r\n- 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新实例。\r\n\r\n## 代码实现\r\n\r\n1. 使用Object.create继承prototype属性\r\n```javascript\r\nfunction myNew (constructor, ...args) {\r\n    var obj = Object.create(constructor.prototype);\r\n    var result = constructor.apply(obj, args);\r\n    return typeof result === 'object' ? result : obj;\r\n}\r\n```\r\n\r\n2. 重写新对象的__proto__属性\r\n```javascript\r\nfunction myNew (constructor, ...args) {\r\n    var obj = new Object();\r\n    obj.__proto__  = constructor.prototype;\r\n    var result = constructor.apply(obj, args);\r\n    return typeof result === 'object' ? result : obj;\r\n}\r\n```"}]},{"number":12,"title":"【Q012】JS 中继承是如何实现的","labels":["javascript"],"body":"7种方法","url":"https://github.com/kangyana/daily-question/issues/12","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 原型链\r\n让一个 **构造函数** 的原型是另一个类型的实例，`new` 出来的实例\r\n```javascript\r\nfunction Person () {\r\n  this.name = 'zs';\r\n}\r\n\r\nfunction Man () {};\r\nMan.prototype = new Person();\r\n\r\nnew Man().name // 'zs'\r\n```\r\n\r\n优点：写法方便简洁，容易理解\r\n缺点：对象实例共享所有继承的属性和方法。传教子类型实例的时候，不能传递参数，因为这个对象是一次性创建的（没办法定制化）\r\n\r\n## 2. 借用构造函数继承\r\n在子类型构造函数的内部调用父类型构造函数；使用 apply() 或 call() 方法将父对象的构造函数绑定在子对象上\r\n```javascript\r\nfunction Person (name) {\r\n  this.name = name;\r\n}\r\n\r\nfunction Man (name) {\r\n  Person.call(this, name)\r\n};\r\n```\r\n\r\n优点：解决了原型链实现继承的不能传参的问题和父类的原型共享的问题\r\n缺点：借用构造函数的缺点是方法都在构造函数中定义，因此无法实现函数复用。在父类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式\r\n\r\n## 3. 组合继承（经典继承）\r\n将 `原型链` 和 `借用构造函数` 的组合到一块。\r\n使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。\r\n\r\n```javascript\r\nfunction Person (name) {\r\n  this.name = name;\r\n}\r\nPerson.prototype.sayName = function () {\r\n  console.log('My name is ' + this.name);\r\n}\r\n\r\nfunction Man (name) {\r\n  Person.call(this, name)\r\n};\r\nMan.prototype = new Person();\r\n\r\nnew Man('zs').sayName  // 'My name is zs'\r\n```\r\n\r\n优点: 解决了原型链继承和借用构造函数继承造成的影响\r\n缺点: 无论在什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部\r\n\r\n## 4. 原型式继承\r\n创建一个新对象，挂到新建对象的原型上\r\n```javascript\r\nfunction Person () {\r\n  this.name = 'zs';\r\n}\r\n\r\nvar man = Object.create(Person);\r\n\r\nman.name // 'zs'\r\n```\r\n优点是：不需要单独创建构造函数\r\n缺点是：属性中包含的引用值始终会在相关对象间共享，子类实例不能向父类传参\r\n\r\n## 5. 寄生式继承\r\n寄生式继承的思路与(寄生) `原型式继承` 和 `工厂模式` 似, 即创建一个仅用于封装继承过程的函数,该函数在内部以某种方式来增强对象,最后再像真的是它做了所有工作一样返回对象\r\n\r\n```javascrip\r\nfunction objectCopy(obj) {\r\n  function Fun() { };\r\n  Fun.prototype = obj;\r\n  return new Fun();\r\n}\r\n\r\nfunction createAnother(obj) {\r\n  let clone = objectCopy(obj);\r\n  clone.sayName = function () {\r\n    console.log('My name is ' + this.name);\r\n  };\r\n  return clone;\r\n}\r\n\r\nvar person = { name: 'zs' };\r\n\r\ncreateAnother(person).sayName(); // 'My name is zs'\r\n```\r\n\r\n优点：写法简单，不需要单独创建构造函数\r\n缺点：通过寄生式继承给对象添加函数会导致函数难以复用\r\n\r\n## 6. 寄生组合式继承\r\n通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型\r\n\r\n```javascript\r\n// ...\r\nfunction inheritPrototype(child, parent) {\r\n  let prototype = objectCopy(parent.prototype);\r\n  prototype.constructor = child;\r\n  Child.prototype = prototype;\r\n}\r\n```\r\n优点是：高效率只调用一次父构造函数，并且因此避免了在子原型上面创建不必要，多余的属性。与此同时，原型链还能保持不变\r\n缺点是：代码复杂\r\n\r\n# 7. Class实现继承\r\n优点：语法简单易懂,操作更方便\r\n缺点：并不是所有的浏览器都支持class关键字\r\n"}]},{"number":13,"title":"【Q013】JS 原型和原型链","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/13","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 原型\r\n每个函数都有一个特殊的属性叫作 `原型（prototype）`\r\n每个对象都有一个属性叫作 `__proto__`，这个属性会指向该对象的原型\r\n每个原型都有一个 `constructor` 属性指向关联的构造函数\r\n\r\n## 2. 原型链\r\n当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止\r\n这种原型组成的链状结构就是 `原型链`"}]},{"number":14,"title":"【Q014】闭包与作用域链","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/14","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 作用域\r\n`作用域` 是指程序源代码中 **定义变量** 的区域\r\n作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限\r\n\r\n## 2. 作用域链\r\n当访问一个变量时，解释器会首先在当前作用域查找，如果没有找到，就去父作用域找，直到找到该变量或者不在父作用域中，这就是 `作用域链`\r\n\r\n## 3. 闭包\r\n`闭包` 是指有权访问另外一个函数作用域中的变量的 `函数`\r\n闭包是将函数内部和函数外部连接起来的桥梁\r\n\r\n优点：\r\n\r\n- 闭包里的变量不会污染全局，因为变量被封在闭包里\r\n- 所有变量都在闭包里保证了隐私性和私有性\r\n- 可以让这些局部变量保存在内存中，实现变量数据共享\r\n\r\n缺点：\r\n形成闭包即要把一个函数当成值传递，而且该函数还引用这另一个函数的作用域链使得被引用的函数不能被回收，使用不当容易造成内存泄漏\r\n"}]},{"number":15,"title":"【Q015】let、const、var的区别","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/15","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. var\r\n`var` 语句 用于声明一个函数范围或全局范围的变量，并可将其初始化为一个值（可选）。\r\n\r\n用 `var` 声明的变量的作用域是它当前的执行上下文及其闭包（嵌套函数），或者对于声明在任何函数外的变量来说是全局。\r\n`var` 声明的变量，会提升到该作用域的最顶部。\r\n\r\n## 2. let\r\n`let` 语句声明一个块级作用域的局部变量，并可以初始化为一个值（可选）。\r\n\r\n与 `var` 关键字不同的是，`var` 声明的变量作用域是全局或者整个函数块的。\r\n`var` 和 `let` 的另一个重要区别，`let` 声明的变量不会在作用域中被提升，它是在编译时才初始化。\r\n\r\n## 3. const\r\n常量是块级范围的，非常类似用 `let`。但常量的值是无法（通过重新赋值）改变的，也不能被重新声明。\r\n\r\n`const` 声明创建一个值的只读引用。变量标识符不能重新分配，但改变对象的内容。\r\n\r\n## 4. 区别\r\n\r\n- `var` 在全局作用域声明的变量会变成全局变量，例如浏览器环境下挂载在window对象上。`var`和 `let` 不会。\r\n- `var`和 `let` 声明的变量可以重新赋值，`const` 声明的变量只能改变对象的内容。\r\n"}]},{"number":16,"title":"【Q016】JS 中变量声明提升","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/16","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 变量提升\r\n`var` 声明的 **变量** 和 **函数声明** ，会在代码执行前移动到全局代码的开头位置。\r\n```javascript\r\nbla = 2\r\nvar bla;\r\n\r\n// 可以隐式地（implicitly）将以上代码理解为：\r\n\r\nvar bla;\r\nbla = 2;\r\n```\r\n\r\n因此，建议始终在作用域顶部声明变量（全局代码的顶部和函数代码的顶部），这可以清楚知道哪些变量是函数作用域，哪些变量在作用域链上解决。\r\n\r\n重要的是，提升将影响变量声明，而不会影响其值的初始化。仅在运行到赋值语句时初始化变量的值。在此之前，变量的值始终为 `undefined` 。\r\n```javascript\r\nfunction do_something() {\r\n  console.log(bar); // undefined\r\n  var bar = 111;\r\n  console.log(bar); // 111\r\n}\r\n\r\n// 可以隐式地将以上代码理解为：\r\n\r\nfunction do_something() {\r\n  var bar;\r\n  console.log(bar); // undefined\r\n  bar = 111;\r\n  console.log(bar); // 111\r\n}\r\n```"}]},{"number":17,"title":"【Q017】JS 模块化","labels":["javascript"],"body":"理解模块化发展过程，理解 CommonJS，AMD，CMD，UMD，ES6 模块化","url":"https://github.com/kangyana/daily-question/issues/17","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 原生js的模块化\r\n原生js有几个问题：\r\n\r\n- 代码复用\r\n- 全局作用域污染\r\n- 可维护性\r\n\r\n为了解决这些问题，出现了 `命名空间`  和 `匿名闭包 IIFE 模式`，对代码进行封装，并通过提供外部方法来对它们进行访问。\r\n```javascript\r\n// 命名空间\r\nvar namespace = {}\r\nnamespace.add = function(a, b) {\r\n    console.log(a + b)\r\n}\r\nnamespace.add(1, 2)\r\n\r\n// IIEF\r\nvar utils = (function() {\r\n    var module = {}\r\n    module.multiply = function(a, b) {\r\n        console.log(a * b)\r\n    }\r\n    return module\r\n}())\r\nutils.multiply(1,2)\r\n```\r\n\r\n## 2. CommonJS\r\n09年 `CommonJS`（或者称作 CJS）规范推出，在 **NodeJS** 中实现。主要方法是 **exports** 和 **require**。\r\n```javascript\r\n// utils.js 文件\r\nfunction add(a, b) {\r\n    console.log(a + b)\r\n}\r\nmodule.exports.add = add\r\n\r\n// main.js 文件\r\nvar add = require('./utils').add\r\nadd(1, 2)\r\n```\r\n`CJS` 出来以后，服务端的模块概念已经形成，很自然地，大家就想要客户端模块。\r\n但是 `CJS` 是同步的，服务端读取本地硬盘可以很快同步加载完成，但是浏览器同步读取服务器端的模块可能需要很长的时间，浏览器将会处于”假死”状态。\r\n所以出现异步加载 js 文件的 AMD。\r\n\r\n## 3. AMD\r\n`AMD` 是异步模块定义（Asynchronous Module Definition）。\r\n它采用异步方式加载模块，模块的加载不影响它后面语句的运行。\r\n所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。\r\n\r\n```javascript\r\n// utils.js 文件\r\ndefine([], function() {\r\n    return {\r\n        add: function(a, b) {\r\n            console.log(a + b)\r\n        }\r\n    }\r\n})\r\n\r\n// main.js 文件\r\nrequire(['./utils'], function(utils) {\r\n    utils.add(1, 2)\r\n})\r\n```\r\n\r\n由于原生js不支持，使用 `AMD` 规范进行开发需要用到对应的库函数：`RequireJS`。\r\n`requireJS` 主要解决两个问题：\r\n\r\n- 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器\r\n- js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长\r\n\r\n## 4. CMD\r\n\r\n`CMD`（Common Module Definition）是玉伯在开发 `SeaJS` 的时候提出来的，`SeaJS` 要解决的问题和 `RequireJS` 一样。\r\n不同于 AMD 的依赖前置，CMD 是就近依赖。\r\n\r\n```javascript\r\n// AMD\r\nrequire(['./utils', 'a', 'b'], function(utils) {\r\n    console.log(1)\r\n    // 还没有用到 utils a b 等模块，但是 AMD 已经初始化了所有模块\r\n    console.log(2)\r\n    utils.add(1, 2)\r\n})\r\n\r\n// CMD\r\ndefine(function(require, exports, module){\r\n    console.log(1)\r\n    if(false) {\r\n        var utils = require('./utils') // 需要时再 require，不执行就不会加载\r\n        utils.add(1, 2)\r\n    }\r\n})\r\n```\r\n\r\n但是在 `AMD` 也是支持依赖就近，也就是 `CMD` 这样的写法的，所以，`RequireJS` 中，以上两种方式都能执行。\r\n不过，`RequireJS` 官方文档中，默认都是采用依赖前置的写法。\r\n\r\n## 5. UMD\r\n`UMD` 通用模块定义（Universal Module Definition），同时兼容服务端（CJS）和客户端（AMD）的模块化。\r\n\r\n```javascript\r\n// utils.js 文件同上\r\n(function(root, factory) {\r\n    if (typeof define === 'function' && define.amd) {\r\n        //AMD\r\n        define(['utils'], factory)\r\n    } else if (typeof exports === 'object') {\r\n        //CommonJS\r\n        var utils = require('utils')\r\n        module.exports = factory(utils)\r\n    } else {\r\n        root.result = factory(root.utils)\r\n    }\r\n}(this, function(utils) {\r\n    utils.add(1, 2)\r\n}))\r\n```\r\n\r\n## 6. ES6 模块化\r\n`ES6`（ES2015）自带的模块化，使用 **import** 和 **export** 关键字来导入和导出模块。\r\n\r\n```javascript\r\n// utils.js 文件\r\nexport const utils = {\r\n    add: function(a, b) {\r\n        console.log(a + b)\r\n    }\r\n}\r\n\r\n// main.js 文件\r\nimport { utils } from \"./utils\"\r\nutils.add(1, 2)\r\n```\r\n\r\n## 7. CommonJS 和 ES6 的区别\r\n`CommonJS` 模块输出的是一个值的拷贝，`ES6` 模块输出的是值的引用。\r\n`CommonJS` 模块是运行时加载，`ES6` 模块是编译时输出接口。"}]},{"number":18,"title":"【Q018】IIFE 立即执行函数","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/18","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. IIFE 立即调用函数表达式\r\n`IIFE` (Immediately Invoked Function Expression)是一个在定义时就会立即执行的函数。\r\n\r\n```javascript\r\n(function () {\r\n    // to something...\r\n})();\r\n```\r\n这是一个被称为 **自执行匿名函数** 的设计模式，主要包含两部分。\r\n第一部分是包围在 **圆括号运算符** 里的一个匿名函数，这个匿名函数拥有独立的词法作用域。\r\n这不仅避免了外界访问此 `IIFE` 中的变量，而且又不会污染全局作用域。\r\n\r\n## 2. IIFE 的优点\r\n\r\n- `IIFE` 中定义的任何变量和函数，都会在执行结束时被销毁。适合做初始化工作。\r\n- 创建 **块级作用域** ，避免了向全局作用域中添加变量和函数，因此也避免了多人开发中全局变量和函数的命名冲突。\r\n- `IIFE` 中定义的任何变量和函数，都会在执行结束时被销毁。这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了。"}]},{"number":19,"title":"【Q019】匿名函数","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/19","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 什么是匿名函数\r\n\r\n- `匿名函数`，即没有名称的函数\r\n- 如果单独只写一个匿名函数，此时是不符合语法要求的会报错。需要给 `匿名函数` 包裹一个括号，使之成为 **表达式**\r\n- 被小括号包裹的内容会被js识别为一个函数表达式\r\n\r\n## 2. 创建方式\r\n\r\n```javascript\r\n(function () {\r\n      // to something...\r\n}());\r\n```\r\n"}]},{"number":20,"title":"【Q020】箭头函数","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/20","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 箭头函数\r\n`箭头函数表达式` 的语法比 `函数表达式` 更简洁，并且没有自己的 this、arguments、super或new.target。\r\n`箭头函数表达式` 更适用于那些本来需要 `匿名函数` 的地方，并且它不能用作 `构造函数`。\r\n\r\n```javascript\r\nconst materials = [\r\n  'Hydrogen',\r\n  'Helium',\r\n  'Lithium',\r\n  'Beryllium'\r\n];\r\n\r\nconsole.log(materials.map(material => material.length)); // [8, 6, 7, 9]\r\n```\r\n\r\n## 更短的函数\r\n```javascript\r\nvar elements = [\r\n  'Hydrogen',\r\n  'Helium',\r\n  'Lithium',\r\n  'Beryllium'\r\n];\r\n\r\nelements.map(function(element) {\r\n  return element.length;\r\n}); // [8, 6, 7, 9]\r\n\r\n// 上面的普通函数可以改写成如下的箭头函数\r\nelements.map((element) => {\r\n  return element.length;\r\n});\r\n\r\n// 当箭头函数只有一个参数时，可以省略参数的圆括号\r\nelements.map(element => {\r\n return element.length;\r\n});\r\n\r\n// 当箭头函数的函数体只有一个 `return` 语句时，可以省略 `return` 关键字和方法体的花括号\r\nelements.map(element => element.length);\r\n```\r\n\r\n## 没有单独的this\r\n`箭头函数` 不会创建自己的this，它只会从自己的作用域链的上一层继承 `this`。\r\n```javascript\r\nfunction Person(){\r\n  this.age = 0;\r\n\r\n  setInterval(() => {\r\n    this.age++; // this 正确地指向 p 实例\r\n  }, 1000);\r\n}\r\n\r\nvar p = new Person();\r\n```\r\n\r\n## 与严格模式的关系\r\n鉴于 `this` 是词法层面上的，`严格模式` 中与 `this` 相关的规则都将被忽略。\r\n```javascript\r\nvar f = () => { 'use strict'; return this; };\r\nf() === window; // true\r\n```\r\n\r\n## 通过 call 或 apply 调用\r\n由于 `箭头函数` 没有自己的 `this` 指针，通过 call() 、apply()、bind() 方法调用一个函数时，只能传递参数，他们的第一个参数会被忽略。\r\n```javascript\r\nvar adder = {\r\n  base : 1,\r\n\r\n  add : function(a) {\r\n    var f = v => v + this.base;\r\n    return f(a);\r\n  },\r\n\r\n  addThruCall: function(a) {\r\n    var f = v => v + this.base;\r\n    var b = {\r\n      base : 2\r\n    };\r\n\r\n    return f.call(b, a);\r\n  }\r\n};\r\n\r\nconsole.log(adder.add(1));         // 输出 2\r\nconsole.log(adder.addThruCall(1)); // 仍然输出 2\r\n```\r\n\r\n## 不绑定arguments\r\n`箭头函数` 不绑定Arguments 对象。因此，在本示例中，arguments只是引用了封闭作用域内的 arguments：\r\n```javascript\r\nvar arguments = [1, 2, 3];\r\nvar arr = () => arguments[0];\r\n\r\narr(); // 1\r\n\r\nfunction foo(n) {\r\n  var f = () => arguments[0] + n; // 隐式绑定 foo 函数的 arguments 对象. arguments[0] 是 n，即传给 foo 函数的第一个参数\r\n  return f();\r\n}\r\n\r\nfoo(1); // 2\r\nfoo(2); // 4\r\nfoo(3); // 6\r\nfoo(3,2);//6\r\n```\r\n\r\n## 使用 new 操作符\r\n`箭头函数` 不能用作构造器，和 `new` 一起用会抛出错误。\r\n```javascript\r\nvar Foo = () => {};\r\nvar foo = new Foo(); // TypeError: Foo is not a constructor\r\n```\r\n\r\n## 使用prototype属性\r\n箭头函数没有 `prototype` 属性。\r\n```javascript\r\nvar Foo = () => {};\r\nconsole.log(Foo.prototype); // undefined\r\n```\r\n\r\n## 使用 yield 关键字\r\n`yield` 关键字通常不能在 `箭头函数` 中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作函数生成器。\r\n\r\n## 返回对象字面量\r\n记住用 `params => {object:literal}` 这种简单的语法 **返回对象字面量** 是行不通的。\r\n```javascript\r\nvar func = () => { foo: 1 };\r\n// Calling func() returns undefined!\r\n\r\nvar func = () => { foo: function() {} };\r\n// SyntaxError: function statement requires a name\r\n```\r\n\r\n这是因为花括号（`{}`）里面的代码被解析为一系列语句（即 `foo` 被认为是一个标签，而非对象字面量的组成部分）\r\n所以，记得用圆括号把对象字面量包起来：\r\n\r\n```javascript\r\nvar func = () => ({foo: 1});\r\n```\r\n"}]},{"number":21,"title":"【Q021】函数柯里化","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/21","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 柯里化（Currying）\r\n[柯里化（Currying）](https://en.wikipedia.org/wiki/Currying)是一种关于函数的高阶技术。它不仅被用于 JavaScript，还被用于其他编程语言。\r\n`柯里化` 是一种函数的 **转换** ，它是指将一个函数从可调用的 f(a, b, c) 转换为可调用的 f(a)(b)(c)。\r\n`柯里化` 不会调用函数，它只是对函数进行转换。\r\n\r\n```javascript\r\n// 柯里化函数\r\nfunction curry(f) {\r\n  return function(a) {\r\n    return function(b) {\r\n      return f(a, b);\r\n    };\r\n  };\r\n}\r\n\r\n// 求和函数\r\nfunction sum(a, b) {\r\n  return a + b;\r\n}\r\n\r\nconsole.log(curry(sum)(1)(2)) // 3\r\n```\r\n正如你所看到的，实现非常简单：只有两个包装器（wrapper）。\r\n\r\n- curry(func) 的结果就是一个包装器 function(a)。\r\n- 当它被像 curriedSum(1) 这样调用时，它的参数会被保存在词法环境中，然后返回一个新的包装器 function(b)。\r\n- 然后这个包装器被以 2 为参数调用，并且，它将该调用传递给原始的 sum 函数。\r\n\r\n柯里化更高级的实现，例如 lodash 库的 [_.curry](https://lodash.com/docs#curry)，会返回一个包装器，该包装器允许函数被正常调用或者以偏函数（partial）的方式调用：\r\n```javascript\r\nfunction sum(a, b) {\r\n  return a + b;\r\n}\r\n\r\nvar curriedSum = _.curry(sum); // 使用来自 lodash 库的 _.curry\r\nconsole.log(curriedSum(1, 2)); // 3，仍可正常调用\r\nconsole.log(curriedSum(1)(2)); // 3，以偏函数的方式调用\r\n```\r\n\r\n## 2. 柯里化的目的\r\n要了解它的好处，我们需要一个实际中的例子。\r\n\r\n例如，我们有一个用于格式化和输出信息的日志（logging）函数 `log(date, importance, message)`。\r\n在实际项目中，此类函数具有很多有用的功能，例如通过网络发送日志（log）：\r\n```javascript\r\nfunction log(date, importance, message) {\r\n  console.log(`[${date.getHours()}:${date.getMinutes()}] [${importance}] ${message}`);\r\n}\r\n```\r\n\r\n柯里化之后，log 仍正常运行，也可以以柯里化形式运行：\r\n```javascript\r\nlog = _.curry(log);\r\n\r\nlog(new Date(), \"DEBUG\", \"some debug\"); // log(a, b, c)\r\n\r\nlog(new Date())(\"DEBUG\")(\"some debug\"); // log(a)(b)(c)\r\n```\r\n\r\n现在可以轻松地为当前日志创建便捷函数：\r\n```javascript\r\n// logNow 会是带有固定第一个参数的日志的偏函数\r\nvar logNow = log(new Date());\r\n\r\n// 使用它\r\nlogNow(\"INFO\", \"message\"); // [HH:mm] INFO message\r\n```\r\n\r\n现在，logNow 是具有固定第一个参数的 log，换句话说，就是更简短的“偏应用函数（partially applied function）”或“偏函数（partial）”。\r\n\r\n可以更进一步，为当前的调试日志（debug log）提供便捷函数：\r\n```javascript\r\nvar debugNow = logNow(\"DEBUG\");\r\n\r\ndebugNow(\"message\"); // [HH:mm] DEBUG message\r\n```\r\n\r\n总结：\r\n\r\n- 柯里化之后，我们没有丢失任何东西：log 依然可以被正常调用。\r\n- 我们可以轻松地生成偏函数，例如用于生成今天的日志的偏函数。\r\n\r\n## 3. 柯里化的实现\r\n```javascript\r\nfunction curry(func) {\r\n  return function curried(...args) {\r\n    if (args.length >= func.length) {\r\n      return func.apply(this, args);\r\n    } else {\r\n      return function(...args2) {\r\n        return curried.apply(this, args.concat(args2));\r\n      }\r\n    }\r\n  };\r\n}\r\n```\r\n\r\n## 4. 总结\r\n\r\n- `柯里化` 是一种转换，将 f(a,b,c) 转换为可以被以 f(a)(b)(c) 的形式进行调用。JavaScript 实现通常都保持该函数可以被正常调用，并且如果参数数量不足，则返回偏函数。\r\n- `柯里化` 让我们能够更容易地获取偏函数。就像我们在日志记录示例中看到的那样，普通函数 log(date, importance, message) 在被柯里化之后，当我们调用它的时候传入一个参数（如 log(date)）或两个参数（log(date, importance)）时，它会返回偏函数。"}]},{"number":22,"title":"【Q022】Promise","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/22","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. promise\r\n`Promise` 对象用于表示一个异步操作的最终完成（或失败）及其结果值。\r\n异步方法并不会立即返回最终的值，而是会返回一个 promise，以便在未来某个时候把值交给使用者。\r\n\r\n一个 Promise 必然处于以下几种状态之一：\r\n\r\n- 待定（pending）：初始状态，既没有被兑现，也没有被拒绝。\r\n- 已兑现（fulfilled）：意味着操作成功完成。\r\n- 已拒绝（rejected）：意味着操作失败。\r\n\r\n## 2. Promise 的链式调用\r\n因为 `Promise.prototype.then`、`Promise.prototype.catch` 和 `Promise.prototype.finally`方法返回的是 promise，所以它们可以被链式调用。\r\n![Alt](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/promises.png)\r\n\r\n我们用 promise 的 `then` 方法排列起来的相关处理程序就会被调用。\r\n`.then()` 方法需要两个参数，第一个参数作为处理已兑现状态的回调函数，而第二个参数则作为处理已拒绝状态的回调函数。\r\n```javascript\r\nconst myPromise = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    resolve('foo');\r\n  }, 300);\r\n});\r\n\r\nmyPromise\r\n  .then(handleResolvedA, handleRejectedA)\r\n  .then(handleResolvedB, handleRejectedB)\r\n  .then(handleResolvedC, handleRejectedC);\r\n```\r\n\r\n当 `.then()` 中缺少能够返回 promise 对象的函数时，链式调用就直接继续进行下一环操作。\r\n因此，链式调用可以在最后一个 `.catch()` 之前把所有的处理已拒绝状态的回调函数都省略掉。\r\n```javascript\r\nmyPromise\r\n  .then(handleResolvedA)\r\n  .then(handleResolvedB)\r\n  .then(handleResolvedC)\r\n  .catch(handleRejectedAny);\r\n```\r\n\r\n## 3. finally清理\r\n如果你想在 promise 执行完毕后无论其结果怎样都做一些处理或清理时，`.finally()` 方法可能是有用的。\r\n\r\n`.finally()` 虽然与 `.then(onFinally, onFinally)` 类似，它们不同的是：\r\n\r\n- 调用内联函数时，不需要多次声明该函数或为该函数创建一个变量保存它。\r\n- 由于无法知道 promise 的最终状态，所以 finally 的回调函数中不接收任何参数，它仅用于无论最终结果如何都要执行的情况。"}]},{"number":23,"title":"【Q023】async/await","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/23","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. async 函数\r\n`async` 函数是使用 **async关键字** 声明的函数。`async` 函数是 `AsyncFunction` 构造函数的实例， 并且其中允许使用 **await关键字**。\r\n**async和await关键字** 让我们可以用一种更简洁的方式写出基于`Promise` 的异步行为，而无需刻意地链式调用 `promise`。\r\n\r\n在函数前面的 **async关键字** 做了一件事情：使用函数始终返回一个 promise。其他值将自动被包装在一个 resolved 的 promise 中。\r\n```javascript\r\nasync function f() {\r\n  return 1;\r\n}\r\n\r\nasync function f2() {\r\n  return Promise.resolve(1);\r\n}\r\n\r\nf().then(console.log); // 1\r\nf2().then(console.log); // 1\r\n```\r\n\r\n## 2. await 关键字\r\n`await` 让 JavaScript 引擎等待直到 promise 完成（settle）并返回结果。\r\n```javascript\r\nasync function f() {\r\n  var promise = new Promise((resolve, reject) => {\r\n    setTimeout(() => resolve(\"done!\"), 1000)\r\n  });\r\n\r\n  var result = await promise; // 等待，直到 promise resolve (*)\r\n  console.log(result); // \"done!\"\r\n}\r\n\r\nf();\r\n```\r\n这个函数在执行的时候，“暂停”在了` (*)` 那一行，并在 promise settle 时，拿到 `result` 作为结果继续往下执行。\r\n所以上面这段代码在一秒后显示 “done!”。\r\n\r\n强调一下：await 实际上会暂停函数的执行，直到 promise 状态变为 settled，然后以 promise 的结果继续执行。\r\n这个行为不会耗费任何 CPU 资源，因为 JavaScript 引擎可以同时处理其他任务：执行其他脚本，处理事件等。\r\n\r\n相比于 promise.then，它只是获取 promise 的结果的一个更优雅的语法，并且也更易于读写。\r\n\r\n## 3. Error 处理\r\n如果一个 promise 正常 resolve，`await promise` 返回的就是其结果。\r\n但是如果 promise 被 reject，它将 throw 这个 error，就像在这一行有一个 `throw` 语句那样。\r\n\r\n可以在函数调用后面添加 .catch 来处理这个 error：\r\n```javascript\r\nasync function f() {\r\n  var response = await fetch('http://no-such-url/');\r\n}\r\n\r\n// f() 变成了一个 rejected 的 promise\r\nf().catch(console.log); // TypeError: failed to fetch // (*)\r\n```\r\n\r\n## 4. 总结\r\n函数前面的关键字 async 有两个作用：\r\n\r\n- 让这个函数总是返回一个 promise。\r\n- 允许在该函数内使用 await。\r\n\r\nPromise 前的关键字 await 使 JavaScript 引擎等待该 promise settle，然后有两种情况：\r\n\r\n- 如果有 error，就会抛出异常 —— 就像那里调用了 throw error 一样。\r\n- 否则，就返回结果。\r\n\r\n"}]},{"number":24,"title":"【Q024】Generator","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/24","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. function* 生成器函数\r\n`function*` 这种声明方式会定义一个 **生成器函数** (generator function)，它返回一个 `Generator对象`。\r\n```javascript\r\nfunction* generator(i) {\r\n  yield i;\r\n  yield i + 10;\r\n}\r\n\r\nconst gen = generator(10);\r\nconsole.log(gen.next().value); // 10\r\nconsole.log(gen.next().value); // 20\r\n```\r\n\r\n**生成器函数** 在执行时能暂停，后面又能从暂停处继续执行。\r\n\r\n调用一个生成器函数并不会马上执行它里面的语句，而是返回一个这个生成器的 **迭代器（iterator）对象**。\r\n当这个迭代器的 `next()` 方法被调用时，其内的语句会执行到后续出现 `yield` 的位置为止，`yield` 后紧跟迭代器要返回的值。\r\n或者如果用的是 `yield*`，则表示将执行权移交给另一个生成器函数（当前生成器暂停执行）。\r\n\r\n调用 `next()` 方法时，如果传入了参数，那么这个参数会传给**上一条执行的 yield 语句左边的变量**，例如下面例子中的x：\r\n```javascript\r\nfunction *gen(){\r\n    yield 10;\r\n    x = yield 'foo';\r\n    yield x;\r\n}\r\n\r\nvar gen_obj = gen();\r\nconsole.log(gen_obj.next());// 执行 yield 10，返回 10\r\nconsole.log(gen_obj.next());// 执行 yield 'foo'，返回 'foo'\r\nconsole.log(gen_obj.next(100));// 将 100 赋给上一条 yield 'foo' 的左值，即执行 x=100，返回 100\r\nconsole.log(gen_obj.next());// 执行完毕，value 为 undefined，done 为 true\r\n\r\n```\r\n\r\nyield* 的示例：\r\n```javascript\r\nfunction* anotherGenerator(i) {\r\n  yield i + 1;\r\n  yield i + 2;\r\n  yield i + 3;\r\n}\r\n\r\nfunction* generator(i){\r\n  yield i;\r\n  yield* anotherGenerator(i);// 移交执行权\r\n  yield i + 10;\r\n}\r\n\r\nvar gen = generator(10);\r\nconsole.log(gen.next().value); // 10\r\nconsole.log(gen.next().value); // 11\r\nconsole.log(gen.next().value); // 12\r\nconsole.log(gen.next().value); // 13\r\nconsole.log(gen.next().value); // 20\r\n```\r\n\r\n## 2. Generator对象\r\n`生成器对象` 是由一个 `generator function` 返回的。\r\n```javascript\r\nfunction* gen() {\r\n  yield 1;\r\n  yield 2;\r\n  yield 3;\r\n}\r\n\r\nlet g = gen(); // \"Generator { }\"\r\n```\r\n\r\n## 3. 迭代器对象 iterator\r\n挖坑ing"}]},{"number":25,"title":"【Q025】对象遍历 和 数组遍历","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/25","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"# 一. 对象遍历\r\n## 1. for...in\r\n`for...in` 语句以任意顺序迭代一个对象的除[Symbol](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol)以外的[可枚举](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties)属性，包括继承的可枚举属性。\r\n\r\n```javascript\r\nvar obj = {a:1, b:2, c:3};\r\n\r\nfor (var prop in obj) {\r\n  console.log(\"obj.\" + prop + \" = \" + obj[prop]);\r\n}\r\n\r\n// \"obj.a = 1\"\r\n// \"obj.b = 2\"\r\n// \"obj.c = 3\"\r\n```\r\n\r\n`for...in` 还会获取到**原型链上的可枚举属性**，不过可以使用 `hasOwnProperty()` 方法过滤掉。\r\n```javascript\r\nvar triangle = {a: 1, b: 2, c: 3};\r\n\r\nfunction ColoredTriangle() {\r\n  this.color = 'red';\r\n}\r\n\r\nColoredTriangle.prototype = triangle;\r\n\r\nvar obj = new ColoredTriangle();\r\n\r\nfor (var prop in obj) {\r\n  if (obj.hasOwnProperty(prop)) {\r\n    console.log(`obj.${prop} = ${obj[prop]}`);\r\n  }\r\n}\r\n\r\n// \"obj.color = red\"\r\n```\r\n\r\n### 为什么用 for ... in?\r\n\r\n它最常用的地方应该是用于调试，可以更方便的去检查对象属性。\r\n你在处理有key-value数据，需要检查其中的任何键是否为某值的情况时，推荐用 `for...in`。\r\n\r\n## 2. for...of\r\n`for...of`语句在 **可迭代对象**（包括Array，Map，Set，String，TypedArray，arguments） 上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。\r\n\r\n如果使用 `for...of` 遍历对象，需要给对象的原型一个迭代器方法：\r\n```javascript\r\nvar obj = {\r\n    a:1,\r\n    b:2,\r\n    c:3\r\n};\r\n\r\nobj[Symbol.iterator] = function*(){\r\n    var keys = Object.keys(obj);\r\n    for(var k of keys){\r\n        yield k\r\n    }\r\n};\r\n\r\nfor(var k of obj){\r\n    console.log(k, obj[k]);\r\n}\r\n\r\n// 'a' 1\r\n// 'b' 2\r\n// 'c' 3\r\n```\r\n\r\n### for...of与for...in的区别?\r\n\r\n无论是 `for...in` 还是 `for...of` 语句都是迭代一些东西。它们之间的主要区别在于它们的迭代方式。\r\n- `for...in` 可以迭代Object。\r\n- `for...of` 可以迭代Array等其他 **可迭代对象** ，想迭代Object要给一个迭代器属性。\r\n- `for...in` 还会获取到**原型链上的可枚举属性**\r\n\r\n## 3. Object.keys()\r\n`Object.keys()` 方法会返回一个由一个给定对象的自身可枚举 **属性名（key）组成的数组**，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致。\r\n\r\n```javascript\r\nconst object1 = {\r\n  a: 'somestring',\r\n  b: 42,\r\n  c: false\r\n};\r\n\r\nconsole.log(Object.keys(object1)); //  [\"a\", \"b\", \"c\"]\r\n```\r\n注意：\r\n\r\n- 在 ES5 中，如果此方法的参数不是对象（而是一个原始值），那么它会抛出 **TypeError**。\r\n- 在 ES6 中，非对象的参数将被强制转换为一个对象。\r\n\r\n## 4. Object.getOwnPropertyNames()\r\n`Object.getOwnPropertyNames()` 方法返回一个由指定对象的所有自身属性的 **属性名（key）组成的数组**（属性名 包括不可枚举属性但不包括 `Symbol` 值作为名称的属性）。\r\n\r\n```javascript\r\n// 数组对象\r\nvar arr = [\"a\", \"b\", \"c\"];\r\nconsole.log(Object.getOwnPropertyNames(arr).sort()); // [\"0\", \"1\", \"2\", \"length\"]\r\n\r\n// 类数组对象\r\nvar obj = { 0: \"a\", 1: \"b\", 2: \"c\"};\r\nconsole.log(Object.getOwnPropertyNames(obj).sort()); // [\"0\", \"1\", \"2\"]\r\n\r\n//不可枚举属性\r\nvar my_obj = Object.create({}, {\r\n  getFoo: {\r\n    value: function() { return this.foo; },\r\n    enumerable: false\r\n  }\r\n});\r\nmy_obj.foo = 1;\r\nconsole.log(Object.getOwnPropertyNames(my_obj).sort()); // [\"foo\", \"getFoo\"]\r\n```\r\n\r\n### 如果你只要获取到可枚举属性，请使用 `Object.keys` 或用 `for...in` 循环。\r\n\r\n## 5. Object.getOwnPropertySymbols()\r\n`Object.getOwnPropertySymbols()` 方法返回一个给定对象自身的所有 `Symbol` 属性的数组。\r\n\r\n```javascript\r\nvar obj = {};\r\nvar a = Symbol(\"a\");\r\nvar b = Symbol.for(\"b\");\r\n\r\nobj[a] = \"localSymbol\";\r\nobj[b] = \"globalSymbol\";\r\n\r\nvar objectSymbols = Object.getOwnPropertySymbols(obj);\r\n\r\nconsole.log(objectSymbols.length); // 2\r\nconsole.log(objectSymbols)         // [Symbol(a), Symbol(b)]\r\nconsole.log(objectSymbols[0])      // Symbol(a)\r\n```\r\n\r\n### 与 `Object.getOwnPropertyNames()` 类似，您可以将给定对象的所有符号属性作为 `Symbol` 数组获取。\r\n请注意，`Object.getOwnPropertyNames()` 本身不包含对象的 `Symbol` 属性，只包含字符串属性。\r\n\r\n因为所有的对象在初始化的时候不会包含任何的 `Symbol`，除非你在对象上赋值了 `Symbol` 否则Object.getOwnPropertySymbols()只会返回一个空的数组。\r\n\r\n## 6. Reflect.ownKeys()\r\n`Reflect.ownKeys()` 返回一个由目标对象自身的**属性键（key）组成的数组**。\r\n```javascript\r\nconst object1 = {\r\n  property1: 42,\r\n  property2: 13\r\n};\r\n\r\nconst array1 = [];\r\n\r\nconsole.log(Reflect.ownKeys(object1)); // [\"property1\", \"property2\"]\r\nconsole.log(Reflect.ownKeys(array1)); //  [\"length\"]\r\n```\r\n\r\n### Reflect.ownKeys 方法返回一个由目标对象自身的属性键组成的数组。它的返回值等同于`Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))`。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"# 二、数组遍历\r\n## 1. for 循环\r\n`for循环` 很古老，它在 ECMAScript 1 中就已经存在了。for 循环记录 arr 每个元素的索引和值：\r\n```javascript\r\nconst arr = ['a', 'b', 'c'];\r\narr.prop = 'property value';\r\n\r\nfor (let index=0; index < arr.length; index++) {\r\n  const elem = arr[index];\r\n  console.log(index, elem);\r\n}\r\n\r\n// 0, 'a'\r\n// 1, 'b'\r\n// 2, 'c'\r\n```\r\n\r\n### for 循环的优缺点是什么？\r\n\r\n- 优：它用途广泛。\r\n- 缺：但是当我们要遍历数组时也很麻烦。\r\n- 优：如果我们不想从第一个数组元素开始循环时它仍然很有用，用其他的循环机制很难做到这一点。\r\n\r\n## 2. for-in循环\r\n`for-in循环` 与 `for循环` 一样古老，同样在 ECMAScript 1中就存在了。下面的代码用 for-in 循环输出 arr 的 key：\r\n```javascript\r\nconst arr = ['a', 'b', 'c'];\r\narr.prop = 'property value';\r\n\r\nfor (const key in arr) {\r\n  console.log(key);\r\n}\r\n\r\n// '0'\r\n// '1'\r\n// '2'\r\n// 'prop'\r\n```\r\n\r\n### for-in 不是循环遍历数组的好方法：\r\n\r\n- 它访问的是属性键（key），而不是值（value）。\r\n- 作为属性键（key），数组元素的索引是字符串，而不是数字。\r\n- 它访问的是所有可枚举的属性键（自己的和继承的），而不仅仅是 `Array` 元素的那些。\r\n\r\n### for-in 访问继承属性的实际用途是：遍历对象的所有可枚举属性。\r\n\r\n## 3. 数组方法 .forEach()\r\n鉴于 `for` 和 `for-in` 都不特别适合在数组上循环，因此在 ECMAScript 5 中引入了一个辅助方法：Array.prototype.forEach()：\r\n```javascript\r\nconst arr = ['a', 'b', 'c'];\r\narr.prop = 'property value';\r\n\r\narr.forEach((elem, index) => {\r\n  console.log(elem, index);\r\n});\r\n\r\n// 'a', 0\r\n// 'b', 1\r\n// 'c', 2\r\n```\r\n\r\n### forEach 循环的优缺点是什么？\r\n\r\n- 优：它使我们无需执行大量操作就能够可访问数组元素和索引。\r\n- 缺：不能在它的循环体中使用 `await`。\r\n- 缺：不能提前退出 `forEach()循环`。而在 `for循环` 中可以使用 `break`。\r\n\r\n### 中止 .forEach() 的解决方法\r\n\r\n## 4. 数组方法 .some()\r\n如果想要中止 `.forEach()` 之类的循环，建议使用：`.some()` \r\n`.some()` 还会循环遍历所有数组元素，并在其回调返回真值时停止。\r\n```javascript\r\nconst arr = ['red', 'green', 'blue'];\r\narr.some((elem, index) => {\r\n  if (index >= 2) {\r\n    return true; // 中止循环\r\n  }\r\n  console.log(elem);\r\n  //此回调隐式返回 `undefined`，这\r\n  //是一个伪值。 因此，循环继续。\r\n});\r\n\r\n// 'red'\r\n// 'green'\r\n```\r\n\r\n## 5. for-of 循环\r\nfor-of 循环在 ECMAScript 6 开始支持：\r\n\r\n```javascript\r\nconst arr = ['a', 'b', 'c'];\r\narr.prop = 'property value';\r\n\r\nfor (const elem of arr) {\r\n  console.log(elem);\r\n}\r\n\r\n// 'a'\r\n// 'b'\r\n// 'c'\r\n```\r\n\r\n### for-of 在循环遍历数组时非常有效：\r\n\r\n- 用来遍历数组元素。\r\n- 可以使用 `await`。\r\n- 可以将 `break` 和 `continue` 用于外部作用域。\r\n\r\n## 6. 总结\r\n`for-of` 循环的可用性比 `for`，`for-in` 和 `.forEach()` 更好。\r\n\r\n通常四种循环机制之间的性能差异应该是无关紧要。\r\n如果你要做一些运算量很大的事，还是切换到 `WebAssembly` 更好一些。\r\n\r\n"}]}]}