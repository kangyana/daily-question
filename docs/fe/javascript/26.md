# 【Q026】常见的数组方法


::: tip Issue
欢迎在 Gtihub Issue 中回答此问题: [Issue 26](https://github.com/kangyana/daily-question/issues/26)
:::

::: tip Author
回答者: [kangyana](https://github.com/kangyana)
:::
# 一、数组遍历相关
## 1. Array.prototype.entries()
`entries()` 方法返回一个新的 **Array Iterator** 对象，该对象包含数组中每个索引的键/值对。
```javascript
const array1 = ['a', 'b', 'c'];
const iterator1 = array1.entries();

console.log(iterator1.next().value); // [0, "a"]
console.log(iterator1.next().value); // [1, "b"]
```

### 常用于与 `for...of` 构成数组遍历：
```javascript
const a = ["a", "b", "c"];

for (const [index, element] of a.entries()) {
    console.log(index, element);
}

// 0 'a'
// 1 'b'
// 2 'c'
```

## 2. Array.prototype.every()
`every()` 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。

备注： 若收到一个空数组，此方法在任何情况下都会返回 true。

```javascript
const array1 = [1, 30, 39, 29, 10, 13];

const flag = array1.every((item) => item < 40);
console.log(flag); // true
```

### 常用于判断每一项都符合条件

## 3. Array.prototype.filter()
`filter()` 方法创建给定数组一部分的 `浅拷贝`，其包含通过所提供函数实现的测试的所有元素。
```javascript
const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];

const result = words.filter(word => word.length > 6);
console.log(result); // ["exuberant", "destruction", "present"]
```

### 常用于筛选数组

## 4. Array.prototype.flat()
`flat()` 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。

根据参数提取嵌套数组的结构深度，默认值为 1：
```javascript
const arr1 = [0, 1, 2, [3, 4], [[5, 6]]];

console.log(arr1.flat()); // [0, 1, 2, 3, 4, [5, 6]]
console.log(arr1.flat(2)); // [0, 1, 2, 3, 4, 5, 6]
```

还可以移除数组中的空项：
```javascript
var arr4 = [1, 2, , 4, 5];

console.log(arr4.flat()); // [1, 2, 4, 5]
````

### 常用于数组降维

## 5. Array.prototype.flatMap()
`flatMap()` 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。
它与 `map` 连着深度值为 1 的 `flat` 的效果几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些。

```javascript
const arr1 = [1, 2, [3], [4, 5], 6, []];

console.log(arr1.flatMap(num => num)); // [1, 2, 3, 4, 5, 6]
// 效果等同于
console.log(arr1.map(num => num).flat()) // [1, 2, 3, 4, 5, 6]
```

### 可用于 需要在 `map()` 时 **插入/减少** 某一项
```javascript
var a = [5, 4, -3, 20, 17, -33, -4, 18]

a.flatMap((n) => {
  if (n < 0) return [];
  if (n % 2 == 0) return [n];
  return [n-1, 1]
})

console.log(a); // [4, 1, 4, 20, 16, 1, 18]
```

替代方案（低效，不推荐）：

`reduce()` 加 `concat()`
```javascript
var arr = [1, 2, 3, 4];

arr.flatMap(x => [x, x * 2]); // [1, 2, 2, 4, 3, 6, 4, 8]
// 
arr.reduce((acc, x) => acc.concat([x, x * 2]), []); // [1, 2, 2, 4, 3, 6, 4, 8]
```

## 6. Array.prototype.forEach()
`forEach()` 方法对数组的每个元素执行一次给定的函数。
```javascript
const array1 = ['a', 'b', 'c'];

array1.forEach(element => console.log(element));

// "a"
// "b"
// "c"
```

`forEach` 不会直接改变调用它的对象，但是那个对象可能会被 `callbackFn` 函数改变。

备注：除了抛出异常以外，没有办法中止或跳出 forEach() 循环。

若你需要提前终止循环，你可以使用：

- for循环
- for...in/for...of 循环
- Array.prototype.every()
- Array.prototype.some()
- Array.prototype.find()
- Array.prototype.findIndex()

最后四个方法，甚至可以对数组元素判断，以便确定是否需要继续遍历。

### 常用于 *不需要异步* 且 *不需要提前跳出* 的数组循环。

## 7. Array.prototype.keys()
`keys()` 方法返回一个包含数组中每个索引键的 `Array Iterator` 对象。
```javascript
const array1 = ['a', 'b', 'c'];
const iterator = array1.keys();

for (const key of iterator) {
  console.log(key);
}

// 0
// 1
// 2
```

### 此方法很少使用

## 8. Array.prototype.map()
`map()` 方法 **创建一个新数组**，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。
```javascript
const array1 = [1, 4, 9, 16];

console.log(array1.map(x => x * 2)); // [2, 8, 18, 32]
```

若你不想返回的新数组，请使用 `forEach()` 或 `for...of`。

### 常用于 遍历修改某一项 且 创建新数组。

### 经典八股文：
```javascript
["1", "2", "3"].map(parseInt); 
```
我们期望输出 [1, 2, 3], 而实际结果是 [1, NaN, NaN]

`parseInt` 经常被带着一个参数使用，但是这里接受两个。
第一个参数是一个表达式而第二个是回调函数的基，`Array.prototype.map` 传递 3 个参数：element，index，array

第三个参数被 `parseInt` 忽视了，但不是第二个。因此可能出现混淆。
下面是迭代步骤的拆解：
```javascript
parseInt("1", 0); // 1
parseInt("2", 1); // NaN
parseInt("3", 2); // NaN
```

## 9. Array.prototype.reduce()
`reduce()` 方法对数组中的每个元素按序执行一个由您提供的 **reducer** 函数。
每一次运行 **reducer** 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。
```javascript
const array1 = [1, 2, 3, 4];

// 求和
const initialValue = 0;
const sum = array1.reduce((prev, cur) => prev + cur, initialValue);

console.log(sum); // 10
```

### 常用于累加对象数组里的值，例如求和

数组去重
```javascript
var arrary1 = ['a', 'b', 'a', 'b', 'c', 'e', 'e', 'c', 'd', 'd', 'd', 'd']

var array2 = arrary1.reduce((prev, cur) => {
  if (prev.indexOf(cur) === -1) prev.push(cur)
  return prev
}, [])

console.log(array2); // ['a', 'b', 'c', 'e', 'd']
```

对象数组分组
```javascript
var array1 = [
  { type: 'fruit', name: 'apple' },
  { type: 'vegetable', name: 'tomato' },
  { type: 'fruit', name: 'mango' },
]

const dictionary = {};

array1.reduce((prev, cur) => {
  if (prev[cur.type]) {
    prev[cur.type].push(cur)
  } else {
    prev[cur.type] = [cur]
  }
  return prev
}, dictionary)

console.log(dictionary); // {fruit: Array(2), vegetable: Array(1)}
```

## 10. Array.prototype.reduceRight()
`reduceRight()` 方法接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。
```javascript
const array1 = [[0, 1], [2, 3], [4, 5]];

const result = array1.reduceRight((acc, cur) => acc.concat(cur));
console.log(result); // [4, 5, 2, 3, 0, 1]
```

### `reduce` 与 `reduceRight` 之间的区别：正序遍历和倒序遍历
```javascript
var a = ['1', '2', '3', '4', '5'];
var left  = a.reduce((prev, cur) => prev + cur);
var right = a.reduceRight((prev, cur) => prev + cur);

console.log(left);  // "12345"
console.log(right); // "54321"
```

## 11. Array.prototype.some()
`some()` 方法测试数组中是不是至少有 1 个元素通过了被提供的函数测试。它返回的是一个 `Boolean` 类型的值。
```javascript
const array = [1, 2, 3, 4, 5];

console.log(array.some((item) => item % 2 === 0)); // true
```

备注： 如果用一个空数组进行测试，在任何情况下它返回的都是false。

### 常用于检查数组是否存在不符合条件的值。（性能推荐，找到第一个值就跳出循环）

## 12. Array.prototype.values()
`values()` 方法返回一个新的 `Array Iterator` 对象，该对象包含数组每个索引的值。
```javascript
const array1 = ['a', 'b', 'c'];
const iterator = array1.values();

for (const value of iterator) {
  console.log(value);
}

// "a"
// "b"
// "c"
```

### 与 `key()` 方法一样很少被使用

## 13. Array.prototype[@@iterator]()
`@@iterator` 和 `values()` 的初始值是同一个函数对象。

### 同 `values()` 方法使用
::: tip Author
回答者: [kangyana](https://github.com/kangyana)
:::
# 二、数组增删改
## 1. Array.prototype.concat()
## 2. Array.prototype.copyWithin()
## 3. Array.prototype.fill()
## 4. Array.prototype.pop()
## 5. Array.prototype.push()
## 6. Array.prototype.push()
## 7. Array.prototype.shift()
## 8. Array.prototype.slice()
## 9. Array.prototype.splice()
## 10. Array.prototype.unshift()
::: tip Author
回答者: [kangyana](https://github.com/kangyana)
:::
# 3. 数组查询
## 1. Array.prototype.at()
## 2. Array.prototype.find()
## 3. Array.prototype.findIndex()
## 4. Array.prototype.findLast()
## 5. Array.prototype.findLastIndex()
## 6. Array.prototype.includes()
## 7. Array.prototype.indexOf()
## 8. Array.prototype.lastIndexOf()
::: tip Author
回答者: [kangyana](https://github.com/kangyana)
:::
# 4. 数组创建
## 1. Array.of()
## 2. Array.from()
::: tip Author
回答者: [kangyana](https://github.com/kangyana)
:::
# 5. 其他
## 1. Array.isArray()
## 2. Array.prototype.join()
## 3. Array.prototype.reverse()
## 4. Array.prototype.sort()
## 5. Array.prototype.toLocaleString()
## 6. Array.prototype.toString()
