{"javascript":[{"number":1,"title":"【Q001】js 有几种基本的数据类型","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/1","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 动态类型\r\nJS 是一种 **弱类型** 或者说 **动态类型** 语言。\r\n这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。\r\n这也意味着你可以使用同一个变量保存不同类型的数据：\r\n```javascript\r\nlet foo = 42;    // foo 现在是一个数字\r\nfoo     = 'bar'; // foo 现在是一个字符串\r\nfoo     = true;  // foo 现在是一个布尔值\r\n```\r\n\r\n## 2. 数据类型\r\nJavaScript 语言中类型集合由 `基础数据类型` 和 `引用数据类型` 组成。\r\n\r\n### 基础数据类型\r\n直接表示在语言底层的不可变数据，也叫 **原始值**，共有 **7** 个：\r\n\r\n- 布尔 Boolean\r\n- 空类 Null\r\n- 未定义 Undefined\r\n- 数字 Number\r\n- 字符串 String\r\n- 大整数 BigInt（es6新增）\r\n- 符号 Symbol（es6新增）\r\n\r\n### 引用数据类型\r\n`引用类型` 的值是保存在内存中的对象（同时保存在栈内存和堆内存中），`引用类型` 的值是按引用访问的。\r\n\r\n- Object 对象\r\n- Array 数组\r\n- Function 函数\r\n- RegExp 正则\r\n- Date 日期"}]},{"number":2,"title":"【Q002】如何判断 js 数据类型","labels":["javascript"],"body":"基础类型和复杂类型","url":"https://github.com/kangyana/daily-question/issues/2","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"### typeof用于判断基本数据类型，无法区分object、array、null\r\n```javascript\r\n    typeof 1 // 'number'\r\n    typeof \"1\" // 'string'\r\n    typeof undefined // 'undefined'\r\n    \r\n    typeof null // 'object'\r\n    typeof [] // 'object'\r\n    typeof {} // 'object'\r\n    typeof function() {} // 'function'\r\n```\r\n\r\n### 区分object和array，可以使用`Array.isArray()`\r\n```javascript\r\n    Array.isArray([1, 2, 3]); // true\r\n    Array.isArray({foo: 123}); // false\r\n    Array.isArray(\"foobar\"); // false\r\n    Array.isArray(undefined); // false\r\n```"}]},{"number":3,"title":"【Q003】typeof和instanceof的区别","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/3","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 一、typeof\r\n`typeof`操作符返回一个字符串，表示未经计算的操作数的类型。\r\n\r\n语法：\r\n```javascript\r\ntypeof operand\r\n```\r\n\r\n|类型 | 结果 |\r\n| ---- | ---- |\r\n| undefined | `\"undefined\"` |\r\n| boolean | `\"boolean\"` |\r\n| string | `\"string\"` |\r\n| symbol | `\"symbol\"` |\r\n| bigInt | `\"bigint\"` |\r\n| function | `\"function\"` |\r\n| object \\| array \\| null | `\"object\"` |\r\n\r\n由上表可得知，`typeof`是无法区分`object` | `array` | `null`类型的。\r\n\r\n## 二、instanceof\r\n`instanceof` 运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。\r\n\r\n语法：\r\n```javascript\r\nobject instanceof constructor\r\n```\r\n\r\n只能用于构造函数，无法用于基础类型。\r\n\r\n## 三、总结区别\r\n`typeof`与`instanceof`都是判断数据类型的方法，区别如下：\r\n\r\n- `typeof`会返回一个变量的基本类型，instanceof返回的是一个布尔值。\r\n- `instanceof` 可以准确地判断复杂引用数据类型，但是无法判断基本类型。\r\n- `typeof`无法判断除了`function`外的引用类型。\r\n"}]},{"number":4,"title":"【Q004】如何判断一个变量是不是Array","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/4","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. instanceof 判断\r\n```javascript\r\nvar arr = [1,2,3];\r\narr instanceof Array; // true\r\narr instanceof Object; // false\r\n\r\nvar obj = {id:1};\r\nobj instanceof Array; // false\r\nobj instanceof Object; // true\r\n```\r\n\r\n## 2. 构造函数 判断\r\n```javascript\r\nvar arr = [1,2,3];\r\narr.__proto__.constructor === Array; //  true\r\n\r\nvar obj = {id:1};\r\nobj.__proto__.constructor === Object; // true\r\n```\r\n\r\n## 3. toString() 判断\r\n```javascript\r\nvar arr = [1,2,3];\r\nObject.prototype.toString.call(arr);  // [object Array]\r\n\r\nvar obj = {id:1};\r\nObject.prototype.toString.call(obj); // [object Object]\r\n```\r\n\r\n## 4. Array.isArray() 判断\r\n```javascript\r\nvar arr = [1,2,3];\r\nArray.isArray(arr); //  true\r\n\r\nvar obj = {id:1};\r\nArray.isArray(obj); // false\r\n```"}]},{"number":5,"title":"【Q005】==和===有什么不同","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/5","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. ==\r\n等于运算符 `==` 检查其两个操作数是否相等，并返回 `Boolean` 结果。\r\n同时会尝试强制类型转换。\r\n\r\n隐式转换：\r\n`string` 和 `number` 比较时，会自动转换为 `number` 类型。\r\n\r\n## 2. ===\r\n全等运算符 `===` 检查其两个操作数是否相等，并返回 `Boolean` 结果。\r\n它总是认为不同类型的操作数是不同的。\r\n\r\n## 3. 区别\r\n\r\n- `==` 不会比较数据类型，`===` 会检查类型\r\n- `==`会隐式转换"}]},{"number":6,"title":"【Q006】事件机制","labels":["javascript"],"body":"事件循环","url":"https://github.com/kangyana/daily-question/issues/6","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"JavaScript 有一个基于 **事件循环** 的并发模型，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。\r\n\r\n## 1. 可视化描述\r\n![Alt](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop/the_javascript_runtime_environment_example.svg)\r\n\r\n## 2. 栈（stack)\r\n栈是由多个 **函数调用** 形成的 **帧** 组成\r\n\r\n```javascript\r\nfunction foo(b) {\r\n  let a = 10;\r\n  return a + b + 11;\r\n}\r\n\r\nfunction bar(x) {\r\n  let y = 3;\r\n  return foo(x * y);\r\n}\r\n\r\nconsole.log(bar(7)); // 42\r\n```\r\n\r\n当调用 `bar` 时，第一个帧被创建并压入栈中，帧中包含了 `bar` 的参数和局部变量。\r\n当 `bar` 调用 `foo` 时，第二个帧被创建并被压入栈中，放在第一个帧之上，帧中包含 `foo` 的参数和局部变量。\r\n当 `foo` 执行完毕然后返回时，第二个帧就被弹出栈（剩下 `bar` 函数的调用帧 ）。\r\n当 `bar` 也执行完毕然后返回时，第一个帧也被弹出，栈就被清空了。\r\n\r\n## 3. 堆（heap）\r\n堆是放 **object** 的 **内存区域**\r\n\r\n## 4. 队列（queue）\r\n队列是 **待处理消息的消息队列**，每一个消息都关联着一个用以处理这个消息的回调函数。\r\n\r\n在 **事件循环** 期间的某个时刻，运行时会从最先进入队列的消息开始处理队列中的消息。\r\n被处理的消息会被移出队列，并作为输入参数来调用与之关联的函数。\r\n正如前面所提到的，调用一个函数总是会为其创造一个新的栈帧。\r\n\r\n函数的处理会一直进行到执行栈再次为空为止；然后事件循环将会处理队列中的下一个消息。\r\n\r\n## 5. 事件循环（event loop）\r\n之所以称之为 **事件循环**，是因为它经常按照类似如下的方式来被实现：\r\n\r\n```javascript\r\nwhile (queue.waitForMessage()) {\r\n  queue.processNextMessage();\r\n}\r\n```\r\n\r\n`queue.waitForMessage()` 会同步地等待消息到达 "}]},{"number":7,"title":"【Q007】事件委托","labels":["javascript"],"body":"事件流、事件冒泡","url":"https://github.com/kangyana/daily-question/issues/7","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 事件委托\r\n将事件侦听器添加到一个父级元素上。\r\n这样就只用添加一次事件侦听器，可以避免向很多 DOM 节点添加多个事件侦听器。\r\n\r\n## 2. 事件冒泡\r\n事件委托的实现是利用 **事件冒泡** 的机制。\r\n事件流：事件的触发会从最底层的 DOM 元素开始发生，一直向上传播，直到 document 对象。\r\n\r\n## 3. 优点\r\n\r\n- 减少了内存消耗，优化程序性能\r\n- 动态绑定事件，减少重复工作"}]},{"number":8,"title":"【Q008】e.preventDefault()是干什么的","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/8","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"- **e.preventDefault()** 取消默认事件\r\n- **e.stopPropagation()** 防止冒泡和捕获 \r\n"}]},{"number":9,"title":"【Q009】JS中this是如何工作的","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/9","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"**this** 永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。\r\n\r\n## 1. 全局环境中\r\n`this` 指向全局对象\r\n\r\n```javascript\r\n// 在浏览器中\r\nconsole.log(this === window); // true\r\n\r\n// 在 Node 中\r\nconsole.log(this === globalThis); // true\r\n```\r\n## 2. 函数内部\r\n`this` 的值取决于函数被调用的方式。\r\n\r\n非严格模式下，`this` 的值默认指向全局对象\r\n```javascript\r\nfunction f1(){\r\n  return this;\r\n}\r\n\r\nf1() === window;   // true\r\n```\r\n\r\n严格模式下，如果进入执行环境时没有设置 `this` 的值，`this` 会保持为 `undefined`\r\n```javascript\r\nfunction f2(){\r\n  \"use strict\";\r\n  return this;\r\n}\r\n\r\nf2() === undefined; // true\r\n```\r\n\r\n如果要想把 `this` 的值从一个环境传到另一个，就要用 `call` 或者 `apply` 方法\r\n\r\n## 3. 类内部\r\n`this` 在 `类` 中的表现与在函数中类似，因为类本质上也是函数，但也有一些区别和注意事项\r\n\r\n在类的构造函数中，this 是一个常规对象。类中所有 **非静态的方法** 都会被添加到 `this` 的原型中\r\n```javascript\r\nclass Example {\r\n  constructor() {\r\n    const proto = Object.getPrototypeOf(this);\r\n    console.log(Object.getOwnPropertyNames(proto));\r\n  }\r\n  first(){}\r\n  second(){}\r\n  static third(){}\r\n}\r\n\r\nnew Example(); // ['constructor', 'first', 'second']\r\n```\r\n## 4. 派生类内部\r\n派生类的构造函数没有初始的 `this` 绑定，在调用 super() 之前引用 `this` 会报错\r\n\r\n## 5. bind()后\r\n`this` 的值指向绑定的参数\r\n```javascript\r\nfunction f(){\r\n  return this.a;\r\n}\r\n\r\nvar g = f.bind({a:\"azerty\"});\r\nconsole.log(g()); // azerty\r\n```\r\n\r\n## 6. 箭头函数内部\r\n`this` 的值指向外部环境，相当于传递了 `this`"}]},{"number":10,"title":"【Q010】apply、call、bind的区别，及源码实现","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/10","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. apply()\r\n`apply()` 方法调用一个具有给定 `this` 值的函数，以及以一个数组的形式提供的参数\r\n```javascript\r\nconst numbers = [5, 6, 2, 3, 7];\r\n\r\nconst max = Math.max.apply(null, numbers); // 7\r\n```\r\n\r\n源码实现\r\n```javascript\r\nFunction.prototype.myApply = function (context, args) {\r\n    context = context || window;\r\n    let fn = Symbol();\r\n    context[fn] = this;\r\n    return context[fn](...args);\r\n}\r\n```\r\n\r\n## 2. call()\r\n`call` 方法使用一个指定的 `this` 值和单独给出的一个或多个参数来调用一个函数\r\n\r\n可以用来实现 **继承**\r\n```javascript\r\nfunction Product(name, price) {\r\n  this.name = name;\r\n  this.price = price;\r\n}\r\n\r\nfunction Food(name, price) {\r\n  Product.call(this, name, price);\r\n  this.category = 'food';\r\n}\r\n\r\nconsole.log(new Food('cheese', 5).name); // cheese\r\n```\r\n\r\n源码实现，与apply区别只有参数变化\r\n```javascript\r\nFunction.prototype.myCall = function (context, ...args) {\r\n    context = context || window;\r\n    let fn = Symbol();\r\n    context[fn] = this;\r\n    return context[fn](...args);\r\n}\r\n```\r\n\r\n## 3. bind()\r\n`bind()` 方法创建一个新的函数，在 ·bind()· 被调用时，这个新函数的 this 被指定为 `bind()` 的第一个参数，而其余参数将作为新函数的参数\r\n\r\n```javascript\r\nconst module = {\r\n  x: 42,\r\n  getX: function() {\r\n    return this.x;\r\n  }\r\n};\r\n\r\nconst unboundGetX = module.getX;\r\nconsole.log(unboundGetX()); // undefined（函数内this指向全局）\r\n\r\nconst boundGetX = unboundGetX.bind(module);\r\nconsole.log(boundGetX()); // 42\r\n```\r\n\r\n源码实现\r\n```javascript\r\n\r\nFunction.prototype.myBind = function (context) {\r\n    const self = this\r\n    const args = Array.from(arguments).slice(1)\r\n \r\n    return function F() {\r\n        const newArgs = args.concat([...arguments])\r\n        if (this instanceof F) {\r\n            return new self(...newArgs)\r\n        } else {\r\n            return self.apply(context, newArgs)\r\n        }\r\n    }\r\n```\r\n\r\n## 4. 区别\r\n\r\n- `apply` 与 `call` 非常相似，`call` 接受一个参数列表，而 `apply` 接受一个参数的单数组\r\n- `call`、`apply` 是直接调用，`bind` 是返回某个函数，等待某个状态触发再执行\r\n\r\n"}]},{"number":11,"title":"【Q011】js中new关键字原理","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/11","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## new原理\r\n`new` 操作符用来创建构造函数的实例，以这种方式调用构造函数会执行如下操作：\r\n\r\n- 在内存中创建一个新对象；\r\n- 这个对象内部的[[Prototype]]特性被复制为构造函数的prototype属性;\r\n- 构造函数内部的this被复制为这个新对象（即this指向新对象）；\r\n- 执行构造函数内部的代码（给新对象添加属性）；\r\n- 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新实例。\r\n\r\n## 代码实现\r\n\r\n1. 使用Object.create继承prototype属性\r\n```javascript\r\nfunction myNew (constructor, ...args) {\r\n    var obj = Object.create(constructor.prototype);\r\n    var result = constructor.apply(obj, args);\r\n    return typeof result === 'object' ? result : obj;\r\n}\r\n```\r\n\r\n2. 重写新对象的__proto__属性\r\n```javascript\r\nfunction myNew (constructor, ...args) {\r\n    var obj = new Object();\r\n    obj.__proto__  = constructor.prototype;\r\n    var result = constructor.apply(obj, args);\r\n    return typeof result === 'object' ? result : obj;\r\n}\r\n```"}]},{"number":12,"title":"【Q012】JS 中继承是如何实现的","labels":["javascript"],"body":"7种方法","url":"https://github.com/kangyana/daily-question/issues/12","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 原型链\r\n让一个 **构造函数** 的原型是另一个类型的实例，`new` 出来的实例\r\n```javascript\r\nfunction Person () {\r\n  this.name = 'zs';\r\n}\r\n\r\nfunction Man () {};\r\nMan.prototype = new Person();\r\n\r\nnew Man().name // 'zs'\r\n```\r\n\r\n优点：写法方便简洁，容易理解\r\n缺点：对象实例共享所有继承的属性和方法。传教子类型实例的时候，不能传递参数，因为这个对象是一次性创建的（没办法定制化）\r\n\r\n## 2. 借用构造函数继承\r\n在子类型构造函数的内部调用父类型构造函数；使用 apply() 或 call() 方法将父对象的构造函数绑定在子对象上\r\n```javascript\r\nfunction Person (name) {\r\n  this.name = name;\r\n}\r\n\r\nfunction Man (name) {\r\n  Person.call(this, name)\r\n};\r\n```\r\n\r\n优点：解决了原型链实现继承的不能传参的问题和父类的原型共享的问题\r\n缺点：借用构造函数的缺点是方法都在构造函数中定义，因此无法实现函数复用。在父类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式\r\n\r\n## 3. 组合继承（经典继承）\r\n将 `原型链` 和 `借用构造函数` 的组合到一块。\r\n使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。\r\n\r\n```javascript\r\nfunction Person (name) {\r\n  this.name = name;\r\n}\r\nPerson.prototype.sayName = function () {\r\n  console.log('My name is ' + this.name);\r\n}\r\n\r\nfunction Man (name) {\r\n  Person.call(this, name)\r\n};\r\nMan.prototype = new Person();\r\n\r\nnew Man('zs').sayName  // 'My name is zs'\r\n```\r\n\r\n优点: 解决了原型链继承和借用构造函数继承造成的影响\r\n缺点: 无论在什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部\r\n\r\n## 4. 原型式继承\r\n创建一个新对象，挂到新建对象的原型上\r\n```javascript\r\nfunction Person () {\r\n  this.name = 'zs';\r\n}\r\n\r\nvar man = Object.create(Person);\r\n\r\nman.name // 'zs'\r\n```\r\n优点是：不需要单独创建构造函数\r\n缺点是：属性中包含的引用值始终会在相关对象间共享，子类实例不能向父类传参\r\n\r\n## 5. 寄生式继承\r\n寄生式继承的思路与(寄生) `原型式继承` 和 `工厂模式` 似, 即创建一个仅用于封装继承过程的函数,该函数在内部以某种方式来增强对象,最后再像真的是它做了所有工作一样返回对象\r\n\r\n```javascrip\r\nfunction objectCopy(obj) {\r\n  function Fun() { };\r\n  Fun.prototype = obj;\r\n  return new Fun();\r\n}\r\n\r\nfunction createAnother(obj) {\r\n  let clone = objectCopy(obj);\r\n  clone.sayName = function () {\r\n    console.log('My name is ' + this.name);\r\n  };\r\n  return clone;\r\n}\r\n\r\nvar person = { name: 'zs' };\r\n\r\ncreateAnother(person).sayName(); // 'My name is zs'\r\n```\r\n\r\n优点：写法简单，不需要单独创建构造函数\r\n缺点：通过寄生式继承给对象添加函数会导致函数难以复用\r\n\r\n## 6. 寄生组合式继承\r\n通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型\r\n\r\n```javascript\r\n// ...\r\nfunction inheritPrototype(child, parent) {\r\n  let prototype = objectCopy(parent.prototype);\r\n  prototype.constructor = child;\r\n  Child.prototype = prototype;\r\n}\r\n```\r\n优点是：高效率只调用一次父构造函数，并且因此避免了在子原型上面创建不必要，多余的属性。与此同时，原型链还能保持不变\r\n缺点是：代码复杂\r\n\r\n# 7. Class实现继承\r\n优点：语法简单易懂,操作更方便\r\n缺点：并不是所有的浏览器都支持class关键字\r\n"}]},{"number":13,"title":"【Q013】JS 原型和原型链","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/13","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 原型\r\n每个函数都有一个特殊的属性叫作 `原型（prototype）`\r\n每个对象都有一个属性叫作 `__proto__`，这个属性会指向该对象的原型\r\n每个原型都有一个 `constructor` 属性指向关联的构造函数\r\n\r\n## 2. 原型链\r\n当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止\r\n这种原型组成的链状结构就是 `原型链`"}]},{"number":14,"title":"【Q014】闭包与作用域链","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/14","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 作用域\r\n`作用域` 是指程序源代码中 **定义变量** 的区域\r\n作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限\r\n\r\n## 2. 作用域链\r\n当访问一个变量时，解释器会首先在当前作用域查找，如果没有找到，就去父作用域找，直到找到该变量或者不在父作用域中，这就是 `作用域链`\r\n\r\n## 3. 闭包\r\n`闭包` 是指有权访问另外一个函数作用域中的变量的 `函数`\r\n闭包是将函数内部和函数外部连接起来的桥梁\r\n\r\n优点：\r\n\r\n- 闭包里的变量不会污染全局，因为变量被封在闭包里\r\n- 所有变量都在闭包里保证了隐私性和私有性\r\n- 可以让这些局部变量保存在内存中，实现变量数据共享\r\n\r\n缺点：\r\n形成闭包即要把一个函数当成值传递，而且该函数还引用这另一个函数的作用域链使得被引用的函数不能被回收，使用不当容易造成内存泄漏\r\n"}]},{"number":15,"title":"【Q015】let、const、var的区别","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/15","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. var\r\n`var` 语句 用于声明一个函数范围或全局范围的变量，并可将其初始化为一个值（可选）。\r\n\r\n用 `var` 声明的变量的作用域是它当前的执行上下文及其闭包（嵌套函数），或者对于声明在任何函数外的变量来说是全局。\r\n`var` 声明的变量，会提升到该作用域的最顶部。\r\n\r\n## 2. let\r\n`let` 语句声明一个块级作用域的局部变量，并可以初始化为一个值（可选）。\r\n\r\n与 `var` 关键字不同的是，`var` 声明的变量作用域是全局或者整个函数块的。\r\n`var` 和 `let` 的另一个重要区别，`let` 声明的变量不会在作用域中被提升，它是在编译时才初始化。\r\n\r\n## 3. const\r\n常量是块级范围的，非常类似用 `let`。但常量的值是无法（通过重新赋值）改变的，也不能被重新声明。\r\n\r\n`const` 声明创建一个值的只读引用。变量标识符不能重新分配，但改变对象的内容。\r\n\r\n## 4. 区别\r\n\r\n- `var` 在全局作用域声明的变量会变成全局变量，例如浏览器环境下挂载在window对象上。`var`和 `let` 不会。\r\n- `var`和 `let` 声明的变量可以重新赋值，`const` 声明的变量只能改变对象的内容。\r\n"}]},{"number":16,"title":"【Q016】JS 中变量声明提升","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/16","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 变量提升\r\n`var` 声明的 **变量** 和 **函数声明** ，会在代码执行前移动到全局代码的开头位置。\r\n```javascript\r\nbla = 2\r\nvar bla;\r\n\r\n// 可以隐式地（implicitly）将以上代码理解为：\r\n\r\nvar bla;\r\nbla = 2;\r\n```\r\n\r\n因此，建议始终在作用域顶部声明变量（全局代码的顶部和函数代码的顶部），这可以清楚知道哪些变量是函数作用域，哪些变量在作用域链上解决。\r\n\r\n重要的是，提升将影响变量声明，而不会影响其值的初始化。仅在运行到赋值语句时初始化变量的值。在此之前，变量的值始终为 `undefined` 。\r\n```javascript\r\nfunction do_something() {\r\n  console.log(bar); // undefined\r\n  var bar = 111;\r\n  console.log(bar); // 111\r\n}\r\n\r\n// 可以隐式地将以上代码理解为：\r\n\r\nfunction do_something() {\r\n  var bar;\r\n  console.log(bar); // undefined\r\n  bar = 111;\r\n  console.log(bar); // 111\r\n}\r\n```"}]},{"number":17,"title":"【Q017】JS 模块化","labels":["javascript"],"body":"理解模块化发展过程，理解 CommonJS，AMD，CMD，UMD，ES6 模块化","url":"https://github.com/kangyana/daily-question/issues/17","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 原生js的模块化\r\n原生js有几个问题：\r\n\r\n- 代码复用\r\n- 全局作用域污染\r\n- 可维护性\r\n\r\n为了解决这些问题，出现了 `命名空间`  和 `匿名闭包 IIFE 模式`，对代码进行封装，并通过提供外部方法来对它们进行访问。\r\n```javascript\r\n// 命名空间\r\nvar namespace = {}\r\nnamespace.add = function(a, b) {\r\n    console.log(a + b)\r\n}\r\nnamespace.add(1, 2)\r\n\r\n// IIEF\r\nvar utils = (function() {\r\n    var module = {}\r\n    module.multiply = function(a, b) {\r\n        console.log(a * b)\r\n    }\r\n    return module\r\n}())\r\nutils.multiply(1,2)\r\n```\r\n\r\n## 2. CommonJS\r\n09年 `CommonJS`（或者称作 CJS）规范推出，在 **NodeJS** 中实现。主要方法是 **exports** 和 **require**。\r\n```javascript\r\n// utils.js 文件\r\nfunction add(a, b) {\r\n    console.log(a + b)\r\n}\r\nmodule.exports.add = add\r\n\r\n// main.js 文件\r\nvar add = require('./utils').add\r\nadd(1, 2)\r\n```\r\n`CJS` 出来以后，服务端的模块概念已经形成，很自然地，大家就想要客户端模块。\r\n但是 `CJS` 是同步的，服务端读取本地硬盘可以很快同步加载完成，但是浏览器同步读取服务器端的模块可能需要很长的时间，浏览器将会处于”假死”状态。\r\n所以出现异步加载 js 文件的 AMD。\r\n\r\n## 3. AMD\r\n`AMD` 是异步模块定义（Asynchronous Module Definition）。\r\n它采用异步方式加载模块，模块的加载不影响它后面语句的运行。\r\n所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。\r\n\r\n```javascript\r\n// utils.js 文件\r\ndefine([], function() {\r\n    return {\r\n        add: function(a, b) {\r\n            console.log(a + b)\r\n        }\r\n    }\r\n})\r\n\r\n// main.js 文件\r\nrequire(['./utils'], function(utils) {\r\n    utils.add(1, 2)\r\n})\r\n```\r\n\r\n由于原生js不支持，使用 `AMD` 规范进行开发需要用到对应的库函数：`RequireJS`。\r\n`requireJS` 主要解决两个问题：\r\n\r\n- 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器\r\n- js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长\r\n\r\n## 4. CMD\r\n\r\n`CMD`（Common Module Definition）是玉伯在开发 `SeaJS` 的时候提出来的，`SeaJS` 要解决的问题和 `RequireJS` 一样。\r\n不同于 AMD 的依赖前置，CMD 是就近依赖。\r\n\r\n```javascript\r\n// AMD\r\nrequire(['./utils', 'a', 'b'], function(utils) {\r\n    console.log(1)\r\n    // 还没有用到 utils a b 等模块，但是 AMD 已经初始化了所有模块\r\n    console.log(2)\r\n    utils.add(1, 2)\r\n})\r\n\r\n// CMD\r\ndefine(function(require, exports, module){\r\n    console.log(1)\r\n    if(false) {\r\n        var utils = require('./utils') // 需要时再 require，不执行就不会加载\r\n        utils.add(1, 2)\r\n    }\r\n})\r\n```\r\n\r\n但是在 `AMD` 也是支持依赖就近，也就是 `CMD` 这样的写法的，所以，`RequireJS` 中，以上两种方式都能执行。\r\n不过，`RequireJS` 官方文档中，默认都是采用依赖前置的写法。\r\n\r\n## 5. UMD\r\n`UMD` 通用模块定义（Universal Module Definition），同时兼容服务端（CJS）和客户端（AMD）的模块化。\r\n\r\n```javascript\r\n// utils.js 文件同上\r\n(function(root, factory) {\r\n    if (typeof define === 'function' && define.amd) {\r\n        //AMD\r\n        define(['utils'], factory)\r\n    } else if (typeof exports === 'object') {\r\n        //CommonJS\r\n        var utils = require('utils')\r\n        module.exports = factory(utils)\r\n    } else {\r\n        root.result = factory(root.utils)\r\n    }\r\n}(this, function(utils) {\r\n    utils.add(1, 2)\r\n}))\r\n```\r\n\r\n## 6. ES6 模块化\r\n`ES6`（ES2015）自带的模块化，使用 **import** 和 **export** 关键字来导入和导出模块。\r\n\r\n```javascript\r\n// utils.js 文件\r\nexport const utils = {\r\n    add: function(a, b) {\r\n        console.log(a + b)\r\n    }\r\n}\r\n\r\n// main.js 文件\r\nimport { utils } from \"./utils\"\r\nutils.add(1, 2)\r\n```\r\n\r\n## 7. CommonJS 和 ES6 的区别\r\n`CommonJS` 模块输出的是一个值的拷贝，`ES6` 模块输出的是值的引用。\r\n`CommonJS` 模块是运行时加载，`ES6` 模块是编译时输出接口。"}]},{"number":18,"title":"【Q018】IIFE 立即执行函数","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/18","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. IIFE 立即调用函数表达式\r\n`IIFE` (Immediately Invoked Function Expression)是一个在定义时就会立即执行的函数。\r\n\r\n```javascript\r\n(function () {\r\n    // to something...\r\n})();\r\n```\r\n这是一个被称为 **自执行匿名函数** 的设计模式，主要包含两部分。\r\n第一部分是包围在 **圆括号运算符** 里的一个匿名函数，这个匿名函数拥有独立的词法作用域。\r\n这不仅避免了外界访问此 `IIFE` 中的变量，而且又不会污染全局作用域。\r\n\r\n## 2. IIFE 的优点\r\n\r\n- `IIFE` 中定义的任何变量和函数，都会在执行结束时被销毁。适合做初始化工作。\r\n- 创建 **块级作用域** ，避免了向全局作用域中添加变量和函数，因此也避免了多人开发中全局变量和函数的命名冲突。\r\n- `IIFE` 中定义的任何变量和函数，都会在执行结束时被销毁。这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了。"}]},{"number":19,"title":"【Q019】匿名函数","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/19","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 什么是匿名函数\r\n\r\n- `匿名函数`，即没有名称的函数\r\n- 如果单独只写一个匿名函数，此时是不符合语法要求的会报错。需要给 `匿名函数` 包裹一个括号，使之成为 **表达式**\r\n- 被小括号包裹的内容会被js识别为一个函数表达式\r\n\r\n## 2. 创建方式\r\n\r\n```javascript\r\n(function () {\r\n      // to something...\r\n}());\r\n```\r\n"}]},{"number":20,"title":"【Q020】箭头函数","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/20","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 箭头函数\r\n`箭头函数表达式` 的语法比 `函数表达式` 更简洁，并且没有自己的 this、arguments、super或new.target。\r\n`箭头函数表达式` 更适用于那些本来需要 `匿名函数` 的地方，并且它不能用作 `构造函数`。\r\n\r\n```javascript\r\nconst materials = [\r\n  'Hydrogen',\r\n  'Helium',\r\n  'Lithium',\r\n  'Beryllium'\r\n];\r\n\r\nconsole.log(materials.map(material => material.length)); // [8, 6, 7, 9]\r\n```\r\n\r\n## 更短的函数\r\n```javascript\r\nvar elements = [\r\n  'Hydrogen',\r\n  'Helium',\r\n  'Lithium',\r\n  'Beryllium'\r\n];\r\n\r\nelements.map(function(element) {\r\n  return element.length;\r\n}); // [8, 6, 7, 9]\r\n\r\n// 上面的普通函数可以改写成如下的箭头函数\r\nelements.map((element) => {\r\n  return element.length;\r\n});\r\n\r\n// 当箭头函数只有一个参数时，可以省略参数的圆括号\r\nelements.map(element => {\r\n return element.length;\r\n});\r\n\r\n// 当箭头函数的函数体只有一个 `return` 语句时，可以省略 `return` 关键字和方法体的花括号\r\nelements.map(element => element.length);\r\n```\r\n\r\n## 没有单独的this\r\n`箭头函数` 不会创建自己的this，它只会从自己的作用域链的上一层继承 `this`。\r\n```javascript\r\nfunction Person(){\r\n  this.age = 0;\r\n\r\n  setInterval(() => {\r\n    this.age++; // this 正确地指向 p 实例\r\n  }, 1000);\r\n}\r\n\r\nvar p = new Person();\r\n```\r\n\r\n## 与严格模式的关系\r\n鉴于 `this` 是词法层面上的，`严格模式` 中与 `this` 相关的规则都将被忽略。\r\n```javascript\r\nvar f = () => { 'use strict'; return this; };\r\nf() === window; // true\r\n```\r\n\r\n## 通过 call 或 apply 调用\r\n由于 `箭头函数` 没有自己的 `this` 指针，通过 call() 、apply()、bind() 方法调用一个函数时，只能传递参数，他们的第一个参数会被忽略。\r\n```javascript\r\nvar adder = {\r\n  base : 1,\r\n\r\n  add : function(a) {\r\n    var f = v => v + this.base;\r\n    return f(a);\r\n  },\r\n\r\n  addThruCall: function(a) {\r\n    var f = v => v + this.base;\r\n    var b = {\r\n      base : 2\r\n    };\r\n\r\n    return f.call(b, a);\r\n  }\r\n};\r\n\r\nconsole.log(adder.add(1));         // 输出 2\r\nconsole.log(adder.addThruCall(1)); // 仍然输出 2\r\n```\r\n\r\n## 不绑定arguments\r\n`箭头函数` 不绑定Arguments 对象。因此，在本示例中，arguments只是引用了封闭作用域内的 arguments：\r\n```javascript\r\nvar arguments = [1, 2, 3];\r\nvar arr = () => arguments[0];\r\n\r\narr(); // 1\r\n\r\nfunction foo(n) {\r\n  var f = () => arguments[0] + n; // 隐式绑定 foo 函数的 arguments 对象. arguments[0] 是 n，即传给 foo 函数的第一个参数\r\n  return f();\r\n}\r\n\r\nfoo(1); // 2\r\nfoo(2); // 4\r\nfoo(3); // 6\r\nfoo(3,2);//6\r\n```\r\n\r\n## 使用 new 操作符\r\n`箭头函数` 不能用作构造器，和 `new` 一起用会抛出错误。\r\n```javascript\r\nvar Foo = () => {};\r\nvar foo = new Foo(); // TypeError: Foo is not a constructor\r\n```\r\n\r\n## 使用prototype属性\r\n箭头函数没有 `prototype` 属性。\r\n```javascript\r\nvar Foo = () => {};\r\nconsole.log(Foo.prototype); // undefined\r\n```\r\n\r\n## 使用 yield 关键字\r\n`yield` 关键字通常不能在 `箭头函数` 中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作函数生成器。\r\n\r\n## 返回对象字面量\r\n记住用 `params => {object:literal}` 这种简单的语法 **返回对象字面量** 是行不通的。\r\n```javascript\r\nvar func = () => { foo: 1 };\r\n// Calling func() returns undefined!\r\n\r\nvar func = () => { foo: function() {} };\r\n// SyntaxError: function statement requires a name\r\n```\r\n\r\n这是因为花括号（`{}`）里面的代码被解析为一系列语句（即 `foo` 被认为是一个标签，而非对象字面量的组成部分）\r\n所以，记得用圆括号把对象字面量包起来：\r\n\r\n```javascript\r\nvar func = () => ({foo: 1});\r\n```\r\n"}]},{"number":21,"title":"【Q021】函数柯里化","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/21","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 柯里化（Currying）\r\n[柯里化（Currying）](https://en.wikipedia.org/wiki/Currying)是一种关于函数的高阶技术。它不仅被用于 JavaScript，还被用于其他编程语言。\r\n`柯里化` 是一种函数的 **转换** ，它是指将一个函数从可调用的 f(a, b, c) 转换为可调用的 f(a)(b)(c)。\r\n`柯里化` 不会调用函数，它只是对函数进行转换。\r\n\r\n```javascript\r\n// 柯里化函数\r\nfunction curry(f) {\r\n  return function(a) {\r\n    return function(b) {\r\n      return f(a, b);\r\n    };\r\n  };\r\n}\r\n\r\n// 求和函数\r\nfunction sum(a, b) {\r\n  return a + b;\r\n}\r\n\r\nconsole.log(curry(sum)(1)(2)) // 3\r\n```\r\n正如你所看到的，实现非常简单：只有两个包装器（wrapper）。\r\n\r\n- curry(func) 的结果就是一个包装器 function(a)。\r\n- 当它被像 curriedSum(1) 这样调用时，它的参数会被保存在词法环境中，然后返回一个新的包装器 function(b)。\r\n- 然后这个包装器被以 2 为参数调用，并且，它将该调用传递给原始的 sum 函数。\r\n\r\n柯里化更高级的实现，例如 lodash 库的 [_.curry](https://lodash.com/docs#curry)，会返回一个包装器，该包装器允许函数被正常调用或者以偏函数（partial）的方式调用：\r\n```javascript\r\nfunction sum(a, b) {\r\n  return a + b;\r\n}\r\n\r\nvar curriedSum = _.curry(sum); // 使用来自 lodash 库的 _.curry\r\nconsole.log(curriedSum(1, 2)); // 3，仍可正常调用\r\nconsole.log(curriedSum(1)(2)); // 3，以偏函数的方式调用\r\n```\r\n\r\n## 2. 柯里化的目的\r\n要了解它的好处，我们需要一个实际中的例子。\r\n\r\n例如，我们有一个用于格式化和输出信息的日志（logging）函数 `log(date, importance, message)`。\r\n在实际项目中，此类函数具有很多有用的功能，例如通过网络发送日志（log）：\r\n```javascript\r\nfunction log(date, importance, message) {\r\n  console.log(`[${date.getHours()}:${date.getMinutes()}] [${importance}] ${message}`);\r\n}\r\n```\r\n\r\n柯里化之后，log 仍正常运行，也可以以柯里化形式运行：\r\n```javascript\r\nlog = _.curry(log);\r\n\r\nlog(new Date(), \"DEBUG\", \"some debug\"); // log(a, b, c)\r\n\r\nlog(new Date())(\"DEBUG\")(\"some debug\"); // log(a)(b)(c)\r\n```\r\n\r\n现在可以轻松地为当前日志创建便捷函数：\r\n```javascript\r\n// logNow 会是带有固定第一个参数的日志的偏函数\r\nvar logNow = log(new Date());\r\n\r\n// 使用它\r\nlogNow(\"INFO\", \"message\"); // [HH:mm] INFO message\r\n```\r\n\r\n现在，logNow 是具有固定第一个参数的 log，换句话说，就是更简短的“偏应用函数（partially applied function）”或“偏函数（partial）”。\r\n\r\n可以更进一步，为当前的调试日志（debug log）提供便捷函数：\r\n```javascript\r\nvar debugNow = logNow(\"DEBUG\");\r\n\r\ndebugNow(\"message\"); // [HH:mm] DEBUG message\r\n```\r\n\r\n总结：\r\n\r\n- 柯里化之后，我们没有丢失任何东西：log 依然可以被正常调用。\r\n- 我们可以轻松地生成偏函数，例如用于生成今天的日志的偏函数。\r\n\r\n## 3. 柯里化的实现\r\n```javascript\r\nfunction curry(func) {\r\n  return function curried(...args) {\r\n    if (args.length >= func.length) {\r\n      return func.apply(this, args);\r\n    } else {\r\n      return function(...args2) {\r\n        return curried.apply(this, args.concat(args2));\r\n      }\r\n    }\r\n  };\r\n}\r\n```\r\n\r\n## 4. 总结\r\n\r\n- `柯里化` 是一种转换，将 f(a,b,c) 转换为可以被以 f(a)(b)(c) 的形式进行调用。JavaScript 实现通常都保持该函数可以被正常调用，并且如果参数数量不足，则返回偏函数。\r\n- `柯里化` 让我们能够更容易地获取偏函数。就像我们在日志记录示例中看到的那样，普通函数 log(date, importance, message) 在被柯里化之后，当我们调用它的时候传入一个参数（如 log(date)）或两个参数（log(date, importance)）时，它会返回偏函数。"}]},{"number":22,"title":"【Q022】Promise","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/22","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. promise\r\n`Promise` 对象用于表示一个异步操作的最终完成（或失败）及其结果值。\r\n异步方法并不会立即返回最终的值，而是会返回一个 promise，以便在未来某个时候把值交给使用者。\r\n\r\n一个 Promise 必然处于以下几种状态之一：\r\n\r\n- 待定（pending）：初始状态，既没有被兑现，也没有被拒绝。\r\n- 已兑现（fulfilled）：意味着操作成功完成。\r\n- 已拒绝（rejected）：意味着操作失败。\r\n\r\n## 2. Promise 的链式调用\r\n因为 `Promise.prototype.then`、`Promise.prototype.catch` 和 `Promise.prototype.finally`方法返回的是 promise，所以它们可以被链式调用。\r\n![Alt](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/promises.png)\r\n\r\n我们用 promise 的 `then` 方法排列起来的相关处理程序就会被调用。\r\n`.then()` 方法需要两个参数，第一个参数作为处理已兑现状态的回调函数，而第二个参数则作为处理已拒绝状态的回调函数。\r\n```javascript\r\nconst myPromise = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    resolve('foo');\r\n  }, 300);\r\n});\r\n\r\nmyPromise\r\n  .then(handleResolvedA, handleRejectedA)\r\n  .then(handleResolvedB, handleRejectedB)\r\n  .then(handleResolvedC, handleRejectedC);\r\n```\r\n\r\n当 `.then()` 中缺少能够返回 promise 对象的函数时，链式调用就直接继续进行下一环操作。\r\n因此，链式调用可以在最后一个 `.catch()` 之前把所有的处理已拒绝状态的回调函数都省略掉。\r\n```javascript\r\nmyPromise\r\n  .then(handleResolvedA)\r\n  .then(handleResolvedB)\r\n  .then(handleResolvedC)\r\n  .catch(handleRejectedAny);\r\n```\r\n\r\n## 3. finally清理\r\n如果你想在 promise 执行完毕后无论其结果怎样都做一些处理或清理时，`.finally()` 方法可能是有用的。\r\n\r\n`.finally()` 虽然与 `.then(onFinally, onFinally)` 类似，它们不同的是：\r\n\r\n- 调用内联函数时，不需要多次声明该函数或为该函数创建一个变量保存它。\r\n- 由于无法知道 promise 的最终状态，所以 finally 的回调函数中不接收任何参数，它仅用于无论最终结果如何都要执行的情况。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 4. 经典八股文\r\n### ① 使用promise实现并发请求限制（阿里云笔试题）\r\n> 有 8 个图片资源的 url，已经存储在数组 `urls` 中，而且已经有一个函数 `loadImages`。\r\n> 要求：\r\n> 1. 任意时刻，同时下载的链接数量不可以超过 n 个。\r\n> 2. 尽可能快速地将所有图片下载完成。\r\n\r\n```javascript\r\nconst urls = [\r\n  \"https://www.kkkk1000.com/images/getImgData/getImgDatadata.jpg\",\r\n  \"https://www.kkkk1000.com/images/getImgData/gray.gif\",\r\n  \"https://www.kkkk1000.com/images/getImgData/Particle.gif\",\r\n  \"https://www.kkkk1000.com/images/getImgData/arithmetic.png\",\r\n  \"https://www.kkkk1000.com/images/getImgData/arithmetic2.gif\",\r\n  \"https://www.kkkk1000.com/images/getImgData/getImgDataError.jpg\",\r\n  \"https://www.kkkk1000.com/images/getImgData/arithmetic.gif\",\r\n  \"https://www.kkkk1000.com/images/wxQrCode2.png\",\r\n];\r\n\r\nfunction loadImages(urls,limit){}\r\n\r\nloadImages(urls, 3);\r\n```\r\n\r\n#### 解析：该题主要考察对 `Promise` 的使用，重点需要理解 `Promise.race()` 和 `Promise.allSettled()` 的用法。\r\n```javascript\r\nconst urls = [\r\n  'https://www.kkkk1000.com/images/getImgData/getImgDatadata.jpg',\r\n  'https://www.kkkk1000.com/images/getImgData/gray.gif',\r\n  'https://www.kkkk1000.com/images/getImgData/Particle.gif',\r\n  'https://www.kkkk1000.com/images/getImgData/arithmetic.png',\r\n  'https://www.kkkk1000.com/images/getImgData/arithmetic2.gif',\r\n  'https://www.kkkk1000.com/images/getImgData/getImgDataError.jpg',\r\n  'https://www.kkkk1000.com/images/getImgData/arithmetic.gif',\r\n  'https://www.kkkk1000.com/images/wxQrCode2.png',\r\n];\r\n\r\n// 加载单个图片\r\nfunction loadSingleImg(url) {\r\n  return new Promise((resolve, reject) => {\r\n    const img = new Image();\r\n    img.onload = function () {\r\n      console.log(`加载成功：${url}`);\r\n      resolve(url);\r\n    };\r\n    img.onerror = function (err) {\r\n      console.log(`加载失败：${url}`);\r\n      reject(err);\r\n    };\r\n    img.src = url;\r\n  });\r\n}\r\n\r\n// 批量加载图片\r\nasync function loadImages(urls, limit) {\r\n  const promises = [];\r\n  const queue = urls.splice(0, limit).map((url, index) => {\r\n    const _p = loadSingleImg(url);\r\n    promises.push(_p);\r\n    return _p.then((res) => {\r\n      return [index, res];\r\n    });\r\n  });\r\n  for (const item of urls) {\r\n    const [index] = await Promise.race(queue);\r\n    const _p = loadSingleImg(item);\r\n    promises.push(_p);\r\n    queue[index] = _p.then((res) => {\r\n      return [index, res];\r\n    });\r\n  }\r\n\r\n  return Promise.allSettled(promises);\r\n}\r\n\r\n// 测试用例\r\nloadImages(urls, 3).then((res) => {\r\n  console.log('批量加载完毕');\r\n});\r\n```"}]},{"number":23,"title":"【Q023】async/await","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/23","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. async 函数\r\n`async` 函数是使用 **async关键字** 声明的函数。`async` 函数是 `AsyncFunction` 构造函数的实例， 并且其中允许使用 **await关键字**。\r\n**async和await关键字** 让我们可以用一种更简洁的方式写出基于`Promise` 的异步行为，而无需刻意地链式调用 `promise`。\r\n\r\n在函数前面的 **async关键字** 做了一件事情：使用函数始终返回一个 promise。其他值将自动被包装在一个 resolved 的 promise 中。\r\n```javascript\r\nasync function f() {\r\n  return 1;\r\n}\r\n\r\nasync function f2() {\r\n  return Promise.resolve(1);\r\n}\r\n\r\nf().then(console.log); // 1\r\nf2().then(console.log); // 1\r\n```\r\n\r\n## 2. await 关键字\r\n`await` 让 JavaScript 引擎等待直到 promise 完成（settle）并返回结果。\r\n```javascript\r\nasync function f() {\r\n  var promise = new Promise((resolve, reject) => {\r\n    setTimeout(() => resolve(\"done!\"), 1000)\r\n  });\r\n\r\n  var result = await promise; // 等待，直到 promise resolve (*)\r\n  console.log(result); // \"done!\"\r\n}\r\n\r\nf();\r\n```\r\n这个函数在执行的时候，“暂停”在了` (*)` 那一行，并在 promise settle 时，拿到 `result` 作为结果继续往下执行。\r\n所以上面这段代码在一秒后显示 “done!”。\r\n\r\n强调一下：await 实际上会暂停函数的执行，直到 promise 状态变为 settled，然后以 promise 的结果继续执行。\r\n这个行为不会耗费任何 CPU 资源，因为 JavaScript 引擎可以同时处理其他任务：执行其他脚本，处理事件等。\r\n\r\n相比于 promise.then，它只是获取 promise 的结果的一个更优雅的语法，并且也更易于读写。\r\n\r\n## 3. Error 处理\r\n如果一个 promise 正常 resolve，`await promise` 返回的就是其结果。\r\n但是如果 promise 被 reject，它将 throw 这个 error，就像在这一行有一个 `throw` 语句那样。\r\n\r\n可以在函数调用后面添加 .catch 来处理这个 error：\r\n```javascript\r\nasync function f() {\r\n  var response = await fetch('http://no-such-url/');\r\n}\r\n\r\n// f() 变成了一个 rejected 的 promise\r\nf().catch(console.log); // TypeError: failed to fetch // (*)\r\n```\r\n\r\n## 4. 总结\r\n函数前面的关键字 async 有两个作用：\r\n\r\n- 让这个函数总是返回一个 promise。\r\n- 允许在该函数内使用 await。\r\n\r\nPromise 前的关键字 await 使 JavaScript 引擎等待该 promise settle，然后有两种情况：\r\n\r\n- 如果有 error，就会抛出异常 —— 就像那里调用了 throw error 一样。\r\n- 否则，就返回结果。\r\n\r\n"}]},{"number":24,"title":"【Q024】Generator","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/24","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. function* 生成器函数\r\n`function*` 这种声明方式会定义一个 **生成器函数** (generator function)，它返回一个 `Generator对象`。\r\n```javascript\r\nfunction* generator(i) {\r\n  yield i;\r\n  yield i + 10;\r\n}\r\n\r\nconst gen = generator(10);\r\nconsole.log(gen.next().value); // 10\r\nconsole.log(gen.next().value); // 20\r\n```\r\n\r\n**生成器函数** 在执行时能暂停，后面又能从暂停处继续执行。\r\n\r\n调用一个生成器函数并不会马上执行它里面的语句，而是返回一个这个生成器的 **迭代器（iterator）对象**。\r\n当这个迭代器的 `next()` 方法被调用时，其内的语句会执行到后续出现 `yield` 的位置为止，`yield` 后紧跟迭代器要返回的值。\r\n或者如果用的是 `yield*`，则表示将执行权移交给另一个生成器函数（当前生成器暂停执行）。\r\n\r\n调用 `next()` 方法时，如果传入了参数，那么这个参数会传给**上一条执行的 yield 语句左边的变量**，例如下面例子中的x：\r\n```javascript\r\nfunction *gen(){\r\n    yield 10;\r\n    x = yield 'foo';\r\n    yield x;\r\n}\r\n\r\nvar gen_obj = gen();\r\nconsole.log(gen_obj.next());// 执行 yield 10，返回 10\r\nconsole.log(gen_obj.next());// 执行 yield 'foo'，返回 'foo'\r\nconsole.log(gen_obj.next(100));// 将 100 赋给上一条 yield 'foo' 的左值，即执行 x=100，返回 100\r\nconsole.log(gen_obj.next());// 执行完毕，value 为 undefined，done 为 true\r\n\r\n```\r\n\r\nyield* 的示例：\r\n```javascript\r\nfunction* anotherGenerator(i) {\r\n  yield i + 1;\r\n  yield i + 2;\r\n  yield i + 3;\r\n}\r\n\r\nfunction* generator(i){\r\n  yield i;\r\n  yield* anotherGenerator(i);// 移交执行权\r\n  yield i + 10;\r\n}\r\n\r\nvar gen = generator(10);\r\nconsole.log(gen.next().value); // 10\r\nconsole.log(gen.next().value); // 11\r\nconsole.log(gen.next().value); // 12\r\nconsole.log(gen.next().value); // 13\r\nconsole.log(gen.next().value); // 20\r\n```\r\n\r\n## 2. Generator对象\r\n`生成器对象` 是由一个 `generator function` 返回的。\r\n```javascript\r\nfunction* gen() {\r\n  yield 1;\r\n  yield 2;\r\n  yield 3;\r\n}\r\n\r\nlet g = gen(); // \"Generator { }\"\r\n```\r\n\r\n## 3. 迭代器对象 iterator\r\n挖坑ing"}]},{"number":25,"title":"【Q025】对象遍历 和 数组遍历","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/25","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"# 一. 对象遍历\r\n## 1. for...in\r\n`for...in` 语句以任意顺序迭代一个对象的除[Symbol](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol)以外的[可枚举](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties)属性，包括继承的可枚举属性。\r\n\r\n```javascript\r\nvar obj = {a:1, b:2, c:3};\r\n\r\nfor (var prop in obj) {\r\n  console.log(\"obj.\" + prop + \" = \" + obj[prop]);\r\n}\r\n\r\n// \"obj.a = 1\"\r\n// \"obj.b = 2\"\r\n// \"obj.c = 3\"\r\n```\r\n\r\n`for...in` 还会获取到**原型链上的可枚举属性**，不过可以使用 `hasOwnProperty()` 方法过滤掉。\r\n```javascript\r\nvar triangle = {a: 1, b: 2, c: 3};\r\n\r\nfunction ColoredTriangle() {\r\n  this.color = 'red';\r\n}\r\n\r\nColoredTriangle.prototype = triangle;\r\n\r\nvar obj = new ColoredTriangle();\r\n\r\nfor (var prop in obj) {\r\n  if (obj.hasOwnProperty(prop)) {\r\n    console.log(`obj.${prop} = ${obj[prop]}`);\r\n  }\r\n}\r\n\r\n// \"obj.color = red\"\r\n```\r\n\r\n### 为什么用 for ... in?\r\n\r\n它最常用的地方应该是用于调试，可以更方便的去检查对象属性。\r\n你在处理有key-value数据，需要检查其中的任何键是否为某值的情况时，推荐用 `for...in`。\r\n\r\n## 2. for...of\r\n`for...of`语句在 **可迭代对象**（包括Array，Map，Set，String，TypedArray，arguments） 上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。\r\n\r\n如果使用 `for...of` 遍历对象，需要给对象的原型一个迭代器方法：\r\n```javascript\r\nvar obj = {\r\n    a:1,\r\n    b:2,\r\n    c:3\r\n};\r\n\r\nobj[Symbol.iterator] = function*(){\r\n    var keys = Object.keys(obj);\r\n    for(var k of keys){\r\n        yield k\r\n    }\r\n};\r\n\r\nfor(var k of obj){\r\n    console.log(k, obj[k]);\r\n}\r\n\r\n// 'a' 1\r\n// 'b' 2\r\n// 'c' 3\r\n```\r\n\r\n### for...of与for...in的区别?\r\n\r\n无论是 `for...in` 还是 `for...of` 语句都是迭代一些东西。它们之间的主要区别在于它们的迭代方式。\r\n- `for...in` 可以迭代Object。\r\n- `for...of` 可以迭代Array等其他 **可迭代对象** ，想迭代Object要给一个迭代器属性。\r\n- `for...in` 还会获取到**原型链上的可枚举属性**\r\n\r\n## 3. Object.keys()\r\n`Object.keys()` 方法会返回一个由一个给定对象的自身可枚举 **属性名（key）组成的数组**，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致。\r\n\r\n```javascript\r\nconst object1 = {\r\n  a: 'somestring',\r\n  b: 42,\r\n  c: false\r\n};\r\n\r\nconsole.log(Object.keys(object1)); //  [\"a\", \"b\", \"c\"]\r\n```\r\n注意：\r\n\r\n- 在 ES5 中，如果此方法的参数不是对象（而是一个原始值），那么它会抛出 **TypeError**。\r\n- 在 ES6 中，非对象的参数将被强制转换为一个对象。\r\n\r\n## 4. Object.getOwnPropertyNames()\r\n`Object.getOwnPropertyNames()` 方法返回一个由指定对象的所有自身属性的 **属性名（key）组成的数组**（属性名 包括不可枚举属性但不包括 `Symbol` 值作为名称的属性）。\r\n\r\n```javascript\r\n// 数组对象\r\nvar arr = [\"a\", \"b\", \"c\"];\r\nconsole.log(Object.getOwnPropertyNames(arr).sort()); // [\"0\", \"1\", \"2\", \"length\"]\r\n\r\n// 类数组对象\r\nvar obj = { 0: \"a\", 1: \"b\", 2: \"c\"};\r\nconsole.log(Object.getOwnPropertyNames(obj).sort()); // [\"0\", \"1\", \"2\"]\r\n\r\n//不可枚举属性\r\nvar my_obj = Object.create({}, {\r\n  getFoo: {\r\n    value: function() { return this.foo; },\r\n    enumerable: false\r\n  }\r\n});\r\nmy_obj.foo = 1;\r\nconsole.log(Object.getOwnPropertyNames(my_obj).sort()); // [\"foo\", \"getFoo\"]\r\n```\r\n\r\n### 如果你只要获取到可枚举属性，请使用 `Object.keys` 或用 `for...in` 循环。\r\n\r\n## 5. Object.getOwnPropertySymbols()\r\n`Object.getOwnPropertySymbols()` 方法返回一个给定对象自身的所有 `Symbol` 属性的数组。\r\n\r\n```javascript\r\nvar obj = {};\r\nvar a = Symbol(\"a\");\r\nvar b = Symbol.for(\"b\");\r\n\r\nobj[a] = \"localSymbol\";\r\nobj[b] = \"globalSymbol\";\r\n\r\nvar objectSymbols = Object.getOwnPropertySymbols(obj);\r\n\r\nconsole.log(objectSymbols.length); // 2\r\nconsole.log(objectSymbols)         // [Symbol(a), Symbol(b)]\r\nconsole.log(objectSymbols[0])      // Symbol(a)\r\n```\r\n\r\n### 与 `Object.getOwnPropertyNames()` 类似，您可以将给定对象的所有符号属性作为 `Symbol` 数组获取。\r\n请注意，`Object.getOwnPropertyNames()` 本身不包含对象的 `Symbol` 属性，只包含字符串属性。\r\n\r\n因为所有的对象在初始化的时候不会包含任何的 `Symbol`，除非你在对象上赋值了 `Symbol` 否则Object.getOwnPropertySymbols()只会返回一个空的数组。\r\n\r\n## 6. Reflect.ownKeys()\r\n`Reflect.ownKeys()` 返回一个由目标对象自身的**属性键（key）组成的数组**。\r\n```javascript\r\nconst object1 = {\r\n  property1: 42,\r\n  property2: 13\r\n};\r\n\r\nconst array1 = [];\r\n\r\nconsole.log(Reflect.ownKeys(object1)); // [\"property1\", \"property2\"]\r\nconsole.log(Reflect.ownKeys(array1)); //  [\"length\"]\r\n```\r\n\r\n### Reflect.ownKeys 方法返回一个由目标对象自身的属性键组成的数组。它的返回值等同于`Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))`。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"# 二、数组遍历\r\n## 1. for 循环\r\n`for循环` 很古老，它在 ECMAScript 1 中就已经存在了。for 循环记录 arr 每个元素的索引和值：\r\n```javascript\r\nconst arr = ['a', 'b', 'c'];\r\narr.prop = 'property value';\r\n\r\nfor (let index=0; index < arr.length; index++) {\r\n  const elem = arr[index];\r\n  console.log(index, elem);\r\n}\r\n\r\n// 0, 'a'\r\n// 1, 'b'\r\n// 2, 'c'\r\n```\r\n\r\n### for 循环的优缺点是什么？\r\n\r\n- 优：它用途广泛。\r\n- 缺：但是当我们要遍历数组时也很麻烦。\r\n- 优：如果我们不想从第一个数组元素开始循环时它仍然很有用，用其他的循环机制很难做到这一点。\r\n\r\n## 2. for-in循环\r\n`for-in循环` 与 `for循环` 一样古老，同样在 ECMAScript 1中就存在了。下面的代码用 for-in 循环输出 arr 的 key：\r\n```javascript\r\nconst arr = ['a', 'b', 'c'];\r\narr.prop = 'property value';\r\n\r\nfor (const key in arr) {\r\n  console.log(key);\r\n}\r\n\r\n// '0'\r\n// '1'\r\n// '2'\r\n// 'prop'\r\n```\r\n\r\n### for-in 不是循环遍历数组的好方法：\r\n\r\n- 它访问的是属性键（key），而不是值（value）。\r\n- 作为属性键（key），数组元素的索引是字符串，而不是数字。\r\n- 它访问的是所有可枚举的属性键（自己的和继承的），而不仅仅是 `Array` 元素的那些。\r\n\r\n### for-in 访问继承属性的实际用途是：遍历对象的所有可枚举属性。\r\n\r\n## 3. 数组方法 .forEach()\r\n鉴于 `for` 和 `for-in` 都不特别适合在数组上循环，因此在 ECMAScript 5 中引入了一个辅助方法：Array.prototype.forEach()：\r\n```javascript\r\nconst arr = ['a', 'b', 'c'];\r\narr.prop = 'property value';\r\n\r\narr.forEach((elem, index) => {\r\n  console.log(elem, index);\r\n});\r\n\r\n// 'a', 0\r\n// 'b', 1\r\n// 'c', 2\r\n```\r\n\r\n### forEach 循环的优缺点是什么？\r\n\r\n- 优：它使我们无需执行大量操作就能够可访问数组元素和索引。\r\n- 缺：不能在它的循环体中使用 `await`。\r\n- 缺：不能提前退出 `forEach()循环`。而在 `for循环` 中可以使用 `break`。\r\n\r\n### 中止 .forEach() 的解决方法\r\n\r\n## 4. 数组方法 .some()\r\n如果想要中止 `.forEach()` 之类的循环，建议使用：`.some()` \r\n`.some()` 还会循环遍历所有数组元素，并在其回调返回真值时停止。\r\n```javascript\r\nconst arr = ['red', 'green', 'blue'];\r\narr.some((elem, index) => {\r\n  if (index >= 2) {\r\n    return true; // 中止循环\r\n  }\r\n  console.log(elem);\r\n  //此回调隐式返回 `undefined`，这\r\n  //是一个伪值。 因此，循环继续。\r\n});\r\n\r\n// 'red'\r\n// 'green'\r\n```\r\n\r\n## 5. for-of 循环\r\nfor-of 循环在 ECMAScript 6 开始支持：\r\n\r\n```javascript\r\nconst arr = ['a', 'b', 'c'];\r\narr.prop = 'property value';\r\n\r\nfor (const elem of arr) {\r\n  console.log(elem);\r\n}\r\n\r\n// 'a'\r\n// 'b'\r\n// 'c'\r\n```\r\n\r\n### for-of 在循环遍历数组时非常有效：\r\n\r\n- 用来遍历数组元素。\r\n- 可以使用 `await`。\r\n- 可以将 `break` 和 `continue` 用于外部作用域。\r\n\r\n## 6. 总结\r\n`for-of` 循环的可用性比 `for`，`for-in` 和 `.forEach()` 更好。\r\n\r\n通常四种循环机制之间的性能差异应该是无关紧要。\r\n如果你要做一些运算量很大的事，还是切换到 `WebAssembly` 更好一些。\r\n\r\n"}]},{"number":26,"title":"【Q026】常见的数组方法","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/26","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"# 一、数组遍历相关\r\n## 1. Array.prototype.entries()\r\n`entries()` 方法返回一个新的 **Array Iterator** 对象，该对象包含数组中每个索引的键/值对。\r\n```javascript\r\nconst array1 = ['a', 'b', 'c'];\r\nconst iterator1 = array1.entries();\r\n\r\nconsole.log(iterator1.next().value); // [0, \"a\"]\r\nconsole.log(iterator1.next().value); // [1, \"b\"]\r\n```\r\n\r\n### 常用于与 `for...of` 构成数组遍历：\r\n```javascript\r\nconst a = [\"a\", \"b\", \"c\"];\r\n\r\nfor (const [index, element] of a.entries()) {\r\n    console.log(index, element);\r\n}\r\n\r\n// 0 'a'\r\n// 1 'b'\r\n// 2 'c'\r\n```\r\n\r\n## 2. Array.prototype.every()\r\n`every()` 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。\r\n\r\n备注： 若收到一个空数组，此方法在任何情况下都会返回 true。\r\n\r\n```javascript\r\nconst array1 = [1, 30, 39, 29, 10, 13];\r\n\r\nconst flag = array1.every((item) => item < 40);\r\nconsole.log(flag); // true\r\n```\r\n\r\n### 常用于判断每一项都符合条件\r\n\r\n## 3. Array.prototype.filter()\r\n`filter()` 方法创建给定数组一部分的 `浅拷贝`，其包含通过所提供函数实现的测试的所有元素。\r\n```javascript\r\nconst words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];\r\n\r\nconst result = words.filter(word => word.length > 6);\r\nconsole.log(result); // [\"exuberant\", \"destruction\", \"present\"]\r\n```\r\n\r\n### 常用于筛选数组\r\n\r\n## 4. Array.prototype.flat()\r\n`flat()` 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。\r\n\r\n根据参数提取嵌套数组的结构深度，默认值为 1：\r\n```javascript\r\nconst arr1 = [0, 1, 2, [3, 4], [[5, 6]]];\r\n\r\nconsole.log(arr1.flat()); // [0, 1, 2, 3, 4, [5, 6]]\r\nconsole.log(arr1.flat(2)); // [0, 1, 2, 3, 4, 5, 6]\r\n```\r\n\r\n还可以移除数组中的空项：\r\n```javascript\r\nvar arr4 = [1, 2, , 4, 5];\r\n\r\nconsole.log(arr4.flat()); // [1, 2, 4, 5]\r\n````\r\n\r\n### 常用于数组降维\r\n\r\n## 5. Array.prototype.flatMap()\r\n`flatMap()` 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。\r\n它与 `map` 连着深度值为 1 的 `flat` 的效果几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些。\r\n\r\n```javascript\r\nconst arr1 = [1, 2, [3], [4, 5], 6, []];\r\n\r\nconsole.log(arr1.flatMap(num => num)); // [1, 2, 3, 4, 5, 6]\r\n// 效果等同于\r\nconsole.log(arr1.map(num => num).flat()) // [1, 2, 3, 4, 5, 6]\r\n```\r\n\r\n### 可用于 需要在 `map()` 时 **插入/减少** 某一项\r\n```javascript\r\nvar a = [5, 4, -3, 20, 17, -33, -4, 18]\r\n\r\na.flatMap((n) => {\r\n  if (n < 0) return [];\r\n  if (n % 2 == 0) return [n];\r\n  return [n-1, 1]\r\n})\r\n\r\nconsole.log(a); // [4, 1, 4, 20, 16, 1, 18]\r\n```\r\n\r\n替代方案（低效，不推荐）：\r\n\r\n`reduce()` 加 `concat()`\r\n```javascript\r\nvar arr = [1, 2, 3, 4];\r\n\r\narr.flatMap(x => [x, x * 2]); // [1, 2, 2, 4, 3, 6, 4, 8]\r\n// \r\narr.reduce((acc, x) => acc.concat([x, x * 2]), []); // [1, 2, 2, 4, 3, 6, 4, 8]\r\n```\r\n\r\n## 6. Array.prototype.forEach()\r\n`forEach()` 方法对数组的每个元素执行一次给定的函数。\r\n```javascript\r\nconst array1 = ['a', 'b', 'c'];\r\n\r\narray1.forEach(element => console.log(element));\r\n\r\n// \"a\"\r\n// \"b\"\r\n// \"c\"\r\n```\r\n\r\n`forEach` 不会直接改变调用它的对象，但是那个对象可能会被 `callbackFn` 函数改变。\r\n\r\n备注：除了抛出异常以外，没有办法中止或跳出 forEach() 循环。\r\n\r\n若你需要提前终止循环，你可以使用：\r\n\r\n- for循环\r\n- for...in/for...of 循环\r\n- Array.prototype.every()\r\n- Array.prototype.some()\r\n- Array.prototype.find()\r\n- Array.prototype.findIndex()\r\n\r\n最后四个方法，甚至可以对数组元素判断，以便确定是否需要继续遍历。\r\n\r\n### 常用于 *不需要异步* 且 *不需要提前跳出* 的数组循环。\r\n\r\n## 7. Array.prototype.keys()\r\n`keys()` 方法返回一个包含数组中每个索引键的 `Array Iterator` 对象。\r\n```javascript\r\nconst array1 = ['a', 'b', 'c'];\r\nconst iterator = array1.keys();\r\n\r\nfor (const key of iterator) {\r\n  console.log(key);\r\n}\r\n\r\n// 0\r\n// 1\r\n// 2\r\n```\r\n\r\n### 此方法很少使用\r\n\r\n## 8. Array.prototype.map()\r\n`map()` 方法 **创建一个新数组**，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。\r\n```javascript\r\nconst array1 = [1, 4, 9, 16];\r\n\r\nconsole.log(array1.map(x => x * 2)); // [2, 8, 18, 32]\r\n```\r\n\r\n若你不想返回的新数组，请使用 `forEach()` 或 `for...of`。\r\n\r\n### 常用于 遍历修改某一项 且 创建新数组。\r\n\r\n### 经典八股文：\r\n```javascript\r\n[\"1\", \"2\", \"3\"].map(parseInt); \r\n```\r\n我们期望输出 [1, 2, 3], 而实际结果是 [1, NaN, NaN]\r\n\r\n`parseInt` 经常被带着一个参数使用，但是这里接受两个。\r\n第一个参数是一个表达式而第二个是回调函数的基，`Array.prototype.map` 传递 3 个参数：element，index，array\r\n\r\n第三个参数被 `parseInt` 忽视了，但不是第二个。因此可能出现混淆。\r\n下面是迭代步骤的拆解：\r\n```javascript\r\nparseInt(\"1\", 0); // 1\r\nparseInt(\"2\", 1); // NaN\r\nparseInt(\"3\", 2); // NaN\r\n```\r\n\r\n## 9. Array.prototype.reduce()\r\n`reduce()` 方法对数组中的每个元素按序执行一个由您提供的 **reducer** 函数。\r\n每一次运行 **reducer** 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。\r\n```javascript\r\nconst array1 = [1, 2, 3, 4];\r\n\r\n// 求和\r\nconst initialValue = 0;\r\nconst sum = array1.reduce((prev, cur) => prev + cur, initialValue);\r\n\r\nconsole.log(sum); // 10\r\n```\r\n\r\n### 常用于累加对象数组里的值，例如求和\r\n\r\n数组去重\r\n```javascript\r\nvar arrary1 = ['a', 'b', 'a', 'b', 'c', 'e', 'e', 'c', 'd', 'd', 'd', 'd']\r\n\r\nvar array2 = arrary1.reduce((prev, cur) => {\r\n  if (prev.indexOf(cur) === -1) prev.push(cur)\r\n  return prev\r\n}, [])\r\n\r\nconsole.log(array2); // ['a', 'b', 'c', 'e', 'd']\r\n```\r\n\r\n对象数组分组\r\n```javascript\r\nvar array1 = [\r\n  { type: 'fruit', name: 'apple' },\r\n  { type: 'vegetable', name: 'tomato' },\r\n  { type: 'fruit', name: 'mango' },\r\n]\r\n\r\nconst dictionary = {};\r\n\r\narray1.reduce((prev, cur) => {\r\n  if (prev[cur.type]) {\r\n    prev[cur.type].push(cur)\r\n  } else {\r\n    prev[cur.type] = [cur]\r\n  }\r\n  return prev\r\n}, dictionary)\r\n\r\nconsole.log(dictionary); // {fruit: Array(2), vegetable: Array(1)}\r\n```\r\n\r\n## 10. Array.prototype.reduceRight()\r\n`reduceRight()` 方法接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。\r\n```javascript\r\nconst array1 = [[0, 1], [2, 3], [4, 5]];\r\n\r\nconst result = array1.reduceRight((acc, cur) => acc.concat(cur));\r\nconsole.log(result); // [4, 5, 2, 3, 0, 1]\r\n```\r\n\r\n### `reduce` 与 `reduceRight` 之间的区别：正序遍历和倒序遍历\r\n```javascript\r\nvar a = ['1', '2', '3', '4', '5'];\r\nvar left  = a.reduce((prev, cur) => prev + cur);\r\nvar right = a.reduceRight((prev, cur) => prev + cur);\r\n\r\nconsole.log(left);  // \"12345\"\r\nconsole.log(right); // \"54321\"\r\n```\r\n\r\n## 11. Array.prototype.some()\r\n`some()` 方法测试数组中是不是至少有 1 个元素通过了被提供的函数测试。它返回的是一个 `Boolean` 类型的值。\r\n```javascript\r\nconst array = [1, 2, 3, 4, 5];\r\n\r\nconsole.log(array.some((item) => item % 2 === 0)); // true\r\n```\r\n\r\n备注： 如果用一个空数组进行测试，在任何情况下它返回的都是false。\r\n\r\n### 常用于检查数组是否存在不符合条件的值。（性能推荐，找到第一个值就跳出循环）\r\n\r\n## 12. Array.prototype.values()\r\n`values()` 方法返回一个新的 `Array Iterator` 对象，该对象包含数组每个索引的值。\r\n```javascript\r\nconst array1 = ['a', 'b', 'c'];\r\nconst iterator = array1.values();\r\n\r\nfor (const value of iterator) {\r\n  console.log(value);\r\n}\r\n\r\n// \"a\"\r\n// \"b\"\r\n// \"c\"\r\n```\r\n\r\n### 与 `key()` 方法一样很少被使用\r\n\r\n## 13. Array.prototype[@@iterator]()\r\n`@@iterator` 和 `values()` 的初始值是同一个函数对象。\r\n\r\n### 同 `values()` 方法使用"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"# 二、数组增删改\r\n## 1. Array.prototype.concat()\r\n`concat()` 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。\r\n```javascript\r\nconst array1 = ['a', 'b', 'c'];\r\nconst array2 = ['d', 'e', 'f'];\r\nconst array3 = array1.concat(array2);\r\n\r\nconsole.log(array3); // [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]\r\n```\r\n\r\n### 常用于合并数组\r\n\r\n使用 Symbol.isConcatSpreadable 合并类数组对象\r\n`concat` 默认情况下不会将类数组对象视作数组——仅在 `Symbol.isConcatSpreadable` 被设置为真值（例如，true）时才会将类数组对象视作数组。\r\n```javascript\r\nconst obj1 = { 0: 1, 1: 2, 2: 3, length: 3 };\r\nconst obj2 = { 0: 1, 1: 2, 2: 3, length: 3, [Symbol.isConcatSpreadable]: true };\r\n\r\nconsole.log([0].concat(obj1, obj2)); // [ 0, { '0': 1, '1': 2, '2': 3, length: 3 }, 1, 2, 3 ]\r\n```\r\n\r\n## 2. Array.prototype.copyWithin()\r\n`copyWithin()` 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。\r\n```javascript\r\nconst array1 = ['a', 'b', 'c', 'd', 'e'];\r\n\r\nconsole.log(array1.copyWithin(0, 3, 4)); // [\"d\", \"b\", \"c\", \"d\", \"e\"]\r\nconsole.log(array1.copyWithin(1, 3)); // [\"d\", \"d\", \"e\", \"d\", \"e\"]\r\n```\r\n\r\n### `copyWithin` 就像 C 和 C++ 的 `memcpy` 函数一样，且它是用来移动 `Array` 或者 `TypedArray` 数据的一个高性能的方法。\r\n复制以及粘贴序列这两者是为一体的操作;即使复制和粘贴区域重叠，粘贴的序列也会有拷贝来的值。\r\n\r\n## 3. Array.prototype.fill()\r\n`fill()` 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。\r\n```javascript\r\nconst array1 = [1, 2, 3, 4];\r\n\r\nconsole.log(array1.fill(0, 2, 4)); // [1, 2, 0, 0]\r\nconsole.log(array1.fill(5, 1)); // [1, 5, 5, 5]\r\nconsole.log(array1.fill(6)); // [6, 6, 6, 6]\r\n```\r\n\r\n### 常用于快速填充数组\r\n\r\n## 4. Array.prototype.pop()\r\n`pop()` 方法从数组中删除最后一个元素，并返回该元素的值。此方法会更改数组的长度。\r\n```javascript\r\nconst plants = ['broccoli', 'cauliflower', 'cabbage', 'kale', 'tomato'];\r\n\r\nconsole.log(plants.pop()); // \"tomato\"\r\nconsole.log(plants); // [\"broccoli\", \"cauliflower\", \"cabbage\", \"kale\"]\r\n\r\nplants.pop();\r\nconsole.log(plants); // [\"broccoli\", \"cauliflower\", \"cabbage\"]\r\n```\r\n\r\n### 常用于删除掉数组的最后一位\r\n\r\n## 5. Array.prototype.push()\r\n`push()` 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。\r\n```javascript\r\nconst animals = ['pigs', 'goats', 'sheep'];\r\n\r\nconst count = animals.push('cows');\r\nconsole.log(count); // 4\r\nconsole.log(animals); // [\"pigs\", \"goats\", \"sheep\", \"cows\"]\r\n\r\nanimals.push('chickens', 'cats', 'dogs');\r\nconsole.log(animals); // [\"pigs\", \"goats\", \"sheep\", \"cows\", \"chickens\", \"cats\", \"dogs\"]\r\n```\r\n\r\n### 常用于给数组添加元素\r\n\r\n合并两个数组\r\n```javascript\r\nvar vegetables = ['parsnip', 'potato'];\r\nvar moreVegs = ['celery', 'beetroot'];\r\n\r\n// 相当于 vegetables.push(...moreVegs);\r\nArray.prototype.push.apply(vegetables, moreVegs);\r\n\r\nconsole.log(vegetables); // ['parsnip', 'potato', 'celery', 'beetroot']\r\n```\r\n\r\n像数组一样使用对象\r\n`push` 是特意设计为通用的，我们可以使用它来获得便利。\r\n```javascript\r\nvar obj = {\r\n    length: 0,\r\n\r\n    addElem: function addElem (elem) {\r\n        // obj.length is automatically incremented\r\n        // every time an element is added.\r\n        [].push.call(this, elem);\r\n    }\r\n};\r\n\r\nobj.addElem({});\r\nobj.addElem({});\r\n\r\nconsole.log(obj.length); // 2\r\nconsole.log(obj); // {0: {}, 1: {}, length: 2, addElem: ƒ}\r\n```\r\n\r\n## 6. Array.prototype.shift()\r\n`shift()` 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。\r\n```javascript\r\nconst array1 = [1, 2, 3];\r\n\r\nconst firstElement = array1.shift();\r\n\r\nconsole.log(array1); // [2, 3]\r\nconsole.log(firstElement); // 1\r\n```\r\n\r\n### 常用于删除数组中第一位\r\n\r\n## 7. Array.prototype.slice()\r\n`slice()` 方法返回一个新的数组对象，这一对象是一个由 `begin` 和 `end` 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。\r\n```javascript\r\nconst animals = ['ant', 'bison', 'camel', 'duck', 'elephant'];\r\n\r\nconsole.log(animals.slice(2)); // [\"camel\", \"duck\", \"elephant\"]\r\nconsole.log(animals.slice(2, 4)); // [\"camel\", \"duck\"]\r\nconsole.log(animals.slice(1, 5)); // [\"bison\", \"camel\", \"duck\", \"elephant\"]\r\nconsole.log(animals.slice(-2)); // [\"duck\", \"elephant\"]\r\nconsole.log(animals.slice(2, -1)); // [\"camel\", \"duck\"]\r\nconsole.log(animals.slice()); // [\"ant\", \"bison\", \"camel\", \"duck\", \"elephant\"]\r\n```\r\n\r\n### 常用于截取数组\r\n\r\n类数组对象转数组\r\n```javascript\r\nfunction list() {\r\n  return Array.prototype.slice.call(arguments);\r\n}\r\n\r\nvar list1 = list(1, 2, 3); // [1, 2, 3]\r\n```\r\n除了使用 `Array.prototype.slice.call(arguments)`，你也可以简单的使用 `[].slice.call(arguments) 来代替`。另外，你可以使用 `bind` 来简化该过程。\r\n```javascript\r\nfunction list() {\r\n  return Function.prototype.call.bind(Array.prototype.slice)(arguments);\r\n}\r\n\r\nvar list1 = list(1, 2, 3); // [1, 2, 3]\r\n```\r\n\r\n## 8. Array.prototype.splice()\r\n`splice()` 方法通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容。此方法会改变原数组。\r\n```javascript\r\nconst months = ['Jan', 'March', 'April', 'June'];\r\nmonths.splice(1, 0, 'Feb');\r\n\r\nconsole.log(months); // [\"Jan\", \"Feb\", \"March\", \"April\", \"June\"]\r\n\r\nmonths.splice(4, 1, 'May');\r\n\r\nconsole.log(months); // [\"Jan\", \"Feb\", \"March\", \"April\", \"May\"]\r\n```\r\n\r\n### 常用于替换数组中某一段\r\n\r\n## 9. Array.prototype.unshift()\r\n`unshift()` 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度。\r\n```javascript\r\nconst array1 = [1, 2, 3];\r\n\r\nconsole.log(array1.unshift(4, 5)); // 5\r\nconsole.log(array1); // [4, 5, 1, 2, 3]\r\n```\r\n\r\n### 常用于添加多个元素到数组开头"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"# 3. 数组查询\r\n## 1. Array.prototype.at()\r\n`at()` 方法接收一个整数值并返回该索引的项目，允许正数和负数。负整数从数组中的最后一个项目开始倒数。\r\n```javascript\r\nconst array1 = [5, 12, 8, 130, 44];\r\n\r\nlet index = 2;\r\nconsole.log(`${index}: ${array1.at(index)}`); // \"2: 8\"\r\n\r\nindex = -2;\r\nconsole.log(`${index}: ${array1.at(index)}`); // \"-2: 130\"\r\n```\r\n\r\n### 常用于快速寻找数组最后一个值\r\n\r\n比较不同的数组方法\r\n这个例子比较了选择 `Array` 中倒数第二项的不同方法，凸显了 `at()` 方法的简洁性和可读性。\r\n```javascript\r\n// 数组及数组元素。\r\nconst colors = ['red', 'green', 'blue'];\r\n\r\n// 使用长度属性。\r\nconst lengthWay = colors[colors.length-2];\r\nconsole.log(lengthWay); // 'green'\r\n\r\n// 使用 slice() 方法。注意会返回一个数组。\r\nconst sliceWay = colors.slice(-2, -1);\r\nconsole.log(sliceWay[0]); // 'green'\r\n\r\n// 使用 at() 方法。\r\nconst atWay = colors.at(-2);\r\nconsole.log(atWay); // 'green'\r\n```\r\n\r\n## 2. Array.prototype.find()\r\n`find()` 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 `undefined`。\r\n```javascript\r\nconst array1 = [5, 12, 8, 130, 44];\r\n\r\nconst found = array1.find(element => element > 10);\r\nconsole.log(found); // 12\r\n```\r\n\r\n### 常用于 用对象的属性查找数组里的对象\r\n```javascript\r\nconst inventory = [\r\n  {name: 'apples', quantity: 2},\r\n  {name: 'bananas', quantity: 0},\r\n  {name: 'cherries', quantity: 5}\r\n];\r\n\r\nvar item = inventory.find(item => item.name === 'cherries');\r\nconsole.log(item); // { name: 'cherries', quantity: 5 }\r\n```\r\n\r\n## 3. Array.prototype.findIndex()\r\n`findIndex()` 方法返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1。\r\n```javascript\r\nconst array1 = [5, 12, 8, 130, 44];\r\n\r\nconst index = array1.findIndex(element => element > 13);\r\nconsole.log(index); // 3\r\n```\r\n\r\n### 常用于 查找数组中第一个匹配元素的索引。\r\n\r\n## 4. Array.prototype.findLast()\r\n`findLast()` 方法返回数组中满足提供的测试函数条件的最后一个元素的值。如果没有找到对应元素，则返回 `undefined`。\r\n```javascript\r\nconst array1 = [5, 12, 8, 130, 44];\r\n\r\nconst item = array1.findLast(element => element > 13);\r\nconsole.log(item); // 44\r\n```\r\n\r\n### 常用于 查找数组中最后一个匹配元素。\r\n\r\n## 5. Array.prototype.findLastIndex()\r\n`findLastIndex()` 方法返回数组中满足提供的测试函数条件的最后一个元素的索引。若没有找到对应元素，则返回 -1。\r\n```javascript\r\nconst array1 = [5, 12, 8, 130, 44];\r\n\r\nconst item = array1.findLastIndex(element => element > 13);\r\nconsole.log(item); // 4\r\n```\r\n\r\n### 常用于 查找数组中最后一个匹配元素的索引。\r\n\r\n## 6. Array.prototype.includes()\r\n`includes()` 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 `true`，否则返回 `false`。\r\n```javascript\r\nconst array1 = [1, 2, 3];\r\n\r\nconsole.log(array1.includes(2)); // true\r\n\r\nconst pets = ['cat', 'dog', 'bat'];\r\n\r\nconsole.log(pets.includes('cat')); // true\r\nconsole.log(pets.includes('at')); // false\r\n```\r\n\r\n`includes()` 方法有意设计为通用方法。它不要求this值是数组对象，所以它可以被用于其他类型的对象 (比如类数组对象)。\r\n```javascript\r\n(function() {\r\n  console.log([].includes.call(arguments, 'a')); // true\r\n  console.log([].includes.call(arguments, 'd')); // false\r\n})('a','b','c');\r\n···\r\n\r\n### 常用于 快速查找一个值是否包含在该数组中。\r\n\r\n## 7. Array.prototype.indexOf()\r\n`indexOf()` 方法返回在数组中可以找到给定元素的第一个索引，如果不存在，则返回 -1。\r\n```javascript\r\nconst beasts = ['ant', 'bison', 'camel', 'duck', 'bison'];\r\n\r\nconsole.log(beasts.indexOf('bison')); // 1\r\nconsole.log(beasts.indexOf('bison', 2)); // 4\r\nconsole.log(beasts.indexOf('giraffe')); // -1\r\n```\r\n\r\n### 常用于 快速查找数组中第一个匹配元素的索引。\r\n\r\n## 8. Array.prototype.lastIndexOf()\r\n`lastIndexOf()` 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。\r\n从数组的后面向前查找，从 `fromIndex` 处开始。\r\n```javascript\r\nconst animals = ['Dodo', 'Tiger', 'Penguin', 'Dodo'];\r\n\r\nconsole.log(animals.lastIndexOf('Dodo')); // 3\r\nconsole.log(animals.lastIndexOf('Tiger')); // 1\r\n```\r\n\r\n### 常用于 快速查找数组中最后一个匹配元素的索引。\r\n\r\n## 9. 总结\r\n如果你需要查找的方法：\r\n\r\n- 第一个匹配的元素，使用 `find()`。\r\n- 最后一个匹配的元素，使用 `findLast()`。\r\n- 第一个匹配元素的索引，使用 `findIndex()`。\r\n- 最后一个匹配元素的索引，使用 `findLastIndex()`。\r\n- 纯粹查第一个匹配的索引，使用 `indexOf()`。它类似于 `findIndex()`，但是会检查每个元素是否和值相等，而不是使用一个测试函数。\r\n- 纯粹查最后一个匹配的索引，使用 `lastIndexOf()`。\r\n- 一个值是否包含在该数组中，使用 `includes()`。同样地，它检查每个元素是否和值相等，而不是使用一个测试函数。\r\n- 是否有任意一个元素满足提供的测试函数，使用 `some()`。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"# 4. 数组创建\r\n## 1. Array.of()\r\n`Array.of()` 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。\r\n\r\n### `Array.of()` 和 `Array` 构造函数之间的区别在于处理整数参数：\r\nArray.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个长度为 7 的空数组。\r\n```javascrpt\r\nArray.of(7); // [7]\r\nArray(7); // [empty × 7]\r\n\r\nArray.of(1, 2, 3); // [1, 2, 3]\r\nArray(1, 2, 3);    // [1, 2, 3]\r\n```\r\n\r\n## 2. Array.from()\r\n`Array.from()` 方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。\r\n```javascript\r\nconsole.log(Array.from('foo')); // [\"f\", \"o\", \"o\"]\r\n\r\nconsole.log(Array.from([1, 2, 3], x => x + x)); // [2, 4, 6]\r\n```\r\n\r\n### 常用于 根据指定数据创建数组\r\n\r\n数组去重合并\r\n```javascript\r\nfunction combine(){\r\n    let arr = [].concat.apply([], arguments);  // 没有去重复的新数组\r\n    return Array.from(new Set(arr));\r\n}\r\n\r\nvar m = [1, 2, 2];\r\nvar n = [2, 3, 3];\r\nconsole.log(combine(m,n)); // [1, 2, 3]\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"# 5. 其他\r\n## 1. Array.isArray()\r\n`Array.isArray()` 用于确定传递的值是否是一个 `Array`。\r\n```javascript\r\nArray.isArray([1, 2, 3]);  // true\r\nArray.isArray({foo: 123}); // false\r\nArray.isArray('foobar');   // false\r\nArray.isArray(undefined);  // false\r\n```\r\n\r\n### `Array.isArray()` 和 `instanceof` 的区别\r\n当检测 `Array` 实例时，`Array.isArray` 优于 `instanceof`，因为 `Array.isArray` 能检测 `iframes`。\r\n```javascript\r\nconst iframe = document.createElement('iframe');\r\ndocument.body.appendChild(iframe);\r\nxArray = window.frames[window.frames.length-1].Array;\r\nconst arr = new xArray(1,2,3); // [1,2,3]\r\n\r\n// 正确检查 Array\r\nArray.isArray(arr);  // true\r\n// Considered harmful, because doesn't work through iframes\r\narr instanceof Array; // false\r\n```\r\n\r\n### 常用于 精准的判断数据类型是否为数组\r\n\r\n## 2. Array.prototype.join()\r\n`join()` 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。\r\n如果数组只有一个项目，那么将返回该项目而不使用分隔符。\r\n```javascript\r\nconst elements = ['Fire', 'Air', 'Water'];\r\n\r\nconsole.log(elements.join()); // \"Fire,Air,Water\"\r\nconsole.log(elements.join('')); // \"FireAirWater\"\r\nconsole.log(elements.join('-')); // \"Fire-Air-Water\"\r\n```\r\n\r\n警告： 如果一个元素为 `undefined` 或 `null`，它会被转换为空字符串。\r\n\r\n### 常用于拼接字符串\r\n\r\n## 3. Array.prototype.reverse()\r\n`reverse()` 方法将数组中元素的位置颠倒，并返回该数组。\r\n该方法会改变原数组。\r\n```javascript\r\nconst array1 = ['one', 'two', 'three'];\r\n\r\nconst reversed = array1.reverse();\r\nconsole.log('reversed:', reversed); // [\"three\", \"two\", \"one\"]\r\nconsole.log('array1:', array1); // [\"three\", \"two\", \"one\"]\r\n```\r\n\r\n### 常用于数组反转排序\r\n\r\n## 4. Array.prototype.sort()\r\n`sort()` 方法用[原地算法](https://zh.wikipedia.org/wiki/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)对数组的元素进行排序，并返回数组。\r\n默认排序顺序是在将元素转换为字符串，然后比较它们的 UTF-16 代码单元值序列时构建的。\r\n```javascript\r\nconst months = ['March', 'Jan', 'Feb', 'Dec'];\r\n\r\nconsole.log(months.sort()); // [\"Dec\", \"Feb\", \"Jan\", \"March\"]\r\n\r\nconst array1 = [1, 30, 4, 21, 100000];\r\n\r\nconsole.log(array1.sort()); // [1, 100000, 21, 30, 4]\r\n```\r\n\r\n比较函数的基本用法：\r\n```javascript\r\nfunction compareFn(a, b) {\r\n  if (在某些排序规则中，a 小于 b) {\r\n    return -1;\r\n  }\r\n  if (在这一排序规则下，a 大于 b) {\r\n    return 1;\r\n  }\r\n  // a 一定等于 b\r\n  return 0;\r\n}\r\n```\r\n\r\n比较数字（升序排列）\r\n```javascript\r\nfunction compareNumbers(a, b) {\r\n  return a - b;\r\n}\r\n```\r\n\r\n对非 ASCII 字符排序\r\n当排序非 ASCII 字符的字符串（如包含类似 e, é, è, a, ä 等字符的字符串）。\r\n一些非英语语言的字符串需要使用 `String.localeCompare`。\r\n```javascript\r\nvar items = ['réservé', 'premier', 'cliché', 'communiqué', 'café', 'adieu'];\r\nitems.sort((a, b) =>  a.localeCompare(b));\r\n\r\nconsole.log(items); //  ['adieu', 'café', 'cliché', 'communiqué', 'premier', 'réservé']\r\n```\r\n\r\n### 常用于数组手动排序\r\n\r\n## 5. Array.prototype.toLocaleString()\r\n`toLocaleString()` 返回一个字符串表示数组中的元素。\r\n数组中的元素将使用各自的 `toLocaleString` 方法转成字符串，这些字符串将使用一个特定语言环境的字符串（例如逗号）隔开。\r\n```javascript\r\nconst array1 = [1, 'a', new Date('21 Dec 1997 14:12:00 UTC')];\r\nconst localeString = array1.toLocaleString('en', { timeZone: 'UTC' });\r\n\r\nconsole.log(localeString); // \"1,a,12/21/1997, 2:12:00 PM\"\r\n```\r\n\r\n数组中的元素将会使用各自的 `toLocaleString` 方法：\r\n\r\n- Object: Object.prototype.toLocaleString()\r\n- Number: Number.prototype.toLocaleString()\r\n- Date: Date.prototype.toLocaleString()\r\n\r\n### 用于数字货币转换：\r\n```javascript\r\nvar prices = ['￥7', 500, 8123, 12];\r\n\r\nprices.toLocaleString('ja-JP', { style: 'currency', currency: 'JPY' }); // \"￥7,￥500,￥8,123,￥12\"\r\n```\r\n\r\n## 6. Array.prototype.toString()\r\n`toString()` 方法返回一个字符串，表示指定的数组及其元素。\r\n```javascript\r\nconst array1 = [1, 2, 'a', '1a'];\r\n\r\nconsole.log(array1.toString()); // \"1,2,a,1a\"\r\n```\r\n\r\n`Array` 对象覆盖了 `Object` 的 `toString` 方法。\r\n对于数组对象，`toString` 方法在内部调用 `join()` 方法拼接数组中的元素并返回一个字符串，其中包含用逗号分隔的每个数组元素。\r\n如果 `join` 方法不可用，或者它不是一个函数，将使用 `Object.prototype.toString` 代替，返回 `[object Array]`。\r\n\r\n备注：当一个数组被作为文本值或者进行字符串拼接操作时，将会自动调用其 `toString` 方法。\r\n\r\n### 经典八股文：\r\n`Object.prototype.toString` 和 `Object.toString` 是一回事吗？\r\n\r\n不是。 \r\n因为 `Object.toString` 是 `Object.__proto__.toString`，也就是去上一级的原型中拿的方法，是 `Function.prototype.toString`。\r\n同理 `Number`，`String`，`Array` 里的 `toString` 也和 `Object.prototype.toString` 不一样，而且它们也都被重写了 `toString` 方法。\r\n"}]},{"number":27,"title":"【Q027】Ajax 工作原理","labels":["javascript"],"body":"着重理解，XMLHttpRequest","url":"https://github.com/kangyana/daily-question/issues/27","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 什么是Ajax？\r\n`AJAX`（Asynchronous JavaScript And XML）是使用 `XMLHttpRequest` 对象与服务器通信。\r\n它可以使用 JSON，XML，HTML 和 text 文本等格式发送和接收数据。\r\n`AJAX` 最吸引人的就是它的“异步”特性，也就是说它可以在不重新刷新页面的情况下与服务器通信，交换数据，或更新页面。\r\n\r\n你可以使用 AJAX 最主要的两个特性做下列事：\r\n\r\n- 在不重新加载页面的情况下发送请求给服务器。\r\n- 接受并使用从服务器发来的数据。\r\n\r\n### 如何发送 http 请求\r\n使用 `XMLHttpRequest` 方法建立一个请求：\r\n```javascript\r\nif (window.XMLHttpRequest) { // Mozilla, Safari, IE7+ ...\r\n    httpRequest = new XMLHttpRequest();\r\n} else if (window.ActiveXObject) { // IE 6 and older\r\n    httpRequest = new ActiveXObject(\"Microsoft.XMLHTTP\");\r\n}\r\n```\r\n\r\n请求响应的回调函数：\r\n```javascript\r\nhttpRequest.onreadystatechange = function(){\r\n    if (httpRequest.readyState === XMLHttpRequest.DONE) {\r\n        // Everything is good, the response was received.\r\n    } else {\r\n        // Not ready yet.\r\n    }\r\n};\r\n```\r\n\r\n发送一个实际的请求：\r\n```javascript\r\nhttpRequest.open('GET', 'http://www.example.org/some.file', true);\r\nhttpRequest.send();\r\n```\r\n\r\n可以在 `send` 调用之前设置请求头：\r\n```javascript\r\nhttpRequest.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. Ajax 工作原理\r\n\r\n![Alt](https://raw.githubusercontent.com/kangyana/img-storage/master/xhr_process.png)\r\n\r\n1. 浏览器调用xhr去请求服务器。\r\n2. 浏览器继续做其他工作。\r\n3. xhr请求服务器。\r\n4. 服务器响应xhr。\r\n5. xhr通知浏览器响应的数据。\r\n6. 浏览器利用xhr收到的数据渲染页面。"}]},{"number":28,"title":"【Q028】fetch","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/28","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. fetch\r\n`fetch`API 用于访问和操纵 HTTP 管道的一些具体部分，例如请求和响应。\r\n\r\n这种功能以前是使用 `XMLHttpRequest` 实现的，`Fetch` 提供了一个更理想的替代方案。\r\n```javascript\r\nfetch('http://example.com/movies.json')\r\n  .then(response => response.json())\r\n  .then(data => console.log(data));\r\n```\r\n\r\n### `fetch` 与 `jQuery.ajax()` 的区别：\r\n\r\n- 当接收到一个代表错误的 HTTP 状态码时，从 fetch() 返回的 Promise 不会被标记为 reject，即使响应的 HTTP 状态码是 404 或 500。\r\n相反，它会将 Promise 状态标记为 resolve（如果响应的 HTTP 状态码不在 200 - 299 的范围内，则设置 resolve 返回值的 ok 属性为 false），仅当网络故障时或请求被阻止时，才会标记为 reject。\r\n- fetch 不会发送跨域 cookie，除非你使用了 credentials 的 初始化选项。"}]},{"number":29,"title":"【Q029】同源策略（same-origin policy）","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/29","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 同源策略\r\n`同源策略` 是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。\r\n\r\n## 2. 同源的定义\r\n如果两个 URL 的 protocol (如果有指定的话) 和 host 都相同的话，则这两个 URL 是同源。\r\n这个方案也被称为“协议/主机/端口元组”，或者直接是“元组”。（“元组”是指一组项目构成的整体，双重/三重/四重/五重/等的通用形式）。\r\n\r\n下表给出了与 URL `http://store.company.com/dir/page.html` 的源进行对比的示例：\r\n\r\nURL | 结果 | 原因\r\n-- | -- | --\r\nhttp://store.company.com/dir2/other.html | 同源 | 只有路径不同\r\nhttp://store.company.com/dir/inner/another.html | 同源 | 只有路径不同\r\nhttps://store.company.com/secure.html | 失败 | 协议不同\r\nhttp://store.company.com:81/dir/etc.html | 失败 | 端口不同 ( http:// 默认端口是 80)\r\nhttp://news.company.com/dir/other.html | 失败 | 主机不同\r\n\r\n## 3. 源的继承\r\n在页面中通过 `about:blank` 或 `javascript: URL` 执行的脚本会继承打开该 URL 的文档的源，因为这些类型的 URLs 没有包含源服务器的相关信息。\r\n\r\n## 4. 源的更改\r\n满足某些限制条件的情况下，页面是可以修改它的源。脚本可以将 `document.domain` 的值设置为其当前域或其当前域的父域。如果将其设置为其当前域的父域，则这个较短的父域将用于后续源检查。\r\n\r\n例如：假设 http://store.company.com/dir/other.html 文档中的一个脚本执行以下语句：\r\n```javascript\r\ndocument.domain = \"company.com\";\r\n```\r\n\r\n## 5. 跨源网络访问\r\n同源策略控制不同源之间的交互，例如在使用 `XMLHttpRequest` 或 `<img>` 标签时则会受到同源策略的约束。这些交互通常分为三类：\r\n\r\n- 跨源写操作（Cross-origin writes）一般是被允许的。例如链接（links），重定向以及表单提交。特定少数的 HTTP 请求需要添加 预检请求。\r\n- 跨源资源嵌入（Cross-origin embedding）一般是被允许（后面会举例说明）。\r\n- 跨源读操作（Cross-origin reads）一般是不被允许的，但常可以通过内嵌资源来巧妙的进行读取访问。例如，你可以读取嵌入图片的高度和宽度，调用内嵌脚本的方法，或 availability of an embedded resource。\r\n\r\n以下是可能嵌入跨源的资源的一些示例：\r\n\r\n- `<script src=\"...\"></script>` 标签嵌入跨源脚本。语法错误信息只能被同源脚本中捕捉到。\r\n- `<link rel=\"stylesheet\" href=\"...\">` 标签嵌入 CSS。由于 CSS 的 松散的语法规则，CSS 的跨源需要一个设置正确的 HTTP 头部 Content-Type 。不同浏览器有不同的限制。\r\n- 通过 `<img>` 展示的图片。支持的图片格式包括 PNG,JPEG,GIF,BMP,SVG,...\r\n- 通过 `<video>` 播放的多媒体资源。\r\n- 通过 `<object>` 和 `<applet>`  嵌入的插件。\r\n- 通过 `@font-face` 引入的字体。一些浏览器允许跨源字体（cross-origin fonts），一些需要同源字体（same-origin fonts）。\r\n- 通过 `<iframe>` 载入的任何资源。站点可以使用 X-Frame-Options 消息头来阻止这种形式的跨源交互。\r\n\r\n### 总结：资源和脚本可能会跨域。\r\n\r\n如何允许跨源访问：\r\n可以使用 `CORS` 来允许跨源访问。CORS 是 `HTTP` 的一部分，它允许服务端来指定哪些主机可以从这个服务端加载资源。\r\n\r\n如何阻止跨源访问：\r\n\r\n- 阻止跨源写操作，只要检测请求中的一个不可推测的标记 (CSRF token) 即可，这个标记被称为 Cross-Site Request Forgery (CSRF) 标记。你必须使用这个标记来阻止页面的跨源读操作。\r\n- 阻止资源的跨源读取，需要保证该资源是不可嵌入的。阻止嵌入行为是必须的，因为嵌入资源通常向其暴露信息。\r\n- 阻止跨源嵌入，需要确保你的资源不能通过以上列出的可嵌入资源格式使用。浏览器可能不会遵守 Content-Type 头部定义的类型。例如，如果您在 HTML 文档中指定 `<script>` 标记，则浏览器将尝试将标签内部的 HTML 解析为 JavaScript。当您的资源不是您网站的入口点时，您还可以使用 CSRF 令牌来防止嵌入。\r\n\r\n## 6. 跨源脚本 API 访问\r\n\r\n允许以下对 Window 属性的跨源访问：\r\n\r\n方法\r\n-- | \r\nwindow.blur\r\nwindow.close\r\nwindow.focus\r\nwindow.postMessage\r\n\r\n属性 | 权限\r\n-- | --\r\nwindow.closed | 只读\r\nwindow.frames | 只读\r\nwindow.length | 只读\r\nwindow.location | 读/写\r\nwindow.opener | 只读\r\nwindow.parent | 只读\r\nwindow.self | 只读\r\nwindow.top | 只读\r\nwindow.window | 只读\r\n\r\n允许以下对 Location 属性的跨源访问：\r\n\r\n方法\r\n-- | \r\nlocation.replace\r\n\r\n属性 | 权限\r\n-- | --\r\nHTMLAnchorElement.href | 只写\r\n\r\n某些浏览器允许访问除上述外更多的属性。\r\n\r\n## 7. 跨源数据存储访问\r\n访问存储在浏览器中的数据，如 `localStorage` 和 `IndexedDB`，是以源进行分割。\r\n每个源都拥有自己单独的存储空间，一个源中的 JavaScript 脚本不能对属于其它源的数据进行读写操作。\r\n\r\n`Cookies`使用不同的源定义方式。\r\n一个页面可以为本域和其父域设置 cookie，只要是父域不是公共后缀（public suffix）即可。\r\nFirefox 和 Chrome 使用 `Public Suffix List` 检测一个域是否是公共后缀（public suffix）。\r\nInternet Explorer 使用其内部的方法来检测域是否是公共后缀。\r\n不管使用哪个协议（HTTP/HTTPS）或端口号，浏览器都允许给定的域以及其任何子域名 (sub-domains) 访问 cookie。\r\n当你设置 cookie 时，你可以使用 Domain、Path、Secure、和 HttpOnly 标记来限定其无障碍。\r\n当你读取 cookie 时，你无法知道它是在哪里被设置的。\r\n即使您只使用安全的 https 连接，您看到的任何 cookie 都有可能是使用不安全的连接进行设置的。"}]},{"number":30,"title":"【Q030】JS strict模式","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/30","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 严格模式（strict mode）\r\n**ECMAScript 5**的 `严格模式` 是采用具有限制性 JavaScript 变体的一种方式，从而使代码隐式地脱离“马虎模式/稀松模式/懒散模式“（sloppy mode）。\r\n\r\n`严格模式` 的效果：\r\n\r\n- 严格模式通过抛出错误来消除了一些原有静默错误。\r\n- 严格模式修复了一些导致 JavaScript 引擎难以执行优化的缺陷：有时候，相同的代码，严格模式可以比非严格模式下运行得更快。\r\n- 严格模式禁用了在 ECMAScript 的未来版本中可能会定义的一些语法。\r\n\r\n## 2. 开启严格模式\r\n`严格模式` 可以应用到整个脚本或个别函数中，下表给出了应用范围：\r\n\r\n环境 | 结果\r\n-- | --\r\neva | ✅\r\nFunction | ✅\r\n内联事件处理属性 | ✅\r\nWindowTimers.setTimeout()| ✅\r\n块级作用域 {} | ❌\r\n\r\n### 为脚本开启严格模式\r\n// 整个脚本都开启严格模式的语法\r\n```javascript\r\n\"use strict\";\r\nvar v = \"Hi!  I'm a strict mode script!\";\r\n```\r\n\r\n### 为函数开启严格模式\r\n```javascript\r\nfunction strict() {\r\n  // 函数级别严格模式语法\r\n  'use strict';\r\n  function nested() {\r\n    return \"And so am I!\";\r\n  }\r\n  return \"Hi!  I'm a strict mode function!  \" + nested();\r\n}\r\n\r\nfunction notStrict() {\r\n  return \"I'm not strict.\";\r\n}\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 3. 严格模式的效果\r\n\r\n### 1. 将过失错误转成异常\r\n\r\n- 不行允许意外直接创建全局变量\r\n```javascript\r\n\"use strict\";\r\n                       // 假如有一个全局变量叫做mistypedVariable\r\nmistypedVaraible = 17; // 因为变量名拼写错误\r\n                       // 这一行代码就会抛出 ReferenceError\r\n```\r\n\r\n- 静默失败，只读属性不允许赋值\r\n```javascript\r\n\"use strict\";\r\n\r\n// 给不可写属性赋值\r\nvar obj1 = {};\r\nObject.defineProperty(obj1, \"x\", { value: 42, writable: false });\r\nobj1.x = 9; // 抛出 TypeError 错误\r\n\r\n// 给只读属性赋值\r\nvar obj2 = { get x() { return 17; } };\r\nobj2.x = 5; // 抛出 TypeError 错误\r\n\r\n// 给不可扩展对象的新属性赋值\r\nvar fixed = {};\r\nObject.preventExtensions(fixed);\r\nfixed.newProp = \"ohai\"; // 抛出 TypeError 错误\r\n```\r\n- 不允许删除不可删除的属性\r\n```javascript\r\n\"use strict\";\r\ndelete Object.prototype; // 抛出 TypeError 错误\r\n```\r\n- 不允许重名属性\r\n```javascript\r\n\"use strict\";\r\nvar o = { p: 1, p: 2 }; // !!! 语法错误\r\n```\r\n- 不允许参数重名\r\n```javascript\r\nfunction sum(a, a, c) { // !!! 语法错误\r\n  \"use strict\";\r\n  return a + a + c; // 代码运行到这里会出错\r\n}\r\n```\r\n- 禁止八进制数字语法\r\n```javascript\r\nvar a = 0o10; // ES6: 八进制\r\n```\r\n- 禁止设置 `primitive` 值的属性\r\n```javascript\r\n(function() {\r\n  \"use strict\";\r\n\r\n  false.true = \"\";              //TypeError\r\n  (14).sailing = \"home\";        //TypeError\r\n  \"with\".you = \"far away\";      //TypeError\r\n})();\r\n```\r\n\r\n### 2. 简化变量的使用\r\n\r\n- 禁用 `with` 语法\r\n```javascript\r\n\"use strict\";\r\nvar x = 17;\r\nwith (obj) { // !!! 语法错误\r\n  // 如果没有开启严格模式，with 中的这个 x 会指向 with 上面的那个 x，还是 obj.x？\r\n  // 如果不运行代码，我们无法知道，因此，这种代码让引擎无法进行优化，速度也就会变慢。\r\n  x;\r\n}\r\n```\r\n- 限制 `eval` 的作用域，避免影响到上层\r\n```javascript\r\nvar x = 17;\r\nvar evalX = eval(\"'use strict'; var x = 42; x\");\r\nconsole.assert(x === 17);\r\nconsole.assert(evalX === 42);\r\n```\r\n- 禁止删除变量 delete name\r\n```javascript\r\n\"use strict\";\r\n\r\nvar x;\r\ndelete x; // !!! 语法错误\r\n\r\neval(\"var y; delete y;\"); // !!! 语法错误\r\n```\r\n\r\n### 3. 让eval和arguments变的简单\r\n\r\n- 名称 `eval` 和 `arguments` 不能通过程序语法被绑定或赋值\r\n```javascript\r\n\"use strict\";\r\neval = 17;\r\narguments++;\r\n++eval;\r\nvar obj = { set p(arguments) { } };\r\nvar eval;\r\ntry { } catch (arguments) { }\r\nfunction x(eval) { }\r\nfunction arguments() { }\r\nvar y = function eval() { };\r\nvar f = new Function(\"arguments\", \"'use strict'; return 17;\");\r\n```\r\n\r\n- 参数的值不会随 arguments 对象的值的改变而变化\r\n```javascript\r\nfunction f(a) {\r\n  \"use strict\";\r\n  a = 42;\r\n  return [a, arguments[0]];\r\n}\r\nvar pair = f(17);\r\nconsole.assert(pair[0] === 42);\r\nconsole.assert(pair[1] === 17);\r\n```\r\n\r\n- 不再支持 `arguments.callee`\r\n```javascript\r\n\"use strict\";\r\nvar f = function() { return arguments.callee; };\r\nf(); // 抛出类型错误\r\n```\r\n\r\n### 4. 严格模式下更安全\r\n\r\n- 在严格模式下通过this传递给一个函数的值不会被强制转换为一个对象。\r\n```javascript\r\n\"use strict\";\r\nfunction fun() { return this; }\r\nconsole.assert(fun() === undefined);\r\nconsole.assert(fun.call(2) === 2);\r\nconsole.assert(fun.apply(null) === null);\r\nconsole.assert(fun.call(undefined) === undefined);\r\nconsole.assert(fun.bind(true)() === true);\r\n```\r\n\r\n- 函数内禁止使用 `fun.caller 和 `fun.arguments` 进行拓展\r\n```javascript\r\nfunction restricted() {\r\n  \"use strict\";\r\n  restricted.caller;    // 抛出类型错误\r\n  restricted.arguments; // 抛出类型错误\r\n}\r\n\r\nfunction privilegedInvoker() {\r\n  return restricted();\r\n}\r\n\r\nprivilegedInvoker();\r\n```\r\n\r\n- arguments不会再提供访问与调用这个函数相关的变量的途径\r\n```javascript\r\n\"use strict\";\r\nfunction fun(a, b) {\r\n  \"use strict\";\r\n  var v = 12;\r\n  return arguments.caller; // 抛出类型错误\r\n}\r\nfun(1, 2); // 不会暴露 v（或者 a，或者 b）\r\n```\r\n\r\n## 4. 为未来的 ECMAScript 版本铺路\r\n未来版本的 ECMAScript 很有可能会引入新语法，严格模式对其有保护机制。\r\n\r\n- 一部分字符变成了保留的关键字。\r\n在严格模式下，你不能再用这些名字作为变量名或者形参名。\r\n\r\n关键字\r\n-- |\r\nimplements\r\ninterface\r\nlet\r\npackage\r\nprivate\r\nprotected\r\npublic\r\nstatic\r\nyield\r\n\r\n```javascript\r\nfunction package(protected) { // !!!\r\n  \"use strict\";\r\n  var implements; // !!!\r\n\r\n  interface: // !!!\r\n  while (true) {\r\n    break interface; // !!!\r\n  }\r\n\r\n  function private() { } // !!!\r\n}\r\nfunction fun(static) { 'use strict'; } // !!!\r\n```\r\n\r\n-  严格模式禁止了不在脚本或者函数层面上的函数声明\r\n```javascript\r\n\"use strict\";\r\nif (true) {\r\n  function f() { } // !!! 语法错误\r\n  f();\r\n}\r\n\r\nfor (var i = 0; i < 5; i++) {\r\n  function f2() { } // !!! 语法错误\r\n  f2();\r\n}\r\n\r\nfunction baz() { // 合法\r\n  function eit() { } // 同样合法\r\n}\r\n```\r\n这种禁止放到严格模式中并不是很合适，因为这样的函数声明方式从 ES5 中延伸出来的。但这是 ECMAScript 委员会推荐的做法，浏览器就实现了这一点。"}]},{"number":31,"title":"【Q031】cookie","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/31","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. cookie\r\n`Cookie` 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。\r\n通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。\r\n\r\n`Cookie` 主要用于以下三个方面：\r\n\r\n- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）\r\n- 个性化设置（如用户自定义设置、主题等）\r\n- 浏览器行为跟踪（如跟踪分析用户行为等）\r\n\r\n`Cookie` 曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。\r\n由于服务器指定 `Cookie` 后，浏览器的每次请求都会携带 `Cookie` 数据，会带来额外的性能开销（尤其是在移动环境下）。\r\n新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 `Web storage 或 `IndexedDB`。\r\n\r\n\r\n## 2. 设置cookie\r\n当服务器收到 HTTP 请求时，服务器可以在响应头里面添加一个 `Set-Cookie` 选项。\r\n浏览器收到响应后通常会保存下 `Cookie`，之后对该服务器每一次请求中都通过 `Cookie` 请求头部将 `Cookie` 信息发送给服务器。\r\n另外，`Cookie` 的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。\r\n\r\n```\r\nSet-Cookie: <cookie 名>=<cookie 值>\r\n```\r\n\r\n## 3.定义 Cookie 的生命周期\r\nCookie 的生命周期可以通过两种方式定义：\r\n\r\n- 会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。\r\n- 持久性 Cookie：生命周期取决于过期时间（Expires）或有效期（Max-Age）指定的一段时间。\r\n\r\n```\r\nSet-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;\r\n```\r\n\r\n## 4. 限制访问 Cookie\r\n有两种方法可以确保 Cookie 被安全发送，并且不会被意外的参与者或脚本访问：\r\n\r\n属性 | 效果 | 预防\r\n-- | -- | --\r\nSecure | 只通过 HTTPS 协议加密过的请求 |  `man-in-the-middle` 的攻击\r\nHttpOnly | 禁止 `document.cookie` 访问 Cookie | `XSS` 的攻击\r\n\r\n```\r\nSet-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly\r\n```\r\n\r\n## 5. Cookie 的作用域\r\n`Domain` 和 `Path` 标识定义了 Cookie 的*作用域：*即允许 Cookie 应该发送给哪些 URL。\r\n\r\n### Domain 属性\r\n`Domain` 指定了哪些主机可以接受 Cookie。如果不指定，默认为 **origin**，不包含子域名。\r\n如果指定了Domain，则一般包含子域名。因此，指定 `Domain` 比省略它的限制要少。\r\n但是，当子域需要共享有关用户的信息时，这可能会有所帮助。\r\n\r\n### Path 属性\r\n`Path` 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。\r\n以字符 %x2F (\"/\") 作为路径分隔符，子路径也会被匹配。\r\n\r\n例如，设置 Path=/docs，则以下地址都会匹配：\r\n\r\n- /docs\r\n- /docs/Web/\r\n- /docs/Web/HTTP"}]},{"number":32,"title":"【Q032】sessionStorage、localStorage","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/32","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. Web Storage\r\n`Web Strorage` 使浏览器能以一种比使用 Cookie 更直观的方式存储键/值对。\r\n\r\nWeb Storage 包含如下两种机制：\r\n\r\n- `sessionStorage` 为每一个给定的源（given origin）维持一个独立的存储区域，该存储区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。\r\n- `localStorage` 同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。\r\n\r\n## 2. sessionStorage\r\n`sessionStorage` 属性允许你访问一个，对应当前源的 **浏览器会议储存** 的对象。\r\n它的生命周期是 一次浏览器会话。\r\n\r\n```javascript\r\n// 保存数据到 sessionStorage\r\nsessionStorage.setItem('key', 'value');\r\n\r\n// 从 sessionStorage 获取数据\r\nlet data = sessionStorage.getItem('key');\r\n\r\n// 从 sessionStorage 删除保存的数据\r\nsessionStorage.removeItem('key');\r\n\r\n// 从 sessionStorage 删除所有保存的数据\r\nsessionStorage.clear();\r\n```\r\n## 3. localStorage\r\n`localStorage` 属性允许你访问一个，**Document源** 的对象。\r\n它的生命周期是长期，直到你手动清除。\r\n\r\n语法同 sessionStorage：\r\n```javascript\r\n// 保存 localStorage 项\r\nlocalStorage.setItem('myCat', 'Tom');\r\n\r\n// 读取 localStorage 项\r\nlet cat = localStorage.getItem('myCat');\r\n\r\n// 移除 localStorage 项\r\nlocalStorage.removeItem('myCat');\r\n\r\n// 移除所有的 localStorage 项\r\nlocalStorage.clear();\r\n```\r\n\r\n## 4. 区别\r\n\r\n- 生命周期：localStorage 是长久储存，sessionStorage 是一次浏览器会话。\r\n- 应用场景：localStorage 适合储存个性设置，sessionStorage 适合储存敏感信息（token等）。"}]},{"number":33,"title":"【Q032】IndexedDB","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/33","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. IndexedDB\r\nIndexedDB 用来在 **客户端存储** 大量的结构化数据（包括文件/二进制大型对象blobs）。\r\n该 API 使用索引实现对数据的高性能搜索。\r\n虽然 `Web Storage` 在存储较少量的数据很有用，但对于存储更大量的结构化数据来说力不从心。而 IndexedDB 提供了这种场景的解决方案。\r\n\r\n## 2. 关键概念和用法\r\nIndexedDB 是一个事务型数据库系统，类似于基于 SQL 的 RDBMS。\r\nIndexedDB 是一个面向对象数据库，允许您存储和检索用键索引的对象。\r\n您只需要指定数据库模式，打开与数据库的连接，然后检索和更新一系列事务。\r\n\r\n### 操作流程：\r\n\r\n1. 打开数据库。\r\n2. 在数据库中创建一个对象仓库（object store）。\r\n3. 启动一个事务，并发送一个请求来执行一些数据库操作，像增加或提取数据等。\r\n4. 通过监听正确类型的 DOM 事件以等待操作完成。\r\n5. 在操作结果上进行一些操作（可以在 request 对象中找到）\r\n\r\n```javascript\r\nconst dbName = \"the_name\"; // 数据库名称\r\nvar version = 1; // 数据库版本号\r\n\r\n// 打开数据库\r\nvar request = indexedDB.open(dbName, version);\r\n\r\nrequest.onerror = function(event) {\r\n  // 错误处理\r\n};\r\nrequest.onupgradeneeded = function(event) {\r\n  var db = event.target.result;\r\n\r\n  // 建立一个对象仓库来存储我们客户的相关信息，我们选择 ssn 作为键路径（key path）\r\n  // 因为 ssn 可以保证是不重复的\r\n  var objectStore = db.createObjectStore(\"customers\", { keyPath: \"ssn\" });\r\n\r\n  // 建立一个索引来通过姓名来搜索客户。名字可能会重复，所以我们不能使用 unique 索引\r\n  objectStore.createIndex(\"name\", \"name\", { unique: false });\r\n\r\n  // 使用邮箱建立索引，我们向确保客户的邮箱不会重复，所以我们使用 unique 索引\r\n  objectStore.createIndex(\"email\", \"email\", { unique: true });\r\n\r\n  // 使用事务的 oncomplete 事件确保在插入数据前对象仓库已经创建完毕\r\n  objectStore.transaction.oncomplete = function(event) {\r\n    // 将数据保存到新创建的对象仓库\r\n    var customerObjectStore = db.transaction(\"customers\", \"readwrite\").objectStore(\"customers\");\r\n    customerData.forEach(function(customer) {\r\n      customerObjectStore.add(customer);\r\n    });\r\n  };\r\n};\r\n```\r\n\r\n## 3. 同步还是异步\r\n使用 IndexedDB 执行的操作是异步执行的，以免阻塞应用程序。\r\n\r\n## 4. 储存限制和回收标准\r\n在不同浏览器中有所不同。\r\n\r\n## 5. 成熟的第三方包\r\n\r\n- [localForage](https://localforage.github.io/localForage/)：一个简单的 Polyfill，提供了简单的客户端数据存储的值语法。它在后台使用 IndexedDB，并在不支持 IndexedDB 的浏览器中回退到 WebSQL 或 localStorage。\r\n- [idb](https://www.npmjs.com/package/idb)：一个微小的（〜1.15k）库，大多 API 与 IndexedDB 类似，但做了一些小的改进，让数据库的可用性得到了大大的提升。"}]},{"number":34,"title":"【Q034】web worker","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/34","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. web worker\r\n`Web Worker`  为 Web 内容在后台线程中运行脚本提供了一种简单的方法。\r\nworker 可以与 js 互相通信，线程可以执行任务而不干扰用户界面。\r\n\r\n### 常用来做 耗时的计算，Service worker等后台任务\r\n\r\n## 2. worker的使用\r\n### 生成一个专用 worker\r\n```javascript\r\n// main.js\r\nvar myWorker = new Worker('worker.js');\r\n```\r\n\r\n### worker 中消息的接收和发送\r\n你可以通过 `postMessage()` 方法和 `onmessage` 事件处理函数触发 workers 的方法。\r\n\r\n主线程向 worker 发消息\r\n```javascript\r\n// main.js\r\nfirst.onchange = function() {\r\n  myWorker.postMessage([first.value,second.value]);\r\n  console.log('Message posted to worker');\r\n}\r\n\r\nsecond.onchange = function() {\r\n  myWorker.postMessage([first.value,second.value]);\r\n  console.log('Message posted to worker');\r\n}\r\n```\r\nworker接收消息的回调\r\n```javascript\r\n// worker.js\r\nonmessage = function(e) {\r\n  console.log('Message received from main script');\r\n  var workerResult = 'Result: ' + (e.data[0] * e.data[1]);\r\n  console.log('Posting message back to main script');\r\n  postMessage(workerResult);\r\n}\r\n```\r\n\r\n主线程响应 worker 回传的消息\r\n```javascript\r\n// main.js\r\nmyWorker.onmessage = function(e) {\r\n  result.textContent = e.data;\r\n  console.log('Message received from worker');\r\n}\r\n```\r\n\r\n### 终止 worker\r\n主线程调用 `terminate` 方法关闭\r\n```javascript\r\n// main.js\r\nmyWorker.terminate();\r\n```\r\n\r\nworker线程调用 `close` 方法关闭\r\n```javascript\r\n// worker.js\r\nclose();\r\n```\r\n\r\n### 处理错误\r\n当 worker 出现运行中错误时，它的 `onerror` 事件处理函数会被调用。\r\n该事件不会冒泡并且可以被取消；为了防止触发默认动作，worker 可以调用错误事件的 `preventDefault()` 方法。\r\n```javascript\r\n// worker.js\r\nonerror = function(err) {\r\n  console.log('错误消息：', err.message);\r\n  console.log('错误文件：', err.filename);\r\n  console.log('错误行数：', err.lineno);\r\n}\r\n```\r\n\r\n### 生成 subworker\r\nworker 能够生成更多的 worker。\r\n\r\n### 引入脚本与库\r\nWorker 线程能够访问一个全局函数 `importScripts()` 来引入脚本，该函数接受 0 个或者多个 URI 作为参数来引入资源。\r\n```javascript\r\nimportScripts();                        /* 什么都不引入 */\r\nimportScripts('foo.js');                /* 只引入 \"foo.js\" */\r\nimportScripts('foo.js', 'bar.js');      /* 引入两个脚本 */\r\n```\r\n\r\n浏览器加载并运行每个的脚本，脚本中的全局对象都能够被 worker 使用。\r\n如果脚本无法加载，将抛出 NETWORK_ERROR 异常，接下来的代码也无法执行，而之前执行的代码 **异步执行的代码** 依然能够运行。\r\nimportScripts() 之后的函数声明有效，因为函数提升。\r\n\r\n备注： 脚本的下载顺序不固定，但执行时会按照传入 importScripts() 中的文件名顺序进行。\r\n这个过程是同步完成的；直到所有脚本都下载并运行完毕，importScripts() 才会返回。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 3. pwa 渐进式 Web 应用\r\n`PWA`（Progressive Web Apps）运用现代的 Web API 以及传统的渐进式增强策略来创建跨平台 Web 应用程序。\r\n`PWA` 使 **web应用** 具有与 **原生应用** 相同的用户体验。\r\n\r\n## 4. 通过 Service workers 让 PWA 离线工作\r\n`Service Worker` 是浏览器和网络之间的虚拟代理。\r\n它解决决了如何正确 **缓存网站资源** 并使其在离线时可用的问题。\r\n\r\n### Service Worker 的生命周期\r\n注册sw后，sw.js 文件会自动下载、安装，然后激活。\r\n\r\n### 注册 Service Worker\r\n```javascript\r\nif('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.register('/pwa-examples/js13kpwa/sw.js');\r\n};\r\n```\r\n\r\n### 安装\r\n安装sw，并缓存文件\r\n```javascript\r\nvar cacheName = 'js13kPWA-v1'; // 缓存版本号\r\nvar appShellFiles = [\r\n  '/pwa-examples/js13kpwa/index.html',\r\n  '/pwa-examples/js13kpwa/app.js',\r\n  '/pwa-examples/js13kpwa/style.css',\r\n]; // 需要缓存的资源路径\r\n\r\nself.addEventListener('install', function(e) {\r\n  console.log('SW 安装');\r\n  // 等待缓存后再安装\r\n  e.waitUntil(\r\n    caches.open(cacheName).then(function(cache) {\r\n          console.log('SW 缓存资源');\r\n      return cache.addAll(appShellFiles);\r\n    })\r\n  );\r\n});\r\n```\r\n\r\n### 拦截请求\r\n缓存中查找资源是否被缓存：如果存在，将会返回缓存的资源；如果不存在，会转而从网络中请求数据，然后将它缓存起来。\r\n```javascript\r\nself.addEventListener('fetch', function(e) {\r\n  e.respondWith(\r\n    caches.match(e.request).then(function(r) {\r\n      console.log('SW 拦截到请求'+e.request.url);\r\n      return r || fetch(e.request).then(function(response) {\r\n                return caches.open(cacheName).then(function(cache) {\r\n          console.log('[Service Worker] Caching new resource: '+e.request.url);\r\n          cache.put(e.request, response.clone());\r\n          return response;\r\n        });\r\n      });\r\n    })\r\n  );\r\n});\r\n```\r\n\r\n### 更新\r\n当有资源变动时，更新版本号，会创新一个新sw缓存文件。\r\n```javascript\r\nappShellFiles.push('/pwa-examples/js13kpwa/icons/icon-32.png');\r\n\r\ncacheName = 'js13kPWA-v2';\r\n```\r\n旧的 Service Worker 仍然会正常运行，直到没有任何页面使用到它为止。\r\n\r\n\r\n### 激活\r\n用来清理不需要的缓存。\r\n```javascript\r\nself.addEventListener('activate', function(e) {\r\n  console.log('SW 激活');\r\n  e.waitUntil(\r\n    caches.keys().then(function(keyList) {\r\n      return Promise.all(keyList.map(function(key) {\r\n        if(cacheName.indexOf(key) === -1) {\r\n          return caches.delete(key);\r\n        }\r\n      }));\r\n    })\r\n  );\r\n});\r\n\r\n```"}]},{"number":35,"title":"【Q035】请解释什么是单页面应用","labels":["javascript"],"body":"请解释什么是单页面应用（single page app），以及如何使其对搜索引擎友好（SEO-friendly）","url":"https://github.com/kangyana/daily-question/issues/35","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 单页面应用 SPA\r\n单页面应用（single page app）加载单个html，切换 url 不会再去请求html。\r\n原理是JS会感知到url的变化，然后js会动态的将当前页面的内容清除掉，然后将下一个页面的内容挂载到当前的页面上。\r\n路由是由前端来控制，判断显示哪个页面。\r\n\r\n![Alt](https://img-blog.csdnimg.cn/20190109220800340.jpeg)\r\n\r\n### 优点\r\n\r\n- 有良好的交互体验，不会重新加载页面\r\n- 不请求html文件，减轻服务器压力\r\n- 前后端分离开发，后端接口可以通用开放给 多个客户端（web，小程序，app）。\r\n\r\n### 缺点\r\n\r\n- 首屏加载时间比较慢\r\n- SEO效果差"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. 优化方案\r\n\r\n### 优化首屏加载体验\r\n\r\n- 资源懒加载\r\n- 构建骨架屏\r\n\r\n### 优化SEO\r\n\r\n- 完善 `title` 和 `meta` 标签\r\n- 服务器端渲染（SSR）\r\n"}]},{"number":36,"title":"【Q036】可变对象和不可变对象","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/36","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 可变\r\n`可变` (Mutable)是一种可以更改的变量。 JS 中，只有 **对象和数组** 是可变的，原始值不可变。\r\n`可变对象` 是在创建后可以修改其状态的对象。\r\n`不可变对象` 一旦创建，其状态无法更改。\r\n\r\n![Alt](https://img-blog.csdnimg.cn/b847f40a83c04cf3b7e1b58bc58a6acf.png)\r\n\r\n## 2. 创建不可变对象\r\n\r\n### 不可扩展\r\n`Object.preventExtensions()` 可以使一个对象不可再添加新的属性，参数为目标对象，返回修改后的对象。\r\n```javascript\r\nvar obj = Object.preventExtensions({});\r\n\r\n// 直接定义新的属性会报错\r\nObject.defineProperty(obj, 'content', {\r\n  value: 'hello'\r\n}); // TypeError: Cannot define property:p, object is not extensible.\r\n\r\n// 非严格模式下通过点符号添加不会报错，但会静默失败，原对象仍然没有 content 属性\r\nobj.content = 'hello';\r\nobj.content; // undefined\r\n```\r\n\r\n对应的，Object.isExtensible() 可以判断一个对象是否可扩展，即是否可以添加新的属性。参数是目标对象，返回布尔值， true 代表可扩展，false 不可扩展。\r\n```javascript\r\nvar obj = new Object();\r\nObject.isExtensible(obj); // true\r\nObject.preventExtensions(obj);\r\nObject.isExtensible(obj); // false\r\n```\r\n\r\n### 密封\r\n`Object.seal()` 可以使一个对象无法添加新属性的同时，也无法删除旧属性。参数是目标对象，返回修改后的对象。\r\n\r\n其本质是通过修改属性的 configurable 为 false 来实现的。在属性描述对象里讲到，configurable 为 false 时，其他配置不可改变，writable 只能 true 变 false，且属性无法被删除。而由于只要 writable 或 configurable 其中之一为 true，则 value 可改，所以密封之后的对象还是可以改属性值的。\r\n```javascript\r\nvar obj = {content: 'hello'};\r\nObject.getOwnPropertyDescriptor(obj, 'content');\r\n// Object {\r\n//   value: \"hello\",\r\n//   writable: true,\r\n//   enumerable: true,\r\n//   configurable: true\r\n// }\r\nObject.seal(obj);\r\nObject.getOwnPropertyDescriptor(obj, 'content'); // seal 后 configurable 变为 false\r\n// Object {\r\n//   value: \"hello\",\r\n//   writable: true,\r\n//   enumerable: true,\r\n//   configurable: false\r\n// }\r\n```\r\n\r\n对应的，Object.isSealed() 可以检测一个对象是否密封，即是否可以增删属性。参数是目标对象，返回布尔值，true 代表被密封不可增删属性，false 代表没被密封可增删属性。\r\n```javascript\r\nvar obj = new Object();\r\nObject.isExtensible(obj); // true\r\nObject.isSealed(obj); // false\r\nObject.seal(obj);\r\nObject.isExtensible(obj); // false，注意 seal 后对象的 isExtensible() 也随之改变\r\nObject.isSealed(obj); // true\r\n```\r\n\r\n### 冻结\r\n`Object.freeze()` 可以使对象一个对象不能再添加新属性，也不可以删除旧属性，且不能修改属性的值。参数是目标对象，返回修改后的对象。\r\n```javascript\r\nvar obj = Object.freeze({name: 'example'});\r\n\r\n// 直接定义新的属性会报错\r\nObject.defineProperty(obj, 'content', {\r\n  value: 'hello'\r\n}); // TypeError: Cannot define property:p, object is not extensible.\r\n\r\n// 非严格模式下通过点符号添加不会报错，但会静默失败，原对象仍然没有 content 属性\r\nobj.content = 'hello';\r\nobj.content; // undefined\r\n\r\ndelete obj.name; // 删除失败，返回 false\r\n\r\nobj.name = 'hello';\r\nobj.name; // 仍然是 \"example\"\r\n```\r\n\r\n对应的，`Object.isFrozen()` 可以检测一个对象是否冻结，即是否可以增删改。参数是目标对象，返回布尔值，true 表示已经冻结不可再增删改，false 反之。\r\n```javascript\r\nvar obj = new Object();\r\nObject.isExtensible(obj); // true\r\nObject.isSealed(obj); // false\r\nObject.isFrozen(obj); // false\r\nObject.freeze(obj);\r\nObject.isExtensible(obj); // false，注意 freeze 后对象的 isExtensible() 也随之改变\r\nObject.isSealed(obj); // true，注意 freeze 后对象的 isSealed() 也随之改变\r\nObject.isFrozen(obj); // true\r\n```\r\n\r\n### 总结\r\n无论是不可扩展，密封，还是冻结，都是 **浅层控制** 的，即只控制对象本身属性的增删改。如果对象属性是一个引用类型，比如数组 subArr 或对象 subObj等，虽然subArr、subObj 的不可被删改，但subArr、subObj 的 **属性** 仍然可增删改。\r\n```javascript\r\nvar obj = Object.freeze({\r\n  content: {name: 'example'}\r\n});\r\nobj.content = new Object();\r\nobj.content; // {name: \"example\"}，content 本身不可改\r\nobj.content.name = 'test';\r\nobj.content; // {name: \"test\"}，但 content 的属性仍可改，因为冻结的是 obj 而不是 obj.content\r\n```\r\n\r\n由于每个对象都有一个属性 `__proto__`，该属性的值是该对象的原型对象，也是引用类型，由于冻结是浅层的所以原型对象并不会被连着冻结，仍然可以通过给对象的原型对象加属性达到给当前对象新增属性的效果。所以如果想进一步冻结还需要把原型对象也冻结上。\r\n```javascript\r\nvar obj = Object.freeze({});\r\nobj.content = 'hello';\r\nobj.content; // undefined，增加失败\r\n\r\nvar proto = Object.getPrototypeOf(obj);\r\nproto.content = 'hello';\r\nobj.content; // \"hello\"，增加成功\r\n\r\nObject.freeze(proto);\r\nproto.name = 'example';\r\nobj.name; // undefined，冻结原型之后增加失败\r\n```\r\n\r\n"}]},{"number":37,"title":"【Q037】什么是事件循环（event loop）","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/37","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 事件循环\r\n之所以称之为 `事件循环`，是因为它经常按照类似如下的方式来被实现：\r\n```javascript\r\nwhile (queue.waitForMessage()) {\r\n  queue.processNextMessage();\r\n}\r\n```\r\n`queue.waitForMessage()` 会同步地等待消息到达 (如果当前没有任何消息等待被处理)。\r\n\r\n### 执行至完成\r\n每一个消息完整地执行后，其它消息才会被执行。这为程序的分析提供了一些优秀的特性，包括：当一个函数执行时，它不会被抢占，只有在它运行完毕之后才会去运行任何其他的代码，才能修改这个函数操作的数据。这与 C 语言不同，例如，如果函数在线程中运行，它可能在任何位置被终止，然后在另一个线程中运行其他代码。\r\n\r\n这个模型的一个缺点在于当一个消息需要太长时间才能处理完毕时，Web 应用程序就无法处理与用户的交互，例如点击或滚动。为了缓解这个问题，浏览器一般会弹出一个“这个脚本运行时间过长”的对话框。一个良好的习惯是缩短单个消息处理时间，并在可能的情况下将一个消息裁剪成多个消息。\r\n\r\n### 添加消息\r\n在浏览器里，每当一个事件发生并且有一个事件监听器绑定在该事件上时，一个消息就会被添加进消息队列。如果没有事件监听器，这个事件将会丢失。所以当一个带有点击事件处理器的元素被点击时，就会像其他事件一样产生一个类似的消息。\r\n\r\n函数 `setTimeout` 接受两个参数：待加入队列的消息和一个时间值（可选，默认为 0）。这个时间值代表了消息被实际加入到队列的最小延迟时间。如果队列中没有其它消息并且栈为空，在这段延迟时间过去之后，消息会被马上处理。但是，如果有其它消息，`setTimeout` 消息必须等待其它消息处理完。因此第二个参数仅仅表示最少延迟时间，而非确切的等待时间。\r\n\r\n下面的例子演示了这个概念（`setTimeout` 并不会在计时器到期之后直接执行）：\r\n```javascript\r\nconst s = new Date().getSeconds();\r\n\r\nsetTimeout(function() {\r\n  // 输出 \"2\"，表示回调函数并没有在 500 毫秒之后立即执行\r\n  console.log(\"Ran after \" + (new Date().getSeconds() - s) + \" seconds\");\r\n}, 500);\r\n\r\nwhile(true) {\r\n  if(new Date().getSeconds() - s >= 2) {\r\n    console.log(\"Good, looped for 2 seconds\");\r\n    break;\r\n  }\r\n}\r\n```\r\n\r\n### 零延迟\r\n零延迟并不意味着回调会立即执行。以 0 为第二参数调用 setTimeout 并不表示在 0 毫秒后就立即调用回调函数。\r\n\r\n其等待的时间取决于队列里待处理的消息数量。在下面的例子中，\"这是一条消息\" 将会在回调获得处理之前输出到控制台，这是因为延迟参数是运行时处理请求所需的最小等待时间，但并不保证是准确的等待时间。\r\n\r\n基本上，`setTimeout` 需要等待当前队列中所有的消息都处理完毕之后才能执行，即使已经超出了由第二参数所指定的时间。\r\n```javascript\r\n(function() {\r\n\r\n  console.log('这是开始');\r\n\r\n  setTimeout(function cb() {\r\n    console.log('这是来自第一个回调的消息');\r\n  });\r\n\r\n  console.log('这是一条消息');\r\n\r\n  setTimeout(function cb1() {\r\n    console.log('这是来自第二个回调的消息');\r\n  }, 0);\r\n\r\n  console.log('这是结束');\r\n\r\n})();\r\n\r\n// \"这是开始\"\r\n// \"这是一条消息\"\r\n// \"这是结束\"\r\n// \"这是来自第一个回调的消息\"\r\n// \"这是来自第二个回调的消息\"\r\n```\r\n\r\n### 多个运行时互相通信\r\n一个 web worker 或者一个跨域的 `iframe` 都有自己的栈、堆和消息队列。两个不同的运行时只能通过 `postMessage` 方法进行通信。如果另一个运行时侦听 `message` 事件，则此方法会向该运行时添加消息。\r\n\r\n### 永不阻塞\r\nJavaScript 的事件循环模型与许多其他语言不同的一个非常有趣的特性是，它永不阻塞。处理 I/O 通常通过事件和回调来执行，所以当一个应用正等待一个 `IndexedDB` 请求返回时，它仍然可以处理其它事情，比如用户输入。\r\n\r\n由于历史原因有一些例外，如 `alert` 或者同步 XHR，但应该尽量避免使用它们。"}]},{"number":38,"title":"【Q038】创建对象有几种方法","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/38","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 通过{}创建对象\r\n```javascript\r\nvar obj = {};\r\n```\r\n\r\n如果对象不用重复创建，这种方式是比较方便的。\r\n\r\n## 2. 通过new Object()创建对象\r\n```javascript\r\nvar obj = new Object();\r\n```\r\n\r\n## 3. 使用字面量创建对象\r\n```javascript\r\nvar person = { name: 'zhang', age: 20 };\r\n\r\n// 等同于\r\nvar person = {};\r\nperson.name = 'zhang';\r\nperson.age = 20;\r\n```\r\n\r\n## 4. 使用工厂模式创建对象\r\n这种方式是使用一个函数来创建对象，减少重复代码，解决了前面三种方式的代码冗余的问题，但是方法不能共享的问题还是存在。\r\n```javascript\r\nfunction createObject(name){\r\n    var o = new Object();\r\n    o.name = name;\r\n    o.sayName = function(){\r\n        alert(this.name);\r\n    };\r\n    return o;\r\n}\r\n\r\nvar o1 = createObject('zhang');\r\nvar o2 = createObject('li');\r\n\r\n// 优点：解决了前面的代码重复的问题\r\n// 缺点：调用的还是不同的方法\r\nconsole.log(o1.sayName===o2.sayName); // false\r\n```\r\n\r\n## 5. 通过构造函数创建对象\r\n所谓构造函数，是首字母大写的函数。通过new 构造函数来创建对象。\r\n还是没有解决方法不能共享的问题。\r\n```javascript\r\nfunction Person(name){\r\n    this.name = name;\r\n    this.sayName = function(){\r\n        alert(this.name);\r\n    };\r\n}\r\n\r\nvar p1 = new Person('zhang');\r\nvar p2 = new Person('li');\r\n\r\nconsole.log(p1.constructor === p2.constructor); // true\r\nconsole.log(p1.constructor === Person); // true\r\nconsole.log(p1.sayName===p2.sayName); // false\r\n```\r\n\r\n## 6. 通过原型模式创建对象\r\n每个方法中都有一个原型（prototype），每个原型都有一个构造器（constructor），构造器又指向这个方法。\r\n```javascript\r\nfunction Animal(){}\r\nconsole.log(Animal.prototype.constructor === Animal); // true\r\n```\r\n\r\n原型创建对象：\r\n```javascript\r\nfunction Animal() { }\r\n\r\nAnimal.prototype.name = 'animal';\r\nAnimal.prototype.sayName = function () { alert(this.name); };\r\n\r\nvar a1 = new Animal();\r\nvar a2 = new Animal();\r\n\r\na1.sayName();\r\n\r\nconsole.log(a1.sayName === a2.sayName); // true\r\nconsole.log(Animal.prototype.constructor); // function Animal(){}\r\nconsole.log(Animal.prototype.constructor === Animal); // true\r\n```\r\n通过原型创建对象，把属性和方法绑定到prototype上，通过这种方式创建对象，方法是共享的，每个对象调用的是同一个方法。\r\n\r\n这种方式创建的对象会存在问题，假如原型中包含有引用类型的属性，那么如果某个对象修改了该属性的值，所有的该原型创建的对象访问的值都会改变。\r\n```javascript\r\nfunction Animal (){}\r\n\r\nAnimal.prototype = {\r\n    name: 'animal',\r\n    friends: ['dog','cat'],\r\n    sayName: function(){\r\n        alert(this.name);\r\n    }\r\n};\r\n\r\nvar a1 = new Animal();\r\nvar a2 = new Animal();\r\n\r\na2.friends.push('snake');\r\nconsole.log(a2.friends); // [dog,cat,snake]\r\nconsole.log(a1.friends); // [dog,cat,snake]\r\n```\r\n\r\n## 7. 通过原型 + 构造函数的方式创建对象\r\n这种方式结合了上面两种方式，解决了代码冗余，方法不能共享，引用类型改变值的问题。\r\n```javascript\r\nfunction Animal(name){\r\n    this.name = name;\r\n    this.friends = ['dog','cat'];\r\n}\r\n\r\nAnimal.prototype.sayName = function(){\r\n    alert(this.name);\r\n};\r\n\r\nvar a1 = new Animal('d');\r\nvar a2 = new Animal('c');\r\n\r\na1.friends.push('snake');\r\nconsole.log(a1.friends); // [dog,cat,snake]\r\nconsole.log(a2.friends); // [dog,cat]\r\n```"}]},{"number":39,"title":"【Q039】深拷贝和浅拷贝","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/39","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 浅拷贝\r\n如果属性是基本类型，拷贝的就是基本类型的值，\r\n如果属性是引用类型，拷贝的就是内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。\r\n\r\n### 赋值和浅拷贝的区别\r\n\r\n对原始数据的影响：\r\n\r\n  | 是否指向同一对象 | 改变基本数据类型 | 改变引用数据类型\r\n-- | -- | -- | --\r\n赋值 | √ | √ | √\r\n浅拷贝 | × | × | √\r\n\r\n## 2. 浅拷贝的实现\r\n### 展开运算符...\r\n```javascript\r\nvar obj2 = {...obj1};\r\n```\r\n\r\n### Object.assign()\r\n```javascript\r\nvar obj2 = Object.assign({}, obj1);\r\n```\r\n\r\n### Array.prototype.concat()\r\n此方法只对数组\r\n```javascript\r\nvar arr2 = arr1.concat([]);\r\n```\r\n\r\n### Array.prototype.slice()\r\n此方法只对数组\r\n```javascript\r\nvar arr2 = arr1.slice();\r\n```\r\n\r\n\r\n## 3. 深拷贝的实现\r\n深拷贝是将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象，且修改新对象不会影响原对象。\r\n\r\n### JSON.parse(JSON.stringify())\r\n```javascript\r\nvar obj2 = JSON.parse(JSON.stringify(obj1));\r\n```\r\n\r\n### 手写递归\r\n递归效果：遍历对象、数组直到里边都是基本数据类型，然后再去复制。\r\n```javascript\r\n// 检测数据类型的功能函数\r\nconst checkedType = (target) => Object.prototype.toString.call(target).replace(/\\[object (\\w+)\\]/, \"$1\").toLowerCase();\r\n// 实现深拷贝（Object/Array）\r\nconst cloneDeep = (target) => {\r\n    let result;\r\n    let type = checkedType(target);\r\n    if(type === 'object') result = {};\r\n    else if(type === 'array') result = [];\r\n    else  return target;\r\n    for (let key in target) {\r\n        if(checkedType(target[key]) === 'object' || checkedType(target[key]) === 'array') {\r\n            result[key] = clone(target[key]);\r\n        } else {\r\n            result[key] = target[key]; \r\n        }\r\n    }\r\n    return result;\r\n}\r\n```"}]},{"number":40,"title":"【Q040】网页各种高度","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/40","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 屏幕的宽高\r\n```javascript\r\nwindow.screen.width\r\nwindow.screen.height\r\n```\r\n\r\n## 2. 工作区的宽高\r\n```javascript\r\nwindow.screen.availWidth\r\nwindow.screen.availHeight\r\n```\r\n\r\n## 3. 文档的宽高\r\n```javascript\r\ndocument.body.scrollHeight\r\ndocument.body.scrollWidth\r\n```\r\n\r\n## 4. 滚动条卷出去的宽高\r\n```javascript\r\ndocument.body.scrollLeft\r\ndocument.body.scrollTop\r\n```\r\n\r\n## 5. 文档可见区域的宽高\r\n```javascript\r\ndocument.body.clientHeight\r\ndocument.body.clientWidth\r\n```\r\n\r\n## 6. 文档可见区域的宽高（加边距、边框、滚动条）\r\n```javascript\r\ndocument.body.offsetHeight\r\ndocument.body.offsetWidth\r\n```\r\n\r\n## 7. 窗口的宽高\r\n```javascript\r\nwindow.innerHeight\r\nwindow.innerWidth\r\n```"}]},{"number":41,"title":"【Q041】requestAnimationFrame","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/41","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. window.requestAnimationFrame\r\n`window.requestAnimationFrame()` 执行一个动画，并在浏览器下次重绘之前调用指定的回调函数更新动画。\r\n该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。\r\n\r\n一个向右侧移动的方块：\r\n```javascript\r\nfunction animationTest() {\r\n\tvar div = document.createElement('div');\r\n\tdiv.style.width = '100px'\r\n\tdiv.style.height = '100px'\r\n\tdiv.style.position = 'absolute'\r\n\tdiv.style.top = '0px';\r\n\tdiv.style.left = '0px';\r\n\tdiv.style.backgroundColor = '#f00'\r\n\tdiv.style.zIndex = '999999'\r\n\tdocument.body.appendChild(div);\r\n\t\r\n\tlet distance = 0;\r\n\tfunction move(){\r\n\t\tdistance++\r\n\t\tconsole.log(distance) // 打印当前帧，方块移动的距离\r\n\t\tdiv.style.left = distance + 'px'\r\n\t\trequestAnimationFrame(move); // 通知浏览器开始绘制下一帧的时候，继续执行move函数\r\n\t}\r\n\tmove();\r\n}\r\n\r\nanimationTest()\r\n```\r\n\r\n## 2. window.cancelAnimationFrame\r\n取消一个先前通过调用window.requestAnimationFrame()方法添加到计划中的动画帧请求。\r\n\r\n```javascript\r\nfunction animationTest(){\r\n\tlet animationId;\r\n\tconst button = document.createElement(\"button\");\r\n\tbutton.innerHTML = \"停止动画\"\r\n\tbutton.style.position = 'absolute'\r\n\tbutton.style.top = '150px';\r\n\tbutton.style.left = '0px';\r\n\tbutton.style.zIndex = '999999'\r\n\tbutton.onclick = () => {\r\n\t\tif(!!animationId){\r\n\t\t\twindow.cancelAnimationFrame(animationId);\r\n\t\t\tbutton.innerHTML = \"开始动画\"\r\n\t\t\tanimationId = void 0;\r\n\t\t}else{\r\n\t\t\tmove()\r\n\t\t\tbutton.innerHTML = \"停止动画\"\r\n\t\t}\r\n\t}\r\n\r\n\tconst div = document.createElement(\"div\");\r\n\tdiv.style.width = '100px'\r\n\tdiv.style.height = '100px'\r\n\tdiv.style.position = 'absolute'\r\n\tdiv.style.top = '0px';\r\n\tdiv.style.left = '0px';\r\n\tdiv.style.backgroundColor = '#f00'\r\n\tdiv.style.zIndex = '999999'\r\n\tdocument.body.appendChild(div);\r\n\tdocument.body.appendChild(button);\r\n\t\r\n\tlet distance = 0;\r\n\tfunction move(){\r\n\t\tdistance++\r\n\t\tconsole.log(distance) // 打印当前帧，方块移动的距离\r\n\t\tdiv.style.left = distance + 'px'\r\n\t\tanimationId = requestAnimationFrame(move); // 通知浏览器开始绘制下一帧的时候，继续执行move函数\r\n\t}\r\n\tmove();\r\n}\r\n\r\nanimationTest()\r\n```\r\n\r\n## 3. 应用\r\n### 可以用来替代mousemove的动画\r\nmousemove的触发频率很高，很多时候，我们不需要这么高的触发频率，常常为了优化性能，我们会写一个截流函数，来降低它触发的频率。\r\n如果你仅仅是为了让画面看起来更流畅，对频率没有特殊的需求。那么你可以直接使用requestAnimationFrame。\r\n\r\n```javascript\r\nfunction mousemoveTest(){\r\n\tdocument.addEventListener(\"mousemove\", move);\r\n\t\r\n\tfunction move(){\r\n\t\trequestAnimationFrame(() => {\r\n\t\t\t// todo 高性能消耗的代码\r\n\t\t\tconsole.log(\"move 函数执行了\")\r\n\t\t})\r\n\t}\r\n}\r\nmousemoveTest()\r\n```"}]},{"number":42,"title":"【Q042】requestIdleCallback","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/42","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. requestIdleCallback\r\n`window.requestIdleCallback()` 方法插入一个函数，这个函数将在浏览器空闲时期被调用。\r\n这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间timeout，则有可能为了在超时前执行函数而打乱执行顺序。\r\n\r\n你可以在空闲回调函数中调用 requestIdleCallback()，以便在下一次通过事件循环之前调度另一个回调。\r\n\r\n```javascript\r\n// 回调函数执行：当前帧有空闲时间，或者指定时间到了\r\nlet id = requestIdleCallback(function someHeavyComputation(deadline) {\r\n  while((deadline.timeRemaining() > 0 || deadline.didTimeout) && thereIsMoreWorkToDo) {\r\n    doWorkIfNeeded(); // 一定会在将来某个比较空闲的时间（或者在指定时间过期后）得到反复执行\r\n  }\r\n\r\n  if(thereIsMoreWorkToDo) {\r\n    id = requestIdleCallback(someHeavyComputation);\r\n  }\r\n}, { timeout: 1000 });\r\n\r\nwindow.cancelIdleCallback(id);\r\n```\r\n"}]},{"number":43,"title":"【Q043】webassembly","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/43","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. WebAssembly\r\n`Wasm` 是一种新的编码方式，可以在现代的网络浏览器中运行。\r\n它是一种低级的类汇编语言，具有紧凑的二进制格式，可以接近原生的性能运行，并为诸如 C / C ++等语言提供一个编译目标，以便它们可以在 Web 上运行。\r\n它也被设计为可以与 JavaScript 共存，允许两者一起工作。\r\n\r\n### 常用于需要 **安全稳定的** 运行程序的环境\r\n\r\n## 2. WebAssembly 实现\r\n根据所使用的语言，有四种方法可以在 Web 应用程序中实现 WebAssembly。\r\n\r\n- 使用 `Emscripten` 移植 C/C++ 应用程序。\r\n- 直接在程序集级别编写或生成 WebAssembly\r\n- 编写一个 `Rust` 应用程序并将 WebAssembly 作为其输出。\r\n- 使用编译为 WebAssembly 二进制文件的 AssemblyScript。\r\n\r\n## 3. WebAssembly 优势\r\nWebAssembly 正在迅速成为一种主流技术，它被所有主要的浏览器供应商采用，特别是因为接近原生的代码性能。除此之外 WebAssembly 还拥有以下优势：\r\n\r\n- **更好的性能**：WebAssembly 在两个方面提供了增强的性能，即启动速度和吞吐量。缩小的 JavaScript 需要被解析、解释、编译和优化。另一方面，wasm 更紧凑，并且由于其简洁的设计，二进制格式允许更快的解析和快速优化。\r\n- **便携且安全**：它独立于平台、独立于硬件和独立于语言，它不对设备或浏览器没有任何特殊要求，这增强了其便携性，代码在内存安全的沙盒环境中进行验证和执行，可以防止安全漏洞和数据损坏。\r\n- **集成遗留库**：如果应用程序使用 C/C++ 或任何其他兼容语言，WebAssembly 可以轻松地将代码或桌面应用程序可用于 Web。通常使用两个库；用于 Rust 的 wasm-pack 和用于 C/C++ 的 Emscripten。\r\n\r\n## 4. WebAssembly 局限性\r\n\r\n- **没有垃圾回收机制**：与采用垃圾回收的 JavaScript 不同，Wasm 使用平面/线性内存模型，在实例化时分配大量内存并且不会自动回收内存。\r\n- **不能直接访问DOM**：WebAssembly 无法访问文档对象模型 (DOM)，任何 DOM 操作都需要使用 JavaScript 间接完成。或者，在通过 JavaScript 胶水代码完成 DOM 操作的情况下，也可以使用任何工具链，例如 Emscripten。性能取决于所使用的库。\r\n- **旧浏览器不支持**：通常较旧的浏览器没有可用于实例化和加载 Wasm 模块的所需对象。\r\n\r\n## 5. WebAssembly 应用场景\r\nWebAssembly 通常用于需要高性能的计算密集型应用程序。这些包括元宇宙相关技术 AR/VR 实时开发、视频编辑、VPN、图像识别等。\r\n\r\n- 在 tensorflow.js 中加入 wasm 后端支持后，模型的性能提升了 10 倍左右。\r\n- 由于它最初是用 C++ 编写的，因此 Figma 使用 Emscripten 导出到 Asm.js，通过添加适当的 Emscripten 标志启动 WebAssembly 后，大概 3 倍的性能提升。\r\n- 切换到 WebAssembly 后，OpenCV Python 库的性能提升非常明显。 ResNet50 的推理时间增加了 15 倍，内核性能测试速度提高了 3.5 倍。\r\n- Unity 使用 Emscripten 输出 WebAssembly 为游戏导出网络播放器，传统上由于 JavaScript 速度变慢而无法导出到 Web 的游戏，在 Web 上获得了始终如一的良好性能。\r\n"}]},{"number":44,"title":"【Q044】垃圾回收","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/44","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 垃圾回收机制 Garbage Collection\r\n创建一个基本类型、对象、函数……都是需要占用内存的，但js会自动分配，不需要显式手动的去分配内存。\r\njs 也会自动回收，不需要手动的去回收。\r\n\r\n## 2. GC 策略\r\n在 JS 内存管理中有一个概念叫做 **可达性**，就是那些以某种方式可访问或者说可用的值，它们被保证存储在内存中，反之不可访问则需回收。\r\n至于如何回收，其实就是怎样发现这些不可达的垃圾它并给予清理的问题， JS 定期找出用不到的内存并释放。\r\n\r\n回收流程就涉及到了一些算法策略：\r\n"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 3. 标记清除算\r\n标记清除（Mark-Sweep），大多数浏览器的 JS 都在采用标记清除算法。\r\n此算法分为 **标记** 和 **清除** 两个阶段，标记阶段即为所有活动对象做上标记，清除阶段则把没有标记销毁。\r\n引擎在执行 GC 时，需要从出发点去遍历内存中所有的对象去打标。\r\n\r\n### 标记清除算法的流程：\r\n\r\n- GC 在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0\r\n- 然后从各个根对象开始遍历，把不是垃圾的节点改成1\r\n- 清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间\r\n- 最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收\r\n\r\n### 优点：\r\n简单，打标识只用二进制位（0和1）\r\n\r\n### 缺点：\r\n\r\n清除之后，剩余的对象内存位置是不变的，会导致空闲内存空间是不连续的，出现了 `内存碎片` （如下图）\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12247ac3d8f249a5ab85b9b40ba1147b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n这就牵扯出了内存分配的问题，新建对象分配内存时候，要找到尺寸符合的空块才能插入。\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb5107f04a3249ce8d37ec7cc5fd9668~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n## 4. 引用计数算法\r\n引用计数（Reference Counting），这其实是早先的一种垃圾回收算法，它把 对象是否不再需要 简化定义为 对象有没有其他对象引用到它，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收，目前很少使用这种算法了，因为它的问题很多，不过我们还是需要了解一下。\r\n\r\n### 它的策略是跟踪记录每个变量值被使用的次数：\r\n\r\n- 当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1\r\n- 如果同一个值又被赋给另一个变量，那么引用数加 1\r\n- 如果该变量的值被其他的值覆盖了，则引用次数减 1\r\n- 当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存\r\n\r\n```javascript\r\nlet a = new Object() \t// 此对象的引用计数为 1（a引用）\r\nlet b = a \t\t// 此对象的引用计数是 2（a,b引用）\r\na = null  \t\t// 此对象的引用计数为 1（b引用）\r\nb = null \t \t// 此对象的引用计数为 0（无引用）\r\n```\r\n\r\n当两个对象互相引用时，假如被多次调用，那么就会造成大量的内存不会被释放\r\n```javascript\r\nfunction test(){\r\n  let A = new Object()\r\n  let B = new Object()\r\n  \r\n  A.b = B\r\n  B.a = A\r\n}\r\n```\r\n\r\n### 优点：\r\n结构清晰，引用值为 0 时，也就是在变成垃圾的那一刻就会被回收，所以它可以立即回收垃圾。\r\n而标记清除算法需要每隔一段时间进行一次，那在应用程序（JS脚本）运行过程中线程就必须要暂停去执行一段时间的 GC，另外，标记清除算法需要遍历堆里的活动以及非活动对象来清除，而引用计数则只需要在引用时计数就可以了。\r\n\r\n### 缺点：\r\n首先它需要一个计数器，而此计数器需要占很大的位置，因为我们也不知道被引用数量的上限。\r\n还有就是无法解决循环引用无法回收的问题，这也是最严重的。\r\n\r\n## 5. V8对GC的优化\r\n\r\n### 分代式垃圾回收：\r\n分代式机制把一些新、小、存活时间短的对象作为新生代，采用一小块内存频率较高的快速清理，而一些大、老、存活时间长的对象作为老生代，使其很少接受检查，新老生代的回收机制及频率是不同的，可以说此机制的出现很大程度提高了垃圾回收机制的效率。\r\n\r\n**新生代** 的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1～8M 的容量。\r\n**老生代** 的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大。\r\nV8 整个堆内存的大小就等于新生代加上老生代的内存（如下图）\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abae5b06648a40d2aaa453b5d8a83939~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n### 新生代垃圾回收\r\n新生代对象是通过一个名为 Scavenge 的算法进行垃圾回收，在 Scavenge算法 的具体实现中，主要采用了一种复制式的方法即 Cheney算法。\r\n\r\nCheney算法 中将堆内存一分为二，一个是处于使用状态的空间我们暂且称之为 使用区，一个是处于闲置状态的空间我们称之为 空闲区，如下图所示\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa2d5ad1d89b4b7b919f20e4a5f8973a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作。\r\n\r\n当开始进行垃圾回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记完成之后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段，即将非活动对象占用的空间清理掉。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区。\r\n\r\n当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理。\r\n\r\n另外还有一种情况，如果复制一个对象到空闲区时，空闲区空间占用超过了 25%，那么这个对象会被直接晋升到老生代空间中，设置为 25% 的比例的原因是，当完成 Scavenge 回收后，空闲区将翻转成使用区，继续进行对象内存的分配，若占比过大，将会影响后续内存分配。\r\n\r\n### 老生代垃圾回收\r\n相比于新生代，老生代的垃圾回收就比较容易理解了，上面我们说过，对于大多数占用空间大、存活时间长的对象会被分配到老生代里，因为老生代中的对象通常比较大，如果再如新生代一般分区然后复制来复制去就会非常耗时，从而导致回收执行效率不高，所以老生代垃圾回收器来管理其垃圾回收执行，它的整个流程就采用的就是上文所说的标记清除算法了。\r\n\r\n首先是标记阶段，从一组根元素开始，递归遍历这组根元素，遍历过程中能到达的元素称为活动对象，没有到达的元素就可以判断为非活动对象。\r\n\r\n清除阶段老生代垃圾回收器会直接将非活动对象，也就是数据清理掉。\r\n\r\n前面我们也提过，标记清除算法在清除后会产生大量不连续的内存碎片，过多的碎片会导致大对象无法分配到足够的连续内存，而 V8 中就采用了我们上文中说的标记整理算法来解决这一问题来优化空间。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 6. 内存泄露\r\n虽然js引擎有内存回收，v8也做出了优化。\r\n我们的代码中依然要主动避免一些不利于引擎做垃圾回收操作，因为不是所有无用对象内存都可以被回收的，那当不再用到的内存，没有及时回收时，我们叫它 `内存泄漏`（Memory leak）。\r\n\r\n### 不正当的闭包\r\n```javascript\r\nfunction fn2(){\r\n  let test = new Array(1000).fill('isboyjc')\r\n  return function(){\r\n    console.log(test)\r\n    return test\r\n  }\r\n}\r\nlet fn2Child = fn2()\r\nfn2Child()\r\n\r\n// 解决方案：\r\nfn2Child = null\r\n```\r\n\r\n### 额外的全局变量\r\n```javascript\r\nfunction fn(){\r\n  // 没有声明从而制造了隐式全局变量test1\r\n  test1 = new Array(1000).fill('isboyjc1')\r\n  \r\n  // 函数内部this指向window，制造了隐式全局变量test2\r\n  this.test2 = new Array(1000).fill('isboyjc2')\r\n}\r\nfn()\r\n```\r\n\r\n### 游离DOM引用\r\n```javascript\r\nlet root = document.querySelector('#root')\r\nlet ul = document.querySelector('#ul')\r\nlet li3 = document.querySelector('#li3')\r\n\r\n// 由于ul变量存在，整个ul及其子元素都不能GC\r\nroot.removeChild(ul)\r\n\r\n// 虽置空了ul变量，但由于li3变量引用ul的子节点，所以ul元素依然不能被GC\r\nul = null\r\n\r\n// 已无变量引用，此时可以GC\r\nli3 = null\r\n```\r\n\r\n### 遗忘的定时器\r\n```javascript\r\n// 获取数据\r\nlet someResource = getData()\r\nsetInterval(() => {\r\n  const node = document.getElementById('Node')\r\n\tif(node) {\r\n    node.innerHTML = JSON.stringify(someResource))\r\n\t}\r\n}, 1000)\r\n```\r\n\r\n### 遗忘的事件监听器\r\n```javascript\r\nwindow.addEventListener(\"resize\", function() {})\r\n```\r\n\r\n### 遗忘的Map、Set对象\r\n当使用 `Map` 或 `Set` 存储对象时，同 `Object` 一致都是强引用，如果不将其主动清除引用，其同样会造成内存不自动进行回收。\r\n\r\n### 未清理的console输出\r\n\r\n## 7. 内存膨胀\r\n在短时间内内存占用极速上升到达一个峰值，想要避免需要使用技术手段减少对内存的占用。\r\n\r\n## 8. 频繁 GC\r\nGC 执行的特别频繁，一般出现在频繁使用大的临时变量导致新生代空间被装满的速度极快，而每次新生代装满时就会触发 GC，频繁 GC 同样会导致页面卡顿，想要避免的话就不要搞太多的临时变量，因为临时变量不用了就会被回收。"}]},{"number":45,"title":"【Q045】proxy","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/45","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. Proxy\r\n`Proxy` 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。\r\n\r\n```javascript\r\nconst handler = {\r\n    get: function(obj, prop) {\r\n        return prop in obj ? obj[prop] : 37;\r\n    }\r\n};\r\n\r\nconst p = new Proxy({}, handler);\r\np.a = 1;\r\np.b = undefined;\r\n\r\nconsole.log(p.a, p.b);      // 1, undefined\r\nconsole.log('c' in p, p.c); // false, 3\r\n```\r\n\r\n## 2. 用法\r\n\r\n### 无操作转发代理\r\n在以下例子中，我们使用了一个原生 JavaScript 对象，代理会将所有应用到它的操作转发到这个对象上。\r\n```javascript\r\nlet target = {};\r\nlet p = new Proxy(target, {});\r\n\r\np.a = 37;   // 操作转发到目标\r\n\r\nconsole.log(target.a);    // 37. 操作已经被正确地转发\r\n```\r\n\r\n### 验证\r\n通过代理，你可以轻松地验证向一个对象的传值。下面的代码借此展示了 `set handler` 的作用。\r\n```javascript\r\nlet validator = {\r\n  set: function(obj, prop, value) {\r\n    if (prop === 'age') {\r\n      if (!Number.isInteger(value)) {\r\n        throw new TypeError('The age is not an integer');\r\n      }\r\n      if (value > 200) {\r\n        throw new RangeError('The age seems invalid');\r\n      }\r\n    }\r\n\r\n    // The default behavior to store the value\r\n    obj[prop] = value;\r\n\r\n    // 表示成功\r\n    return true;\r\n  }\r\n};\r\n\r\nlet person = new Proxy({}, validator);\r\nperson.age = 100;\r\n\r\nconsole.log(person.age); // 100\r\nperson.age = 'young'; // Uncaught TypeError: The age is not an integer\r\nperson.age = 300; // Uncaught RangeError: The age seems invalid\r\n```\r\n\r\n### 扩展构造函数\r\n方法代理可以轻松地通过一个新构造函数来扩展一个已有的构造函数。这个例子使用了 `construct` 和 `apply`。\r\n```javascript\r\nfunction extend(sup, base) {\r\n  var descriptor = Object.getOwnPropertyDescriptor(\r\n    base.prototype, \"constructor\"\r\n  );\r\n  base.prototype = Object.create(sup.prototype);\r\n  var handler = {\r\n    construct: function(target, args) {\r\n      var obj = Object.create(base.prototype);\r\n      this.apply(target, obj, args);\r\n      return obj;\r\n    },\r\n    apply: function(target, that, args) {\r\n      sup.apply(that, args);\r\n      base.apply(that, args);\r\n    }\r\n  };\r\n  var proxy = new Proxy(base, handler);\r\n  descriptor.value = proxy;\r\n  Object.defineProperty(base.prototype, \"constructor\", descriptor);\r\n  return proxy;\r\n}\r\n\r\nvar Person = function (name) {\r\n  this.name = name\r\n};\r\n\r\nvar Boy = extend(Person, function (name, age) {\r\n  this.age = age;\r\n});\r\n\r\nBoy.prototype.sex = \"M\";\r\n\r\nvar Peter = new Boy(\"Peter\", 13);\r\nconsole.log(Peter.sex);  // \"M\"\r\nconsole.log(Peter.name); // \"Peter\"\r\nconsole.log(Peter.age);  // 13\r\n```\r\n\r\n## 互换 DOM 节点的属性\r\n有时，我们可能需要互换两个不同的元素的属性或类名。下面的代码以此为目标，展示了 `set handler` 的使用场景。\r\n```javascript\r\nlet view = new Proxy({\r\n  selected: null\r\n}, {\r\n  set: function(obj, prop, newval) {\r\n    let oldval = obj[prop];\r\n\r\n    if (prop === 'selected') {\r\n      if (oldval) {\r\n        oldval.setAttribute('aria-selected', 'false');\r\n      }\r\n      if (newval) {\r\n        newval.setAttribute('aria-selected', 'true');\r\n      }\r\n    }\r\n\r\n    // 默认行为是存储被传入 setter 函数的属性值\r\n    obj[prop] = newval;\r\n\r\n    // 表示操作成功\r\n    return true;\r\n  }\r\n});\r\n\r\nlet i1 = view.selected = document.getElementById('item-1');\r\nconsole.log(i1.getAttribute('aria-selected')); // 'true'\r\n\r\nlet i2 = view.selected = document.getElementById('item-2');\r\nconsole.log(i1.getAttribute('aria-selected')); // 'false'\r\nconsole.log(i2.getAttribute('aria-selected')); // 'true'\r\n```\r\n\r\n### 值修正及附加属性\r\n以下 `products` 代理会计算传值并根据需要转换为数组。这个代理对象同时支持一个叫做 `latestBrowser` 的附加属性，这个属性可以同时作为 getter 和 setter。\r\n```javascript\r\nlet products = new Proxy({\r\n  browsers: ['Internet Explorer', 'Netscape']\r\n}, {\r\n  get: function(obj, prop) {\r\n    // 附加一个属性\r\n    if (prop === 'latestBrowser') {\r\n      return obj.browsers[obj.browsers.length - 1];\r\n    }\r\n\r\n    // 默认行为是返回属性值\r\n    return obj[prop];\r\n  },\r\n  set: function(obj, prop, value) {\r\n    // 附加属性\r\n    if (prop === 'latestBrowser') {\r\n      obj.browsers.push(value);\r\n      return;\r\n    }\r\n\r\n    // 如果不是数组，则进行转换\r\n    if (typeof value === 'string') {\r\n      value = [value];\r\n    }\r\n\r\n    // 默认行为是保存属性值\r\n    obj[prop] = value;\r\n\r\n    // 表示成功\r\n    return true;\r\n  }\r\n});\r\n\r\nconsole.log(products.browsers); // ['Internet Explorer', 'Netscape']\r\nproducts.browsers = 'Firefox';  // 如果不小心传入了一个字符串\r\nconsole.log(products.browsers); // ['Firefox'] <- 也没问题，得到的依旧是一个数组\r\n\r\nproducts.latestBrowser = 'Chrome';\r\nconsole.log(products.browsers);      // ['Firefox', 'Chrome']\r\nconsole.log(products.latestBrowser); // 'Chrome'\r\n```"}]},{"number":46,"title":"【Q046】Object.defineProperty","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/46","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. Object.defineProperty\r\n`Object.defineProperty()` 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。\r\n\r\n备注： 应当直接在 `Object` 构造器对象上调用此方法，而不是在任意一个 Object 类型的实例上调用。\r\n\r\n### 参数\r\n- obj：要定义属性的对象。\r\n- prop：要定义或修改的属性的名称 。\r\n- descriptor：要定义或修改的属性描述符。\r\n\r\n```javascript\r\nconst object1 = {};\r\n\r\nObject.defineProperty(object1, 'property1', {\r\n  value: 42,\r\n  writable: false\r\n});\r\n\r\nobject1.property1 = 77; // 严格模式下报错\r\nconsole.log(object1.property1); // 42\r\n```\r\n\r\n### 该方法允许精确地添加或修改对象的属性。\r\n通过赋值操作添加的普通属性是可枚举的，可以改变这些属性的值，也可以 `delete` 这些属性。\r\n这个方法允许修改默认的额外选项。默认情况下，使用 `Object.defineProperty()` 添加的属性值是 **不可修改的**（immutable）。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. 属性描述符\r\n对象里目前存在的属性描述符有两种主要形式：\r\n\r\n- 数据描述符：是一个具有值的属性，该值可以是可写的，也可以是不可写的。\r\n- 存取描述符：是由 getter 函数和 setter 函数所描述的属性。一个描述符只能是这两者其中之一；不能同时是两者。\r\n\r\n这两种描述符都是对象。以下为可选键值：\r\n\r\n可选键 | 类型 | 描述 | 默认值\r\n-- | -- | -- | --\r\nconfigurable | 通用 | 当且仅当该属性的 configurable 键值为 true 时，<br />该属性的描述符才能够被改变，<br />同时该属性也能从对应的对象上被删除。| false\r\nenumerable | 通用 | 当且仅当该属性的 configurable 键值为 true 时，<br />该属性的描述符才能够被改变，<br />同时该属性也能从对应的对象上被删除。| false\r\nvalue | 数据描述符 | 该属性对应的值。可以是任何有效的 JS 值（数值，对象，函数等）。| undefined\r\nwritable | 数据描述符 | 当且仅当该属性的 writable 键值为 true 时，<br />属性的值（value）才能被直接赋值。 | false\r\nget | 存取描述符 | 属性的 getter 函数，如果没有 getter，则为 undefined。<br />当访问该属性时，会调用此函数。执行时会传入 this 对象。<br />该函数的返回值会被用作属性的值。| undefined\r\nset | 存取描述符 | 属性的 setter 函数，如果没有 setter，则为 undefined。<br />当属性值被修改时，会调用此函数。执行时会传入 this 对象。| undefined\r\n\r\n记住，这些选项不一定是自身属性，也要考虑继承来的属性。\r\n为了确认保留这些默认值，在设置之前，可能要冻结 `Object.prototype`，明确指定所有的选项，或者通过 `Object.create(null)` 将 `__proto__` 属性指向 `null`。\r\n\r\n```javascript\r\n// 使用 __proto__\r\nvar obj = {};\r\nvar descriptor = Object.create(null); // 没有继承的属性\r\n// 默认没有 enumerable，没有 configurable，没有 writable\r\ndescriptor.value = 'static';\r\nObject.defineProperty(obj, 'key', descriptor);\r\n\r\n// 显式\r\nObject.defineProperty(obj, \"key\", {\r\n  enumerable: false,\r\n  configurable: false,\r\n  writable: false,\r\n  value: \"static\"\r\n});\r\n\r\n// 循环使用同一对象\r\nfunction withValue(value) {\r\n  var d = withValue.d || (\r\n    withValue.d = {\r\n      enumerable: false,\r\n      writable: false,\r\n      configurable: false,\r\n      value: null\r\n    }\r\n  );\r\n  d.value = value;\r\n  return d;\r\n}\r\n// ... 并且 ...\r\nObject.defineProperty(obj, \"key\", withValue(\"static\"));\r\n\r\n// 如果 freeze 可用，防止后续代码添加或删除对象原型的属性\r\n// （value, get, set, enumerable, writable, configurable）\r\n(Object.freeze||Object)(Object.prototype);\r\n```\r\n"}]},{"number":47,"title":"【Q047】map set","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/47","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. Map\r\n`Map` 对象保存键值对，并且能够记住键的原始插入顺序。任何值都可以作为一个键或一个值。\r\n\r\n```javascript\r\nconst map1 = new Map();\r\n\r\nmap1.set('a', 1);\r\nmap1.set('b', 2);\r\nmap1.set('c', 3);\r\nconsole.log(map1.get('a')); // 1\r\n\r\nmap1.set('a', 97);\r\nconsole.log(map1.get('a')); // 97\r\nconsole.log(map1.size); // 3\r\n\r\nmap1.delete('b');\r\nconsole.log(map1.size); // 2\r\n```\r\n\r\n### 键的相等\r\n\r\n- 键的比较基于 `零值相等` 算法。\r\n- `NaN` 是与 NaN 相等的（虽然 NaN !== NaN），剩下所有其它的值是根据 === 运算符的结果判断是否相等。\r\n- 在目前的 ECMAScript 规范中，-0 和 +0 被认为是相等的。\r\n\r\n## 2. Object 和 Map 的比较\r\n`Object` 和 `Map` 类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值。\r\n因此 ES6 以前我们一直都把对象当成 `Map` 使用。\r\n\r\n不过 `Map` 和 `Object` 有一些重要的区别，在下列情况中使用 `Map` 会是更好的选择：\r\n\r\n |  | Map | Object |\r\n | -- | -- | --  |\r\n | 意外的键 | 默认无键 | 原型链上的键可能会冲突  |\r\n | 键的类型 | 任何 | `String` \\| `Symbol`  |\r\n | 键的顺序 | 有序 | 不规则  |\r\n | 键值个数 | `size` | 手动计算  |\r\n | 迭代 | √ | ×  |\r\n | 性能 | 频繁操作下表现好 | 无优化  |\r\n | 序列化和解析 | × | √  |\r\n\r\n## 3. Set\r\n`Set` 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。\r\n`Set` 对象是值的集合，你可以按照插入的顺序迭代它的元素。Set 中的元素只会出现一次，即 Set 中的元素是唯一的。\r\n其他特性同 `Map`\r\n\r\n### 常用于数组去重\r\n```javascript\r\nconst numbers = [2,3,4,4,2,3,3,4,4,5,5,6,6,7,5,32,3,4,5]\r\nconsole.log([...new Set(numbers)]) // [2, 3, 4, 5, 6, 7, 32]\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 4. 对于Object 和 Map的使用取舍的知识点补充\r\n## HashMap\r\n基于哈希表的 Map，提供所有可选的映射操作。\r\n很多语言里有这个内置对象，例如java、php、rust...\r\njs 因为历史原因，es6才加入Map 内置对象。在此之前我们使用Object模拟 HashMap做映射效果。\r\n也是因为Map加入的很晚，大部分开发者没有对其充分利用，现代框架设计上对Map的支持度也不足（例如react hooks的deps）。\r\n\r\n下面，列举一些应该更多考虑使用 Map 的一些原因：\r\n\r\n## 为什么 Object 不符合 HashMap 的使用情况\r\n\r\n- 限制 **键的类型** 为 `String` 和 `Symbol`，其他类型的键都被 `toString` 转为 `String`。\r\n```javascript\r\nconst foo = []\r\nconst bar = {}\r\nconst obj = {[foo]: 'foo', [bar]: 'bar'}\r\n\r\nconsole.log(obj) // {\"\": 'foo', [object Object]: 'bar'}\r\n```\r\n- Object可能会存在继承到的键，这些 **意外的键** 可能会造成冲突。\r\n- Object **键的顺序** 在 js低版本下很混乱。ES6 新增了定义时的有序，ES11 新增了继承属性的有序。\r\n\r\n## 不必要的继承\r\n在ES6之前，获得 hash map 的唯一方法是创建一个空对象：\r\n```javascript\r\nvar hashMap = {}\r\n```\r\n\r\n然而，在创建时，这个对象不再是空的。\r\n尽管 hashMap 是用一个空的对象字面量创建的，但它自动继承了 `Object.prototype`。\r\n这就是为什么我们可以在 hashMap 上调用 `hasOwnProperty`、`toString`、`constructor` 等方法，尽管我们从未在该对象上明确定义这些方法。\r\n```javascript\r\nvar hashMap = {}\r\n\r\nconsole.log(hashMap.__proto__ === Object.prototype) // true\r\n```\r\n\r\n由于原型继承，我们现在有两种类型的属性被混淆了：存在于对象本身的属性，即它自己的属性，以及存在于原型链的属性，即继承的属性。\r\n\r\n因此，我们需要一个额外的检查（例如 `hasOwnProperty`）来确保一个给定的属性确实是用户提供的，而不是从原型继承的。\r\n```javascript\r\nvar hashMap = { name: 'zs' }\r\n\r\nconsole.log(hashMap.hasOwnProperty('name')) // true\r\nconsole.log(hashMap.hasOwnProperty('__proto__')) // false\r\n```\r\n\r\n除此之外，在运行时对 `Object.prototype` 的任何改变都会在所有对象中引起连锁反应。这就为原型污染攻击打开了大门，这对大型的 JS 应用程序来说是一个严重的安全问题。\r\n```javascript\r\nvar hashMap = {}\r\nObject.prototype.age = 18\r\n\r\nconsole.log(hashMap.age) // 18\r\n```\r\n\r\n不过，我们可以通过使用 es5的 `Object.create(null)` 来解决这个问题，它可以生成一个不继承 `Object.prototype` 的对象。\r\n```javascript\r\nvar hashMap = Object.create(null)\r\n\r\nconsole.log(hashMap) // undefined\r\n```\r\n\r\n### 键值冲突\r\n当一个对象自己的属性与它的原型上的属性有名称冲突时，它就会打破预期，从而使程序崩溃。\r\n\r\n`hasOwnProperty` 有一个风险，当对象里定义了hasOwnProperty属性会覆盖。\r\n```javascript\r\nvar hashMap = { name: 'zs' }\r\nconsole.log(hashMap.hasOwnProperty('name')) // true\r\n\r\nhashMap.hasOwnProperty = 1;\r\nconsole.log(hashMap.hasOwnProperty('name')) // hashMap.hasOwnProperty is not a function\r\n```\r\n\r\n可以做 **防御性编程** 来防止这种情况。例如，我们可以从 `Object.prototype` 中借用`hasOwnProperty` 来代替\r\n```javascript\r\nvar hashMap = { name: 'zs' }\r\nhashMap.hasOwnProperty = 1;\r\n\r\nconsole.log(Object.prototype.hasOwnProperty.call(hashMap, 'name')) // true\r\n```\r\n\r\n还有一个更简短的方法就是在一个对象的字面量上调用该方法，如`{}.hasOwnProperty.call` 和 ES2022 新出的方法 `Object.hasOwn`。\r\n\r\n### 次优的人机工程学\r\n`Object` 没有提供足够的人机工程学，不能作为 HashMap 使用，许多常见的任务不能直观地执行。\r\n\r\n#### size\r\nObject 并没有提供方便的API来获取 size，即属性的数量。而且，对于什么是一个对象的 size ，还有一些细微的差别：\r\n\r\n- 如果只关心字符串、可枚举的键，那么可以用 Object.keys() 将键转换为数组，并获得其length。\r\n- 如果k只想要不可枚举的字符串键，那么必须得使用 Object.getOwnPropertyNames 来获得一个键的列表并获得其 length。\r\n- 如果只对 symbol  键感兴趣，可以使用 getOwnPropertySymbols 来显示 symbol  键。或者可以使用 Reflect.ownKeys 来一次获得字符串键和 symbol  键，不管它是否是可枚举的。\r\n\r\n上述所有选项的运行时复杂度为 **O(n)**，因为我们必须先构造一个键的数组，然后才能得到其长度。\r\n\r\n#### iterate\r\n循环遍历对象也有类似的复杂性。\r\n我们可以使用 `for...in` 循环。但它会读取到继承的可枚举属性。\r\n```javascript\r\nObject.prototype.foo = 'bar'\r\n\r\nconst obj = {id: 1} \r\n\r\nfor (const key in obj) {\r\n\tconsole.log(key) // 'id', 'foo'\r\n}\r\n```\r\n\r\n我们不能对一个对象使用 `for ... of`，因为默认情况下它不是一个可迭代的对象，除非我们明确定义 `Symbol.iterator` 方法在它上面。\r\n```javascript\r\nObject.prototype.foo = 'bar'\r\n\r\nconst obj = {id: 1}\r\n\r\nobj[Symbol.iterator] = function*(){\r\n    var keys = Object.keys(obj);\r\n    for(var k of keys){\r\n        yield k\r\n    }\r\n};\r\n\r\nfor(var key of obj){\r\n    console.log(key) // 'id', 'foo'\r\n}\r\n```\r\n\r\n我们可以使用 `Object.keys`、`Object.values` 和 `Object.entry` 来获得一个可枚举的字符串键（或/和值）的列表，并通过该列表进行迭代，这引入了一个额外的开销步骤。\r\n```javascript\r\nObject.prototype.foo = 'bar'\r\n\r\nconst obj = {id: 1} \r\n\r\nfor (const key of Object.keys(obj)) {\r\n\tconsole.log(key) // 'id', 'foo'\r\n}\r\n```\r\n\r\n还有一个是 插入对象的键的顺序并不是按我们的顺序来的，这是一个很蛋疼的地方。在大多数浏览器中，整数键是按升序排序的，并优先于字符串键，即使字符串键是在整数键之前插入的：\r\n```javascript\r\nconst obj = {}\r\n\r\nobj.foo = 'first'\r\nobj[2] = 'second'\r\nobj[1] = 'last'\r\n\r\nconsole.log(obj) // {1: 'last', 2: 'second', foo: 'first'}\r\n```\r\n\r\n## clear\r\n没有简单的方法来删除一个对象的所有属性，我们必须用 `delete` 操作符一个一个地删除每个属性，这在历史上是众所周知的慢。\r\n```javascript\r\n// 对象删除所有属性\r\nconst obj = {id: 1, foo: 'bar'}\r\n\r\nfor (const key in obj) {\r\n\tdelete obj[key]\r\n}\r\n\r\n// HashMap删除所有属性\r\nconst map1 = new Map();\r\n\r\nmap1.clear();\r\n```\r\n\r\n## 检查属性是否存在\r\n我们不能依靠点/括号符号来检查一个属性的存在，因为值本身可能被设置为 undefined。相反，得使用 `Object.prototype.hasOwnProperty` 或 `Object.hasOwn`。\r\n```javascript\r\n// 对象检查属性\r\nconst obj = {a: undefined}\r\n\r\nObject.hasOwn(obj, 'a') // true\r\n\r\n// HashMap检查属性\r\nconst map1 = new Map();\r\nmap1.has('a') // false\r\n```\r\n\r\n## Map\r\nES6 为我们带来了 Map，首先，与只允许键值为 String 和 symbols 的 Object 不同，`Map` 支持任何数据类型的键。\r\n但更重要的是，Map 在用户定义的和内置的程序数据之间提供了一个干净的分离，代价是需要一个额外的 `Map.prototype.get` 来获取对应的项。\r\nMap 也提供了更好的人机工程学。Map 默认是一个可迭代的对象。这说明可以用 for ... of 轻松地迭代，并做一些事情，比如使用嵌套的解构来从 Map 中取出第一个项。\r\n```javascript\r\nconst [[firstKey, firstValue]] = map\r\n```\r\n\r\n与 Object 相比，Map 为各种常见任务提供了专门的方法：\r\nMap.prototype.has 检查一个给定的项是否存在，与必须在对象上使用Object.prototype.hasOwnProperty/Object.hasOwn 相比，不那么尴尬了。\r\n\r\n- `Map.prototype.has` 检查一个给定的项是否存在，与在对象上使用`Object.prototype.hasOwnProperty/Object.hasOwn` 相比要好。\r\n- `Map.prototype.get` 返回与提供的键相关的值。有的可能会觉得这比对象上的点符号或括号符号更笨重。不过，它提供了一个干净的用户数据和内置方法之间的分离。\r\n- `Map.prototype.size` 返回 Map 中的项的个数，与获取对象大小的操作相比，这明显好太多了。此外，它的速度也更快。\r\n- `Map.prototype.clear` 可以删除 Map 中的所有项，它比 delete 操作符快得多。\r\n\r\n### 性能差异\r\n在 JS 社区中，似乎有一个共同的信念，即在大多数情况下，Map 要比 Object 快。有些人声称通过从 Object 切换到 Map 可以看到明显的性能提升。\r\n我在 LeetCode 上也证实了这种想法，对于数据量大的 Object 会超时，但 Map 上则不会。\r\n\r\n### 内存使用情况\r\nMap 比 Object 消耗的内存少20%到50%，因为 Map 不像 Object 那样存储属性描述符，比如 writable/enumerable/configurable 。\r\n\r\n"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 5. 总结\r\n\r\n- Map 比 Object 快，除非有小的整数、数组索引的键，而且它更节省内存。\r\n- 如果你需要一个频繁更新的 HashMap，请使用 Map；如果你想一个固定的键值集合（即记录），请使用Object，并注意原型继承带来的陷阱。\r\n- 现代框架下的日常工作使用Object更利于维护。（例如react hooks的deps不检测Map/Set）。"}]},{"number":48,"title":"【Q048】null 和 undefined 的区别","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/48","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. null\r\n值 `null` 特指 **对象** 的值未设置。它是 JavaScript `基本类型` 之一，在布尔运算中被认为是 `falsy`。\r\n\r\n值 `null` 是一个字面量，不像 `undefined`，它不是全局对象的一个属性。\r\n`null` 是表示缺少的标识，指示变量未指向任何对象。\r\n把 `null` 作为尚未创建的对象，也许更好理解。在 API 中，`null` 常在返回类型应是一个对象，但没有关联的值的地方使用。\r\n\r\n```javascript\r\n// foo 不存在，它从来没有被定义过或者是初始化过：\r\nconsole.log(foo); // \"ReferenceError: foo is not defined\"\r\n\r\n// foo 现在已经是知存在的，但是它没有类型或者是值：\r\nvar foo = null;\r\nconsole.log(foo); // null\r\n```\r\n\r\n当检测 null 或 undefined 时，注意相等（==）与全等（===）两个操作符的区别，前者会执行类型转换：\r\n```javascript\r\ntypeof null        // \"object\" (因为一些以前的原因而不是'null')\r\ntypeof undefined   // \"undefined\"\r\nnull === undefined // false\r\nnull  == undefined // true\r\nnull === null // true\r\nnull == null // true\r\n!null //true\r\nisNaN(1 + null) // false\r\nisNaN(1 + undefined) // true\r\n```\r\n\r\n## 2. undefined\r\n`undefined` 是全局对象的一个属性。也就是说，它是全局作用域的一个变量。\r\n`undefined` 的最初值就是原始数据类型 `undefined`。\r\n一个没有被赋值的变量的类型是 `undefined`。如果方法或者是语句中操作的变量没有被赋值，则会返回 `undefined`。\r\n```javascript\r\nfunction test(a){\r\n    console.log(typeof a);    // undefined\r\n    return a;\r\n}\r\n\r\ntest();                       // 返回\"undefined\"\r\n```\r\n\r\n## 3. null 与 undefined 的相同点\r\n\r\n- 都是原始类型，保存在栈中变量本地\r\n- 转换布尔值都为 false\r\n- 转换成对象的时候，都会报错\r\n- 宽松相等(==) 判断是相等的\r\n\r\n## 4. null 与 undefined 的不同点\r\n\r\n- undefined 表示变量声明过但并未赋过值，null 表示一个变量将来可能指向一个对象。\r\n- typeof 检测时，undefined 类型是 undefined，null 类型是 object\r\n- 数值转换时，null 可以转化为0，undefined 无法参与计算\r\n- 手动释放内存，可以使用null\r\n\r\n\r\n"}]},{"number":49,"title":"【Q049】symbol","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/49","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. Symbol\r\n`symbol` 是一种基本数据类型。\r\n`Symbol()` 函数会返回 symbol 类型的值，该类型具有静态属性和静态方法。\r\n它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的 symbol 注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法：`new Symbol()`。\r\n\r\n每个从 `Symbol()` 返回的 symbol 值都是唯一的。一个 symbol 值能作为对象属性的标识符；这是该数据类型仅有的目的。\r\n\r\n```javascript\r\nvar sym1 = Symbol();\r\nvar sym2 = Symbol('foo');\r\nvar sym3 = Symbol('foo');\r\nvar sym4 = new Symbol(); // TypeError\r\n\r\nconsole.log(sym2 === sym3) // false\r\n```\r\n\r\n## 2. Symbol用法\r\n### 对 symbol 使用 typeof 运算符\r\n```javascript\r\nconsole.log(typeof Symbol()) // 'symbol'\r\nconsole.log(typeof Symbol('foo')) // 'symbol'\r\nconsole.log(typeof Symbol.iterator) // 'symbol'\r\n```\r\n\r\n### Symbol 类型转换\r\n当使用 symbol 值进行类型转换时需要注意一些事情：\r\n\r\n- 尝试将一个 symbol 值转换为一个 number 值时，会抛出一个 TypeError \r\n- 使用宽松相等时，Object(sym) == sym // true.\r\n- 这会阻止你从一个 symbol 值隐式地创建一个新的 string 类型的属性名。例如，Symbol(\"foo\") + \"bar\" 将抛出一个 TypeError\r\n\r\n### Symbols 与 for...in 迭代\r\nSymbols 在 `for...in` 迭代中不可枚举。\r\n另外，`Object.getOwnPropertyNames()` 不会返回 symbol 对象的属性，但是你能使用 `Object.getOwnPropertySymbols()` 得到它们。\r\n```javascript\r\nvar obj = {};\r\n\r\nobj[Symbol(\"a\")] = \"a\";\r\nobj[Symbol.for(\"b\")] = \"b\";\r\nobj[\"c\"] = \"c\";\r\nobj.d = \"d\";\r\n\r\nfor (var i in obj) {\r\n   console.log(i); // 'c', 'd'\r\n}\r\n```\r\n\r\n### Symbols 与 JSON.stringify()\r\n当使用 JSON.stringify() 时，以 symbol 值作为键的属性会被完全忽略：\r\n```javascript\r\nJSON.stringify({[Symbol(\"foo\")]: \"foo\"});\r\n// '{}'\r\n```\r\n\r\n### Symbol 包装器对象作为属性的键\r\n当一个 Symbol 包装器对象作为一个属性的键时，这个对象将被强制转换为它包装过的 symbol 值：\r\n```javascript\r\nvar sym = Symbol(\"foo\");\r\nvar obj = {[sym]: 1};\r\nobj[sym];            // 1\r\nobj[Object(sym)];    // 1\r\n```"}]},{"number":50,"title":"【Q050】Object.assign","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/50","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. Object.assign\r\n`Object.assign()` 方法将所有可枚举的自有属性从一个或多个源对象复制到目标对象，返回修改后的对象。\r\n如果目标对象与源对象具有相同的 **键**，则目标对象中的属性将被源对象中的属性覆盖，后面的源对象的属性将类似地覆盖前面的源对象的属性。\r\n\r\n```javascript\r\nconst target = { a: 1, b: 2 };\r\nconst source = { b: 4, c: 5 };\r\n\r\nconst returnedTarget = Object.assign(target, source);\r\n\r\nconsole.log(target); // { a: 1, b: 4, c: 5 }\r\nconsole.log(returnedTarget === target); // true\r\n```\r\n\r\n### 常用于合并对象\r\n\r\n## 2. 用法\r\n### 合并对象\r\n```javascript\r\nconst o1 = { a: 1 };\r\nconst o2 = { b: 2 };\r\nconst o3 = { c: 3 };\r\n\r\nconst obj = Object.assign(o1, o2, o3);\r\nconsole.log(obj); // { a: 1, b: 2, c: 3 }\r\nconsole.log(o1);  // { a: 1, b: 2, c: 3 }\r\n```\r\n\r\n### 复制对象\r\n```javascript\r\nconst obj = { a: 1 };\r\nconst copy = Object.assign({}, obj);\r\nconsole.log(copy); // { a: 1 }\r\n```\r\n\r\n### 浅拷贝\r\n针对 深拷贝，需要使用其他办法，因为 Object.assign() 只复制属性值。\r\n假如源对象是一个对象的引用，它仅仅会复制其引用值。\r\n```javascript\r\nlet obj1 = { a: 0 , b: { c: 0}};\r\nlet obj2 = Object.assign({}, obj1);\r\nconsole.log(JSON.stringify(obj2)); // { \"a\": 0, \"b\": { \"c\": 0}}\r\n\r\nobj1.a = 1;\r\nconsole.log(JSON.stringify(obj1)); // { \"a\": 1, \"b\": { \"c\": 0}}\r\nconsole.log(JSON.stringify(obj2)); // { \"a\": 0, \"b\": { \"c\": 0}}\r\n\r\nobj2.a = 2;\r\nconsole.log(JSON.stringify(obj1)); // { \"a\": 1, \"b\": { \"c\": 0}}\r\nconsole.log(JSON.stringify(obj2)); // { \"a\": 2, \"b\": { \"c\": 0}}\r\n\r\nobj2.b.c = 3;\r\nconsole.log(JSON.stringify(obj1)); // { \"a\": 1, \"b\": { \"c\": 3}}\r\nconsole.log(JSON.stringify(obj2)); // { \"a\": 2, \"b\": { \"c\": 3}}\r\n\r\n// Deep Clone\r\nobj1 = { a: 0 , b: { c: 0}};\r\nlet obj3 = JSON.parse(JSON.stringify(obj1));\r\nobj1.a = 4;\r\nobj1.b.c = 4;\r\nconsole.log(JSON.stringify(obj3)); // { \"a\": 0, \"b\": { \"c\": 0}}\r\n```\r\n\r\n### 拷贝 Symbol 类型属性\r\n```javascript\r\nconst o1 = { a: 1 };\r\nconst o2 = { [Symbol('foo')]: 2 };\r\n\r\nconst obj = Object.assign({}, o1, o2);\r\nconsole.log(obj); // { a : 1, [Symbol(\"foo\")]: 2 }\r\nObject.getOwnPropertySymbols(obj); // [Symbol(foo)]\r\n```\r\n\r\n### 原型链上的属性和不可枚举属性不能被复制\r\n```javascript\r\nconst obj = Object.create({ foo: 1 }, { // foo is on obj's prototype chain.\r\n  bar: {\r\n    value: 2  // bar is a non-enumerable property.\r\n  },\r\n  baz: {\r\n    value: 3,\r\n    enumerable: true  // baz is an own enumerable property.\r\n  }\r\n});\r\n\r\nconst copy = Object.assign({}, obj);\r\nconsole.log(copy); // { baz: 3 }\r\n```\r\n\r\n### 异常会打断后续拷贝任务\r\n```javascript\r\nconst target = Object.defineProperty({}, 'foo', {\r\n  value: 1,\r\n  writable: false\r\n}); // target.foo is a read-only property\r\n\r\nObject.assign(target, { bar: 2 }, { foo2: 3, foo: 3, foo3: 3 }, { baz: 4 });\r\n// TypeError: \"foo\" is read-only\r\n// The Exception is thrown when assigning target.foo\r\n\r\nconsole.log(target.bar);  // 2, the first source was copied successfully.\r\nconsole.log(target.foo2); // 3, the first property of the second source was copied successfully.\r\nconsole.log(target.foo);  // 1, exception is thrown here.\r\nconsole.log(target.foo3); // undefined, assign method has finished, foo3 will not be copied.\r\nconsole.log(target.baz);  // undefined, the third source will not be copied either.\r\n```"}]},{"number":51,"title":"【Q051】常见的 DOM 方法","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/51","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 0. DOM常见的操作主要分为\r\n- 创建节点\r\n- 查询节点\r\n- 更新节点\r\n- 添加节点\r\n- 删除节点\r\n\r\n## 1. 创建节点\r\n### createElement\r\n创建新元素，接受一个参数，即要创建元素的标签名\r\n```javascript\r\nconst divEl = document.createElement(\"div\");\r\n```\r\n\r\n### createTextNode\r\n创建一个文本节点\r\n```javascript\r\nconst textEl = document.createTextNode(\"content\");\r\n```\r\n\r\n### createDocumentFragment\r\n用来创建一个文档碎片，它表示一种轻量级的文档，主要是用来存储临时节点，然后把文档碎片的内容一次性添加到 `DOM` 中\r\n```javascript\r\nconst fragment = document.createDocumentFragment();\r\n```\r\n当请求把一个 `DocumentFragment` 节点插入文档树时，插入的不是 `DocumentFragment` 自身，而是它的所有子孙节点\r\n\r\n### createAttribute\r\n创建属性节点，可以是自定义属性\r\n```javascript\r\nconst dataAttribute = document.createAttribute('custom');\r\nconsle.log(dataAttribute);\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"\r\n\r\n## 2. 获取节点\r\n### querySelector\r\n传入任何有效的css 选择器，即可选中单个 DOM元素（首个）：\r\n```javascript\r\ndocument.querySelector('.element')\r\ndocument.querySelector('#element')\r\ndocument.querySelector('div')\r\ndocument.querySelector('[name=\"username\"]')\r\ndocument.querySelector('div + p > span')\r\n```\r\n如果页面上没有指定的元素时，返回 null\r\n\r\n### querySelectorAll\r\n返回一个包含节点子树内所有与之相匹配的Element节点列表，如果没有相匹配的，则返回一个空节点列表\r\n```javascript\r\nconst notLive = document.querySelectorAll(\"p\");\r\n```\r\n需要注意的是，该方法返回的是一个 `NodeList` 的静态实例，它是一个静态的快照，而非实时的查询\r\n\r\n### 其它\r\n```javascript\r\ndocument.getElementById('id属性值');返回拥有指定id的对象的引用\r\ndocument.getElementsByClassName('class属性值');返回拥有指定class的对象集合\r\ndocument.getElementsByTagName('标签名');返回拥有指定标签名的对象集合\r\ndocument.getElementsByName('name属性值'); 返回拥有指定名称的对象结合\r\ndocument/element.querySelector('CSS选择器');  仅返回第一个匹配的元素\r\ndocument/element.querySelectorAll('CSS选择器');   返回所有匹配的元素\r\ndocument.documentElement;  获取页面中的HTML标签\r\ndocument.body; 获取页面中的BODY标签\r\ndocument.all[''];  获取页面中的所有元素节点的对象集合型\r\n```\r\n\r\n除此之外，每个DOM元素还有 `parentNode`、`childNodes`、`firstChild`、`lastChild`、`nextSibling`、`previousSibling`属性，关系图如下图所示\r\n\r\n![Alt](https://static.vue-js.com/c100f450-7fdc-11eb-ab90-d9ae814b240d.png)"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 3. 更新节点\r\n### innerHTML\r\n不但可以修改一个 `DOM` 节点的文本内容，还可以直接通过 `HTML` 片段修改 `DOM 节点内部的子树\r\n```javascript\r\n// 获取<p id=\"p\">...</p >\r\nvar p = document.getElementById('p');\r\n// 设置文本为abc:\r\np.innerHTML = 'ABC'; // <p id=\"p\">ABC</p >\r\n// 设置HTML:\r\np.innerHTML = 'ABC <span style=\"color:red\">RED</span> XYZ';\r\n// <p>...</p >的内部结构已修改\r\n```\r\n\r\n### innerText、textContent\r\n自动对字符串进行 `HTML` 编码，保证无法设置任何 `HTML` 标签\r\n```javascript\r\n// 获取<p id=\"p-id\">...</p >\r\nvar p = document.getElementById('p-id');\r\n// 设置文本:\r\np.innerText = '<script>alert(\"Hi\")</script>';\r\n// HTML被自动编码，无法设置一个<script>节点:\r\n// <p id=\"p-id\">&lt;script&gt;alert(\"Hi\")&lt;/script&gt;</p >\r\n```\r\n两者的区别在于读取属性时，`innerText` 不返回隐藏元素的文本，而 `textContent` 返回所有文本\r\n\r\n### style\r\n`DOM` 节点的 `style` 属性对应所有的 `CSS`，可以直接获取或设置。遇到 `-` 需要转化为驼峰命名\r\n```javascript\r\n// 获取<p id=\"p-id\">...</p >\r\nconst p = document.getElementById('p-id');\r\n// 设置CSS:\r\np.style.color = '#ff0000';\r\np.style.fontSize = '20px'; // 驼峰命名\r\np.style.paddingTop = '2em';\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 4. 添加节点\r\n### innerHTML\r\n如果这个 `DOM` 节点是空的，例如，`<div></div>`，那么，直接使用 `innerHTML = '<span>child</span>'`就可以修改 `DOM` 节点的内容，相当于添加了新的 `DOM` 节点\r\n\r\n如果这个 `DOM` 节点不是空的，那就不能这么做，因为 `innerHTML` 会直接替换掉原来的所有子节点\r\n\r\n### appendChild\r\n把一个子节点添加到父节点的最后一个子节点\r\n```javascript\r\nconst js = document.getElementById('js')\r\njs.innerHTML = \"JavaScript\"\r\nconst list = document.getElementById('list');\r\nlist.appendChild(js);\r\n```\r\n\r\n### insertBefore\r\n把子节点插入到指定的位置，使用方法如下：\r\n```javascript\r\nparentElement.insertBefore(newElement, referenceElement)\r\n```\r\n子节点会插入到referenceElement之前\r\n\r\n### setAttribute\r\n在指定元素中添加一个属性节点，如果元素中已有该属性改变属性值\r\n```javascript\r\nconst div = document.getElementById('id')\r\ndiv.setAttribute('class', 'white');//第一个参数属性名，第二个参数属性值。\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 5. 删除节点\r\n删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的 `removeChild` 把自己删掉\r\n```javascript\r\n// 拿到待删除节点:\r\nconst self = document.getElementById('to-be-removed');\r\n// 拿到父节点:\r\nconst parent = self.parentElement;\r\n// 删除:\r\nconst removed = parent.removeChild(self);\r\nremoved === self; // true\r\n```\r\n删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置"}]}],"react":[{"number":52,"title":"【Q052】React 17、React 18新特性","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/52","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. React 17新特性\r\n北京时间8月11日凌晨，React团队发布了 `React17` 第一个RC版本。该版本的最大特性是“无新特性”。\r\n这次版本更迭确实有“新特性” —— 替换了内部使用的 `启发式更新算法`，这个特性对开发者是无感知的。\r\n\r\n### 为什么会出现启发式更新算法\r\nReact纯JS写法太过灵活，使他在 `编译时优化` 方面先天不足。\r\n所以，React的优化主要在 `运行时`。\r\n\r\n### React16的启发式更新算法\r\n`启发式` 指不通过 **显式的指派**，而是通过 **优先级** 调度更新。\r\n其中优先级来源于 `人机交互的研究成果`。\r\n\r\n例如：\r\n- 当用户在输入框输入内容时，希望输入的内容能实时响应在输入框\r\n- 当异步请求数据后，即使等待一会儿再显示内容，用户也是可以接受的\r\n\r\n基于此在React16中：输入框输入内容触发的更新优先级 > 请求数据返回后触发更新优先级\r\n\r\n### 算法实现\r\n在React16、17中，在组件内执行 this.setState后会在该组件对应的fiber节点内产生一种链表数据结构update。\r\n其中，update.expirationTimes为类似时间戳的字段，表示优先级。\r\nexpirationTimes从字面意义理解为过期时间。\r\n该值离当前时间越接近，该update 优先级越高。\r\n当update.expirationTimes超过当前时间，则代表该update过期，优先级变为最高（即同步）。\r\n一棵fiber树的多个fiber节点可能存在多个update。\r\n每次Fiber Reconciler调度更新时，会在所有fiber节点的所有update.expirationTimes中选择一个expirationTimes（一般选择最大的），作为本次更新的优先级。\r\n并从根fiber节点开始向下构建新的fiber树。\r\n构建过程中如果某个fiber节点包含update，且\r\n```javascript\r\nupdate.expirationTimes >= expirationTimes\r\n```\r\n则该update对应的state变化会体现在本次更新中。\r\n可以理解为：每次更新，都会选定一个优先级（expirationTimes），最终页面会渲染为该优先级对应update的快照。\r\n举个例子，我们有如图所示fiber树，当前还没有更新产生，所以没有构建中的fiber树。\r\n\r\n![Alt](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b2f73db7076434092e735bae2ae3d64~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n当在C创建一个低优先级update，调度更新，本次更新选择的优先级为低优先级。\r\n开始构建新的fiber树（图右侧）。\r\n\r\n![Alt](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a44bdcb3599d41adab5e3b22303bf2de~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n此时，我们在D创建一个高优先级update。\r\n这会中断进行中的低优先级更新，重新开始以高优先级生成一棵fiber树。\r\n由于之前的更新被中断，还没有任何渲染操作，此时视图中（左图）还没有任何变化。\r\n\r\n![Alt](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3aa2edacd0dd4481bc773d244c3a6a4d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n本次更新选定的优先级为高优先级，C的update（低优先级）会被跳过。\r\n更新完成后新的fiber树会被渲染到视图中。\r\n\r\n![Alt](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f2277de78b04fcc81a9310e06b9a48a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n由于C被跳过，所以不会在视图（左图）中体现。\r\n接下来我们在E触发一次高优先级update。\r\nC虽然包含低优先级update，但随着时间的推移，他的expirationTimes已经过期，变为高优先级。\r\n\r\n![Alt](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a67d1f46c524c3fb221fae04fd93954~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n所以本次更新会有C E两个fiber节点产生变化。\r\n最终完成更新后，视图如下：\r\n\r\n![Alt](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02806250332141338705f6e556d9b4dd~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n### 算法缺陷\r\n如果只考虑中断/继续这样的CPU操作，以expirationTimes大小作为衡量优先级依据的模型可以很好工作。\r\n但是expirationTimes模型不能满足IO操作（Suspense）。\r\n在该模型下，高优先级IO任务（Suspense）会中断低优先级CPU任务。\r\n还记得么，每次更新，都是以某一优先级作为整棵树的优先级更新标准，而不仅仅是某一组件，即使更新的源头（update）确实是某个组件产生的。\r\nexpirationTimes模型只能区分是否>=expirationTimes这种情况。\r\n为了拓展Concurrent Mode能力边界，需要一种更细粒度的启发式优先级更新算法。\r\n\r\n### React17启发式更新算法\r\n最理想的模型是：可以指定任意几个优先级，更新会以这些优先级对应update生成页面快照。\r\n但是现有架构下，该方案实现上有瓶颈。\r\n妥协之下，React17的解决方案是：指定一个连续的优先级区间，每次更新都会以区间内包含的优先级生成对应页面快照。\r\n这种优先级区间模型被称为lanes（车道模型）。\r\n具体做法是：使用一个31位的二进制代表31种可能性。\r\n\r\n- 其中每个bit被称为一个lane（车道），代表优先级\r\n- 某几个lane组成的二进制数被称为一个lanes，代表一批优先级\r\n\r\n可以从源码中看到，从蓝线一路划下去，每个bit都对应一个lane或lanes。\r\n\r\n![Alt](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba935553f49e48888fa4742f72e9591e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n当update产生，会根据React16同样的启发式方式，获得如下优先级的一种：\r\n```javascript\r\nexport const SyncLanePriority: LanePriority = 17;\r\nexport const SyncBatchedLanePriority: LanePriority = 16;\r\nexport const InputDiscreteLanePriority: LanePriority = 14;\r\nexport const InputContinuousLanePriority: LanePriority = 12;\r\nexport const DefaultLanePriority: LanePriority = 10;\r\nexport const TransitionShortLanePriority: LanePriority = 8;\r\nexport const TransitionLongLanePriority: LanePriority = 6;\r\n```\r\n\r\n其中值越高，优先级越大。比如：\r\n- 点击事件回调中触发this.setState产生的update会获得InputDiscreteLanePriority。\r\n- 同步的update会获得SyncLanePriority。\r\n\r\n接下来，update会以priority为线索寻找没被占用的lane。\r\n如果当前fiber树已经存在更新且更新的lanes包含了该lane，则update需要寻找其他lane。\r\n比如，InputDiscreteLanePriority对应的lanes为InputDiscreteLanes。\r\n```javascript\r\n// 第4、5位为1\r\nconst InputDiscreteLanes: Lanes = 0b0000000000000000000000000011000;\r\n```\r\n\r\n该lanes包含第4、5位2个bit位。\r\n如果其中\r\n```javascript\r\n// 第五位为1\r\n0b0000000000000000000000000010000\r\n```\r\n\r\n第五位的lane已经被占用，则该update可以尝试占有后一个，即\r\n```javascript\r\n// 第四位为1\r\n0b0000000000000000000000000001000\r\n```\r\n\r\n如果InputDiscreteLanes的两个lane都被占用，则该update的优先级会下降到InputContinuousLanePriority并继续寻找空余的lane。\r\n这个过程就像：购物中心每一层（不同优先级）都有一个露天停车场（lanes），停车场有多个车位（lane）。\r\n我们先开车到顶楼找车位（lane），如果没有车位就下一楼继续找。\r\n直到找到空余车位。\r\n由于lanes可以包含多个lane，可以很方便的区分IO操作（Suspense）与CPU操作。\r\n当构建fiber树进入构建Suspense子树时，会将Suspense的lane插入本次更新选定的lanes中。\r\n当构建离开Suspense子树时，会将Suspense lane从本次更新的lanes中移除。\r\n\r\n### 总结\r\nReact16的expirationTimes模型只能区分是否>=expirationTimes决定节点是否更新。\r\nReact17的lanes模型可以选定一个更新区间，并且动态的向区间中增减优先级，可以处理更细粒度的更新。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. React 18新特性\r\n### Render API\r\n为了更好的管理root节点，React 18 引入了一个新的 root API，新的 root API 还支持 new concurrent renderer（并发模式的渲染），它允许你进入concurrent mode（并发模式）。\r\n```tsx\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './App';\r\n\r\nconst root = document.getElementById('root')!;\r\n\r\n// React 17\r\nReactDOM.render(<App />, root);\r\n\r\n// React 18\r\nReactDOM.createRoot(root).render(<App />);\r\n```\r\n\r\n同时，在卸载组件时，我们也需要将 unmountComponentAtNode 升级为 root.unmount:\r\n```javascript\r\n// React 17\r\nReactDOM.unmountComponentAtNode(root);\r\n\r\n// React 18\r\nroot.unmount();\r\n```\r\n\r\n###  setState 自动批处理\r\n\r\n- 在 18 之前，只有在react事件处理函数中，才会自动执行批处理，其它情况会多次更新\r\n- 在 18 之后，任何情况都会自动执行批处理，多次更新始终合并为一次\r\n\r\n### flushSync\r\n批处理是一个破坏性改动，如果不想批量更新，你可以使用 flushSync：\r\n```tsx\r\nimport React, { useState } from 'react';\r\nimport { flushSync } from 'react-dom';\r\n\r\nconst App: React.FC = () => {\r\n  const [count1, setCount1] = useState(0);\r\n  const [count2, setCount2] = useState(0);\r\n  return (\r\n    <div\r\n      onClick={() => {\r\n        flushSync(() => {\r\n          setCount1(count => count + 1);\r\n        });\r\n        // 第一次更新\r\n        flushSync(() => {\r\n          setCount2(count => count + 1);\r\n        });\r\n        // 第二次更新\r\n      }}\r\n    >\r\n      <div>count1： {count1}</div>\r\n      <div>count2： {count2}</div>\r\n    </div>\r\n  );\r\n};\r\nexport default App;\r\n```"}]},{"number":53,"title":"【Q053】虚拟 DOM 是什么？以及 Diff 算法原理","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/53","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 虚拟 DOM\r\nJS的DOM操作非常消耗性能，而React把DOM转换成了 **JS对象**。这就是虚拟Dom（Virtual Dom）。\r\n\r\n每次数据更新后，重新计算虚拟Dom，并和上一次生成的虚拟dom进行对比，对发生变化的部分作批量更新。\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e8c8a3a50f44088b5409614d7ee8f3a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n当我们需要创建或更新元素时，React首先会让这个VitrualDom对象进行创建和更改，然后再将VitrualDom对象渲染成真实DOM；\r\n当我们需要对DOM进行事件监听时，首先对VitrualDom进行事件监听，VitrualDom会代理原生的DOM事件从而做出响应。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. Diff 算法\r\nReact需要同时维护两棵虚拟DOM树：一棵表示当前的DOM结构，另一棵在React状态变更将要重新渲染时生成。\r\nReact通过比较这两棵树的差异，决定是否需要修改DOM结构，以及如何修改。这种算法称作Diff算法。\r\n\r\n### Diff 算法过程\r\nDiff算法会对新旧两棵树做深度优先遍历，避免对两棵树做完全比较，因此算法复杂度可以达到O(n)。\r\n然后给每个节点生成一个唯一的标志。\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22e96efebcce4b14a679ec218c4a3efe~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n在遍历的过程中，每遍历到一个节点，就将新旧两棵树作比较，并且只对同一级别的元素进行比较。\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/319324b9cfa24c569f6c6f05300cd73f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n也就是只比较图中用虚线连接起来的部分，把前后差异记录下来。\r\n\r\n## 3.Diff 算法策略\r\n### ① tree diff\r\ntree diff主要针对的是React dom节点跨层级的操作。\r\n由于跨层级的DOM移动操作较少，所以React diff算法的tree diff没有针对此种操作进行深入比较，只是简单进行了删除和创建操作。\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e3e3c42eab447a7bd3ef46e9b748e69~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n由此可以发现，当出现节点跨层级移动时，并不会出现想象中的移动操作，而是以 A 为根节点的整个树被重新创建。这是一种影响 React 性能的操作，因此官方建议不要进行 DOM 节点跨层级的操作。\r\n\r\n#### 基于上述原因，在开发组件时，保持稳定的 DOM 结构会有助于性能的提升。例如，可以通过 CSS 隐藏或显示节点，而不是真正地移除或添加 DOM 节点。\r\n\r\n### ② component diff\r\ncomponent diff是专门针对更新前后的同一层级间的React组件比较的diff 算法：\r\n- 如果是同一类型的组件，按照原策略继续比较 Virtual DOM 树可。\r\n- 如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点，即销毁原组件，创建新组件。\r\n- 对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切知道这点，那么就可以节省大量的 diff 运算时间。因此，React 允许用户通过 shouldComponentUpdate()来判断该组件是否需要进行 diff 算法分析。\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/550916d92fc9467f8eb6e5edb20daa52~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n#### 虽然当两个组件是不同类型但结构相似时，diff 会影响性能，但正如 React 官网所言：不同类型的组件很少存在相似 DOM树的情况，因此这种极端因素很难在实际开发过程中造成重大的影响。\r\n\r\n### ③ element diff\r\nelement diff是专门针对同一层级的所有节点的diff算法。\r\n当节点处于同一层级时，diff 提供了 3 种节点操作，分别为 `INSERT_MARKUP`（插入）、`MOVE_EXISTING`（移动）和 `REMOVE_NODE`（删除）。\r\n\r\n我们将虚拟dom树中欲比较的某同一层级的所有节点的集合分别称为新集合和旧集合，则有以下策略：\r\n\r\n- INSERT_MARKUP：新集合的某个类型组件或元素节点不存在旧集合里，即全新的节点，需要对新节点执行插入操作。\r\n- MOVE_EXISTING：新集合的某个类型组件或元素节点存在旧集合里，且 element 是可更新的类型，generateComponent-Children 已调用receiveComponent，这种情况下 prevChild=nextChild，就需要做移动操作，可以复用以前的 DOM 节点。\r\n- REMOVE_NODE：旧集合的某个组件或节点类型，在新集合里也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者旧组件或节点不在新集合里的，也需要执行删除操作。\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fedb1d9dec9b4c25ba106660fd2bb964~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)"}]},{"number":54,"title":"【Q054】key 是干什么的","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/54","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. key 的作用\r\n同一层级的某个节点添加了对于其他同级节点唯一的key属性，当它在当前层级的位置发生了变化后。\r\nreact diff算法通过新旧节点比较后，如果发现了key值相同的新旧节点，就会执行移动操作（然后依然按原策略深入节点内部的差异对比更新），而不会执行原策略的删除旧节点，创建新节点的操作。\r\n这无疑大大提高了React性能和渲染效率。\r\n\r\n## 2. key 的执行过程\r\n对新集合中的节点进行循环遍历，通过唯一的 key 判断新旧集合中是否存在相同的节点。\r\n如果存在相同节点，判断要移动的节点在旧集合中的位置不在最后一位，才进行移动操作。\r\n\r\n## 3. index 可以作为 key 吗？\r\n### React官方建议不要用遍历的index作为这种场景下的节点的key属性值。\r\n比如当前遍历的所有节点类型都相同，其内部文本不同，在用index作key的情况下，当我们对原始的数据list进行了某些元素的顺序改变操作，导致了新旧集合中在进行diff比较时，相同index所对应的新旧的节点其文本不一致了，就会出现一些节点需要更新渲染文本，而如果用了其他稳定的唯一标识符作为key，则只会发生位置顺序变化，无需更新渲染文本，提升了性能。\r\n\r\n## 4. key 的缺点\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce6eb05a24674c51943127fcde856d34~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作。\r\n\r\n## 5. key 使用注意事项\r\n- 如果遍历的列表子节是作为纯展示，而不涉及到列表元素顺序的动态变更，那使用index作为key还是没有问题的。\r\n- key只是针对同一层级的节点进行了diff比较优化，而跨层级的节点互相之间的key值没有影响。\r\n- 如果存在新旧集合中，相同的key值所对应的节点类型不同（比如从span变成div），这相当于完全替换了旧节点，删除了旧节点，创建了新节点。\r\n- key值在比较之前都会被执行toString()操作，所以尽量不要使用object类型的值作为key，会导致同一层级出现key值相同的节点。"}]},{"number":55,"title":"【Q055】Fiber","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/55","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 为什么需要Fiber\r\n在数据更新时，react生成了一棵更大的虚拟dom树，给diff带来了很大压力——我们想找到真正变化的部分，这需要花费更长的时间。\r\njs占据主线程去做比较，渲染线程便无法做其他工作，用户的交互得不到响应，所以便出现了 `Fiber`。\r\n\r\n### Fiber 是 React 16 中新的协调引擎。它的主要目的是使 Virtual DOM 可以进行增量式渲染。\r\n\r\n`Fiber` 没法让比较的时间缩短，但它使得diff的过程 **分割** 成小段，因为它有了“保存工作进度”的能力。\r\njs会比较一部分虚拟dom，然后让渡主线程，给浏览器去做其他工作，然后继续比较，依次往复，等到最后比较完成，一次性更新到视图上。\r\n\r\n## 2. Fiber 是一种新的数据结构\r\n模拟栈的链表\r\n\r\n## 3. Fiber 是纤程\r\n这种数据结构之所以被叫做 `Fiber`，翻译过来是纤程，它被认为是协程的一种实现形式。\r\n协程是比线程更小的调度单位：它的开启、暂停可以被程序员所控制。\r\n具体来说，`Fiber` 是通过 `requestIdleCallback` 去控制的组件渲染的“进度条”。\r\n\r\n`requesetIdleCallback` 是一个属于宏任务的回调，就像 `setTimeout` 一样。\r\n不同的是，`setTimeout` 的执行时机由我们传入的回调时间去控制，`requesetIdleCallback` 是受屏幕的刷新率去控制，每个16s调用一次。\r\n```javascript\r\nconst workLoop = (deadLine) => {\r\n    let shouldYield = false;// 是否该让出线程\r\n    while(!shouldYield){\r\n        console.log('working')\r\n        // 遍历节点等工作\r\n        shouldYield = deadLine.timeRemaining()<1;\r\n    }\r\n    requestIdleCallback(workLoop)\r\n}\r\nrequestIdleCallback(workLoop);\r\n```\r\n\r\n### 4. 总结\r\n`Fiber` 是React 16提出的一种更新机制，使用链表取代了树，将虚拟dom连接，使得组件更新的流程可以被中断恢复；\r\n它把组件渲染的工作分片，到时会主动让出渲染主线程。"}]},{"number":56,"title":"【Q056】React 事件机制和原生事件机制的关系","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/56","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. React 事件机制\r\nReact 实现了一套事件机制，包括事件注册、事件的合成、事件冒泡、事件派发。\r\n`React事件` 和 `原始事件` 是两套机制。 `React事件` 是基于 `原始事件机制` 下完成的。\r\n\r\n### 原生事件机制（捕获阶段-目标元素阶段-冒泡阶段）\r\n事件绑定在对应dom节点上，在合适时机触发。\r\n```javascript\r\ndocument.getElementById().addEventListener('click',()=>{\r\n // ...\r\n})\r\n```\r\n\r\n### React 重写事件处理机制\r\n\r\n- onClick | onInput | onFocus 等为React事件\r\n- 所有React 事件 都绑定在document上\r\n- React 事件是在冒泡阶段触发\r\n- React 事件触发时机后于原生事件\r\n\r\n## 2. 两者的关系\r\n\r\n- React 事件为合成事件（SyntheticEvent）基于原始事件（Event）。\r\n- 原始事件停止冒泡会阻止合成事件触发 ， 相反不会。\r\n- 不建议混用。 理解后可以得心应手。\r\n\r\n## 3. 响应顺序\r\n\r\n- 原生事件捕获阶段\r\n- 原生事件冒泡阶段\r\n- 原生事件冒泡到document ，开始React 事件执行 模拟冒泡"}]},{"number":57,"title":"【Q057】React 生命周期","labels":["react"],"body":"三个废弃的生命周期","url":"https://github.com/kangyana/daily-question/issues/57","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. React 生命周期\r\nReact 16.8+的生命周期分为三个阶段，分别是 `挂载阶段`、`更新阶段`、`卸载阶段`。\r\n\r\n![Alt](https://img-blog.csdnimg.cn/20210515113558981.png)\r\n\r\n![Alt](https://raw.githubusercontent.com/kangyana/img-storage/master/react_lifecycle.jpg)\r\n\r\n## 2. 挂载阶段\r\n\r\n- constructor\r\n构造函数，最先被执行,我们通常在构造函数里初始化 `state` 对象或者给自定义方法绑定 `this`。\r\n- getDerivedStateFromProps\r\n`static getDerivedStateFromProps(nextProps, prevState)`，这是个静态方法，当我们接收到新的属性想去修改 `state`，可以使用 `getDerivedStateFromProps`。\r\n- render\r\n`render` 是纯函数，只返回需要渲染的东西，不应该包含其它的业务逻辑，可以返回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容。\r\n- componentDidMount\r\n组件装载之后调用，此时可以获取到DOM节点并操作，比如对canvas，svg的操作，服务器请求，订阅都可以写在这个里面。\r\n但是记得在`componentWillUnmount`中取消订阅。\r\n\r\n## 3. 更新阶段\r\n\r\n- getDerivedStateFromProps\r\n此方法在更新个挂载阶段都可能会调用。\r\n- shouldComponentUpdate\r\n`shouldComponentUpdate(nextProps, nextState)`，有两个参数 `nextProps` 和 `nextState`，表示新的属性和变化之后的 `state`。\r\n返回一个布尔值，true表示会触发重新渲染，false表示不会触发重新渲染，默认返回true。\r\n我们通常利用此生命周期来优化React程序性能。\r\n- render\r\n更新阶段也会触发此生命周期。\r\n- getSnapshotBeforeUpdate\r\n`getSnapshotBeforeUpdate(prevProps, prevState)`，这个方法在 `render` 之后，`componentDidUpdate` 之前调用。\r\n有两个参数 `prevProps` 和 `prevState`，表示之前的属性和之前的 `state`。\r\n这个函数有一个返回值，会作为第三个参数传给 `componentDidUpdate`，如果你不想要返回值，可以返回 `null`。\r\n此生命周期必须与 `componentDidUpdate` 搭配使用。\r\n- componentDidUpdate\r\n`componentDidUpdate(prevProps, prevState, snapshot)`，该方法在 `getSnapshotBeforeUpdate` 方法之后被调用。\r\n有三个参数 `prevProps`，`prevState`，`snapshot`，表示之前的 `props`，之前的 `state`，和 `snapshot`。\r\n第三个参数是 `getSnapshotBeforeUpdate` 返回的。\r\n如果触发某些回调函数时需要用到 DOM 元素的状态，则将对比或计算的过程迁移至 `getSnapshotBeforeUpdate`，然后在 `componentDidUpdate` 中统一触发回调或更新状态。\r\n\r\n## 4. 卸载阶段\r\n\r\n- componentWillUnmount\r\n当组件被卸载或者销毁了就会调用，我们可以在这个函数里去清除一些定时器，取消网络请求，清理无效的DOM元素等垃圾清理工作。\r\n\r\n## 5. 三个废弃的生命周期\r\nReact 16之后有三个生命周期被废弃：\r\n\r\n- componentWillMount\r\n- componentWillReceiveProps\r\n- componentWillUpdate\r\n\r\n因为这些 `生命周期` 方法容易被误解和滥用。\r\n\r\n### 为什么要废弃这三个生命周期钩子？它们有哪些问题呢？React 又是如何解决的呢？\r\n我们知道 React 的更新流程分为：`render阶段` 和 `commit阶段`。\r\n这三个生命周期钩子都是在 `render阶段` 执行的。\r\n\r\n在 `fiber` 架构被应用之后，低优先级任务的 `render阶段` 可以被高优先级任务打断。\r\n而这导致的问题就是：在 `render阶段` 执行的生命周期函数可能被执行多次，这三个方法也会被执行多次。\r\n\r\n用一个静态函数 `getDerivedStateFromProps` 来取代被废弃的几个生命周期函数，这样开发者就无法通过 `this` 获取到组件的实例，也不能发送网络请求以及调用 `this.setState`。\r\n它就是强制开发者在 `render` 之前只做无副作用的操作，间接强制我们无法进行这些不合理不规范的操作，从而避免对生命周期的滥用。"}]},{"number":58,"title":"【Q058】React 组件性能优化","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/58","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"React 组件性能优化的核心是减少渲染真实DOM 节点的频率，减少 Virtual DOM对比的频率。\r\n\r\n## 1. 组件卸载前进行清理操作\r\n在组件中为 window 注册的全局事件, 以及定时器, 在组件卸载前要清理掉, 防止组件卸载后继续执行影响应用性能。\r\n```javascript\r\nuseEffect(() => {\r\n  let timer = setInterval(() => {\r\n    console.log('timer is running...')\r\n  }, 1000)\r\n\r\n  return () => clearInterval(timer) // 负责执行清理操作\r\n}, [])\r\n```\r\n\r\n## 2. PureComponent 纯组件\r\n### 什么是纯组件\r\n纯组件会对组件输入数据进行浅层比较，如果当前输入数据和上次输入数据相同，组件不会重新渲染。\r\n\r\n### 什么是浅层比较\r\n比较引用数据类型在内存中的引用地址是否相同，比较基本数据类型的值是否相同。\r\n\r\n### 如何实现纯组件\r\n类组件继承 `PureComponent` 类，函数组件使用 `memo` 方法\r\n\r\n### 为什么不直接进行 diff 操作, 而是要先进行浅层比较，浅层比较难道没有性能消耗吗\r\n和进行 `diff` 比较操作相比，浅层比较将消耗更少的性能。\r\n`diff` 操作会重新遍历整颗 `virtualDOM` 树, 而浅层比较只操作当前组件的 `state` 和 `props`。\r\n\r\n## 3. shouldComponentUpdate\r\n纯组件只能进行浅层比较，要进行深层比较，使用 `shouldComponentUpdate`，它用于编写自定义比较逻辑。\r\n返回 `true` 重新渲染组件，返回 `false` 阻止重新渲染。\r\n函数的第一个参数为 `nextProps`, 第二个参数为 `nextState`。\r\n```javascript\r\nshouldComponentUpdate(nextProps, nextState) {\r\n  if (this.state.name !== nextState.name || this.state.age !== nextState.age) {\r\n    return true\r\n  }\r\n  return false\r\n}\r\n```\r\n\r\n## 4. React.memo\r\n### memo 基本使用\r\n将函数组件变为纯组件，将当前 `props` 和上一次的 `props` 进行浅层比较，如果相同就阻止组件重新渲染。\r\n\r\n### 为 memo 传递比较逻辑\r\n使用 `memo` 方法自定义比较逻辑，用于执行深层比较。\r\n比较函数的第一个参数为上一次的 `props` , 比较函数的第二个参数为下一次的 `props`, 比较函数返回 `true`, 不进行渲染, 比较函数返回 `false`, 组件重新渲染。\r\n\r\n## 5. 使用组件懒加载\r\n使用 `lazy`（组件懒加载）可以减少 bundle 文件大小, 加快组件呈递速度。\r\n```javascript\r\nimport React, { lazy } from 'react';\r\n\r\nconst Home = lazy(() => import(/* webpackChunkName: \"Home\" */ \"./Home\"))\r\n```\r\n\r\n## 6. 使用 Fragment 避免额外标记\r\nReact 组件中返回的 jsx 如果有多个同级元素, 多个同级元素必须要有一个共同的父级。\r\n```javascript\r\n<div>\r\n  <div>message a</div>\r\n  <div>message b</div>\r\n</div>\r\n```\r\n\r\n为了满足这个条件我们通常都会在最外层添加一个div, 但是这样的话就会多出一个无意义的标记, 如果每个组件都多出这样的一个无意义标记的话, 浏览器渲染引擎的负担就会加剧。\r\n为了解决这个问题, React 推出了 `fragment` 占位符标记. 使用占位符标记既满足了拥有共同父级的要求又不会多出额外的无意义标记。\r\n```javascript\r\n<>\r\n  <div>message a</div>\r\n  <div>message b</div>\r\n</>\r\n}\r\n```\r\n\r\n## 7. 减少使用内联函数定义\r\n在使用内联函数后, `render` 方法每次运行时都会创建该函数的新实例。\r\n导致 React 在进行 `Virtual DOM` 比对时, 新旧函数比对不相等，导致 React 总是为元素绑定新的函数实例, 而旧的函数实例又要交给垃圾回收器处理。\r\n```javascript\r\n<input onChange={e => this.setState({ inputValue: e.target.value })} />\r\n```\r\n\r\n正确的做法是在组件中单独定义函数, 将函数绑定给事件。\r\n```javascript\r\nsetInputValue = e => {\r\n  this.setState({ inputValue: e.target.value })\r\n}\r\n\r\n<input onChange={this.setInputValue} />\r\n```\r\n\r\n## 8. 在构造函数中进行函数this绑定\r\n在类组件中如果使用 fn() {} 这种方式定义函数, 函数 `this` 默认指向 `undefined`。\r\n也就是说函数内部的 `this` 指向需要被更正。\r\n\r\n可以在构造函数中对函数的 `this` 进行更正, 也可以在行内进行更正, 两者看起来没有太大区别, 但是对性能的影响是不同的。\r\n```javascript\r\nexport default class App extends React.Component {\r\n   constructor() {\r\n    super()\r\n     // 方式一\r\n     // 构造函数只执行一次, 所以函数 this 指向更正的代码也只执行一次.\r\n    this.handleClick = this.handleClick.bind(this)\r\n  }\r\n  handleClick() {\r\n    console.log(this)\r\n  }\r\n  render() {\r\n    // 方式二 \r\n    // 问题: render 方法每次执行时都会调用 bind 方法生成新的函数实例.\r\n    return <button onClick={this.handleClick.bind(this)}>按钮</button>\r\n  }\r\n}\r\n```\r\n\r\n## 9. 类组件中的箭头函数\r\n在类组件中使用箭头函数不会存在 `this` 指向问题, 因为箭头函数本身并不绑定 `this`。\r\n箭头函数在 `this` 指向问题上占据优势，但是同时也有不利的一面。\r\n\r\n当使用箭头函数时，该函数被添加为类的实例对象属性，而不是原型对象属性。\r\n如果组件被多次重用，每个组件实例对象中都将会有一个相同的函数实例，降低了函数实例的可重用性造成了资源浪费。\r\n\r\n综上所述，更正函数内部 `this` 指向的最佳做法仍是在构造函数中使用 `bind` 方法进行绑定。\r\n\r\n## 10. 避免使用内联样式属性\r\n当使用内联 style 为元素添加样式时, 内联 style 会被编译为 JS 代码。\r\n通过 JS 代码将样式规则映射到元素的身上, 浏览器就会花费更多的时间执行脚本和渲染 UI, 从而增加了组件的渲染时间。\r\n\r\n更好的办法是将 CSS 文件导入样式组件，能通过 CSS 直接做的事情就不要通过 JavaScript 去做，因为 JavaScript 操作 DOM 非常慢。\r\n\r\n## 11. 优化条件渲染\r\n频繁的挂载和卸载组件是一项耗性能的操作, 为了确保应用程序的性能, 应该减少组件挂载和卸载的次数。\r\n在 React 中我们经常会根据条件渲染不同的组件，条件渲染是一项必做的优化操作。\r\n```javascript\r\nif (true) {\r\n  return (\r\n    <>\r\n      <AdminHeader />\r\n      <Header />\r\n      <Content />\r\n    </>\r\n  )\r\n} else {\r\n  return (\r\n    <>\r\n      <Header />\r\n      <Content />\r\n    </>\r\n  )\r\n}\r\n\r\n// 改为\r\n\r\nreturn (\r\n  <>\r\n    {true && <AdminHeader />}\r\n    <Header />\r\n    <Content />\r\n  </>\r\n)\r\n```\r\n\r\n## 12. 避免重复无限渲染\r\n当应用程序状态发生更改时, React 会调用 `render` 方法。\r\n如果在 `render` 方法中继续更改应用程序状态, 就会发生 `render` 方法递归调用导致应用报错。\r\n```javascript\r\nrender() {\r\n  this.setState({name: \"李四\"})\r\n  return <div>{this.state.name}</div>\r\n}\r\n```\r\n与其他生命周期函数不同, `render` 方法应该被作为纯函数。\r\n这意味着, 在 `render` 方法中不要做以下事情：\r\n\r\n- 不要调用 `setState` 方法\r\n- 不要使用其他手段查询更改原生 DOM 元素\r\n- 以及其他更改应用程序的任何操作\r\n\r\n`render` 方法的执行要根据状态的改变, 这样可以保持组件的行为和渲染方式一致。\r\n\r\n## 13. 为组件创建错误边界\r\n默认情况下, 组件渲染错误会导致整个应用程序中断, 创建错误边界可确保在特定组件发生错误时应用程序不会中断。\r\n\r\n错误边界涉及到两个生命周期函数, 分别为 `getDerivedStateFromError` 和 `componentDidCatch`。\r\n\r\n## 14. 避免数据结构突变\r\n组件中 `props` 和 `state` 的数据结构应该保持一致, 数据结构突变会导致输出不一致。\r\n\r\n## 15. 依赖优化\r\n按需引入第三方依赖包。\r\n\r\n## 16. 为列表数据添加唯一标识key\r\n\r\n- 可以避免因元素变化而导致重新创建\r\n- 动态列表（排序、过滤、从中间或者顶部删除item）不建议用索引作为key\r\n\r\n## 17. 高阶组件是类组件之间共享逻辑，类中使用较多\r\n什么是高阶组件 Higher Order Component (HOC)\r\n\r\n- 高阶组件是React应用中共享代码、增加逻辑复用的一种方式，比如A组件和B组件都需要使用一个相同的逻辑。可以使用高阶组件将逻辑抽取到一个公共的地方使用。\r\n- 高阶组件的核心思想就是在组件的外层再包裹一层执行逻辑的组件，在外层组件中执行逻辑，再将逻辑执行的结果传递到内容组件。\r\n- 高阶组件由一个函数返回，函数接受组件作为参数，返回一个新的组件，参数组件就是要服用的组件，函数内部返回的新组件就是执行逻辑的组件，在新组件内部执行完逻辑以后再调用参数组件并将逻辑结果传递给参数组件。\r\n\r\n## 18、渲染属性和 Portal\r\n渲染属性类中使用较多 `Portal` 将元素渲染到任何根元素"}]},{"number":59,"title":"【Q059】React.memo","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/59","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. React.memo\r\n`React.memo` 为 `高阶组件`。\r\n`props` 不变的情况下渲染，可以使用 `memo` 将组件包起来，通过记忆组件渲染结果的方式来提高组件的性能表现。\r\n相当于，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。\r\n\r\n`memo` 仅检查 `props` 变更，如果有其他状态改变，它仍会重新渲染。\r\n\r\n默认情况下其只会对复杂对象做浅层对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。\r\n```javascript\r\nfunction MyComponent(props) {\r\n  /* 使用 props 渲染 */\r\n}\r\nexport default React.memo(MyComponent, (prevProps, nextProps) => {\r\n  /*\r\n  如果把 nextProps 传入 render 方法的返回结果与\r\n  将 prevProps 传入 render 方法的返回结果一致则返回 true，\r\n  否则返回 false\r\n  */\r\n});\r\n```\r\n\r\n### 此方法仅作为 **性能优化** 的方式而存在。但请不要依赖它来“阻止”渲染，因为这会产生 bug。\r\n\r\n## 2. 与 shouldComponentUpdate() 的区别\r\n`memo` 的第二个参数 areEqual 的返回值是`props` 判断相等，\r\n`shouldComponentUpdate` 的返回值恰好相反，是 `props` 判断不等。"}]},{"number":60,"title":"【Q060】props.children","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/60","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. props.children\r\n每个组件都可以获取到 `props.children`。它包含组件的开始标签和结束标签之间的内容。例如：\r\n```html\r\n<Welcome>Hello world!</Welcome>\r\n```\r\n\r\n在 Welcome 组件中获取 props.children，就可以得到字符串 Hello world!：\r\n```javascript\r\nfunction Welcome(props) {\r\n  return <p>{props.children}</p>;\r\n}\r\n```\r\n\r\n对于 class 组件，请使用 this.props.children 来获取：\r\n```javascript\r\nclass Welcome extends React.Component {\r\n  render() {\r\n    return <p>{this.props.children}</p>;\r\n  }\r\n}\r\n```\r\n\r\n## 2. props.children 的数据类型\r\n`props.children` 的值有三种可能：\r\n\r\n- 如果当前组件没有子节点，它就是 `undefined`；\r\n- 如果有一个子节点，数据类型是 `object`；\r\n- 如果有多个子节点，数据类型就是 `array`。\r\n\r\n### 判断数据类型\r\n使用 `isValidElement()` 可以判断是是否为 React元素(object)。\r\n```javascript\r\nReact.isValidElement(object)\r\n```\r\n\r\n## 3. React.Children 方法\r\nReact 提供了工具方法 `React.Children` 来处理 `props.children`。\r\n\r\n### React.Children.map\r\n在 `children` 里的每个直接子节点上调用一个函数，并将 `this` 设置为 `thisArg`。\r\n如果 `children` 是一个数组，它将被遍历并为数组中的每个子节点调用该函数。\r\n如果子节点为 `null` 或是 `undefined`，则此方法将返回 `null` 或是 `undefined`，而不会返回数组。\r\n```javascript\r\nReact.Children.map(children, function[(thisArg)])\r\n```\r\n\r\n### React.Children.forEach\r\n与 `React.Children.map()` 类似，但它不会返回一个数组。\r\n```javascript\r\nReact.Children.forEach(children, function[(thisArg)])\r\n```\r\n\r\n### React.Children.count\r\n返回 `children` 中的组件总数量，等同于通过 `map` 或 `forEach` 调用回调函数的次数。\r\n```javascript\r\nReact.Children.count(children)\r\n```\r\n\r\n### React.Children.only\r\n验证 `children` 是否只有一个子节点（一个 React 元素），如果有则返回它，否则此方法会抛出错误。\r\n```javascript\r\nReact.Children.only(children)\r\n```\r\n\r\n### React.Children.toArray\r\n将 `children` 这个复杂的数据结构以数组的方式扁平展开并返回，并为每个子节点分配一个 `key`。\r\n当你想要在渲染函数中操作子节点的集合时，它会非常实用，特别是当你想要在向下传递 `props.children` 之前对内容重新排序或获取子集时。\r\n```javascript\r\nReact.Children.toArray(children)\r\n```\r\n\r\n注意：此方法会重写 `key`，给 `key` 一个 `.$` 前缀。\r\n![Alt](https://raw.githubusercontent.com/kangyana/img-storage/master/toArray_key.png)"}]},{"number":61,"title":"【Q061】content","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/61","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. content\r\n`Context`（上下文） 提供了一个无需为每层组件手动添加 `props`，就能在组件树间进行数据传递的方法。\r\n\r\n## 2. 何时使用 Context\r\n`Context` 设计目的是为了共享那些对于一个组件树而言是 **全局的数据**，例如当前认证的用户、主题或首选语言。\r\n\r\n## 3. 使用 Context 之前的考虑\r\n`Context` 主要应用场景在于很多不同层级的组件需要访问同样一些的数据。请谨慎使用，因为这会使得组件的复用性变差。\r\n\r\n如果你只是想避免层层传递一些属性，`组件组合（component composition）` 有时候是一个比 context 更好的解决方案。\r\n\r\n## 4. Content 的API\r\n### React.createContext\r\n创建一个 `Context` 对象。\r\n当 React 渲染一个订阅了这个 `Context` 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 `Provider` 中读取到当前的 `context` 值。\r\n```javascript\r\nconst MyContext = React.createContext(defaultValue);\r\n```\r\n\r\n### Context.Provider\r\nProvider 接收一个 value 属性，传递给消费组件。\r\n当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。\r\n```javascript\r\n<MyContext.Provider value={/* 某个值 */}>\r\n```\r\n\r\n### Context.Consumer\r\n一个 React 组件，它可以订阅 `context` 的变更。\r\n此组件可以让你在 `函数式组件` 中可以订阅 `context`。\r\n```javascript\r\n<MyContext.Consumer>\r\n  {value => /* 基于 context 值进行渲染*/}\r\n</MyContext.Consumer>\r\n```\r\n\r\n### Context.displayName\r\n`context` 对象接受一个名为 `displayName` 的 属性，类型为字符串。\r\nReact DevTools 使用该字符串来确定 `context` 要显示的内容。\r\n```javascript\r\nconst MyContext = React.createContext(/* some value */);\r\nMyContext.displayName = 'MyDisplayName';\r\n\r\n<MyContext.Provider> // \"MyDisplayName.Provider\" 在 DevTools 中\r\n<MyContext.Consumer> // \"MyDisplayName.Consumer\" 在 DevTools 中\r\n```\r\n\r\n## 5. 注意事项\r\n`context` 根据 `value` 属性值的浅比较来决定何时进行渲染。\r\n当 `provider` 的父组件进行重渲染时，可能会在 `consumers` 组件中触发意外的渲染。\r\n\r\n当每一次 `Provider` 重渲染时，由于 `value` 属性总是被赋值为新的对象，以下的代码会重新渲染下面所有的 `consumers` 组件：\r\n```javascript\r\nclass App extends React.Component {\r\n  render() {\r\n    return (\r\n      <MyContext.Provider value={{something: 'something'}}>\r\n        <Toolbar />\r\n      </MyContext.Provider>\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n为了防止这种情况，将 `value` 状态提升到父节点的 `state` 里：\r\n```javascript\r\nclass App extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      value: {something: 'something'},\r\n    };\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <MyContext.Provider value={this.state.value}>\r\n        <Toolbar />\r\n      </MyContext.Provider>\r\n    );\r\n  }\r\n}\r\n```"}]},{"number":62,"title":"【Q062】setState 是同步还是异步？","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/62","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. setState 是同步还是异步？\r\n`setState` 是异步的，但不是 `setTimeout`、`Promise` 那种异步，只是指 `setState` 之后是否 `state` 马上变了，是否马上 `render`。\r\n`setState` 会创建 `update` 对象挂到 `fiber` 对象上，然后调度 `performSyncWorkOnRoot` 重新渲染。\r\n\r\n在 react17 中，`setState` 是批量执行的，因为执行前会设置 `executionContext`。\r\n但如果在 `setTimeout`、事件监听器等函数里，就不会设置 `executionContext` 了，这时候 `setState` 会同步执行。\r\n可以在外面包一层 `batchUpdates` 函数，手动设置下 `excutionContext` 来切换成异步批量执行。\r\n\r\n在 react18 里面，如果用 `createRoot` 的 api，就不会有这种问题了。\r\n`setState` 是同步还是异步这个问题等 react18 普及以后就不会再有了，因为所有的 `setState` 都是异步批量执行了。"}]},{"number":63,"title":"【Q063】setState 批更新","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/63","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. setState 同步更新还是异步更新？\r\n### React18 以前的版本\r\nreact 事件中，`setState` 是异步更新的。\r\n但是在 `setTimeout` 、`addEventListener` 添加的原生事件中，`setState` 则是同步的。\r\n\r\n```javascript\r\n// Legacy同步模式\r\n\r\nconst container = document.getElementById('root');\r\nReactDOM.render(<App />, container);\r\n```\r\n\r\n### React18 以后\r\n`setState` 的更新统一是异步的。\r\n```javascript\r\n// Concurrent异步模式，在这个模式下，任何情况下setState都是异步更新的。目前createRoot方法还在实验中\r\n\r\nconst container = document.getElementById('root');\r\nReactDOM.createRoot(container).render(<App />)\r\n```\r\n\r\n## 2. setState 批更新\r\n在 React 18 之前，如果在回调函数的异步调用中，执行 `setState`，由于丢失上下文，无法做合并处理。\r\n所以每次 `setState` 调用都会触发一次 **重新渲染**。\r\n```javascript\r\nfunction handleClick() {\r\n\t// React 18 之前的版本\r\n\t(/*...*/).then(() => {\r\n\t\tsetCount(c => c + 1); // 立刻重新渲染\r\n\t\tsetShow(show => !show); // 立刻重新渲染\r\n\t});\r\n}\r\n```\r\n\r\nReact 18中，任何情况下都可以合并渲染！\r\n如果仍然希望setState之后立即重新渲染，只需要使用 `flushSync` 包裹。\r\n```javascript\r\nfunction handleClick() {\r\n\t// React 18\r\n\tfecth(/*...*/).then(() => {\r\n\t\tReactDOM.flushSync(() => {\r\n\t\t\tsetCount(c => c + 1); // 立刻重新渲染\r\n\t\t\tsetFlag(f => !f);\r\n\t\t})\r\n\t})\r\n}\r\n```\r\n"}]},{"number":64,"title":"【Q064】组件通信","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/64","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 父组件向子组件通信\r\n**父组件** 通过 `props` 向 **子组件** 传递需要的信息。\r\n```javascript\r\n// 子组件\r\nconst Child = props =>{\r\n  return <p>{props.name}</p>\r\n}\r\n\r\n// 父组件\r\nconst Parent = ()=>{\r\n  return <Child name=\"zhangsan\" />\r\n}\r\n```\r\n\r\n## 2. 子组件向父组件通信\r\n`props` + 回调函数。\r\n```javascript\r\n// 子组件\r\nconst Child = props =>{\r\n  const hanleCb = () =>{\r\n    props.callback('Here is zhangsan!')\r\n  }\r\n  return (\r\n    <button onClick={hanleCb}>post message</button>\r\n  )\r\n}\r\n\r\n// 父组件\r\nconst Parent = () => {\r\n  const callback = (msg) => {\r\n    console.log(msg)\r\n  }\r\n  return (\r\n    <Child callback={callback} />\r\n  )\r\n}\r\n```\r\n\r\n## 3. 跨级组件通信\r\n即 **父组件** 向 **更深层子组件** 通信。有两种解决方案：\r\n\r\n- 使用 `props` 层层传递\r\n- 使用 `context`\r\n\r\n```javascript\r\n// context方式实现跨级组件通信 \r\n// Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据\r\n\r\nconst BatteryContext = createContext();\r\n\r\n//  子组件的子组件 \r\nclass GrandChild extends Component {\r\n    render(){\r\n        return (\r\n            <BatteryContext.Consumer>\r\n                {\r\n                    color => <h1 style={{\"color\":color}}>我是红色的:{color}</h1>\r\n                }\r\n            </BatteryContext.Consumer>\r\n        ) \r\n    }\r\n}\r\n\r\n//  子组件\r\nconst Child = () =>{\r\n    return (\r\n        <GrandChild/>\r\n    )\r\n}\r\n// 父组件\r\nclass Parent extends Component {\r\n      state = {\r\n          color:\"red\"\r\n      }\r\n      render(){\r\n          const {color} = this.state\r\n          return (\r\n          <BatteryContext.Provider value={color}>\r\n              <Child />\r\n          </BatteryContext.Provider> \r\n          )\r\n      }\r\n}\r\n```\r\n\r\n## 4. 非嵌套关系的组件通信\r\n即没有任何 **包含关系** 的组件。有三种解决方案：\r\n\r\n- 可以使用自定义事件通信（发布订阅模式）\r\n- 可以通过 `redux` 等状态库进行全局状态管理\r\n- 如果是 **兄弟组件** 通信，找到共同的父节点传递 `Props`。"}]},{"number":65,"title":"【Q065】高阶组件原理","labels":["react"],"body":"有哪些常见的高阶组件？","url":"https://github.com/kangyana/daily-question/issues/65","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 高阶组件 HOC\r\n`高阶组件`是 React 中用于 **复用组件逻辑** 的一种高级技巧。\r\n`HOC` 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的 **设计模式**。\r\n\r\n### 如何实现\r\n参数为组件，返回值为新组件的函数。\r\n```javascript\r\nconst EnhancedComponent = higherOrderComponent(WrappedComponent);\r\n```\r\n\r\n## 2. 使用 HOC 解决复用\r\n假设有一个 `CommentList` 组件，它订阅外部数据源，用以渲染评论列表：\r\n```javascript\r\n// 假设 \"DataSource\" 是个全局范围内的数据源变量\r\n\r\n// 评论列表组件\r\nconst CommentList = () => {\r\n  const [comments, setComments] = useState([]);\r\n  \r\n  const handleChange = () => {\r\n    setComments(DataSource.getComments());\r\n  }\r\n  \r\n  useEffect(() => {\r\n    // 订阅\r\n    DataSource.addChangeListener(handleChange);\r\n    \r\n    // 清除订阅\r\n    return () => {\r\n      DataSource.removeChangeListener(handleChange);\r\n    }\r\n  }, [])\r\n  \r\n  return <div>\r\n    {comments.map((item) => (\r\n      <Comment comment={item} key={item.id} />\r\n    ))}\r\n  </div>\r\n}\r\n```\r\n\r\n稍后，编写了一个用于订阅单个博客帖子的组件，该帖子遵循类似的模式：\r\n```javascript\r\n// 博客组件\r\nconst BlogPost = (props) => {\r\n  const { id } = props;\r\n  const [blog, setBlog] = useState();\r\n  \r\n  const handleChange = () => {\r\n    setComments(DataSource.getBlog(id));\r\n  }\r\n  \r\n  useEffect(() => {\r\n    // 订阅\r\n    DataSource.addChangeListener(handleChange);\r\n    \r\n    // 清除订阅\r\n    return () => {\r\n      DataSource.removeChangeListener(handleChange);\r\n    }\r\n  }, []) \r\n  \r\n  return <div>{blog?.title}</div>\r\n}\r\n```\r\n\r\n`CommentList` 和 `BlogPost` 有很多相同之处：\r\n\r\n- 在挂载时，向 `DataSource` 添加一个侦听器。\r\n- 在侦听器内部，当数据源发生变化时，调用 `setState`。\r\n- 在卸载时，清除侦听器。\r\n\r\n这时可以写一个 `HOC`：\r\n```javascript\r\nconst withSubscription = (WrappedComponent, selectData) => {\r\n  return (props) => {\r\n    const [data, setData] = useState();\r\n    \r\n    const handleChange = () => {\r\n      setData(selectData(DataSource, props));\r\n    }\r\n    \r\n    useEffect(() => {\r\n      // 订阅\r\n      DataSource.addChangeListener(handleChange);\r\n      \r\n      // 清除订阅\r\n      return () => {\r\n        DataSource.removeChangeListener(handleChange);\r\n      }\r\n    }, []) \r\n    \r\n    return <WrappedComponent data={data} {...props} />\r\n  }\r\n}\r\n```\r\n\r\n`CommentList` 和 `BlogPost` 组件可以把 **订阅相关代码** 删掉了，只需要套上 `withSubscription`：\r\n```javascript\r\nconst CommentListWithSubscription = withSubscription(\r\n  CommentList,\r\n  (DataSource) => DataSource.getComments()\r\n);\r\n\r\nconst BlogPostWithSubscription = withSubscription(\r\n  BlogPost,\r\n  (DataSource, props) => DataSource.getBlogPost(props.id)\r\n);\r\n```\r\n\r\n注意，`HOC` 不会修改传入的组件，也不会使用继承来复制其行为。\r\n相反，`HOC` 通过将组件包装在容器组件中来组成新组件。`HOC` 是纯函数，没有副作用。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 3. 不要改变原始组件，而应该使用组合。\r\n不要试图在 `HOC` 中修改 **组件原型**。\r\n\r\n错误示范：\r\n```javascript\r\nconst logProps = (InputComponent) => {\r\n  InputComponent.prototype.componentDidUpdate = function(prevProps) {\r\n    console.log('Current props: ', this.props);\r\n    console.log('Previous props: ', prevProps);\r\n  };\r\n\r\n  return InputComponent;\r\n}\r\n\r\n// 每次调用 logProps 时，增强组件都会有 log 输出。\r\nconst EnhancedComponent = logProps(InputComponent);\r\n```\r\n\r\n`HOC` 不应该修改传入组件，而应该使用 **组合** 的方式，通过将组件包装在容器组件中实现功能：\r\n```javascript\r\nfunction logProps(WrappedComponent) {\r\n  return class extends React.Component {\r\n    componentDidUpdate(prevProps) {\r\n      console.log('Current props: ', this.props);\r\n      console.log('Previous props: ', prevProps);\r\n    }\r\n    render() {\r\n      return <WrappedComponent {...this.props} />;\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n`HOC` 与 **容器组件模式** 之间有相似之处。\r\n**容器组件** 担任将高级和低级关注点分离的责任，由容器管理订阅和状态，并将 `prop` 传递给处理 UI 的组件。\r\n`HOC` 使用容器作为其实现的一部分，你可以将 `HOC` 视为 **参数化容器组件**。\r\n\r\n## 4. 约定：将不相关的 props 传递给被包裹的组件\r\n这种约定保证了 `HOC` 的 **灵活性**、**可复用性**、**纯净性**。\r\n```javascript\r\nconst testHoc = (WrappedComponent) => {\r\n  return (props) => {\r\n    const { msg, ...restProps } = props;\r\n    \r\n    console.log(msg);\r\n    \r\n    return <WrappedComponent  {...restProps} />\r\n  }\r\n}\r\n```\r\n\r\n## 5. 约定：最大化可组合性\r\n`HOC` 通常可以接收多个参数，最常见的 `HOC` 如下：\r\n```javascript\r\n// React Redux 的 `connect` 函数\r\nconst ConnectedComment = connect(commentSelector, commentActions)(CommentList);\r\n```\r\n\r\n看起来很消耗心智，拆开写法\r\n```javascript\r\n// connect 是一个函数，它的返回值为另外一个函数。\r\nconst enhance = connect(commentListSelector, commentListActions);\r\n// 返回值为 HOC，它会返回已经连接 Redux store 的组件\r\nconst ConnectedComment = enhance(CommentList);\r\n```\r\n\r\n由上可得，`connect` 是一个返回高阶组件的高阶函数。\r\n像 `connect` 函数返回的单参数 `HOC` 具有签名 `Component => Component`。 \r\n输出类型与输入类型相同的函数很容易组合在一起。\r\n```javascript\r\n// 不推荐如下写法...\r\nconst EnhancedComponent = withRouter(connect(commentSelector)(WrappedComponent))\r\n\r\n// ... 建议编写组合工具函数\r\nconst enhance = compose(\r\n  withRouter,\r\n  connect(commentSelector)\r\n)\r\nconst EnhancedComponent = enhance(WrappedComponent)\r\n```\r\n\r\n其中 `connect` 和其他 `HOC` 承担 **装饰器** 的角色。\r\n\r\n许多第三方库都提供了 `compose` 工具函数，包括 `lodash`  和 `Ramda`。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 6. 约定：包装显示名称以便轻松调试\r\n`HOC` 创建的容器组件会与任何其他组件一样，会显示在 `React Developer Tools` 中。\r\n为了方便调试，请选择一个显示名称，以表明它是 `HOC` 的产物。\r\n\r\n最常见的方式是用 `HOC` 包住被包装组件的显示名称。\r\n比如高阶组件名为 `withSubscription`，并且被包装组件的显示名称为 `CommentList`，\r\n显示名称应该为 `WithSubscription(CommentList)`\r\n```javascript\r\nfunction withSubscription(WrappedComponent) {\r\n  class WithSubscription extends React.Component {/* ... */}\r\n  WithSubscription.displayName = `WithSubscription(${getDisplayName(WrappedComponent)})`;\r\n  return WithSubscription;\r\n}\r\n\r\nfunction getDisplayName(WrappedComponent) {\r\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\r\n}\r\n```\r\n\r\n## 7. 注意事项\r\n### 不要在 render 方法中使用 HOC\r\n`render` 频繁 **重新挂载组件** 会导致该组件及其所有子组件的 **状态丢失**。\r\n```javascript\r\nrender() {\r\n  // 每次调用 render 函数都会创建一个新的 EnhancedComponent\r\n  const EnhancedComponent = enhance(MyComponent);\r\n  // 这将导致子树每次渲染都会进行卸载，和重新挂载的操作！\r\n  return <EnhancedComponent />;\r\n}\r\n```\r\n\r\n### 务必复制静态方法\r\n如果原始组件上有 **静态方法**，`HOC` 创建的新组件会丢失这些静态方法。\r\n```javascript\r\nWrappedComponent.staticMethod = () =>{};\r\n\r\nconst EnhancedComponent = enhance(WrappedComponent);\r\n\r\nconsole.log(EnhancedComponent.staticMethod); // undefined\r\n```\r\n\r\n以下是三种解决方案：\r\n\r\n- 手动拷贝静态方法。\r\n```javascript\r\nfunction enhance(WrappedComponent) {\r\n  class Enhance extends React.Component {/*...*/}\r\n  Enhance.staticMethod = WrappedComponent.staticMethod;\r\n  return Enhance;\r\n}\r\n```\r\n\r\n- 使用第三方库 `hoist-non-react-statics` 自动拷贝。\r\n```javascript\r\nimport hoistNonReactStatic from 'hoist-non-react-statics';\r\n\r\nfunction enhance(WrappedComponent) {\r\n  class Enhance extends React.Component {/*...*/}\r\n  hoistNonReactStatic(Enhance, WrappedComponent);\r\n  return Enhance;\r\n}\r\n```\r\n\r\n- 额外导出静态方法。\r\n```javascript\r\nMyComponent.someFunction = someFunction;\r\nexport default MyComponent;\r\nexport { someFunction };\r\n\r\n// 在要使用的组件中，import 它们\r\nimport MyComponent, { someFunction } from './MyComponent.js';\r\n```\r\n\r\n## 8. Refs 不会被传递\r\n虽然 `HOC` 的约定是将所有 `props` 传递给被包装组件，但这对于 `refs` 并不适用。\r\n因为 `ref` 并不是 `prop`，像 `key` 一样，它是由 React 专门处理的。\r\n如果将 `ref` 添加到 `HOC` 的返回组件中，则 `ref` 引用指向容器组件，而不是被包装组件。\r\n\r\n可以使用 `React.forwardRef API` 解决。\r\n```javascript\r\nfunction logProps(Component) {\r\n  class LogProps extends React.Component {\r\n\r\n    render() {\r\n      const {forwardedRef, ...rest} = this.props;\r\n      return <Component ref={forwardedRef} {...rest} />;\r\n    }\r\n  }\r\n\r\n  return React.forwardRef((props, ref) => {\r\n    return <LogProps {...props} forwardedRef={ref} />;\r\n  });\r\n}\r\n```"}]},{"number":66,"title":"【Q066】受控组件和非受控组件","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/66","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 受控组件\r\n行为受 React **状态**(state) 控制的表单组件。\r\n```javascript\r\nconst Input = (props) => {\r\n  const { value, onChange } = props;\r\n\r\n  return <input value={value} onChange={e => onChange(e.target.value)} />\r\n}\r\n```\r\n\r\n## 2. 非受控组件\r\n行为不受 React **状态** 控制的表单组件，行为完全由用户操作影响。\r\n```javacscript\r\nconst Input = () => {\r\n  const [value, setValue] = useState('');\r\n  \r\n  return <input value={value} onChange={e => setValue(e.target.value)} />\r\n}\r\n```\r\n\r\n## 3. 受控组件 和 非受控组件 的区别\r\n控制组件行为的 **状态** 是否由外部传入。\r\n\r\n![alt](https://pic4.zhimg.com/80/v2-7285ea005390e41d3245b960af384d73_720w.jpg)\r\n图中蓝色表示 **组件**，黄色表示 **状态**。\r\n\r\n## 4. 受控又非受控组件\r\n现代组件库，有非常多的组件需要做到既支持受控模式，又支持非受控模式。\r\n例如 `antd` 涉及 **输入值、切换、展开收起** 的组件，都需要做到。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 5. 如何实现 受控又非受控组件\r\n### 解决方案：内外两个状态，手动同步\r\n无论哪种模式都使用 **子组件状态** 。\r\n当 **受控模式** 时，将 **父组件状态** 同步给 **子组件状态**。\r\n![alt](https://pic1.zhimg.com/v2-1334f4d825c82890005508729e6ff6cc_r.jpg)\r\n\r\n```javascript\r\nconst Input = (props) => {\r\n  const { value: _value, onChange } = props;\r\n  const [value, setValue] = useState(_value);\r\n  \r\n  const isControlled =_value !== undefined; // 是否受控\r\n  \r\n  const handleChange = (e) => {\r\n    // 不受控才改变内部状态\r\n    if (!isControlled) setValue(e.target.value);\r\n    onChange(e.target.value);\r\n  }\r\n  \r\n  useEffect(() => {\r\n    // 外部值变化，手动同步内部状态\r\n    if (isControlled) setValue(_value);\r\n  }, [isControlled])\r\n  \r\n  return <input value={value} onChange={handleChange} />\r\n}\r\n```\r\n\r\n仔细看上面的代码，我们会发现在 **受控模式** 下存在两个问题：\r\n\r\n- 原子性：**子组件状态** 更新比 **父组件状态** 更新晚一个渲染周期。产生撕裂感（tearing）。\r\n- 性能：在 `useEffect` 使用 `setState`，会额外触发一次渲染。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 6. 解决原子性\r\n我们不需要 **子组件状态** 和 **父组件状态** 时刻统一。\r\n只需要判断，**受控模式** 下直接使用 **父组件状态** 就好了。\r\n\r\n![alt](https://pic2.zhimg.com/80/v2-c2148d954e3f4a85150928cc4a076bbd_720w.webp)\r\n\r\n这样即使状态的同步存在延迟，子组件使用的值也是最新的。\r\n```javascript\r\nconst Input = (props) => {\r\n  // ...同上面的\r\n  const finalValue = isControlled ? _value : value; // 真正使用的值\r\n  \r\n  return <input value={finalValue} onChange={handleChange} />\r\n}\r\n```\r\n\r\n## 7. 解决性能\r\n在 `useEffect` 使用 `setState`，会额外触发一次 **子组件** 的渲染。\r\n\r\n### 此处 `state` 的作用是什么？\r\n\r\n- 持久化存放数据\r\n- 更新会触发重渲染\r\n\r\n### 是否能绕过 `state` 机制?\r\n可以使用 `ref` + `forceUpdate` 的组合。\r\n\r\n![alt](https://pic2.zhimg.com/80/v2-fea0d9c628e4c7fc70fc5b4eb6249e39_720w.webp)\r\n图中的虚线浅色圆圈表示 `ref`，刷新图标表示 `forceUpdate` 函数。\r\n\r\n```javascript\r\nconst Input = (props) => {\r\n  const { value: _value, onChange } = props;\r\n  \r\n  const [flag, forceUpdate] = useReducer(v => v + 1, 0); // 触发渲染用的\r\n  \r\n  const isControlled =_value !== undefined; // 是否受控\r\n  \r\n  const stateRef = useRef(_value);\r\n  // 受控模式下，将外部的值同步给 Ref\r\n  if (isControlled) {\r\n    stateRef.current = _value;\r\n  }\r\n  \r\n  const handleChange = (e) => {\r\n    // 手动同步 Ref\r\n    stateRef.current = e.target.value;\r\n    // 手动触发渲染\r\n    forceUpdate();\r\n    onChange(e.target.value);\r\n  }\r\n  \r\n  return <input value={stateRef.current} onChange={handleChange} />\r\n}\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 7. 抽象与复用\r\n我们可以把 `受控又非受控组件` 的效果封装为 `Hook`，供其他表单组件使用。\r\n\r\n```javascript\r\nconst usePropsValue = (props) => {\r\n  const { value, onChange, defaultValue } = props;\r\n    \r\n  const [flag, forceUpdate] = useReducer(v => v + 1, 0); // 触发渲染用的\r\n  \r\n  const isControlled = useMemo(() => value !== undefined, [value]); // 是否受控\r\n  \r\n  const stateRef = useRef(isControlled ? value : defaultValue);\r\n  // 受控模式下，将外部的值同步给 Ref\r\n  if (isControlled) {\r\n    stateRef.current = value;\r\n  }\r\n\r\n  const setState = (nextValue) => {\r\n    if (nextValue === stateRef.current) return;\r\n    // 手动同步 Ref\r\n    stateRef.current = nextValue;\r\n    // 手动触发渲染\r\n    forceUpdate();\r\n    onChange?.(nextValue);\r\n  }\r\n  \r\n  return [stateRef.current, setState];\r\n}\r\n```"}]},{"number":67,"title":"【Q067】为什么要是用 React Hooks?","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/67","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 为什么使用 Hook？\r\n`Hook` 是 React16.8 的新增特性。\r\n`Hook` 可以让你不必写 `class` 组件也能使用 `state` 等 React 特性。\r\n\r\n`Hook` 解决了许多 **组件问题**：\r\n\r\n## 2. 在组件之间复用状态逻辑很难\r\nReact 没有提供将复用逻辑加到组件里的方案。\r\n`class` 组件的复用方案是 `render props` 和 `HOC`，这些方案需要你重写组件结构。\r\n在 `React DevTools` 中，由 `providers`，`consumers`，`HOC`，`render props` 等其他抽象层组成的组件会形成 **嵌套地狱**，非常不利于观摩。\r\n\r\n自定义 `Hook` 可以提取复用状态逻辑，使你无需修改组件结构即可使用复用。\r\n\r\n## 3. 复杂组件变得难以理解\r\n状态逻辑和副作用充斥，每个 `生命周期` 常常包含一些不相关的逻辑。\r\n例如，组件常常在 `componentDidMount` 和 `componentDidUpdate` 中获取数据。\r\n但是，在 `componentDidMount` 中可能需要处理其他逻辑，例如事件监听并在 `componentWillUnmount ` 中取消。\r\n完全不相关的代码放在同一个生命周期里，后续维护不那么明了。\r\n\r\n`Hook` 组件可以使用 `Effect` 将关联代码拆成更小的函数，并非是死板的 `生命周期`。\r\n\r\n## 4. 难以理解的 class\r\n你必须去理解 `this` 的工作方式，才能很好的使用 `class`。\r\n\r\n`Hook` 这种函数式组件，以很低的使用成本就可以写出好组件。"}]},{"number":68,"title":"【Q068】React Hooks 实现原理","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/68","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. useState / useReducer\r\n`useState` 和 `useReducer` 都是关于 **状态** 的获取和更新。\r\n`useState` 是 `useReducer` 的一个简化版，其背后用的都是同一套逻辑。\r\n\r\n### Hook 如何保存状态\r\n`Hook` 保存状态的位置其实与 `class` 的一致：\r\n\r\n- 两者的 **状态** 都被挂载在组件实例对象 `FiberNode` 的 `memoizedState` 属性中。\r\n- 两者保存 **状态** 的数据结构完全不同；\r\n`class` 直接把 `state` 对象保存在 `memoizedState` 中；\r\n`Hook` 用链表保存 **状态**，`memoizedState` 中保存的是链表的头指针。\r\n\r\n让我们看下链表的结构：\r\n```typescript\r\n// react-reconciler/src/ReactFiberHooks.js\r\n\r\nexport type Hook = {\r\n  memoizedState: any, // 最新的状态值\r\n  baseState: any, // 初始状态值\r\n  baseUpdate: Update<any, any> | null,\r\n  queue: UpdateQueue<any, any> | null, // 临时保存对状态值的操作，更准确来说是一个链表数据结构中的一个指针\r\n  next: Hook | null,  // 指向下一个链表节点\r\n};\r\n```\r\n\r\n官方文档一直强调 `Hook` 的调用只能放在 **函数组件/自定义Hook** 的顶部，\r\n因为只能通过 `Hook` 调用的顺序来与实际保存的数据结构来关联：\r\n\r\n![alt](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/1/17307e7bb3014026~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)\r\n\r\n### Hook 如何更新\r\n`useState` 和 `useReducer` 都返回了更新函数（dispatcher），`dispatcher` 的运行原理是怎样的呢？\r\n每次调用 `dispatcher`，不会立即更新 **状态**，而是创建一条修改操作。\r\n在对应 `Hook` 对象的 `queue` 属性挂载的链表上加一个新节点：\r\n\r\n![alt](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/1/17307e7f74c14584~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)\r\n\r\n在下次执行函数组件时，走到 `useState` 这步，链表才会计算最新的 **状态**。\r\n\r\n### 为什么把更新操作都保存到链表，保存最后一条更新操作不行吗？\r\n因为 `dispatcher` 还支持 **函数式更新**。 \r\n```javascript\r\nconst [name, setName] = useState('');\r\n\r\nsetName(name => name + 'a');\r\nsetName(name => name + 'b');\r\nsetName(name => name + 'c');\r\n\r\n// 下次渲染时\r\nconsole.log(name); // 'abc'\r\n```\r\n"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. useEffect\r\n`useEffect` 的保存也是以 **链表** 的形式挂载在 `FiberNode.updateQueue` 中。\r\n下面我们按组件 `生命周期` 中的  `mount` 和 `update` 来阐述 `useEffect` 的执行原理：\r\n \r\n### mount 阶段：mountEffect\r\n① 根据函数组件中依次调用的 `useEffect`，构建成一个链表并挂载在 `FiberNode.updateQueue` 中。\r\n链表节点的数据结构为：\r\n```typescript\r\n const effect: Effect = {\r\n    tag, // 用来标识依赖项有没有变动\r\n    create, // 用户使用useEffect传入的函数体\r\n    destroy, // 上述函数体执行后生成的用来清除副作用的函数\r\n    deps, // 依赖项列表\r\n    next: (null: any),\r\n};\r\n```\r\n\r\n② 组件完成渲染后，遍历链表执行。\r\n\r\n### update 阶段：updateEffect\r\n同样在依次调用 `useEffect` 时，判断此时传入的依赖列表，与链表节点 `Effect.deps` 中保存的做一次浅比较。\r\n如果一致，则在 `Effect.tag` 标记上 `NoHookEffect`。\r\n\r\n### 执行阶段\r\n在每次组件渲染完成后，就会进入 `useEffect` 的执行阶段：`commitHookEffectList()`。\r\n\r\n- 遍历链表\r\n- 如果遇到标签（tag）为 `NoHookEffect` 的节点则跳过\r\n- 如果有清除函数（destroy），先执行清除\r\n- 执行传入的函数（create）\r\n\r\n注意：先清除上一轮的副作用，然后再执行本轮的传入函数。\r\n\r\n## 3. 其它官方 Hook\r\n其它官方 `Hook` 也是相似原理：\r\n- 用链表数据结构来做全局状态保持\r\n- 判断依赖项决定是否要更新状态"}]},{"number":69,"title":"【Q069】React Hooks 使用原则，以及为什么","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/69","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. Hook 规则\r\n`Hook` 本质就是 **函数**，但是在使用它时需要遵循两条规则。\r\n官方提供了一个 [linter 插件](https://www.npmjs.com/package/eslint-plugin-react-hooks)来强制执行这些规则：\r\n\r\n## 2. 只在最顶层使用 Hook\r\n### 不要在循环，条件或嵌套函数中调用 `Hook`。\r\n确保总是在你的 React 函数的最顶层以及任何 `return` 之前调用他们。\r\n这样可以确保每次组件渲染 `Hook` 的调用顺序。\r\n\r\n### 原理分析：\r\nReact 怎么知道哪个 `state` 对应哪个 `useState`？靠链表上 `Hook` 调用的顺序。\r\n```javascript\r\n// 首次渲染\r\nuseState('Mary')           // 1. 使用 'Mary' 初始化变量名为 name 的 state\r\nuseEffect(persistForm)     // 2. 添加 effect 以保存 form 操作\r\nuseState('Poppins')        // 3. 使用 'Poppins' 初始化变量名为 surname 的 state\r\nuseEffect(updateTitle)     // 4. 添加 effect 以更新标题\r\n\r\n// 二次渲染\r\nuseState('Mary')           // 1. 读取变量名为 name 的 state（参数被忽略）\r\nuseEffect(persistForm)     // 2. 替换保存 form 的 effect\r\nuseState('Poppins')        // 3. 读取变量名为 surname 的 state（参数被忽略）\r\nuseEffect(updateTitle)     // 4. 替换更新标题的 effect\r\n```\r\n\r\n如果我们将一个 `Hook` 调用放到一个条件语句中会发生什么呢？\r\n```javascript\r\nif (name !== '') {\r\n  useEffect(function persistForm() {\r\n    localStorage.setItem('formData', name);\r\n  });\r\n}\r\n```\r\n\r\n组件渲染时，当条件判断为 true 时，会跳过这个 `Hook`。这可能会导致意料之外的 bug 产生。\r\n```javascript\r\nuseState('Mary')           // 1. 读取变量名为 name 的 state（参数被忽略）\r\n// useEffect(persistForm)  // 🔴 此 Hook 被忽略！\r\nuseState('Poppins')        // 🔴 2. 读取变量名为 surname 的 state 失败\r\nuseEffect(updateTitle)     // 🔴 3. 替换更新标题的 effect 失败\r\n```\r\n\r\n### 这就是为什么 Hook 需要在我们组件的最顶层调用。\r\n如果我们想要有条件地执行一个 `effect`，可以将判断放到 `Hook` 的内部：\r\n```javascript\r\nuseEffect(function persistForm() {\r\n  // 👍 将条件判断放置在 effect 中\r\n  if (name !== '') {\r\n    localStorage.setItem('formData', name);\r\n  }\r\n});\r\n```\r\n\r\n## 3. 只在 React 函数中调用 Hook\r\n\r\n调用环境 | 是否允许\r\n-- | --\r\nReact 函数组件 | ✅\r\n自定义 Hook | ✅\r\n普通 JS 函数 | ❌\r\n函数外 | ❌\r\n\r\n## 4. ESLint 插件\r\n使用 [eslint-plugin-react-hooks](https://www.npmjs.com/package/eslint-plugin-react-hooks) 可以有效的约束 `Hook` 错误的使用。\r\n```bash\r\nnpm install eslint-plugin-react-hooks --save-dev\r\n```\r\n\r\n```javascript\r\n// .eslintrc\r\n\r\n{\r\n  \"plugins\": [\r\n    \"react-hooks\"\r\n  ],\r\n  \"rules\": {\r\n    \"react-hooks/rules-of-hooks\": \"error\", // 检查 Hook 的规则\r\n    \"react-hooks/exhaustive-deps\": \"warn\" // 检查 effect 的依赖\r\n  }\r\n}\r\n```"}]},{"number":70,"title":"【Q070】React Hooks 使用中常见问题","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/70","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. useState 问题\r\n\r\n### 不要使用旧的状态\r\n先来看一个计数器的例子：\r\n```javascript\r\nconst Increaser = () => {\r\n  const [count, setCount] = useState(0);\r\n  \r\n  return (\r\n    <div>\r\n      <button onClick={() => setCount(count + 1)}>+</button>\r\n      <div>Counter: {count}</div>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n连续快速点击 **加号按钮**，很可能 `count` 没有达到预期的值。\r\n这是因为 `setState` 是异步的，状态在下一次渲染时才更新。\r\n此时的 `count` 就是旧值。正确用法是 **函数式更新**：\r\n\r\n```javascript\r\n<button onClick={() => setCount(_count => _count+ 1)}>+</button>\r\n```\r\n\r\n### 不要在不需要重新渲染时使用 useState\r\n看下面的例子：\r\n```javascript\r\nconst Counter = () => {\r\n  const [counter, setCounter] = useState(0);\r\n\r\n  return (\r\n    <div>\r\n      <button onClick={() =>  setCounter(_count => _count + 1)}>Counter</button>\r\n      <button onClick={() => console.log(counter)}>Counter Log</button>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n因为 `counter` 没有用在渲染，所以点击第一个按钮不会触发渲染，`setState` 也在等待更新。\r\n此时再点击第二个按钮，打印的 `counter` 为旧值。这与期待不符。\r\n\r\n解决方案是，用 `useRef` 替代 `useState`。\r\n```javascript\r\nconst counter = useRef(0);\r\n\r\n<button onClick={() =>  counter.current++}>Counter</button>\r\n<button onClick={() => console.log(counter.current)}>Counter Log</button>\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. useEffect 问题\r\n\r\n### 不要忘记清理副作用\r\n来看一个计数器的例子：\r\n```javascript\r\nconst DelayedIncreaser = () => {\r\n  const [count, setCount] = useState(0);\r\n  const [increase, setShouldIncrease] = useState(false);\r\n  \r\n  useEffect(() => {\r\n    if (increase) {\r\n      setInterval(() => {\r\n        setCount(count => count + 1)\r\n      }, 1000);\r\n    }\r\n  }, [increase]);\r\n  \r\n  return (\r\n    <div>\r\n      <button onClick={() => setShouldIncrease(true)}>+</button>\r\n      <div>Count: {count}</div>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n在点击按钮时，`count` 每秒会增加1。\r\n但是当卸载组件的时，就会报错。\r\n\r\n正确的用法是卸载前清理定时器：\r\n```javascript\r\nuseEffect(() => {\r\n    if (increase) {\r\n      const id = setInterval(() => {\r\n        setCount(count => count + 1)\r\n      }, 1000);\r\n      return () => clearInterval(id);\r\n    }\r\n}, [increase]);\r\n```\r\n\r\n### 不要使用 ref 作为 useEffect 的依赖\r\n```javascript\r\nconst count = useRef(0);\r\n\r\nuseEffect(() => {\r\n  console.log(count.current)\r\n}, [count.current])\r\n```\r\n\r\n`ref` 的更新不会引起组件的渲染，所以不会调用 `useEffect` 函数。\r\n\r\n## 3. Map数据\r\n不建议用 `useState` 保存 `Map`，也不建议用 `useEffect` 监听 `Map`。"}]},{"number":71,"title":"【Q071】官方自带的 Hooks","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/71","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. useState\r\n```javascript\r\nconst [state, setState] = useState(initialState);\r\n```\r\n返回一个 `state`，以及更新函数 `setState`。\r\n\r\n在初始渲染期间，返回的`state` 与传入的 `initialState` 值相同。\r\n\r\n`setState` 函数用于更新 `state`。它接收一个新的 `state` 值并将组件的一次重新渲染加入队列。\r\n```javascript\r\nsetState(newState);\r\n```\r\n在后续的重新渲染中，`useState` 返回的第一个值将始终是更新后最新的 `state`。\r\n\r\n#### 注意\r\nReact 会确保 `setState` 函数的标识是稳定的，并且不会在组件重新渲染时发生变化。\r\n这就是为什么可以安全地从 `useEffect` 或 `useCallback` 的依赖列表中省略 `setState`。\r\n\r\n### 函数式更新\r\n如果新的 `state` 需要通过使用先前的 `state` 计算得出，那么可以将函数传递给 `setState`。\r\n该函数将接收先前的 `state`，并返回一个更新后的值。\r\n下面的计数器组件示例展示了 `setState` 的两种用法：\r\n```javascript\r\nfunction Counter({initialCount}) {\r\n  const [count, setCount] = useState(initialCount);\r\n  return (\r\n    <>\r\n      Count: {count}\r\n      <button onClick={() => setCount(initialCount)}>Reset</button>\r\n      <button onClick={() => setCount(prevCount => prevCount - 1)}>-</button>\r\n      <button onClick={() => setCount(prevCount => prevCount + 1)}>+</button>\r\n    </>\r\n  );\r\n}\r\n```\r\n\r\n“+” 和 “-” 按钮采用函数式形式，因为被更新的 `state` 需要基于之前的 `state`。\r\n但是“重置”按钮则采用普通形式，因为它总是把 `count` 设置回初始值。\r\n\r\n如果你的更新函数返回值与当前 `state` 完全相同，则随后的重渲染会被完全跳过。\r\n\r\n#### 注意：\r\n与 `class` 组件中的 `setState` 方法不同，`useState` 不会自动合并更新对象。\r\n你可以用函数式的 `setState` 结合展开运算符来达到合并更新对象的效果。\r\n```javascript\r\nconst [state, setState] = useState({});\r\nsetState(prevState => {\r\n  // 也可以使用 Object.assign\r\n  return {...prevState, ...updatedValues};\r\n});\r\n```\r\n`useReducer` 是另一种可选方案，它更适合用于管理包含多个子值的 `state` 对象。\r\n\r\n### 惰性初始 state\r\n`initialState` 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。\r\n如果初始 `state` 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 `state`，此函数只在初始渲染时被调用：\r\n```javascript\r\nconst [state, setState] = useState(() => {\r\n  const initialState = someExpensiveComputation(props);\r\n  return initialState;\r\n});\r\n```\r\n\r\n### 跳过 state 更新\r\n如果你更新 `State Hook` 后的 `state` 与当前的 `state` 相同时，React 将跳过子组件的渲染并且不会触发 `effect` 的执行。\r\nReact 使用 **Object.is 比较算法** 来比较 `state`。\r\n\r\n需要注意的是，React 可能仍需要在跳过渲染前渲染该组件。\r\n不过由于 React 不会对组件树的“深层”节点进行不必要的渲染，所以大可不必担心。\r\n如果你在渲染期间执行了高开销的计算，则可以使用 `useMemo` 来进行优化。\r\n\r\n### state 的批更新\r\nReact 可能会将几个 `state` 更新分组到一个重新渲染中，以提高性能。\r\n通常情况下，这可以提高性能，且不影响你的应用程序的行为。\r\n\r\n在 React 18 之前，只有 React 事件处理程序内是批更新。\r\n从 React 18 开始，所有的更新都默认启用批处理。\r\n\r\n在较少的情况下，你需要强制渲染组件，你可以用 `flushSync`包裹 `setState`。\r\n然而，这可能会损害性能，所以只在需要时才这样做。\r\n```javascript\r\nimport { flushSync } from 'react-dom';\r\n\r\nflushSync(() => {\r\n  setCount(c => c + 1);\r\n  setFlag(f => !f);\r\n});\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. useEffect\r\n```javascript\r\nuseEffect(didUpdate);\r\n```\r\n该 `Hook` 接收一个包含命令式、且可能有副作用代码的函数。\r\n\r\n在函数组件主体内改变 DOM、添加订阅、设置定时器、记录日志以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性。\r\n\r\n使用 `useEffect` 完成副作用操作。\r\n赋值给 `useEffect` 的函数会在组件渲染到屏幕之后执行。\r\n你可以把 `effect` 看作从 React 的纯函数式世界通往命令式世界的逃生通道。\r\n\r\n默认情况下，`effect` 将在每轮渲染结束后执行，但你可以选择让它 **在只有某些值改变的时候** 才执行。\r\n\r\n### 清除 effect\r\n通常，组件卸载时需要清除 `effect` 创建的诸如订阅或计时器 ID 等资源。\r\n要实现这一点，`useEffect` 函数需返回一个清除函数。以下就是一个创建订阅的例子：\r\n```javascript\r\nuseEffect(() => {\r\n  const subscription = props.source.subscribe();\r\n  return () => {\r\n    // 清除订阅\r\n    subscription.unsubscribe();\r\n  };\r\n});\r\n```\r\n\r\n为防止内存泄漏，清除函数会在组件卸载前执行。\r\n另外，如果组件多次渲染，则 **在执行下一个 effect 之前，上一个 effect 就已被清除**。\r\n在上述示例中，意味着组件的每一次更新都会创建新的订阅。\r\n若想避免每次更新都触发 `effect` 的执行，请参阅下一小节。\r\n\r\n### effect 的执行时机\r\n与 `componentDidMount`、`componentDidUpdate` 不同的是，\r\n传给 `useEffect` 的函数会在浏览器完成布局与绘制之后，在一个延迟事件中被调用。\r\n这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因为绝大多数操作不应阻塞浏览器对屏幕的更新。\r\n\r\n然而，并非所有 `effect` 都可以被延迟执行。\r\n例如，一个对用户可见的 `DOM` 变更就必须在浏览器执行下一次绘制前被同步执行，这样用户才不会感觉到视觉上的不一致。\r\nReact 为此提供了一个额外的 `useLayoutEffect` 来处理这类 `effect`。\r\n它和 `useEffect` 的结构相同，区别只是调用时机不同。\r\n\r\n此外，从 React 18 开始，当它是离散的用户输入（如点击）的结果时，\r\n或者当它是由 `flushSync` 包装的更新结果时，传递给 `useEffect` 的函数将在屏幕布局和绘制之前同步执行。\r\n这种行为便于事件系统或 `flushSync` 的调用者观察该效果的结果。\r\n\r\n#### 注意\r\n这只影响传递给 `useEffect` 的函数被调用时 — 在这些 `effect` 中执行的更新仍会被推迟。\r\n这与 `useLayoutEffect` 不同，后者会立即启动该函数并处理其中的更新。\r\n\r\n即使在 `useEffect` 被推迟到浏览器绘制之后的情况下，它也能保证在任何新的渲染前启动。\r\nReact 在开始新的更新前，总会先刷新之前的渲染的 `effect`。\r\n\r\n### effect 的条件执行\r\n默认情况下，`effect` 会在每轮组件渲染完成后执行。\r\n这样的话，一旦 `effect` 的依赖发生变化，它就会被重新创建。\r\n\r\n然而，在某些场景下这么做可能会矫枉过正。\r\n比如，在上一章节的订阅示例中，我们不需要在每次组件更新时都创建新的订阅，而是仅需要在 `source prop` 改变时重新创建。\r\n\r\n要实现这一点，可以给 `useEffect` 传递第二个参数，它是 `effect` 所依赖的值数组。更新后的示例如下：\r\n```javascript\r\nuseEffect(\r\n  () => {\r\n    const subscription = props.source.subscribe();\r\n    return () => {\r\n      subscription.unsubscribe();\r\n    };\r\n  },\r\n  [props.source],\r\n);\r\n```\r\n此时，只有当 `props.source` 改变后才会重新创建订阅。\r\n\r\n#### 注意\r\n如果你要使用此优化方式，请确保数组中包含了所有 **外部作用域中会发生变化且在 `effect` 中使用的变量**，\r\n否则你的代码会引用到先前渲染中的旧变量。\r\n\r\n如果想执行只运行一次的 `effect`（仅在组件挂载和卸载时执行），可以传递一个空数组 `[]` 作为第二个参数。\r\n这就告诉 React 你的 `effect` 不依赖于 `props` 或 `state` 中的任何值，所以它永远都不需要重复执行。\r\n这并不属于特殊情况 —— 它依然遵循输入数组的工作方式。\r\n\r\n如果你传入了一个空数组 `[]`，`effect` 内部的 `props` 和 `state` 就会一直持有其初始值。\r\n尽管传入 `[]` 作为第二个参数有点类似于 `componentDidMount` 和 `componentWillUnmount` 的思维模式，\r\n但我们有 **更好的方式** 来避免过于频繁的重复调用 `effect`。\r\n除此之外，请记得 React 会 **等待浏览器完成画面渲染之后才会延迟调用** `useEffect`，因此会使得处理额外操作很方便。\r\n\r\n依赖项数组不会作为参数传给 `effect` 函数。\r\n虽然从概念上来说它表现为：所有 `effect` 函数中引用的值都应该出现在依赖项数组中。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 3. useContext\r\n```javascript\r\nconst value = useContext(MyContext);\r\n```\r\n\r\n接收一个 `context` 对象（`React.createContext` 的返回值）并返回该 `context` 的当前值。\r\n当前的 `context` 值由上层组件中距离当前组件最近的 `<MyContext.Provider>` 的 `value prop` 决定。\r\n\r\n当组件上层最近的 `<MyContext.Provider>` 更新时，该 `Hook` 会触发重渲染，\r\n并使用最新传递给 `MyContext provider` 的 `context value` 值。\r\n即使祖先使用 `React.memo` 或 `shouldComponentUpdate`，也会在组件本身使用 `useContext` 时重新渲染。\r\n\r\n别忘记 `useContext` 的参数必须是 `context` 对象本身：\r\n\r\n- ✔ useContext(MyContext)\r\n- ❌ useContext(MyContext.Consumer)\r\n- ❌ useContext(MyContext.Provider)\r\n\r\n调用了 `useContext` 的组件总会在 `context` 值变化时重新渲染。\r\n如果重渲染组件的开销较大，你可以通过使用 `memoization` 来优化。\r\n\r\n#### 提示\r\n如果你在接触 `Hook` 前已经对 `context API` 比较熟悉，那应该可以理解，\r\n`useContext(MyContext) 相当于 `class` 组件中的 `static contextType = MyContext` 或者 `<MyContext.Consumer>`。\r\n\r\n`useContext(MyContext)` 只是让你能够读取 `context` 的值以及订阅 `context` 的变化。\r\n你仍然需要在上层组件树中使用 `<MyContext.Provider>` 来为下层组件提供 `context`。\r\n\r\n### 和 Context.Provider 一起使用\r\n```javascript\r\nconst themes = {\r\n  light: {\r\n    foreground: \"#000000\",\r\n    background: \"#eeeeee\"\r\n  },\r\n  dark: {\r\n    foreground: \"#ffffff\",\r\n    background: \"#222222\"\r\n  }\r\n};\r\n\r\nconst ThemeContext = React.createContext(themes.light);\r\n\r\nfunction App() {\r\n  return (\r\n    <ThemeContext.Provider value={themes.dark}>\r\n      <Toolbar />\r\n    </ThemeContext.Provider>\r\n  );\r\n}\r\n\r\nfunction Toolbar(props) {\r\n  return (\r\n    <div>\r\n      <ThemedButton />\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction ThemedButton() {\r\n  const theme = useContext(ThemeContext);\r\n  return (\r\n    <button style={{ background: theme.background, color: theme.foreground }}>\r\n      I am styled by theme context!\r\n    </button>\r\n  );\r\n}\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 4. useReducer\r\n```javascript\r\nconst [state, dispatch] = useReducer(reducer, initialArg, init);\r\n```\r\n\r\n`useState` 的替代方案。它接收一个形如 `(state, action) => newState` 的 `reducer`，\r\n并返回当前的 `state` 以及与其配套的 `dispatch` 方法。\r\n\r\n在某些场景下，`useReducer` 会比 `useState` 更适用，例如 `state` 逻辑较复杂且包含多个子值，\r\n或者下一个 state 依赖于之前的 state 等。\r\n并且，使用 `useReducer` 还能给那些会触发深更新的组件做性能优化，因为 **你可以向子组件传递 dispatch 而不是回调函数**。\r\n\r\n以下是用 `reducer` 重写 `useState` 一节的计数器示例：\r\n```javascript\r\nconst initialState = {count: 0};\r\n\r\nfunction reducer(state, action) {\r\n  switch (action.type) {\r\n    case 'increment':\r\n      return {count: state.count + 1};\r\n    case 'decrement':\r\n      return {count: state.count - 1};\r\n    default:\r\n      throw new Error();\r\n  }\r\n}\r\n\r\nfunction Counter() {\r\n  const [state, dispatch] = useReducer(reducer, initialState);\r\n  return (\r\n    <>\r\n      Count: {state.count}\r\n      <button onClick={() => dispatch({type: 'decrement'})}>-</button>\r\n      <button onClick={() => dispatch({type: 'increment'})}>+</button>\r\n    </>\r\n  );\r\n}\r\n```\r\n\r\n#### 注意\r\nReact 会确保 `dispatch` 函数的标识是稳定的，并且不会在组件重新渲染时改变。\r\n这就是为什么可以安全地从 `useEffect` 或 `useCallback` 的依赖列表中省略 `dispatch`。\r\n\r\n### 指定初始 state\r\n有两种不同初始化 `state` 的方式，你可以根据使用场景选择其中的一种。\r\n将初始 `state` 作为第二个参数传入 `useReducer` 是最简单的方法：\r\n```javascript\r\n  const [state, dispatch] = useReducer(\r\n    reducer,\r\n    {count: initialCount}\r\n  );\r\n```\r\n\r\n#### 注意\r\nReact 不使用 `state = initialState` 这一由 `Redux` 推广开来的参数约定。\r\n有时候初始值依赖于 `props`，因此需要在调用 `Hook` 时指定。\r\n如果你特别喜欢上述的参数约定，可以通过调用 `useReducer(reducer, undefined, reducer)` 来模拟 `Redux` 的行为，\r\n但我们不鼓励你这么做。\r\n\r\n### 惰性初始化\r\n你可以选择惰性地创建初始 `state`。\r\n为此，需要将 `init` 函数作为 `useReducer` 的第三个参数传入，这样初始 `state` 将被设置为 `init(initialArg)`。\r\n\r\n这么做可以将用于计算 `state` 的逻辑提取到 `reducer` 外部，这也为将来对重置 `state` 的 `action` 做处理提供了便利：\r\n```javascript\r\nfunction init(initialCount) {\r\n  return {count: initialCount};\r\n}\r\n\r\nfunction reducer(state, action) {\r\n  switch (action.type) {\r\n    case 'increment':\r\n      return {count: state.count + 1};\r\n    case 'decrement':\r\n      return {count: state.count - 1};\r\n    case 'reset':\r\n      return init(action.payload);\r\n    default:\r\n      throw new Error();\r\n  }\r\n}\r\n\r\nfunction Counter({initialCount}) {\r\n  const [state, dispatch] = useReducer(reducer, initialCount, init);\r\n  return (\r\n    <>\r\n      Count: {state.count}\r\n      <button\r\n        onClick={() => dispatch({type: 'reset', payload: initialCount})}>\r\n        Reset\r\n      </button>\r\n      <button onClick={() => dispatch({type: 'decrement'})}>-</button>\r\n      <button onClick={() => dispatch({type: 'increment'})}>+</button>\r\n    </>\r\n  );\r\n}\r\n```\r\n\r\n### 跳过 dispatch\r\n如果 `Reducer` 的返回值与当前 `state` 相同，React 将跳过子组件的渲染及副作用的执行。\r\nReact 使用 **Object.is 比较算法** 来比较 state。\r\n\r\n需要注意的是，React 可能仍需要在跳过渲染前再次渲染该组件。\r\n不过由于 React 不会对组件树的“深层”节点进行不必要的渲染，所以大可不必担心。\r\n如果你在渲染期间执行了高开销的计算，则可以使用 `useMemo` 来进行优化。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 5. useCallback\r\n```javascript\r\nconst memoizedCallback = useCallback(\r\n  () => {\r\n    doSomething(a, b);\r\n  },\r\n  [a, b],\r\n);\r\n```\r\n\r\n返回一个 `memoized` 回调函数。\r\n\r\n把内联回调函数及依赖项数组作为参数传入 `useCallback`，\r\n它将返回该回调函数的 `memoized` 版本，该回调函数仅在某个依赖项改变时才会更新。\r\n当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 `shouldComponentUpdate`）的子组件时，它将非常有用。\r\n\r\n`useCallback(fn, deps)` 相当于 `useMemo(() => fn, deps)`。\r\n\r\n#### 注意\r\n依赖项数组不会作为参数传给回调函数。\r\n虽然从概念上来说它表现为：所有回调函数中引用的值都应该出现在依赖项数组中。\r\n\r\n### 6. useMemo\r\n```javascript\r\nconst memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\r\n```\r\n返回一个 `memoized` 值。\r\n\r\n把“创建”函数和依赖项数组作为参数传入 `useMemo`，它仅会在某个依赖项改变时才重新计算 `memoized` 值。\r\n这种优化有助于避免在每次渲染时都进行高开销的计算。\r\n\r\n记住，传入 `useMemo` 的函数会在渲染期间执行。\r\n请不要在这个函数内部执行不应该在渲染期间内执行的操作，\r\n诸如副作用这类的操作属于 `useEffect` 的适用范畴，而不是 `useMemo`。\r\n\r\n如果没有提供依赖项数组，`useMemo` 在每次渲染时都会计算新的值。\r\n\r\n### 你可以把 useMemo 作为性能优化的手段，但不要把它当成语义上的保证。\r\n将来，React 可能会选择“遗忘”以前的一些 `memoized` 值，并在下次渲染时重新计算它们，比如为离屏组件释放内存。\r\n先编写在没有 `useMemo` 的情况下也可以执行的代码 —— 之后再在你的代码中添加 `useMemo`，以达到优化性能的目的。\r\n\r\n#### 注意\r\n依赖项数组不会作为参数传给“创建”函数。\r\n虽然从概念上来说它表现为：所有“创建”函数中引用的值都应该出现在依赖项数组中。\r\n\r\n## 7. useRef\r\n```javascript\r\nconst refContainer = useRef(initialValue);\r\n```\r\n`useRef` 返回一个可变的 `ref` 对象，其 `.current` 属性被初始化为传入的参数 `initialValue`。\r\n返回的 `ref` 对象在组件的整个生命周期内持续存在。\r\n\r\n一个常见的用例便是命令式地访问子组件：\r\n```javascript\r\nfunction TextInputWithFocusButton() {\r\n  const inputEl = useRef(null);\r\n  const onButtonClick = () => {\r\n    // `current` 指向已挂载到 DOM 上的文本输入元素\r\n    inputEl.current.focus();\r\n  };\r\n  return (\r\n    <>\r\n      <input ref={inputEl} type=\"text\" />\r\n      <button onClick={onButtonClick}>Focus the input</button>\r\n    </>\r\n  );\r\n}\r\n```\r\n\r\n本质上，`useRef` 就像是可以在其 `.current` 属性中保存一个可变值的“盒子”。\r\n\r\n你应该熟悉 `ref` 这一种 **访问 DOM** 的主要方式。\r\n如果你将 `ref` 对象以 `<div ref={myRef} />` 形式传入组件，则无论该节点如何改变，\r\nReact 都会将 `ref` 对象的 `.current` 属性设置为相应的 `DOM` 节点。\r\n\r\n然而，`useRef()` 比 `ref` 属性更有用。\r\n它可以 **很方便地保存任何可变值**，其类似于在 `class` 中使用实例字段的方式。\r\n\r\n这是因为它创建的是一个普通 JS 对象。\r\n而 `useRef()` 和自建一个 `{current: ...}` 对象的唯一区别是，`useRef` 会在每次渲染时返回同一个 `ref` 对象。\r\n\r\n请记住，当 `ref` 对象内容发生变化时，`useRef` 并不会通知你。\r\n变更 `.current` 属性不会引发组件重新渲染。\r\n如果想要在 React 绑定或解绑 `DOM` 节点的 `ref` 时运行某些代码，则需要使用 **回调 ref** 来实现。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 8. useImperativeHandle\r\n```javascript\r\nuseImperativeHandle(ref, createHandle, [deps])\r\n```\r\n\r\n`useImperativeHandle` 可以让你在使用 `ref` 时自定义暴露给父组件的实例值。\r\n在大多数情况下，应当避免使用 `ref` 这样的命令式代码。\r\n`useImperativeHandle` 应当与 `forwardRef` 一起使用：\r\n\r\n```javascript\r\nfunction FancyInput(props, ref) {\r\n  const inputRef = useRef();\r\n  useImperativeHandle(ref, () => ({\r\n    focus: () => {\r\n      inputRef.current.focus();\r\n    }\r\n  }));\r\n  return <input ref={inputRef} ... />;\r\n}\r\nFancyInput = forwardRef(FancyInput);\r\n```\r\n\r\n在本例中，渲染 `<FancyInput ref={inputRef} />` 的父组件可以调用 `inputRef.current.focus()`。\r\n\r\n## 9. useLayoutEffect\r\n其函数签名与 `useEffect` 相同，但它会在所有的 `DOM` 变更之后同步调用 `effect`。\r\n可以使用它来读取 `DOM` 布局并同步触发重渲染。在浏览器执行绘制之前，`useLayoutEffect` 内部的更新计划将被同步刷新。\r\n\r\n尽可能使用标准的 `useEffect` 以避免阻塞视觉更新。\r\n\r\n#### 提示\r\n如果你正在将代码从 `class` 组件迁移到使用 `Hook` 的函数组件，\r\n则需要注意 `useLayoutEffect` 与 `componentDidMount`、`componentDidUpdate` 的调用阶段是一样的。\r\n但是，我们推荐你一开始先用 `useEffect`，只有当它出问题的时候再尝试使用 `useLayoutEffect`。\r\n\r\n如果你使用服务端渲染，请记住，无论 `useLayoutEffect` 还是 `useEffect` 都无法在 JS 代码加载完成之前执行。\r\n这就是为什么在服务端渲染组件中引入 `useLayoutEffect` 代码时会触发 React 告警。\r\n解决这个问题，需要将代码逻辑移至 `useEffect` 中（如果首次渲染不需要这段逻辑的情况下），\r\n或是将该组件延迟到客户端渲染完成后再显示（如果直到 `useLayoutEffect` 执行之前 HTML 都显示错乱的情况下）。\r\n\r\n若要从服务端渲染的 HTML 中排除依赖布局 `effect` 的组件，可以通过使用 `showChild && <Child />` 进行条件渲染，\r\n并使用 `useEffect(() => { setShowChild(true); }, [])` 延迟展示组件。\r\n这样，在客户端渲染完成之前，UI 就不会像之前那样显示错乱了。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 10. useDebugValue\r\n```javascript\r\nuseDebugValue(value)\r\n```\r\n\r\n`useDebugValue` 可用于在 React 开发者工具中显示自定义 `hook` 的标签。\r\n\r\n例如，名为 `useFriendStatus` 的自定义 `Hook`：\r\n```javascript\r\nfunction useFriendStatus(friendID) {\r\n  const [isOnline, setIsOnline] = useState(null);\r\n\r\n  // 在开发者工具中的这个 Hook 旁边显示标签\r\n  // e.g. \"FriendStatus: Online\"\r\n  useDebugValue(isOnline ? 'Online' : 'Offline');\r\n\r\n  return isOnline;\r\n}\r\n```\r\n\r\n#### 提示\r\n我们不推荐你向每个自定义 `Hook` 添加 `debug` 值。\r\n当它作为共享库的一部分时才最有价值。\r\n\r\n### 延迟格式化 debug 值\r\n在某些情况下，格式化值的显示可能是一项开销很大的操作。\r\n除非需要检查 `Hook`，否则没有必要这么做。\r\n\r\n因此，`useDebugValue` 接受一个格式化函数作为可选的第二个参数。\r\n该函数只有在 `Hook` 被检查时才会被调用。\r\n它接受 `debug` 值作为参数，并且会返回一个格式化的显示值。\r\n\r\n例如，一个返回 `Date` 值的自定义 `Hook` 可以通过格式化函数来避免不必要的 `toDateString` 函数调用：\r\n```javascript\r\nuseDebugValue(date, date => date.toDateString());\r\n```\r\n\r\n## 11. useDeferredValue\r\n```javascript\r\nconst deferredValue = useDeferredValue(value);\r\n```\r\n\r\n`useDeferredValue` 接受一个值，并返回该值的新副本，该副本将推迟到更紧急地更新之后。\r\n如果当前渲染是一个紧急更新的结果，比如用户输入，React 将返回之前的值，然后在紧急渲染完成后渲染新的值。\r\n\r\n该 `hook` 与使用防抖和节流去延迟更新的用户空间 `hooks` 类似。\r\n使用 `useDeferredValue` 的好处是，React 将在其他工作完成（而不是等待任意时间）后立即进行更新，\r\n并且像 `startTransition` 一样，延迟值可以暂停，而不会触发现有内容的意外降级。\r\n\r\n### 缓存子组件\r\n`useDeferredValue` 仅延迟你传递给它的值。\r\n如果你想要在紧急更新期间防止子组件重新渲染，则还必须使用 `memo` 或 `useMemo` 缓存该子组件：\r\n```javascript\r\nfunction Typeahead() {\r\n  const query = useSearchQuery('');\r\n  const deferredQuery = useDeferredValue(query);\r\n\r\n  // Memoizing 告诉 React 仅当 deferredQuery 改变，\r\n  // 而不是 query 改变的时候才重新渲染\r\n  const suggestions = useMemo(() =>\r\n    <SearchSuggestions query={deferredQuery} />,\r\n    [deferredQuery]\r\n  );\r\n\r\n  return (\r\n    <>\r\n      <SearchInput query={query} />\r\n      <Suspense fallback=\"Loading results...\">\r\n        {suggestions}\r\n      </Suspense>\r\n    </>\r\n  );\r\n}\r\n```\r\n\r\n缓存该子组件告诉 React 它仅当 `deferredQuery` 改变而不是 `query` 改变的时候才需要去重新渲染。\r\n这个限制不是 `useDeferredValue` 独有的，它和使用防抖或节流的 `hooks` 使用的相同模式。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 12. useTransition\r\n```javascript\r\nconst [isPending, startTransition] = useTransition();\r\n```\r\n\r\n返回一个状态值表示过渡任务的等待状态，以及一个启动该过渡任务的函数。\r\n\r\n`startTransition` 允许你通过标记更新将提供的回调函数作为一个过渡任务：\r\n```javascript\r\nstartTransition(() => {\r\n  setCount(count + 1);\r\n})\r\n```\r\n\r\n`isPending` 指示过渡任务何时活跃以显示一个等待状态：\r\n```javascript\r\nfunction App() {\r\n  const [isPending, startTransition] = useTransition();\r\n  const [count, setCount] = useState(0);\r\n  \r\n  function handleClick() {\r\n    startTransition(() => {\r\n      setCount(c => c + 1);\r\n    })\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      {isPending && <Spinner />}\r\n      <button onClick={handleClick}>{count}</button>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n#### 注意\r\n过渡任务中触发的更新会让更紧急地更新先进行，比如点击。\r\n\r\n过渡任务中的更新将不会展示由于再次挂起而导致降级的内容。\r\n这个机制允许用户在 React 渲染更新的时候继续与当前内容进行交互。\r\n\r\n## 13. useId\r\n```javascript\r\nconst id = useId();\r\n```\r\n`useId` 是一个用于生成横跨服务端和客户端的稳定的唯一 ID 的同时避免 `hydration` 不匹配的 `hook`。\r\n\r\n#### 注意\r\n`useId` 不用于在列表中生成 `key`。`key` 应该从你的数据中生成。\r\n\r\n一个最简单的例子，直接传递 `id` 给需要它的元素：\r\n```javascript\r\nfunction Checkbox() {\r\n  const id = useId();\r\n  return (\r\n    <>\r\n      <label htmlFor={id}>Do you like React?</label>\r\n      <input id={id} type=\"checkbox\" name=\"react\"/>\r\n    </>\r\n  );\r\n};\r\n```\r\n\r\n对于同一组件中的多个 ID，使用相同的 `id` 并添加后缀：\r\n\r\n```javascript\r\nfunction NameFields() {\r\n  const id = useId();\r\n  return (\r\n    <div>\r\n      <label htmlFor={id + '-firstName'}>First Name</label>\r\n      <div>\r\n        <input id={id + '-firstName'} type=\"text\" />\r\n      </div>\r\n      <label htmlFor={id + '-lastName'}>Last Name</label>\r\n      <div>\r\n        <input id={id + '-lastName'} type=\"text\" />\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n#### 注意\r\n`useId` 生成一个包含 `:` 的字符串 token。\r\n这有助于确保 token 是唯一的，但在 CSS 选择器或 `querySelectorAll` 等 API 中不受支持。\r\n\r\n`useId` 支持 `identifierPrefix` 以防止在多个根应用的程序中发生冲突。 "}]},{"number":72,"title":"【Q072】useEffect 和 useLayoutEffect 的区别","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/72","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. useEffect\r\n`useEffect` 执行一个副作用。\r\n当我们在 `useEffect` 中执行了某个方法后，组件卸载的时候，\r\n需要在 `useEffect` 中设置一个清除函数将前面使用的方法或者值清除掉，这样可以防止内存的泄漏。\r\n```javascript\r\nuseEffect(() => {\r\n    const subscription = props.source.subscribe();\r\n    return () => {\r\n        subscription.unsubscribe();\r\n    };\r\n}, []);\r\n```\r\n\r\n第二个参数可以不传，也可以传一个空数组，或者数组中传值。\r\n如果不传任何值，当任意状态发生改变时，组件都会重新渲染；\r\n如果传一个空数组，则直接当组件DOM第一次加载完成后，才执行一次，后续不管任何状态发生改变都不会再执行；\r\n如果数组中传入相应的值，则会简单当前值是否发生改变，一旦简单的值发生编写，组件就会重新渲染。\r\n\r\n## 2. useLayoutEffect\r\n`useLayoutEffect` 和 `useEffect` 内部的实现是一样的。\r\n\r\n### 不同点\r\n\r\n- `useLayoutEffect` 先调用 `mountLayoutEffect`，再调用 `mountEffectImpl`。\r\n- `useEffect`  先调用 `mountEffect`，再调用 `mountEffectImpl`。\r\n\r\n`mountLayoutEffect` 与 `mountEffect` 又有什么不同呢？\r\n唯一的不同点也只是触发的时机不同。\r\n\r\n`useEffect` 是异步处理副作用，而 `useLayoutEffect` 是同步处理副作用。\r\n\r\n### useLayoutEffect 常用于处理dom，避免闪屏\r\n\r\n## 3. 总结\r\n`useEffect` 和 `useLayoutEffect` 的使用方法一致。\r\n唯一的不同点是执行时机，建议是在大部分场景下使用 `useEffect`来完成副作用的执行。\r\n`useLayoutEffect` 会阻塞渲染，所以只在 `useEffect` 无法解决时再用 `useLayoutEffect`，这样避免了性能问题。"}]},{"number":73,"title":"【Q073】useMemo 和 useCallback 的区别","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/73","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. useCallback\r\n### useCallback 的参数\r\n- callback，需要执行的函数\r\n- deps，需要引入的外部参数或者是依赖参数\r\n\r\n```javascript\r\nconst handleChildrenCallback = useCallback(() => {\r\n  handleChildren();\r\n}, [])\r\n```\r\n\r\n### useCallback 的返回值\r\n返回一个 `memoized` 回调函数。\r\n在依赖参数不变的情况下，返回的回调函数是同一个引用地址。\r\n只有在依赖参数更新时，返回一个新的 `memoized`（地址发生改变）。\r\n\r\n### useCallback 使用场景\r\n配合 `memo` 用于优化子组件的渲染次数。\r\n\r\n## 2. useMemo\r\n`useMemo` 的作用是避免在每次渲染时都进行高开销的计算的优化的策略。\r\n\r\n### useMemo 的参数（与useMemo相同）\r\n\r\n- callback，需要执行的函数\r\n- deps，需要引入的外部参数或者是依赖参数\r\n\r\n### useMemo 的返回值\r\n返回一个 `memoized` 值。\r\n在依赖参数不变的的情况返回的是上次第一次计算的值。\r\n\r\n### useMemo 使用场景\r\n优化针对于当前组件高开销的计算，缓存计算值。\r\n\r\n## 3. 总结\r\n\r\n### 相同之处\r\n\r\n- 参数相似。\r\n- 都是用来做缓存。\r\n\r\n### 不同之处\r\n\r\n- `useCallback` 返回缓存的函数，`useMemo` 返回缓存的值。\r\n- `useCallback` 常用于优化子组件渲染，`useMemo` 常用于优化状态的计算。"}]},{"number":74,"title":"【Q074】如何自己封装一个 Hooks","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/74","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 自定义 Hook\r\n通过自定义 `Hook`，可以将组件逻辑提取到可重用的函数中。\r\n\r\n自定义 `Hook` 是一个函数，其名称以 “use” 开头，函数内部可以调用其他的 `Hook`。\r\n```javascript\r\nfunction useFriendStatus(friendID) {\r\n  const [isOnline, setIsOnline] = useState(null);\r\n\r\n  useEffect(() => {\r\n    function handleStatusChange(status) {\r\n      setIsOnline(status.isOnline);\r\n    }\r\n\r\n    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);\r\n    return () => {\r\n      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);\r\n    };\r\n  });\r\n\r\n  return isOnline;\r\n}\r\n``` \r\n\r\n与 React 组件不同的是，自定义 `Hook` 不需要具有特殊的标识。\r\n我们可以自由的决定它的参数是什么，以及它应该返回什么。\r\n换句话说，它就是一个正常的函数。\r\n但是它的名字应该始终以 `use` 开头，这样可以一眼看出其符合 `Hook 的规则`。\r\n\r\n## 2. 使用自定义 Hook\r\n```javascript\r\nfunction FriendStatus(props) {\r\n  const isOnline = useFriendStatus(props.friend.id);\r\n\r\n  if (isOnline === null) {\r\n    return 'Loading...';\r\n  }\r\n  return isOnline ? 'Online' : 'Offline';\r\n}\r\n```\r\n\r\n### 自定义 `Hook` 必须以 “use” 开头吗？\r\n必须如此，这个约定非常重要。\r\n不遵循的话，由于无法判断某个函数是否包含对其内部 `Hook` 的调用，\r\nReact 将无法自动检查你的 `Hook` 是否违反了 `Hook 的规则`。\r\n\r\n### 在两个组件中使用相同的 Hook 会共享 state 吗？\r\n不会。\r\n自定义 `Hook` 是一种重用状态逻辑的机制(例如设置为订阅并存储当前值)。\r\n所以每次使用自定义 `Hook` 时，其中的所有 `state` 和副作用都是完全隔离的。\r\n\r\n### 自定义 Hook 如何获取独立的 state？\r\n每次调用 `Hook`，它都会获取独立的 `state`。"}]},{"number":75,"title":"【Q075】Suspense","labels":["react"],"body":"suspense，lazy","url":"https://github.com/kangyana/daily-question/issues/75","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. React.Suspense\r\n`Suspense` 使得组件可以“等待”某些操作结束后，再进行渲染。\r\n目前，`Suspense` 仅支持的使用场景是：**通过 React.lazy 动态加载组件**。\r\n\r\n```javascript\r\n// 该组件是动态加载的\r\nconst OtherComponent = React.lazy(() => import('./OtherComponent'));\r\n\r\nfunction MyComponent() {\r\n  return (\r\n    // 显示 <Spinner> 组件直至 OtherComponent 加载完成\r\n    <React.Suspense fallback={<Spinner />}>\r\n      <div>\r\n        <OtherComponent />\r\n      </div>\r\n    </React.Suspense>\r\n  );\r\n}\r\n```\r\n\r\n请注意，`lazy` 组件可以位于 `Suspense` 组件树的深处——它不必包装树中的每一个延迟加载组件。\r\n最佳实践是将 `<Suspense>` 置于你想展示加载指示器（loading indicator）的位置，\r\n而 `lazy()` 则可被放置于任何你想要做代码分割的地方。\r\n\r\n### 服务端渲染中的 Suspense\r\n在服务端渲染过程中，`Suspense` 边界允许你挂起，通过较小的块来刷新应用程序。\r\n当组件挂起时，我们会安排一个低优先级的任务来渲染最近的 `Suspense` 边界的 `fallback`。\r\n如果组件在我们刷新 `fallback` 之前取消挂起，那么我们会发送实际内容并丢弃 `fallback`。\r\n\r\n### hydrate 过程中的 Suspense\r\n`Suspense` 边界依赖于它们的父边界，在它们可以 `hydrate` 前被 `hydrate`，\r\n但是它们可以独立于兄弟边界进行 `hydrate`。\r\n边界 `hydrate` 前发生的事件将导致边界 `hydrate` 的优先级高于相邻边界的优先级。\r\n\r\n## 2. React.lazy\r\n`lazy` 函数能让你像渲染常规组件一样处理动态引入。\r\n```javascript\r\nimport OtherComponent from './OtherComponent';\r\n// 改为动态引入\r\nconst OtherComponent = React.lazy(() => import('./OtherComponent'));\r\n```\r\n\r\n此代码将会在组件首次渲染时，自动导入包含 `OtherComponent` 组件的包。\r\n\r\n`lazy` 接受一个函数，这个函数需要动态调用 `import()`。\r\n它必须返回一个 `Promise`，该 `Promise` 需要 `resolve` 一个 `default export` 的 React 组件。\r\n\r\n应在 `Suspense` 组件中渲染 `lazy` 组件，\r\n如此使得我们可以使用在等待加载 `lazy` 组件时做优雅降级（如 loading 指示器等）。\r\n```javascript\r\nimport React, { Suspense } from 'react';\r\n\r\nconst OtherComponent = React.lazy(() => import('./OtherComponent'));\r\n\r\nfunction MyComponent() {\r\n  return (\r\n    <div>\r\n      <Suspense fallback={<div>Loading...</div>}>\r\n        <OtherComponent />\r\n      </Suspense>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n`fallback` 属性接受任何在组件加载过程中你想展示的 React 元素。\r\n你可以将 `Suspense` 组件置于懒加载组件之上的任何位置。\r\n你甚至可以用一个 `Suspense` 组件包裹多个懒加载组件。\r\n```javascript\r\nimport React, { Suspense } from 'react';\r\n\r\nconst OtherComponent = React.lazy(() => import('./OtherComponent'));\r\nconst AnotherComponent = React.lazy(() => import('./AnotherComponent'));\r\n\r\nfunction MyComponent() {\r\n  return (\r\n    <div>\r\n      <Suspense fallback={<div>Loading...</div>}>\r\n        <section>\r\n          <OtherComponent />\r\n          <AnotherComponent />\r\n        </section>\r\n      </Suspense>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n### 避免兜底\r\n任何组件都可能因渲染而暂停，甚至是已经展示给用户的组件。\r\n为了使屏幕内容始终一致，如果一个已经显示的组件暂停，React 必须隐藏它的树，直到最近的 `<Suspense>` 边界。\r\n然而，从用户的角度来看，这可能会使人很困惑。\r\n\r\n参考这个标签切换的示例：\r\n```javascript\r\nimport React, { Suspense } from 'react';\r\nimport Tabs from './Tabs';\r\nimport Glimmer from './Glimmer';\r\n\r\nconst Comments = React.lazy(() => import('./Comments'));\r\nconst Photos = React.lazy(() => import('./Photos'));\r\n\r\nfunction MyComponent() {\r\n  const [tab, setTab] = React.useState('photos');\r\n  \r\n  function handleTabSelect(tab) {\r\n    setTab(tab);\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <Tabs onTabSelect={handleTabSelect} />\r\n      <Suspense fallback={<Glimmer />}>\r\n        {tab === 'photos' ? <Photos /> : <Comments />}\r\n      </Suspense>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n在这个示例中，如果标签从 `photos` 切换为 `comments`，但 `Comments` 会暂停，用户会看到屏幕闪烁。\r\n这符合常理，因为用户不想看到 `photos`，而 `Comments` 组件还没有准备好渲染其内容，\r\n而 React 为了保证用户体验的一致性，只能显示上面的 `Glimmer`，别无选择。\r\n\r\n然而，有时这种用户体验并不可取。特别是在准备新 UI 时，展示 “旧” 的 UI 会体验更好。\r\n你可以尝试使用新的 `startTransition` API 来让 React 实现这一点：\r\n```javascript\r\nfunction handleTabSelect(tab) {\r\n  startTransition(() => {\r\n    setTab(tab);\r\n  });\r\n}\r\n```\r\n\r\n此处代码会告知 React，将标签切换为 `comments` 不会标记为紧急更新，而是标记为需要一些准备时间的 `transition`。\r\n然后 React 会保留旧的 UI 并进行交互，当它准备好时，会切换为 `<Comments />`。\r\n\r\n### 异常捕获边界（Error boundaries）\r\n如果模块加载失败（如网络问题），它会触发一个错误。\r\n你可以通过 `异常捕获边界（Error boundaries）` 技术来处理这些情况，以显示良好的用户体验并管理恢复事宜。\r\n```javascript\r\nimport React, { Suspense } from 'react';\r\nimport MyErrorBoundary from './MyErrorBoundary';\r\n\r\nconst OtherComponent = React.lazy(() => import('./OtherComponent'));\r\nconst AnotherComponent = React.lazy(() => import('./AnotherComponent'));\r\n\r\nconst MyComponent = () => (\r\n  <div>\r\n    <MyErrorBoundary>\r\n      <Suspense fallback={<div>Loading...</div>}>\r\n        <section>\r\n          <OtherComponent />\r\n          <AnotherComponent />\r\n        </section>\r\n      </Suspense>\r\n    </MyErrorBoundary>\r\n  </div>\r\n);\r\n```"}]},{"number":76,"title":"【Q076】Concurrent","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/76","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. Concurrent 模式\r\n`concurrent` 模式目前仅在 React 的 **实验版本** 可用。安装命令：\r\n```bash\r\nnpm install react@experimental react-dom@experimental\r\n```\r\n\r\n### 开启 concurrent 模式\r\n通常，当我们给 React 添加功能的时候，你可以立即使用。\r\n比如 `Fragments`，`Context`，甚至 `Hook`。\r\n你都可以直接在代码里使用他们，而不用修改之前的代码。\r\n\r\n`concurrent` 模式并不是这样。\r\n它给引入了新的语义，改变了 React 的工作方式。\r\n否则不能启用 `这些新功能`。\r\n这就是它被分组到了新的模式，而不是相继的发布出来。\r\n\r\n你不能为某个子树单独启用 `concurrent` 模式。\r\n你应该在 `ReactDOM.render()` 里启用它。\r\n```javascript\r\nimport ReactDOM from 'react-dom';\r\n\r\n// 正常模式\r\n// ReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// concurrent 模式\r\nReactDOM.unstable_createRoot(document.getElementById('root')).render(<App />);\r\n```\r\n\r\n在 `concurrent` 模式下，生命周期 `之前被标记过` 为“不安全”是真的不安全，会比现在的 React 出现更多的 bug。\r\n在你的 app 完全兼容 `严格模式` 之前，我们不建议使用 `concurrent` 模式。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. Concurrent 模式的新功能\r\n### Transition\r\n`useTransition` API"}]},{"number":77,"title":"【Q077】startTransition","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/77","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. React.startTransition\r\n```javascript\r\nReact.startTransition(callback)\r\n```\r\n\r\n`startTransition` 让你把提供的 `fallback` 里面的更新标记为 `transitions`。\r\n这个方法是为了在 `React.useTransition` 不可用时使用。\r\n\r\n### 注意\r\n过渡期的更新会被更紧急的更新取代，如点击操作。\r\n\r\n过渡期的更新不会显示重新挂起内容的 `fallback`，允许用户在渲染更新时继续进行交互。\r\n\r\n`startTransition` 不提供 `isPending` 的标志。\r\n要跟踪过渡的待定状态，请使用 `React.useTransition`。"}]},{"number":78,"title":"【Q078】Server Component","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/78","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. Server Component 核心概念\r\n截止目前，`React Server Component` 还在开发与研究中，因此不适合投入生产环境使用。\r\n但其概念非常有趣，值得技术人学习。\r\n\r\n### Server Component 概念\r\n解决 \"用户体验、可维护性、性能\" 这个 **不可能三角**。\r\n\r\n用户体验：页面更快的响应。\r\n可维护性：代码应该高内聚低耦合。\r\n性能：请求速度。\r\n\r\n**不可能三角** 就是，最多同时满足两条，而无法三条都同时满足：\r\n\r\n- 保障 **用户体验、可维护性**，用一个请求拉取全部数据，所有组件一次性渲染。但当模块不断增多，无用模块信息不敢随意删除，请求会越来越大，越来越冗余，导致瓶颈卡在取数这块，也就是 **性能不好**。\r\n- 保障 **用户体验、性能**，考虑并行取数，之后流程不变，那么以后业务逻辑新增或减少一个模块，我们就要同时修改并行取数公共逻辑与对应业务模块，**可维护性不好**。\r\n- 保障 **可维护性、性能**，可以每个模块独立取数，但在父级渲染完才渲染子元素的情况下，父子取数就变成了串行，页面加载被阻塞，**用户体验不好**。\r\n\r\n一言蔽之，在前后端解耦的模式下，唯一连接的桥梁就是取数请求。\r\n要把用户体验做好，取数就要提前并行发起，而前端模块是独立维护的，\r\n所以在前端做取数聚合这件事，必然会破坏前端可维护性，\r\n而这并行这件事放在后端的话，会因为后端不能解析前端模块，导致给出的聚合信息滞后，久而久之变得冗余。\r\n\r\n要解决这个问题，就必须加深前端与后端的联系，\r\n所以像 GraphQL 这种前后端约定方案是可行的，但因为其部署成本高，\r\n收益又仅在前端，所以难以在后端推广。\r\n\r\n`Server Component` 是另一种方案，通过启动一个 Node 服务辅助前端，\r\n但做的不是 API 对接，而是运行前端同构 js 代码，直接解析前端渲染模块，\r\n从中自动提取请求并在 Node 端直接与服务器通信，因为服务端间通信成本极低、前端代码又不需要做调整，\r\n请求数据也是动态按需聚合的，因此同时解决了 \"用户体验、可维护性、性能\" 这三个问题。\r\n\r\n其核心改进点如下图所示：\r\n![Alt](https://camo.githubusercontent.com/f92bbe9c970aff1c93ec0d7229181938b396317edcbc8b6ee0931dadf9c6584f/68747470733a2f2f696d672e616c6963646e2e636f6d2f696d6765787472612f69322f4f31434e30314e7474584f4932316b61464a674e4478315f2121363030303030303030373032332d322d7470732d3732302d3436362e706e67)\r\n\r\n如上图所示，这是前后端正常交互模式，可以看到，`Root` 与 `Child` 串行发了两个请求，\r\n因为网络耗时与串行都是严重阻塞部分，因此用红线标记。\r\n\r\n`Server Component` 可以理解为下图，不仅减少了一次网络损耗，请求也变成了并行，\r\n请求返回结果也从纯数据变成了一个同时描述 UI DSL 与数据的特殊结构：\r\n![Alt](https://camo.githubusercontent.com/bc6d8a7d538f3a37793915654ac033fcff619e73154c4ff92e467051831490cf/68747470733a2f2f696d672e616c6963646e2e636f6d2f696d6765787472612f69312f4f31434e30314d4459785a37314b30496b41434c6d464a5f2121363030303030303030313130312d322d7470732d313134322d3436382e706e67)"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. 概述\r\n概括的说，`Server Component` 就是让组件拥有在服务端渲染的能力，从而解决不可能三角问题。\r\n也正因为这个特性，使得 `Server Component` 拥有几种让人眼前一亮的特性，都是纯客户端组件所不具备的：\r\n\r\n- **运行在服务端的组件只会返回 DSL 信息，而不包含其他任何依赖**，因此 Server Component 的所有依赖 npm 包都不会被打包到客户端。\r\n- **可以访问服务端任何 API**，也就是让组件拥有了 Nodejs 能拥有的能力，你理论上可以在前端组件里干任何服务端才能干的事情。\r\n- **Server Component 与 Client Component 无缝集成**，可以通过 Server Component 无缝调用 Client Component。\r\n- **Server Component 会按需返回信息**，在当前逻辑下，走不到的分支逻辑的所有引用都不会被客户端引入。比如 Server Component 虽然引用了一个巨大的 npm 包，但某个分支下没有用到这个包提供的函数，那客户端也不会下载这个巨大的 npm 包到本地。\r\n- **由于返回的不是 HTML，而是一个 DSL，所以服务端组件即便重新拉取，已经产生的 State 也会被维持住**。比如说 A 是 ServerComponent，其子元素 B 是 Client Component，此时对 B 组件做了状态修改比如输入一些文字，此时触发 A 重新拉取 DSL 后，B 已经输入的文字还会保留。\r\n- **可以无缝与 Suspense 结合**，并不会因为网络原因导致连 Suspense 的 loading 都不能及时展示。\r\n- **共享组件可以同时在服务端与客户端运行**。\r\n\r\n### 三个组件\r\n`Server Component` 将组件分为三种：\r\n\r\n序号 | 组件类型 | 后缀 | 运行在服务端 | 运行在客户端\r\n-- | -- | -- | -- | --\r\n1 | Server Component | .server.js | ✔ | ❌\r\n2 | Client Component | .client.js | ❌ | ❌\r\n3 | Shared Component | .js | ✔ | ✔\r\n\r\n下面是 `RFC` 中展示的 `Server Component` 例子：\r\n\r\n```javascript\r\n// Note.server.js - Server Component\r\nimport db from 'db.server'; \r\n// (A1) We import from NoteEditor.client.js - a Client Component.\r\nimport NoteEditor from 'NoteEditor.client';\r\n\r\nfunction Note(props) {\r\n  const {id, isEditing} = props;\r\n  // (B) Can directly access server data sources during render, e.g. databases\r\n  const note = db.posts.get(id);\r\n  \r\n  return (\r\n    <div>\r\n      <h1>{note.title}</h1>\r\n      <section>{note.body}</section>\r\n      {/* (A2) Dynamically render the editor only if necessary */}\r\n      {isEditing \r\n        ? <NoteEditor note={note} />\r\n        : null\r\n      }\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n可以看到，这就是 Node 与 React 混合语法。服务端组件有着苛刻的限制条件：**不能有状态，且 `props` 必须能被序列化**。\r\n\r\n很容易理解，因为服务端组件要被传输到客户端，就必须经过序列化、反序列化的过程，\r\nJSX 是可以被序列化的，`props` 也必须遵循这个规则。\r\n另外服务端不能帮客户端存储状态，因此服务端组件不能用任何 `useState` 等状态相关 API。\r\n\r\n但这两个问题都可以绕过去，即将状态转化为组件的 `props` 入参，由 `.client.js` 存储，见下图：\r\n\r\n![Alt](https://camo.githubusercontent.com/54063f3300557dea44ec11973671c5a770633d4ce85fd5155b3634e78cdf889e/68747470733a2f2f696d672e616c6963646e2e636f6d2f696d6765787472612f69342f4f31434e30314368505a644f316b79304e7375327967565f2121363030303030303030343735312d322d7470732d3531342d3237382e706e67)\r\n\r\n或者利用 `Server Component` 与 `Client Component` 无缝集成的能力，\r\n将状态与无法序列化的 `props` 参数都放在 `Client Component`，由 `Server Component` 调用。\r\n\r\n## 3. 优点\r\n### 零客户端体积\r\n这句话听起来有点夸张，但其实在 `Server Component` 限定条件下还真的是。看下面代码：\r\n```javascript\r\n// NoteWithMarkdown.js\r\nimport marked from 'marked'; // 35.9K (11.2K gzipped)\r\nimport sanitizeHtml from 'sanitize-html'; // 206K (63.3K gzipped)\r\n\r\nfunction NoteWithMarkdown({text}) {\r\n  const html = sanitizeHtml(marked(text));\r\n  return (/* render */);\r\n}\r\n```\r\n\r\n`marked` 与 `sanitize-html` 都不会被下载到本地，所以如果只有这一个文件传输，\r\n客户端的理论增加体积就是 `render` 函数序列化后字符串大小，可能不到 1KB。\r\n\r\n当然这背后也是限制换来的，首先这个组件没有状态，无法在客户端实时执行，\r\n而且在服务端运行也可能消耗额外计算资源，如果某些 npm 包计算复杂度较高的话。\r\n\r\n这个好处可以理解为，`marked` 这个包仅在服务端读取到内存一次，以后只要后客户端想用，\r\n只需要在服务端执行 `marked API` 并把输出结果返回给客户端，而不需要客户端下载 `marked` 这个包了。\r\n\r\n### 拥有完整服务端能力\r\n由于 `Server Component` 在服务端执行，因此可以执行 Nodejs 的任何代码。\r\n```javascript\r\n// Note.server.js - Server Component\r\nimport fs from 'react-fs';\r\n\r\nfunction Note({id}) {\r\n  const note = JSON.parse(fs.readFile(`${id}.json`));\r\n  return <NoteWithMarkdown note={note} />;\r\n}\r\n```\r\n\r\n我们可以把对请求的理解拔高一个层次，即 `request` 只是客户端发起的一个 Http 请求，\r\n其本质是访问一个资源，在服务端就是个 IO 行为。\r\n对于 IO，我们还可以通过 `file` 文件系统写入删除资源、`db` 通过 sql 语法直接访问数据库，\r\n或者 `request` 直接在服务器本地发出请求。\r\n\r\n### 运行时 Code Split\r\n我们都知道 webpack 可以通过静态分析，将没有使用到的 import 移出打包，\r\n而 `Server Component` 可以在运行时动态分析，将当前分支逻辑下没有用到的 import 移出打包：\r\n```javascript\r\n// PhotoRenderer.js\r\nimport React from 'react';\r\n\r\n// one of these will start loading *once rendered and streamed to the client*:\r\nimport OldPhotoRenderer from './OldPhotoRenderer.client.js';\r\nimport NewPhotoRenderer from './NewPhotoRenderer.client.js';\r\n\r\nfunction Photo(props) {\r\n  // Switch on feature flags, logged in/out, type of content, etc:\r\n  if (props.useNewPhotoRenderer) {\r\n    return <NewPhotoRenderer {...props} />;\r\n  } else {\r\n    return <OldPhotoRenderer {...props} />;\r\n  }\r\n}\r\n```\r\n\r\n这是因为 `Server Component` 构建时会进行预打包，运行时就是一个动态的包分发器，\r\n完全可以通过当前运行状态比如 `props.xxx` 来区分当前运行到哪些分支逻辑，\r\n而没有运行到哪些分支逻辑，并且仅告诉客户端拉取当前运行到的分支逻辑的缺失包。\r\n\r\n纯前端模式与之类似的写法是：\r\n```javascript\r\nconst OldPhotoRenderer = React.lazy(() => import('./OldPhotoRenderer.js'));\r\nconst NewPhotoRenderer = React.lazy(() => import('./NewPhotoRenderer.js'));\r\n```\r\n\r\n只是这种写法不够原生，且实际场景往往只有前端框架把路由自动包一层 `Lazy Load`，而普通代码里很少出现这种写法。\r\n\r\n### 无客户端往返的数据端取数\r\n一般考虑到取数网络消耗，我们往往会将其处理成异步，然后在数据返回前展示 Loading：\r\n```javascript\r\n// Note.js\r\n\r\nfunction Note(props) {\r\n  const [note, setNote] = useState(null);\r\n  useEffect(() => {\r\n    // NOTE: loads *after* rendering, triggering waterfalls in children\r\n    fetchNote(props.id).then(noteData => {\r\n      setNote(noteData);\r\n    });\r\n  }, [props.id]);\r\n  if (note == null) {\r\n    return \"Loading\";\r\n  } else {\r\n    return (/* render note here... */);\r\n  }\r\n}\r\n```\r\n\r\n这是因为单页模式下，我们可以快速从 CDN 拿到这个 DOM 结构，但如果再等待取数，整体渲染就变慢了。\r\n而 `Server Component` 因为本身就在服务端执行，因此可以将拿 DOM 结构与取数同时进行：\r\n```javascript\r\n// Note.server.js - Server Component\r\n\r\nfunction Note(props) {\r\n  // NOTE: loads *during* render, w low-latency data access on the server\r\n  const note = db.notes.get(props.id);\r\n  if (note == null) {\r\n    // handle missing note\r\n  }\r\n  return (/* render note here... */);\r\n}\r\n```\r\n\r\n当然这个前提是网络消耗敏感的情况，如果本身就是一个慢 SQL 查询，耗时几秒的情况下，这样做反而适得其反。\r\n\r\n### 减少 Component 层次\r\n看下面的例子：\r\n```javascript\r\n// Note.server.js\r\n// ...imports...\r\n\r\nfunction Note({id}) {\r\n  const note = db.notes.get(id);\r\n  return <NoteWithMarkdown note={note} />;\r\n}\r\n\r\n// NoteWithMarkdown.server.js\r\n// ...imports...\r\n\r\nfunction NoteWithMarkdown({note}) {\r\n  const html = sanitizeHtml(marked(note.text));\r\n  return <div ... />;\r\n}\r\n\r\n// client sees:\r\n<div>\r\n  <!-- markdown output here -->\r\n</div>\r\n```\r\n\r\n虽然在组件层面抽象了 `Note` 与 `NoteWithMarkdown` 两个组件，但由于真正 DOM 内容实体只有一个简单的 div，\r\n所以在 `Server Component` 模式下，返回内容就会简化为这个 div，而无需包含那两个抽象的组件。\r\n\r\n### 限制\r\n`Server Component` 模式下有三种组件，分别是 `Server Component`、`Client Component`、`Shared Component`，\r\n其各自都有一些使用限制，如下：\r\n\r\n#### Server Component：\r\n\r\n- ❌ 不能用 useState、useReducer 等状态存储 API。\r\n- ❌ 不能用 useEffect 等生命周期 API。\r\n- ❌ 不能用 window 等仅浏览器支持的 API。\r\n- ❌ 不能用包含了上面情况的自定义 Hooks。\r\n- ✅ 可无缝访问服务端数据、API。\r\n- ✅ 可渲染其他 Server/Client Component。\r\n\r\n#### Client Component：\r\n\r\n- ❌ 不能引用 Server Component。\r\n- ✅ 但可以在 Server Component 中出现 Client Component 调用 Server Component 的情况，比如 <ClientTabBar><ServerTabContent /></ClientTabBar>。\r\n- ❌ 不能调用服务端 API 获取数据。\r\n- ✅ 可以用一切 React 与浏览器完整能力。\r\n\r\n#### Shared Component：\r\n\r\n- ❌ 不能用 useState、useReducer 等状态存储 API。\r\n- ❌ 不能用 useEffect 等生命周期 API。\r\n- ❌ 不能用 window 等仅浏览器支持的 API。\r\n- ❌ 不能用包含了上面情况的自定义 Hooks。\r\n- ❌ 不能引用 Server Component。\r\n- ❌ 不能调用服务端 API 获取数据。\r\n- ✅ 可以同时在服务器与客户端使用。\r\n\r\n其实不难理解，因为 `Shared Component` 同时在服务器与客户端使用，因此兼具它们的劣势，带来的好处就是更强的复用性。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 4. 精读\r\n要快速理解 `Server Component`，我觉得最好也是最快的方式，就是找到其与十年前 PHP + HTML 的区别。看下面代码：\r\n```javascript\r\n$link = mysqli_connect('localhost', 'root', 'root');\r\nmysql_select_db('test', $link);\r\n$result = mysql_query('select * from table');\r\n\r\nwhile($row=mysql_fetch_assoc($result)){\r\n  echo \"<span>\".$row[\"id\"].\"</span>\";\r\n}\r\n```\r\n\r\n其实 PHP 早就是一套 \"Server Component\" 方案了，在服务端直接访问 DB、并返回给客户端 DOM 片段。\r\n\r\n`React Server Component` 在折腾了这么久后，可以发现，最大的区别是将返回的 HTML 片段改为了 DSL 结构，\r\n这其实是浏览器端有一个强大的 React 框架在背后撑腰的结果。\r\n而这个带来的好处除了可以让我们在服务端能继续写 React 语法，而不用退化到 \"PHP 语法\" 以外，\r\n更重要的是组件状态得以维持。\r\n\r\n另一个重要不同是，PHP 无法解析现在前端生态下任何 npm 包，所以无从解析模块化的前端代码，\r\n所以虽然直觉上感觉 PHP 效率与 `Server Component` 并无区别，\r\n但背后的成本是得写另一套不依赖任何 npm 包、JSX 的语法来返回 HTML 片段，\r\n`Server Component` 大部分特性都无法享受到，而且代码也无法复用。\r\n\r\n所以，本质上还是 HTML 太简单了，无法适应如今前端的复杂度，而普通后端框架虽然后端能力强大，\r\n但在前端能力上还停留在 20 年前（直接返回 DOM），唯有 Node 中间层方案作为桥梁，\r\n才能较好的衔接现代后端代码与现代前端代码。\r\n\r\n### PHP VS Server Component\r\n其实在 PHP 时代，前后端都可以做模块化。\r\n后端模块化显而易见，因为可以将后端代码模块化的开发，最后打包至服务器运行。\r\n前端也可以在服务端模块化开发，只要我们将前后端代码剥离出来即可，下图青色是后端部分，红色是前端部分：\r\n\r\n![Alt](https://camo.githubusercontent.com/6ba630cceb2832f5b89a90d32d56a78cbf681a1dd01101154f286f6f1c2c0e3f/68747470733a2f2f696d672e616c6963646e2e636f6d2f696d6765787472612f69332f4f31434e30316a734b6a4c7131695750486939433470515f2121363030303030303030343432302d322d7470732d3839342d3634322e706e67)\r\n\r\n但这有个问题，因为后端服务对浏览器来说是无状态的，所以后端模块化本身就符合其功能特征，\r\n但前端页面显示在用户浏览器，每次都通过路由跳转到新页面，显然不能最大程度发挥客户端持续运行的优势，\r\n我们希望在保持前端模块化的基础上，在浏览器端有一个持续运行的框架优化用户体验，\r\n因此 `Server Component` 其实做了下面的事情：\r\n\r\n![Alt](https://camo.githubusercontent.com/24566beebd421e9a9b6db1f610eb21bb9c606a0148cf8c0c83b97682e8ae8438/68747470733a2f2f696d672e616c6963646e2e636f6d2f696d6765787472612f69332f4f31434e3031677a615a4e59316c426b4762474a4b55795f2121363030303030303030343738312d322d7470732d313333322d3736302e706e67)\r\n\r\n这样做有两大好处：\r\n\r\n- 兼顾了 PHP 模式下优势，即前后端代码无缝混合，带来一系列体验和能力增强。\r\n- 前后端还是各自模块化编写，图中红色部分是随前端项目整体打包的，因此开发还是保留了模块化特点，且在浏览器上还保持了 React 现代框架运行，无论是单页还是数据驱动等特性都能继续使用。\r\n\r\n## 5. 总结\r\n`Server Component` 还没有成熟，但其理念还是很靠谱的。\r\n\r\n想要同时实现 \"用户体验、可维护性、性能\"，重后端，或者重前端的方案都不可行，只有在前后端取得一种平衡才能达到。`Server Component` 表达了一种职业发展理念，即未来前后端还是会走向全栈，这种全栈是前后端同时做深，从而让程序开发达到纯前端或纯后端无法达到的高度。"}]},{"number":79,"title":"【Q079】componentDidCatch","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/79","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. ErrorBoundary\r\n`ErrorBoundary`（错误边界）是 React 组件，它会在其子组件树中的任何位置捕获 JavaScript 错误，\r\n并记录这些错误，展示降级 UI 而不是崩溃的组件树。\r\n`Error boundaries` 组件会捕获在渲染期间，在生命周期方法以及其整个树的构造函数中发生的错误。\r\n\r\n如果 `class` 组件定义了生命周期方法 `static getDerivedStateFromError()` 或 `componentDidCatch()` 中的任何一个（或两者），\r\n它就成为了 `Error boundaries`。\r\n通过生命周期更新 `state` 可让组件捕获树中未处理的 JavaScript 错误并展示降级 UI。\r\n\r\n仅使用 `Error boundaries` 组件来从意外异常中恢复的情况；不要将它们用于流程控制。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. static getDerivedStateFromError()\r\n```javascript\r\nstatic getDerivedStateFromError(error)\r\n```\r\n\r\n此生命周期会在后代组件抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 `state`。\r\n\r\n```javascript\r\nclass ErrorBoundary extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = { hasError: false };\r\n  }\r\n\r\n  static getDerivedStateFromError(error) {\r\n    // 更新 state 使下一次渲染可以显降级 UI\r\n    return { hasError: true };\r\n  }\r\n\r\n  render() {\r\n    if (this.state.hasError) {\r\n      // 你可以渲染任何自定义的降级  UI\r\n      return <h1>Something went wrong.</h1>;\r\n    }\r\n\r\n    return this.props.children;\r\n  }\r\n}\r\n```\r\n\r\n### 注意\r\n`getDerivedStateFromError()` 会在渲染阶段调用，因此不允许出现副作用。\r\n 如遇此类情况，请改用 `componentDidCatch()`。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 3. componentDidCatch\r\n```javascript\r\ncomponentDidCatch(error, info)\r\n```\r\n\r\n此生命周期在后代组件抛出错误后被调用。 它接收两个参数：\r\n\r\n- `error` —— 抛出的错误。\r\n- `info` —— 带有 `componentStack key` 的对象，其中包含 **有关组件引发错误的栈信息**。\r\n\r\n`componentDidCatch()` 会在“提交”阶段被调用，因此允许执行副作用。\r\n 它应该用于记录错误之类的情况：\r\n \r\n```javascript\r\nclass ErrorBoundary extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = { hasError: false };\r\n  }\r\n\r\n  static getDerivedStateFromError(error) {\r\n    // 更新 state 使下一次渲染可以显示降级 UI\r\n    return { hasError: true };\r\n  }\r\n\r\n  componentDidCatch(error, info) {\r\n    // \"组件堆栈\" 例子:\r\n    //   in ComponentThatThrows (created by App)\r\n    //   in ErrorBoundary (created by App)\r\n    //   in div (created by App)\r\n    //   in App\r\n    logComponentStackToMyService(info.componentStack);\r\n  }\r\n\r\n  render() {\r\n    if (this.state.hasError) {\r\n      // 你可以渲染任何自定义的降级 UI\r\n      return <h1>Something went wrong.</h1>;\r\n    }\r\n\r\n    return this.props.children;\r\n  }\r\n}\r\n```\r\n\r\nReact 的开发和生产构建版本在 `componentDidCatch()` 的方式上有轻微差别。\r\n\r\n在开发模式下，错误会冒泡至 `window`，这意味着任何 `window.onerror` 或 `window.addEventListener('error', callback)` 会中断这些已经被 `componentDidCatch()` 捕获的错误。\r\n\r\n相反，在生产模式下，错误不会冒泡，这意味着任何根错误处理器只会接受那些没有显式地被 `componentDidCatch()` 捕获的错误。\r\n\r\n### 注意\r\n\r\n如果发生错误，你可以通过调用 `setState` 使用 `componentDidCatch()` 渲染降级 UI，但在未来的版本中将不推荐这样做。\r\n可以使用静态 `getDerivedStateFromError()` 来处理降级渲染。"}]},{"number":80,"title":"【Q080】SSR","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/80","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. CSR 和 SSR\r\n### 1. 客户端渲染（Client Side Rendering）\r\n渲染流程：\r\n\r\n![Alt](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/9/16eeb56642155f21~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)\r\n\r\n### 2. 服务端渲染（Server Side Rendering）\r\n\r\n- 是指将单页应用（SPA）在服务器端渲染成 HTML 片段，发送到浏览器，然后交由浏览器为其绑定状态与事件，成为完全可交互页面的过程。（PS：本文中的 SSR 内容都是围绕同构应用来讲的）\r\n- 服务端只负责首次“渲染”（真正意义上，只有浏览器才能渲染页面，服务端其实是生成 HTML 内容），然后返回给客户端，客户端接管页面交互（事件绑定等逻辑），之后客户端路由切换时，直接通过 JS 代码来显示对应的内容，不再需要服务端渲染。（只有页面刷新时会需要）\r\n\r\nSSR 渲染流程：\r\n![Alt](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/9/16eeb5663f9bdfe7~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. 为什么要用 SSR\r\n### 优点：\r\n\r\n- **更快的首屏加载速度**：无需等待 JavaScript 完成下载且执行才显示内容，更快速地看到完整渲染的页面，有更好的用户体验。\r\n- **更友好的 SEO**：\r\n① 爬虫可以直接抓取渲染之后的页面，CSR 首次返回的 HTML 文档中，是空节点（root），不包含内容，爬虫就无法分析你的网站有什么内容，所以就无法给你好的排名。\r\n而 SSR 返回渲染之后的 HTML 片段，内容完整，所以能更好地被爬虫分析与索引。\r\n② 基于旧版本的搜索引擎：我们会给 html 加 title 和 description 来做简单的 seo 优化，这两个本质上并不会提高搜索的排名，而是提高网站转化率。\r\n给网站提供更多的描述，让用户有点击的欲望，从而提高排名。\r\n③ 基于新版本的搜索引擎（全文搜索）：想要光靠上面两个来给网站有个好的排名是不行的，所以需要 SSR 来提供更多的网站内容。\r\n\r\n### 缺点：\r\n\r\n- 对服务器性能消耗较高。\r\n- 项目复杂度变高，出问题需要在前端、node、后端三者之间找。\r\n- 需要考虑 SSR 机器的运维、申请、扩容，增加了运维成本。（可以通过 Serverless 解决）\r\n\r\n## 3. 什么是同构应用\r\n\r\n- **一套代码既可以在服务端运行又可以在客户端运行，这就是同构应用**。\r\n- 在服务器上生成渲染内容，让用户尽早看到有信息的页面。\r\n一个完整的应用除包括纯粹的静态内容以外，还包括各种事件响应、用户交互等。这就意味着在浏览器端一定还要执行 JavaScript 脚本，以完成绑定事件、处理异步交互等工作。\r\n- 从性能及用户体验上来看，服务端渲染应该表达出页面最主要、最核心、最基本的信息；\r\n而浏览器端则需要针对交互完成进一步的页面渲染、事件绑定等增强功能。\r\n所谓同构，就是指前后端共用一套代码或逻辑，而在这套代码或逻辑中，理想的状况是在浏览器端进一步渲染的过程中，判断已有的 DOM 结构和即将渲染出的结构是否相同，若相同，则不重新渲染 DOM 结构，只需要进行事件绑定即可。\r\n- 从这个维度上讲，同构和服务端渲染又有所区别，同构更像是服务端渲染和浏览器端渲染的交集，它弥补了服务端和浏览器端的差异，从而使得同一套代码或逻辑得以统一运行。\r\n同构的核心是“同一套代码”，这是脱离于两端角度的另一个维度。"}]},{"number":81,"title":"【Q081】为什么需要用 redux","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/81","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 为什么需要用 redux\r\n当组件树传递状态足够困难的时候，`redux` 无需手动 **提升状态** 也可以 **共享状态**。\r\n\r\n## 2. 什么时候使用 redux\r\n让我们来模拟 React 项目组件树的发展：\r\n### 阶段一\r\n单向数据流，父组件把自身的状态作为属性传递给子组件。\r\n\r\n![Alt](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/24/15fec0f752bc65da~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)\r\n\r\n### 阶段二\r\n随着添加更多的功能，非父子组件之间需要共享一些状态。\r\n我们通过 **提升状态** 来解决这个问题。\r\n这意味着我们将状态提升到最接近的祖先（Container Component）。\r\n我们将这些函数绑定到容器组件，并将它们作为属性向下传递。\r\n这意味着子组件可以触发其父组件中的状态更改，这将更新树中的所有其他组件。\r\n\r\n![Alt](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/24/15fec0fa567406fc~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)\r\n\r\n### 阶段三\r\n随着添加了更多的功能和组件，我们的应用程序状态流程开始看起来像这样...\r\n状态需要跨多个组件向下传递。\r\n如果您开始遇到上述某些问题，则可能意味着您应该使用 Redux 了。\r\n\r\n![Alt](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/24/15fec0fe0baebb20~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)\r\n\r\n### 使用 Redux 后\r\n状态变成了这样：\r\n\r\n![Alt](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/24/15fec100e3242019~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)\r\n\r\n### 总结\r\n如果您的应用符合以下某些条件，那么我认为应该立即使用 Redux：\r\n\r\n- UI 可以根据应用程序状态显着变化。\r\n- 并不总是以一种线性的，单向的方式流动。\r\n- 许多不相关的组件以相同的方式更新状态。\r\n- 状态树并不简单。\r\n- 状态以许多不同的方式更新。\r\n- 您需要能够撤消以前的用户操作。"}]},{"number":82,"title":"【Q082】react-redux 是干什么的","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/82","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. Redux 是什么\r\n`Redux` 是一个使用叫做 “action” 的事件来管理和更新应用状态的模式和工具库。\r\n它以集中式 `Store`（centralized store）的方式对整个应用中使用的状态进行集中管理，\r\n其规则确保状态只能以可预测的方式更新。\r\n\r\n## 2. 为什么要使用 Redux\r\n`Redux` 帮你管理“全局”状态 - 应用程序中的很多组件都需要的状态。\r\n`Redux` 提供的模式和工具使你更容易理解应用程序中的状态何时、何地、为什么、state 如何被更新，\r\n以及当这些更改发生时你的应用程序逻辑将如何表现. Redux 指导你编写可预测和可测试的代码，\r\n这有助于你确信你的应用程序将按预期工作。\r\n\r\n## 3. 我什么时候应该使用 Redux？\r\n`Redux` 可帮助你处理共享状态的管理，但与任何工具一样，它也需要权衡利弊。\r\n使用 `Redux` 有更多的概念需要学习，还有更多的代码需要编写，需要添加了一些额外代码，并要求你遵循某些限制。\r\n这是短期和长期生产力之间的权衡。\r\n\r\n在以下情况下使用 Redux：\r\n\r\n- 应用中有很多 state 在多个组件中需要使用\r\n- 应用 state 会随着时间的推移而频繁更新\r\n- 更新 state 的逻辑很复杂\r\n- 中型和大型代码量的应用，很多人协同开发\r\n\r\n### 并非所有应用程序都需要 `Redux`。\r\n 花一些时间思考你正在构建的应用程序类型，并决定哪些工具最能帮助解决你正在处理的问题。\r\n \r\n ## 4. Redux 库和工具\r\n `Redux` 是一个小型的独立 JS 库。 但是，它通常与其他几个包一起使用：\r\n\r\n### React-Redux\r\n`Redux` 可以集成到任何的 UI 框架中，其中最常见的是 React 。\r\n[React-Redux](https://react-redux.js.org/) 是官方包，\r\n它可以让 React 组件访问 state 片段和 dispatch actions 更新 store，从而同 Redux 集成起来。\r\n\r\n### Redux Toolkit\r\n[Redux Toolkit](https://redux-toolkit.js.org/) 是我们推荐的编写 `Redux` 逻辑的方法。\r\n它包含我们认为对于构建 `Redux` 应用程序必不可少的包和函数。 \r\n`Redux Toolkit` 构建是我们建议的最佳实践中，简化了大多数 Redux 任务，预防了常见错误，并使编写 `Redux` 应用程序变得更加容易。\r\n\r\n### Redux DevTools 扩展\r\n[Redux DevTools 扩展](https://github.com/zalmoxisus/redux-devtools-extension) 可以显示 Redux 存储中状态随时间变化的历史记录。\r\n这允许你有效地调试应用程序，包括使用强大的技术，如“时间旅行调试”。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 5. Redux 概念\r\n在我们深入研究一些实际代码之前，让我们先谈谈使用 Redux 需要了解的一些术语和概念。\r\n\r\n### State 管理\r\n让我们从一个小的 React 计数器组件开始。 它跟踪组件状态中的数字，并在单击按钮时增加数字：\r\n```javascript\r\nfunction Counter() {\r\n  // State: counter 值\r\n  const [counter, setCounter] = useState(0)\r\n\r\n  // Action: 当事件发生后，触发状态更新的代码\r\n  const increment = () => {\r\n    setCounter(prevCounter => prevCounter + 1)\r\n  }\r\n\r\n  // View: 视图定义\r\n  return (\r\n    <div>\r\n      Value: {counter} <button onClick={increment}>Increment</button>\r\n    </div>\r\n  )\r\n}\r\n```\r\n\r\n这是一个包含以下部分的自包含应用程序：\r\n\r\n- **state**：驱动应用的真实数据源头\r\n- **view**：基于当前状态的视图声明性描述\r\n- **actions**：根据用户输入在应用程序中发生的事件，并触发状态更新\r\n\r\n接下来简要介绍 **单向数据流**（one-way data flow）:\r\n\r\n- 用 state 来描述应用程序在特定时间点的状况\r\n- 基于 state 来渲染出 View\r\n- 当发生某些事情时（例如用户单击按钮），state 会根据发生的事情进行更新，生成新的 state\r\n- 基于新的 state 重新渲染 View\r\n\r\n![Alt](https://cn.redux.js.org/assets/images/one-way-data-flow-04fe46332c1ccb3497ecb04b94e55b97.png)\r\n\r\n然而，当我们有 **多个组件需要共享和使用相同 state **时，可能会变得很复杂，尤其是当这些组件位于应用程序的不同部分时。\r\n有时这可以通过 [\"提升 state\"](https://reactjs.org/docs/lifting-state-up.html) 到父组件来解决，但这并不总是有效。\r\n\r\n解决这个问题的一种方法是从组件中提取共享 state，并将其放入组件树之外的一个集中位置。\r\n这样，我们的组件树就变成了一个大“view”，任何组件都可以访问 state 或触发 action，无论它们在树中的哪个位置！\r\n\r\n通过定义和分离 state 管理中涉及的概念并强制执行维护 view 和 state 之间独立性的规则，代码变得更结构化和易于维护。\r\n\r\n这就是 Redux 背后的基本思想：应用中使用集中式的全局状态来管理，并明确更新状态的模式，以便让代码具有可预测性。\r\n\r\n### 不可变性 Immutability\r\n\"Mutable\" 意为 \"可改变的\"，而 \"immutable\" 意为永不可改变。\r\n\r\nJavaScript 的对象（object）和数组（array）默认都是 mutable 的。如果我创建一个对象，我可以更改其字段的内容。如果我创建一个数组，我也可以更改内容：\r\n```javascript\r\nconst obj = { a: 1, b: 2 }\r\n// 对外仍然还是那个对象，但它的内容已经变了\r\nobj.b = 3\r\n\r\nconst arr = ['a', 'b']\r\n// 同样的，数组的内容改变了\r\narr.push('c')\r\narr[1] = 'd'\r\n```\r\n\r\n这就是 改变 对象或数组的例子。内存中还是原来对象或数组的引用，但里面的内容变化了。\r\n\r\n#### 如果想要不可变的方式来更新，代码必需先复制原来的 object/array，然后更新它的复制体。\r\n\r\nJavaScript array/object 的展开运算符（spread operator）可以实现这个目的：\r\n```javascript\r\nconst obj = {\r\n  a: {\r\n    // 为了安全的更新 obj.a.c，需要先复制一份\r\n    c: 3\r\n  },\r\n  b: 2\r\n}\r\n\r\nconst obj2 = {\r\n  // obj 的备份\r\n  ...obj,\r\n  // 覆盖 a\r\n  a: {\r\n    // obj.a 的备份\r\n    ...obj.a,\r\n    // 覆盖 c\r\n    c: 42\r\n  }\r\n}\r\n\r\nconst arr = ['a', 'b']\r\n// 创建 arr 的备份，并把 c 拼接到最后。\r\nconst arr2 = arr.concat('c')\r\n\r\n// 或者，可以对原来的数组创建复制体\r\nconst arr3 = arr.slice()\r\n// 修改复制体\r\narr3.push('c')\r\n```\r\n\r\n#### Redux 期望所有状态更新都是使用不可变的方式。 "},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 6. Redux 术语\r\n在我们继续之前，你需要熟悉一些重要的 Redux 术语：\r\n\r\n### Action\r\n`action` 是一个具有 `type` 字段的普通 JavaScript 对象。\r\n#### 你可以将 `action` 视为描述应用程序中发生了什么的事件。\r\n\r\n`type` 字段是一个字符串，给这个 action 一个描述性的名字，比如 `todos/todoAdded`。\r\n我们通常把那个类型的字符串写成“域/事件名称”，其中第一部分是这个 action 所属的特征或类别，第二部分是发生的具体事情。\r\n\r\naction 对象可以有其他字段，其中包含有关发生的事情的附加信息。\r\n按照惯例，我们将该信息放在名为 `payload` 的字段中。\r\n\r\n一个典型的 action 对象可能如下所示：\r\n```javascript\r\nconst addTodoAction = {\r\n  type: 'todos/todoAdded',\r\n  payload: 'Buy milk'\r\n}\r\n```\r\n\r\n### Action Creator\r\n`action creator` 是一个创建并返回一个 action 对象的函数。它的作用是让你不必每次都手动编写 action 对象：\r\n```javascript\r\nconst addTodo = text => {\r\n  return {\r\n    type: 'todos/todoAdded',\r\n    payload: text\r\n  }\r\n}\r\n```\r\n\r\n### Reducer\r\n`reducer` 是一个函数，接收当前的 state 和一个 action 对象，必要时决定如何更新状态，并返回新状态。\r\n语法是：`(state, action) => newState`。\r\n#### 你可以将 reducer 视为一个事件监听器，它根据接收到的 action（事件）类型处理事件。\r\n\r\nReducer 必需符合以下规则：\r\n\r\n- 仅使用 state 和 action 参数计算新的状态值\r\n- 禁止直接修改 state。必须通过复制现有的 state 并对复制的值进行更改的方式来做 不可变更新（immutable updates）。\r\n- 禁止任何异步逻辑、依赖随机值或导致其他“副作用”的代码\r\n\r\nreducer 函数内部的逻辑通常遵循以下步骤：\r\n\r\n- 检查 reducer 是否关心这个 action\r\n- 如果是，则复制 state，使用新值更新 state 副本，然后返回新 state\r\n- 否则，返回原来的 state 不变\r\n\r\n下面是 reducer 的小例子，展示了每个 reducer 应该遵循的步骤：\r\n```javascript\r\nconst initialState = { value: 0 }\r\n\r\nfunction counterReducer(state = initialState, action) {\r\n  // 检查 reducer 是否关心这个 action\r\n  if (action.type === 'counter/increment') {\r\n    // 如果是，复制 `state`\r\n    return {\r\n      ...state,\r\n      // 使用新值更新 state 副本\r\n      value: state.value + 1\r\n    }\r\n  }\r\n  // 返回原来的 state 不变\r\n  return state\r\n}\r\n```\r\n\r\nReducer 可以在内部使用任何类型的逻辑来决定新状态应该是什么，如 if/else、switch、循环等等。\r\n\r\n### Store\r\n当前 Redux 应用的 state 存在于一个名为 `store` 的对象中。\r\n\r\nstore 是通过传入一个 reducer 来创建的，并且有一个名为 getState 的方法，它返回当前状态值：\r\n```javascript\r\nimport { configureStore } from '@reduxjs/toolkit'\r\n\r\nconst store = configureStore({ reducer: counterReducer })\r\n\r\nconsole.log(store.getState())\r\n// {value: 0}\r\n```\r\n\r\n### Dispatch\r\nRedux store 有一个方法叫 `dispatch`。\r\n#### 更新 state 的唯一方法是调用 `store.dispatch()` 并传入一个 action 对象。 \r\nstore 将执行所有 reducer 函数并计算出更新后的 state，调用 `getState()` 可以获取新 state。\r\n```javascript\r\nstore.dispatch({ type: 'counter/increment' })\r\n\r\nconsole.log(store.getState())\r\n// {value: 1}\r\n```\r\n\r\n#### dispatch 一个 action 可以形象的理解为 \"触发一个事件\"。\r\n发生了一些事情，我们希望 store 知道这件事。 \r\nReducer 就像事件监听器一样，当它们收到关注的 action 后，它就会更新 state 作为响应。\r\n\r\n我们通常调用 action creator 来调用 action：\r\n```javascript\r\nconst increment = () => {\r\n  return {\r\n    type: 'counter/increment'\r\n  }\r\n}\r\n\r\nstore.dispatch(increment())\r\n\r\nconsole.log(store.getState())\r\n// {value: 2}\r\n```\r\n\r\n### Selector\r\nSelector 函数可以从 store 状态树中提取指定的片段。\r\n随着应用变得越来越大，会遇到应用程序的不同部分需要读取相同的数据，selector 可以避免重复这样的读取逻辑：\r\n```javascript\r\nconst selectCounterValue = state => state.value\r\n\r\nconst currentValue = selectCounterValue(store.getState())\r\nconsole.log(currentValue)\r\n// 2\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 7. 总结\r\n\r\n### Redux 是一个管理全局应用状态的库\r\n\r\n- Redux 通常与 React-Redux 库一起使用，把 Redux 和 React 集成在一起\r\n- Redux Toolkit 是编写 Redux 逻辑的推荐方式\r\n\r\n### Redux 使用 \"单向数据流\"\r\n\r\n- State 描述了应用程序在某个时间点的状态，视图基于该 state 渲染\r\n- 当应用程序中发生某些事情时：\r\n\r\n  - 视图 dispatch 一个 action\r\n  - store 调用 reducer，随后根据发生的事情来更新 state\r\n  - store 将 state 发生了变化的情况通知 UI\r\n\r\n- 视图基于新 state 重新渲染\r\n\r\n### Redux 有这几种类型的代码\r\n\r\n- Action 是有 type 字段的纯对象，描述发生了什么\r\n- Reducer 是纯函数，基于先前的 state 和 action 来计算新的 state\r\n- 每当 dispatch 一个 action 后，store 就会调用 root reducer"}]},{"number":83,"title":"【Q083】react-redux connect 实现原理","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/83","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. connect 的作用\r\n`connect` 和 `Provider` 将 react 和 redux 连接起来。\r\n\r\n- **connect**：用于创建容器组件，可以使容器组件访问到 `Provider` 组件通过 `context` 提供的 `store`，\r\n并将 `mapStateToProps` 和 `mapDispatchToProps` 返回的 `state` 和 `dispatch`传递给UI组件。\r\n- **Provider**：通过 `context` 向子组件提供 `store`。\r\n\r\n## 2. connect 和 Provider 的使用\r\n全局注册：\r\n```javascript\r\n// App.jsx\r\nimport React from 'react'\r\nimport { render } from 'react-dom'\r\nimport { Provider } from 'react-redux'\r\nimport createStore from 'redux'\r\nimport reducer from './reducers'\r\nimport Container from './Container'\r\n\r\nconst store = createStore(reducer)\r\nconst App = () => {\r\n    return (\r\n        <Provider store={store}>\r\n            <Container />\r\n        </Provider>\r\n    )\r\n}\r\n\r\nrender(<App />, document.getElementById('app'))\r\n```\r\n\r\n组件套容器：\r\n```javascript\r\n// Container.jsx\r\nimport React from 'react'\r\nimport { connect } from 'react-redux'\r\n\r\nconst mapStateToProps = (state, ownProps) => ({})\r\n\r\nconst mapDispatchToProps = (dispatch, ownProps) => ({})\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(Demo)\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 3. Provider 源码解析\r\n`Provider` 组件在 `Provider.js` 里面定义，仅有短短几十行代码，核心代码如下：\r\n```javascript\r\nimport { ReactReduxContext } from './Context';\r\n\r\nfunction Provider(_ref) {\r\n  var store = _ref.store, // 获取组件绑定的store\r\n      context = _ref.context,\r\n      children = _ref.children; // 获取子组件\r\n  // contextValue的值为{store， subscription}\r\n  var contextValue = useMemo(function () {\r\n    var subscription = new Subscription(store);\r\n    subscription.onStateChange = subscription.notifyNestedSubs;\r\n    return {\r\n      store: store,\r\n      subscription: subscription\r\n    };\r\n  }, [store]);\r\n  var previousState = useMemo(function () {\r\n    return store.getState();\r\n  }, [store]);\r\n  useEffect(function () {\r\n    var subscription = contextValue.subscription;\r\n    subscription.trySubscribe();\r\n\r\n    if (previousState !== store.getState()) {\r\n      subscription.notifyNestedSubs();\r\n    }\r\n\r\n    return function () {\r\n      subscription.tryUnsubscribe();\r\n      subscription.onStateChange = null;\r\n    };\r\n  }, [contextValue, previousState]);\r\n  // 如果Provider组件上绑定了context就是用绑定的context，如果没有绑定context，就会自己生成context\r\n  // children为嵌套在Provider里层的子组件\r\n  var Context = context || ReactReduxContext;\r\n  return React.createElement(Context.Provider, {\r\n    value: contextValue\r\n  }, children);\r\n}\r\n\r\nexport default Provider;\r\n```\r\n\r\n我们看看这部分代码，如果 `Provider` 组件上绑定了 `context` 就是用绑定的 `context`，\r\n如果没有绑定 `context`，就会自己生成 `context`。\r\n```javascript\r\nvar Context = context || ReactReduxContext;\r\nreturn React.createElement(Context.Provider, {\r\n    value: contextValue\r\n}, children);\r\n```\r\n\r\n`ReactReduxContext` 的生成在 `Context.js` 中：\r\n```javascript\r\nimport React from 'react';\r\nexport var ReactReduxContext =\r\n/*#__PURE__*/\r\nReact.createContext(null);\r\n\r\nif (process.env.NODE_ENV !== 'production') {\r\n  ReactReduxContext.displayName = 'ReactRedux';\r\n}\r\n\r\nexport default ReactReduxContext;\r\n```\r\n\r\n有了 `context` 就可以向子组件提供 `store`。\r\n```javascript\r\n<Provider store={store}>\r\n    <Container />\r\n</Provider>\r\n\r\n// 等价于\r\n\r\n<Provider store={store}>\r\n    <Context.Provider value={{value: contextValue}}>\r\n        <Container />\r\n    </Context.Provider>\r\n</Provider>\r\n```\r\n\r\n打开 react devtool 可以看到最外层组件为 `<Provider>`，里层的子组件由 `<ReactRedux.Provider>` 组件包裹\r\n\r\n![Alt](https://image-static.segmentfault.com/185/773/1857735591-5eb36548abe49_fix732)"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 4. connect 源码解析\r\n`connect` 使用方式如下：\r\n```javascript\r\nconnect(mapStateToProps, mapDispatchToProps)(Demo)\r\n```\r\n\r\n可以猜想到 `connect(mapStateToProps, mapDispatchToProps)` 这部分将返回一个高阶组件，\r\n这个高阶组件的作用就是将 `mapStateToProps` 返回的 `state` 和 `mapDispatchToProps` 返回的 `dispatch` 通过 `props` 传递给`Demo`。\r\n我们通过源码来验证一下猜想是否正确。\r\n\r\n`connect` 函数在 `connect.js` 中实现，函数大概就是如下样子：\r\n```javascript\r\nexport function createConnect(_temp) {\r\n  // coding...\r\n  return function connect(mapStateToProps, mapDispatchToProps, mergeProps, _ref2) {\r\n    // coding...\r\n    return connectHOC(selectorFactory, options);\r\n  };\r\n}\r\nexport default createConnect();\r\n```\r\n\r\n`connectHOC` 函数执行返回的是一个 **高阶组件** `wrapWithConnect(WrappedComponent)`，\r\n它在 `connectAdvanced.js` 中实现，`connectAdvanced` 函数就是 `connectHOC`。\r\n\r\n```javascript\r\nexport default function connectAdvanced(selectorFactory, _ref) {\r\n  // coding...\r\n  return function wrapWithConnect(WrappedComponent) {\r\n    // coding...\r\n    function createChildSelector(store) {\r\n      return selectorFactory(store.dispatch, selectorFactoryOptions);\r\n    }\r\n    // coding...\r\n    function ConnectFunction(props) {\r\n      // coding...\r\n      \r\n      // 获取context对象\r\n      var ContextToUse = useMemo(function () {\r\n        return propsContext && propsContext.Consumer && isContextConsumer(React.createElement(propsContext.Consumer, null)) ? propsContext : Context;\r\n      }, [propsContext, Context]); \r\n      \r\n      // 获取Context.Provider绑定的value值{store，subscription}\r\n      var contextValue = useContext(ContextToUse);\r\n      \r\n      // 获取store\r\n      var store = didStoreComeFromProps ? props.store : contextValue.store;\r\n      // childPropsSelector返回一个函数（），接受store.getState()和props\r\n      var childPropsSelector = useMemo(function () {\r\n        return createChildSelector(store);\r\n      }, [store]);\r\n      \r\n      // 这里执行childPropsSelector，将store.getState()和props传递进去，然后mapStateToProps接受到state和props，至于dispatch，在执行selectorFactory(store.dispatch, selectorFactoryOptions);就传递进去了。\r\n      var actualChildProps = usePureOnlyMemo(function () {\r\n        if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {\r\n          return childPropsFromStoreUpdate.current;\r\n        }\r\n        return childPropsSelector(store.getState(), wrapperProps);\r\n      }, [store, previousStateUpdateResult, wrapperProps]);\r\n      \r\n      // actualChildProps得到的就是mapStateToProps返回的state，把它放在props中传递给UI组件\r\n      var renderedWrappedComponent = useMemo(function () {\r\n        return React.createElement(WrappedComponent, _extends({}, actualChildProps, {\r\n          ref: forwardedRef\r\n        }));\r\n      }, [forwardedRef, WrappedComponent, actualChildProps]);\r\n      \r\n      \r\n      var renderedChild = useMemo(function () {\r\n        // shouldHandleStateChanges控制是否应该订阅redux store中的state变化。\r\n        if (shouldHandleStateChanges) {\r\n          // 订阅redux store中的state变化，返回ContextToUse.Provider嵌套组件\r\n          return React.createElement(ContextToUse.Provider, {\r\n            value: overriddenContextValue\r\n          }, renderedWrappedComponent);\r\n        }\r\n        // 不需要订阅redux store中的state变化就直接返回UI组件\r\n        return renderedWrappedComponent;\r\n      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);\r\n      return renderedChild;\r\n    }\r\n    // React.memo用于创建一个纯函数组件，跟PureComponent一样，但React.memo作用于function component，而PureComponent作用于class component。使用纯函数组件最大的作用就是只有props变化时组件才会重新渲染，可以提高渲染性能。\r\n    var Connect = pure ? React.memo(ConnectFunction) : ConnectFunction;\r\n    Connect.WrappedComponent = WrappedComponent;\r\n    Connect.displayName = displayName;\r\n\r\n    if (forwardRef) {\r\n      var forwarded = React.forwardRef(function forwardConnectRef(props, ref) {\r\n        return React.createElement(Connect, _extends({}, props, {\r\n          forwardedRef: ref\r\n        }));\r\n      });\r\n      forwarded.displayName = displayName;\r\n      forwarded.WrappedComponent = WrappedComponent;\r\n      return hoistStatics(forwarded, WrappedComponent);\r\n    }\r\n    // hoistStatics是hoist-non-react-statics包的导出，用于将组件中非react自带的静态方法复制到另一个组件。该包一般用于定义HOC中，因为当你给一个组件添加一个HOC时，原来的组件会被一个container的组件包裹，这意味着新的组件不会有原来组件任何静态方法。参考：https://zhuanlan.zhihu.com/p/36178509\r\n    return hoistStatics(Connect, WrappedComponent);\r\n  };\r\n}\r\n```\r\n\r\n`connectHOC(selectorFactory, options)` 中 `selectorFactory` 函数传递到 `connectAdvanced(selectorFactory, _ref)` 中，\r\n在 `ConnectFunction(props)` 函数组件中调用 `createChildSelector(store)`，\r\n然后调用 `selectorFactory(store.dispatch, selectorFactoryOptions)`。\r\n`selectorFactory` 函数是 `connect` 中的核心API，它的实现在 `selectorFactory.js` 文件中：\r\n```javascript\r\nexport default function finalPropsSelectorFactory(dispatch, _ref2) {\r\n  var initMapStateToProps = _ref2.initMapStateToProps,\r\n      initMapDispatchToProps = _ref2.initMapDispatchToProps,\r\n      initMergeProps = _ref2.initMergeProps,\r\n      options = _objectWithoutPropertiesLoose(_ref2, [\"initMapStateToProps\", \"initMapDispatchToProps\", \"initMergeProps\"]);\r\n\r\n  var mapStateToProps = initMapStateToProps(dispatch, options);\r\n  var mapDispatchToProps = initMapDispatchToProps(dispatch, options);\r\n  var mergeProps = initMergeProps(dispatch, options);\r\n\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps, options.displayName);\r\n  }\r\n\r\n  var selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory;\r\n  // \r\n  return selectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);\r\n}\r\n```\r\n\r\n`pureFinalPropsSelectorFactory` 函数实现：\r\n```javascript\r\nexport function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, _ref) {\r\n  var areStatesEqual = _ref.areStatesEqual,\r\n      areOwnPropsEqual = _ref.areOwnPropsEqual,\r\n      areStatePropsEqual = _ref.areStatePropsEqual;\r\n  var hasRunAtLeastOnce = false;\r\n  var state;\r\n  var ownProps;\r\n  var stateProps;\r\n  var dispatchProps;\r\n  var mergedProps;\r\n\r\n  function handleFirstCall(firstState, firstOwnProps) {\r\n    state = firstState;\r\n    ownProps = firstOwnProps;\r\n    stateProps = mapStateToProps(state, ownProps);\r\n    dispatchProps = mapDispatchToProps(dispatch, ownProps);\r\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\r\n    hasRunAtLeastOnce = true;\r\n    return mergedProps;\r\n  }\r\n\r\n  function handleNewPropsAndNewState() {}\r\n\r\n  function handleNewProps() {}\r\n\r\n  function handleNewState() {}\r\n\r\n  function handleSubsequentCalls(nextState, nextOwnProps) {\r\n  // coding...\r\n  return function pureFinalPropsSelector(nextState, nextOwnProps) {\r\n    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);\r\n  };\r\n}\r\n```\r\n\r\n`selectorFactory` 的作用就是将连接 `store` 的 `ConnectFunction` 组件中获取的 `state`、`props` 传递给 `MapStateToProps` 和将获取的 `dispatch` 传递给 `mapDispatchToProps`。\r\n然后 `MapStateToProps` 和 `mapDispatchToProps` 的返回值会在 `ConnectFunction` 组件中使用 `props` 传递给UI组件。\r\n\r\n`wrapWithConnect(WrappedComponent)` 返回一个新的、连接到 `store` 的 `ConnectFunction(props)` 函数组件，\r\n该组件内部会根据 `shouldHandleStateChanges` 字段判断是否需要监听 `redux store` 中 `state` 的变化，\r\n如果需要就返回 `ContextToUse.Provider` 包裹UI组件的子组件。\r\n`ContextToUse.Provider` 为组组件提供重新构造的 `overriddenContextValue`，如果不需要监听 `redux store` 中 `state` 的变化，就返回UI组件为子组件。\r\n就如第一部分内容例子，`Brother` 组件不需要 `state`，`Sister` 组件需要 `state`，\r\n那么 `Sister` 组件就会用 `ContextToUse.Provider` 包裹着。整个组件架构就变成如下样子：\r\n\r\n![Alt](https://image-static.segmentfault.com/378/550/3785504273-5eb3706261029_fix732)"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 5. 总结\r\n`connect` 的作用是连接 React 组件与 `Redux store`，它包在我们的容器组件的外一层，它接收上面 `Provider` 提供的 `store` 里面的 `state` 和 `dispatch`，传给一个构造函数，返回一个对象，以属性形式传给我们的容器组件。\r\n\r\n它共有四个参数：\r\n\r\n- mapStateToProps\r\n- mapDispatchToProps\r\n- mergeProps\r\n- options\r\n\r\n`mapStateToProps` 的作用是将 `store` 里的 `state` 绑定到指定组件的 `props` 中。\r\n`mapDispatchToProps` 的作用是将 `store` 里的 `action` 绑定到指定组件的 `props` 中。"}]},{"number":84,"title":"【Q084】redux 工作流程及原理","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/84","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. redux 工作流程\r\n早些时候，我们谈到了“单向数据流”，它描述了更新应用程序的以下步骤序列：\r\n\r\n- State 描述了应用程序在特定时间点的状况\r\n- 基于 state 来渲染视图\r\n- 当发生某些事情时（例如用户单击按钮），state 会根据发生的事情进行更新\r\n- 基于新的 state 重新渲染视图\r\n\r\n具体来说，对于 Redux，我们可以将这些步骤分解为更详细的内容：\r\n- 初始启动：\r\n\r\n  - 使用最顶层的 root reducer 函数创建 Redux store\r\n  - store 调用一次 root reducer，并将返回值保存为它的初始 state\r\n  - 当视图 首次渲染时，视图组件访问 Redux store 的当前 state，并使用该数据来决定要呈现的内容。同时监听 store 的更新，以便他们可以知道 state 是否已更改。\r\n\r\n- 更新环节：\r\n\r\n  - 应用程序中发生了某些事情，例如用户单击按钮\r\n  - dispatch 一个 action 到 Redux store，例如 dispatch({type: 'counter/increment'})\r\n  - store 用之前的 state 和当前的 action 再次运行 reducer 函数，并将返回值保存为新的 state\r\n  - store 通知所有订阅过的视图，通知它们 store 发生更新\r\n  - 每个订阅过 store 数据的视图 组件都会检查它们需要的 state 部分是否被更新。\r\n  - 发现数据被更新的每个组件都强制使用新数据重新渲染，紧接着更新网页\r\n  \r\n动画的方式来表达数据流更新：\r\n![Alt](https://cn.redux.js.org/assets/images/ReduxDataFlowDiagram-49fa8c3968371d9ef6f2a1486bd40a26.gif)"}]},{"number":85,"title":"【Q085】有没有用过其它状态管理器？以及原理","labels":["react"],"body":"mobx","url":"https://github.com/kangyana/daily-question/issues/85","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. dva\r\n`dva` 是一个基于 `redux` 和 `redux-saga`  的数据流方案。\r\n\r\n### 为什么不使用 redux？\r\n- 编辑成本高，需要在 `reducer`, `saga`, `action` 之间来回切换。\r\n- 不便于组织业务模型 。比如写相似的业务页面，需要复制很多文件。\r\n- `saga` 使用太复杂，每监听一个 `action` 都需要走 `fork` -> `watcher` -> `worker` 的流程。\r\n- `entry` 使用麻烦。\r\n\r\n`dva` 正是用于解决这些问题。\r\n\r\n### dva 原理\r\n`dva` 是基于 `redux` + `redux-saga` 的一层轻量封装，没有引入任何新概念，全部代码不到 100 行。\r\n\r\n核心功能是提供了 `app.model` 方法，用于把 `reducer`, `initialState`, `action`, `saga` 封装到一起，例如：\r\n```javascript\r\napp.model({\r\n  namespace: 'products',\r\n  state: {\r\n    list: [],\r\n    loading: false,\r\n  },\r\n  subscriptions: [\r\n    function(dispatch) {\r\n      dispatch({type: 'products/query'});\r\n    },\r\n  ],\r\n  effects: {\r\n    ['products/query']: function*() {\r\n      yield call(delay(800));\r\n      yield put({\r\n        type: 'products/query/success',\r\n        payload: ['ant-tool', 'roof'],\r\n      });\r\n    },\r\n  },\r\n  reducers: {\r\n    ['products/query'](state) {\r\n      return { ...state, loading: true, };\r\n    },\r\n    ['products/query/success'](state, { payload }) {\r\n      return { ...state, loading: false, list: payload };\r\n    },\r\n  },\r\n});\r\n```\r\n\r\n这对应使用 `redux`时，创建的 `sagas/products.js`, `reducers/products.js` 和 `actions/products.js`。\r\n\r\n介绍下 `model`：\r\n\r\n- **namespace**：对应 `reducer` 在 `combine` 到 `rootReducer` 时的 key 值。\r\n- **state**：对应 `reducer` 的 `initialState`。\r\n- **subscription**：事件监听器。\r\n- **effects**：对应 `saga`，并简化了使用\r\n- **reducers**"}]},{"number":86,"title":"【Q086】react-router 路由实现原理","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/86","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. react-router-dom、react-router、history 三者的关系\r\n\r\n- `history` 是 `react-router` 的核心，也是整个路由原理的核心，里面集成了 `popState`、`history.pushState` 等底层路由实现的原理方法。\r\n- `react-router` 是 `react-router-dom` 的核心，里面封装了 `Router`，`Route`，`Switch` 等核心组件，实现了从路由的改变到组件的更新的核心功能。\r\n- `react-router-dom` 是在 `react-router` 的基础上，添加了用于跳转的 `Link` 组件，和 `histoy` 模式下的 `BrowserRouter` 和 `hash` 模式下的 `HashRouter` 组件等。所谓 `BrowserRouter` 和 `HashRouter`，也只不过用了 `history` 库中 `createBrowserHistory` 和 `createHashHistory` 方法。\r\n\r\n用法如下：\r\n```javascript\r\nimport { BrowserRouter as Router, Switch, Route, Redirect, Link } from 'react-router-dom'\r\n\r\nimport Detail from '../src/page/detail'\r\nimport List from '../src/page/list'\r\nimport Index from '../src/page/home/index'\r\n\r\nconst menusList = [\r\n  {\r\n    name: '首页',\r\n    path: '/index'\r\n  },\r\n  {\r\n    name: '列表',\r\n    path: '/list'\r\n  },\r\n  {\r\n    name: '详情',\r\n    path: '/detail'\r\n  },\r\n]\r\n\r\nconst index = () => {\r\n  return <div>\r\n    <div>\r\n      <Router>\r\n        <div>\r\n          {menusList.map((router) => (\r\n            <Link key={router.path} to={router.path}>\r\n              {router.name}\r\n            </Link>\r\n          )}\r\n        </div>\r\n        <Switch>\r\n          <Route path={'/index'} component={Index} />\r\n          <Route path={'/list'} component={List} />\r\n          <Route path={'/detail'} component={Detail} />\r\n          <Redirect from='/*' to='/index' />\r\n        </Switch>\r\n      </Router>\r\n    </div>\r\n  </div>\r\n}\r\n```\r\n\r\n效果如下：\r\n\r\n![Alt](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3eac570169a4480598001f601ef374d5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)\r\n\r\n## 2. 单页面实现核心原理\r\n单页面应用路由实现原理是，切换url，监听url变化，从而渲染不同的页面组件。\r\n主要的方式有 `history` 模式和 `hash` 模式。\r\n\r\n### history 模式原理\r\n#### ① 改变路由\r\n```javascript\r\nhistory.pushState(state, title, path)\r\n```\r\n- **state**：一个与指定网址相关的状态对象， popstate 事件触发时，该对象会传入回调函数。如果不需要可填 null。\r\n- **title**：新页面的标题，但是所有浏览器目前都忽略这个值，可填 null。\r\n- **path**：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个地址。\r\n\r\n```javascript\r\nhistory.replaceState(state, title, path)\r\n```\r\n参数和 `pushState` 一样，这个方法会修改当前的 `history` 对象记录， `history.length` 的长度不会改变。\r\n\r\n#### ② 监听路由\r\n```javascript\r\nwindow.addEventListener('popstate', function(e){\r\n    /* 监听改变 */\r\n})\r\n```\r\n\r\n同一个文档的 `history` 对象出现变化时，就会触发 `popstate` 事件。\r\n`history.pushState` 可以使浏览器地址改变，但是无需刷新页面。\r\n\r\n注意：用 `history.pushState()` 或者 `history.replaceState()` 不会触发 `popstate` 事件。\r\n`popstate` 事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮或者调用 `history.back()`、`history.forward()`、`history.go()` 方法。\r\n\r\n### hash 模式原理\r\n#### ① 改变路由\r\n通过 `window.location.hash` 属性获取和设置 `hash` 值。\r\n\r\n#### ② 监听路由\r\n```javascript\r\nwindow.addEventListener('hashchange', function(e){\r\n    /* 监听改变 */\r\n})\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 3. history 库\r\n`react-router` 路由离不开 `history` 库，`history` 专注于记录路由 `history` 状态，以及 `path` 改变了的回调。\r\n在 `history` 模式下用 `popstate` 监听路由变化，在 `hash` 模式下用 `hashchange` 监听路由的变化。\r\n\r\n接下来我们看 `Browser` 模式下的 `createBrowserHistory` 和 `Hash` 模式下的 `createHashHistory` 方法。\r\n\r\n### createBrowserHistory\r\n`Browser` 模式下路由的运行 ，一切都从 `createBrowserHistory` 开始。\r\n在解析 `history` 过程中，我们重点关注 `setState`、`push`、`handlePopState`、`listen` 方法：\r\n\r\n```javascript\r\nconst PopStateEvent = 'popstate'\r\nconst HashChangeEvent = 'hashchange'\r\n/* 这里简化了createBrowserHistory，列出了几个核心api及其作用 */\r\nfunction createBrowserHistory(){\r\n    /* 全局history  */\r\n    const globalHistory = window.history\r\n    /* 处理路由转换，记录了listens信息。 */\r\n    const transitionManager = createTransitionManager()\r\n    /* 改变location对象，通知组件更新 */\r\n    const setState = () => { /* ... */ }\r\n    \r\n    /* 处理当path改变后，处理popstate变化的回调函数 */\r\n    const handlePopState = () => { /* ... */ }\r\n   \r\n    /* history.push方法，改变路由，通过全局对象history.pushState改变url, 通知router触发更新，替换组件 */\r\n    const push=() => { /*...*/ }\r\n    \r\n    /* 底层应用事件监听器，监听popstate事件 */\r\n    const listen=()=>{ /*...*/ } \r\n    return {\r\n       push,\r\n       listen,\r\n       /* .... */ \r\n    }\r\n}\r\n```\r\n\r\n下面逐一分析各个api，和他们之前的相互作用。\r\n\r\n```javascript\r\nconst PopStateEvent = 'popstate'\r\nconst HashChangeEvent = 'hashchange'\r\n```\r\n\r\n`popstate` 和 `hashchange` 是监听路由变化底层方法。\r\n\r\n#### setState\r\n```javascript\r\nconst setState = (nextState) => {\r\n    /* 合并信息 */\r\n    Object.assign(history, nextState)\r\n    history.length = globalHistory.length\r\n    /* 通知每一个listens 路由已经发生变化 */\r\n    transitionManager.notifyListeners(\r\n      history.location,\r\n      history.action\r\n    )\r\n  }\r\n```\r\n\r\n代码很简单：统一每个 `transitionManager` 管理的 `listener` 路由状态已经更新。\r\n什么时候绑定 `litener`， 我们在接下来的 `React-Router` 代码中会介绍。\r\n\r\n#### listen\r\n```javascript\r\nconst listen = (listener) => {\r\n    /* 添加listen */\r\n    const unlisten = transitionManager.appendListener(listener)\r\n    checkDOMListeners(1)\r\n\r\n    return () => {\r\n      checkDOMListeners(-1)\r\n      unlisten()\r\n    }\r\n}\r\n```\r\n\r\ncheckDOMListeners\r\n```javascript\r\nconst checkDOMListeners = (delta) => {\r\n    listenerCount += delta\r\n    if (listenerCount === 1) {\r\n      addEventListener(window, PopStateEvent, handlePopState)\r\n      if (needsHashChangeListener)\r\n        addEventListener(window, HashChangeEvent, handleHashChange)\r\n    } else if (listenerCount === 0) {\r\n      removeEventListener(window, PopStateEvent, handlePopState)\r\n      if (needsHashChangeListener)\r\n        removeEventListener(window, HashChangeEvent, handleHashChange)\r\n    }\r\n  }\r\n```\r\n\r\n`listen` 本质通过 `checkDOMListeners` 的参数 1 或 -1 来绑定/解绑 `popstate` 事件。\r\n当路由发生改变的时候，调用处理函数 `handlePopState`。\r\n\r\n#### push\r\n```javascript\r\n const push = (path, state) => {\r\n    const action = 'PUSH'\r\n    /* 1 创建location对象 */\r\n    const location = createLocation(path, state, createKey(), history.location)\r\n    /* 确定是否能进行路由转换，还在确认的时候又开始了另一个转变 ,可能会造成异常 */\r\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) => {\r\n      if (!ok)\r\n        return\r\n      const href = createHref(location)\r\n      const { key, state } = location\r\n      if (canUseHistory) {\r\n        /* 改变 url */\r\n        globalHistory.pushState({ key, state }, null, href)\r\n        if (forceRefresh) {\r\n          window.location.href = href\r\n        } else {\r\n          /* 改变 react-router location对象, 创建更新环境 */\r\n          setState({ action, location })\r\n        }\r\n      } else {\r\n        window.location.href = href\r\n      }\r\n    })\r\n  }\r\n```\r\n\r\n`history.push` 流程大致是 生成一个最新的 `location` 对象，\r\n然后通过 `window.history.pushState` 方法改变浏览器当前路由（即当前的 `path`），\r\n最后通过 `setState` 方法通知 `React-Router` 更新，并传递当前的 `location` 对象，\r\n由于这次 url 变化的，是 `history.pushState` 产生的，并不会触发 `popState` 方法，所以需要手动 `setState`，触发组件更新。\r\n\r\n#### handlePopState\r\n最后我们来看看当 `popState` 监听的函数，当 `path` 改变的时候会发生什么：\r\n```javascript\r\n/* 我们简化一下handlePopState */\r\nconst handlePopState = (event)=>{\r\n     /* 获取当前location对象 */\r\n    const location = getDOMLocation(event.state)\r\n    const action = 'POP'\r\n\r\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) => {\r\n        if (ok) {\r\n          setState({ action, location })\r\n        } else {\r\n          revertPop(location)\r\n        }\r\n    })\r\n}\r\n```\r\n\r\n`handlePopState` 代码很简单 ，判断一下 `action` 类型为 `pop`，然后 `setState` ，刷新组件。\r\n\r\n### createHashHistory\r\n`hash` 模式和 `history API` 类似，我们重点讲一下 `hash` 模式下，怎么监听路由和 `push`、`replace` 方法是怎么改变路径的。\r\n\r\n#### ① 监听路由\r\n```javascript\r\n  const HashChangeEvent = 'hashchange'\r\n  const checkDOMListeners = (delta) => {\r\n    listenerCount += delta\r\n    if (listenerCount === 1) {\r\n      addEventListener(window, HashChangeEvent, handleHashChange)\r\n    } else if (listenerCount === 0) {\r\n      removeEventListener(window, HashChangeEvent, handleHashChange)\r\n    }\r\n  }\r\n```\r\n\r\n和之前所说的一样，就是用 `hashchange` 来监听 `hash` 路由的变化。\r\n\r\n#### ② 改变路由\r\n```javascript\r\n\r\n/* 对应 push 方法 */\r\nconst pushHashPath = (path) =>\r\n  window.location.hash = path\r\n\r\n/* 对应replace方法 */\r\nconst replaceHashPath = (path) => {\r\n  const hashIndex = window.location.href.indexOf('#')\r\n\r\n  window.location.replace(\r\n    window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path\r\n  )\r\n}\r\n```\r\n\r\n在 `hash` 模式下，`history.push` 底层是调用了 `window.location.href` 来改变路由。\r\n`history.replace` 底层是掉用 `window.location.replace` 改变路由。\r\n\r\n### history 库整体流程\r\n\r\n![Alt](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac7ed7a701714650b55c9193db2220ea~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 4. 总结\r\n`history` 提供了核心api，如监听路由，更改路由的方法，已经保存路由状态 `state`。\r\n`react-router` 提供路由渲染组件，路由唯一性匹配组件，重定向组件等功能组件。\r\n\r\n### 经典八股文\r\n### 当地址栏改变url，组件的更新渲染都经历了什么？\r\n拿 `history` 模式做参考。\r\n当 url 改变，首先触发 `histoy`，调用事件监听 `popstate` 事件， 触发回调函数 `handlePopState`，\r\n触发`history` 下面的 `setstate` 方法，产生新的 `location` 对象，\r\n然后通知 `Router` 组件更新 `location` 并通过 `context` 上下文传递，\r\n`switch` 通过传递的更新流，匹配出符合的 `Route` 组件渲染，\r\n最后 `Route` 组件取出 `context` 内容，传递给渲染页面，渲染更新。\r\n\r\n### 当我们调用 history.push 方法，切换路由，组件的更新渲染又都经历了什么呢？\r\n拿 `history` 模式做参考。\r\n当我们调用 `history.push` 方法，首先调用 `history` 的 `push` 方法，通过 `history.pushState` 来改变当前 url，\r\n接下来触发 `history` 下面的 `setState` 方法，接下来的步骤同上。\r\n\r\n用一幅图来表示各个路由组件之间的关系。\r\n\r\n![Alt](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5de251f8dc649e3ae1b1fcf382330ee~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)"}]},{"number":87,"title":"【Q087】react-router 有几种路由类型？","labels":["react"],"body":"每种路由类型实现原理","url":"https://github.com/kangyana/daily-question/issues/87","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. react-router 有几种路由类型？\r\n两种路由类型，`history` 模式和 `hash` 模式。\r\n实现原理参考【Q086】。"}]},{"number":88,"title":"【Q088】项目本地开发完成后部署到服务器后报 404","labels":["react"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/88","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 报 404 原因\r\n单页面应用使用 `BrowserRouter` 的话，如果刷新页面 `Nginx` 会根据页面 url 来发送数据。\r\n但是 `Nginx` 中没有关于该路由的配置，导致找不到文件，因而返回 404 页面。\r\n\r\n## 2. 解决方案\r\n- 配置 `Nginx`，使所有访问重定向到 `index.html`，配置完成之后需要命令行运行 `nginx -s reload` 重启服务器。\r\n- 在项目中使用 `HashRouter`，缺点是不利于SEO，并且会在 url 上加一个 # 符号，具体设置可看业务需求。\r\n\r\n## 3. 为什么 hash 模式下没有问题\r\n`hash` 模式我们都知道是用符号#表示的，如 `website.com/#/login`, `hash` 的值为 `#/login`。\r\n\r\n它的特点在于：`hash` 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对服务端完全没有影响，因此改变 `hash` 不会重新加载页面。\r\n\r\n`hash` 模式下，仅 `hash` 符号之前的内容会被包含在请求中，\r\n如 `website.com/#/login` 只有 `website.com` 会被包含在请求中 ，\r\n因此对于服务端来说，即使没有配置 `location`，也不会返回 404 错误。"}]}],"webpack":[{"number":89,"title":"【Q089】为什么需要 webpack","labels":["webpack"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/89","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 为什么需要 webpack ？\r\n想要理解为什么要使用 `webpack`，我们先回顾下历史，在打包工具出现之前，我们是如何在 web 中使用 JavaScript 的。\r\n\r\n在浏览器中运行 JavaScript 有两种方法：\r\n\r\n- 引用一些脚本来存放每个功能。此解决方案很难扩展，因为加载太多脚本会导致网络瓶颈。\r\n- 使用一个包含所有项目代码的大型 .js 文件。但是这会导致作用域、文件大小、可读性和可维护性方面的问题。\r\n\r\n### 立即调用函数表达式(IIFE) - Immediately invoked function expressions\r\n`IIFE` 解决大型项目的作用域问题。\r\n当脚本文件被封装在 `IIFE` 内部时，你可以安全地拼接或安全地组合所有文件，而不必担心作用域冲突。\r\n\r\n`IIFE` 使用方式产生出 `Make`, `Gulp`, `Grunt`, `Broccoli` 或 `Brunch` 等工具。\r\n这些工具称为任务执行器，它们将所有项目文件拼接在一起。\r\n\r\n但是，修改一个文件意味着必须重新构建整个文件。\r\n拼接可以做到很容易地跨文件重用脚本，但是却使构建结果的优化变得更加困难。\r\n如何判断代码是否实际被使用？\r\n\r\n即使你只用到 `lodash` 中的某个函数，也必须在构建结果中加入整个库，然后将它们压缩在一起。\r\n如何 `treeshake` 代码依赖？\r\n难以大规模地实现延迟加载代码块，这需要开发人员手动地进行大量工作。\r\n\r\n### 感谢 Node.js，JavaScript 模块诞生了\r\nNode.js 是一个 JavaScript 运行时，可以在浏览器环境之外的计算机和服务器中使用。\r\n`webpack` 运行在 Node.js 中。\r\n\r\n当 Node.js 发布时，一个新的时代开始了，它带来了新的挑战。\r\n既然不是在浏览器中运行 JavaScript，现在已经没有了可以添加到浏览器中的 html 文件和 script 标签。\r\n那么 Node.js 应用程序要如何加载新的代码 `chunk` 呢？\r\n\r\n`CommonJS` 问世并引入了 `require` 机制，它允许你在当前文件中加载和使用某个模块。\r\n导入需要的每个模块，这一开箱即用的功能，帮助我们解决了作用域问题。\r\n\r\n### npm + Node.js + modules - 大规模分发模块\r\nJavaScript 已经成为一种语言、一个平台和一种快速开发和创建快速应用程序的方式，接管了整个 JavaScript 世界。\r\n\r\n但 `CommonJS` 没有浏览器支持。\r\n没有 [live binding(实时绑定)](https://medium.com/webpack/the-state-of-javascript-modules-4636d1774358)。\r\n循环引用存在问题。\r\n同步执行的模块解析加载器速度很慢。\r\n虽然 `CommonJS` 是 Node.js 项目的绝佳解决方案，但浏览器不支持模块，\r\n因而产生了 **RequireJS**, `Browserify` 和 `SystemJS` 等打包工具，允许我们编写能够在浏览器中运行的 `CommonJS` 模块。\r\n\r\n### ESM - ECMAScript 模块\r\n来自 Web 项目的好消息是，模块正在成为 ECMAScript 标准的官方功能。\r\n然而，浏览器支持不完整，版本迭代速度也不够快，目前还是推荐上面那些早期模块实现。\r\n\r\n### 依赖自动收集\r\n传统的任务构建工具基于 Google 的 Closure 编译器都要求你手动在顶部声明所有的依赖。\r\n然而像 `webpack` 一类的打包工具自动构建并基于你所引用或导出的内容推断出[依赖图谱](https://webpack.docschina.org/concepts/dependency-graph/)。\r\n这个特性与其它的如[plugins](https://webpack.docschina.org/concepts/plugins/) and [loaders](https://webpack.docschina.org/concepts/loaders/)一道让开发者的体验更好。\r\n\r\n### 看起来都不是很好……\r\n是否可以有一种方式，不仅可以让我们编写模块，而且还支持任何模块格式（至少在我们到达 ESM 之前），并且可以同时处理资源和资产？\r\n\r\n**这就是 `webpack` 存在的原因。**\r\n它是一个工具，可以打包你的 JavaScript 应用程序（支持 ESM 和 CommonJS），可以扩展为支持许多不同的静态资源，例如：`images`, `fonts` 和 `stylesheets`。\r\n\r\n`webpack` 关心性能和加载时间；它始终在改进或添加新功能，例如：异步地加载 `chunk` 和预取，以便为你的项目和用户提供最佳体验。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. webpack\r\n`webpack` 是一个模块的 **打包器**。\r\n它的主要目的是打包 JavaScript 文件以便在浏览器中使用，但它也能够转换、打包或包装几乎所有的资源或资产。\r\n\r\n`webpack` 的主要功能：\r\n\r\n- 捆绑 `ES` 模块、`CommonJS` 和 `AMD` 模块（甚至合并）。\r\n- 可以创建一个或多个模块文件，在运行时异步加载（以减少初始加载时间）。\r\n- 依赖关系在编译过程中被解决，减少了运行时的大小。\r\n- `Loaders` 可以在编译时预处理文件，例如 TypeScript 到 JavaScript，Handlebars 字符串到编译的函数，图像到 Base64 等。\r\n- 高度模块化的插件系统可以做任何你的应用程序需要的其他事情。"}]},{"number":90,"title":"【Q090】webpack 5 新特性","labels":["webpack"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/90","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. webpack 5 整体方向\r\n这个版本的重点在于以下几点：\r\n\r\n- 尝试用持久性缓存来提高构建性能。\r\n- 尝试用更好的算法和默认值来改进长期缓存。\r\n- 尝试用更好的 `Tree Shaking` 和代码生成来改善包大小。\r\n- 尝试改善与网络平台的兼容性。\r\n- 尝试在不引入任何破坏性变化的情况下，清理那些在实现 v4 功能时处于奇怪状态的内部结构。\r\n- 试图通过现在引入突破性的变化来为未来的功能做准备，使其能够尽可能长时间地保持在 v5 版本上。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. 删除的功能\r\n以下为 v5 版本删除的功能：\r\n\r\n### 清理弃用的能力\r\n所有在 v4 中被废弃的能力都被移除。\r\n迁移时确保你的 v4 构建没有打印废弃警告。\r\n\r\n### 废弃代码\r\n新的弃用包括一个弃用代码，这样他们更容易被引用。\r\n\r\n### 语法废弃\r\n`require.include` 已被废弃，可以用 `Rule.parser.requireInclude` 替代。\r\n\r\n### 不再为 Node.js 模块 自动引用 Polyfills\r\nv4 在构建时`bundle` 附加了庞大的 `polyfills`。\r\n在大部分情况下，这些 `polyfills` 并非必须。\r\n\r\n迁移时注意：\r\n\r\n- 尽量使用前端兼容的模块。\r\n- 可以手动为 Node.js 核心模块添加 `polyfill`。错误提示会告诉你如何实现。\r\n- 包作者：在 package.json 中添加 browser 字段，使 package 与前端兼容。为浏览器提供 **其他的实现** 或者`dependencies`。\r\n\r\n## 3. 长期缓存\r\n### 确定的 Chunk、模块 ID 和导出名称。\r\n新增了长期缓存的算法。这些算法在生产模式下是默认启用的。\r\n\r\n`chunkIds: \"deterministic\"` `moduleIds: \"deterministic\"` `mangleExports: \"deterministic\"`\r\n\r\n该算法以确定性的方式为模块和分块分配短的（3 或 5 位）数字 ID， 这是包大小和长期缓存之间的一种权衡。\r\n\r\n### 真正的内容哈希\r\n当使用 `contenthash` 时，V5 将使用真正的文件内容哈希值。\r\n之前它 \"只\" 使用内部结构的哈希值。\r\n当只有注释被修改或变量被重命名时，这对长期缓存会有积极影响。\r\n这些变化在压缩后是不可见的。\r\n \r\n ## 4. 开发模式的特性\r\n ### 命名代码块 ID\r\n在开发模式下，默认启用的新命名代码块 ID 算法为模块（和文件名）提供了人类可读的名称。 \r\n模块 ID 由其路径决定，相对于 context。 代码块 ID 由代码块的内容决定。\r\n\r\n所以你不再需要使用 `import(/* webpackChunkName: \"name\" */ \"module\")` 来调试。 \r\n但如果你想控制生产环境的文件名，还是有意义的。\r\n\r\n可以在生产环境中使用 `chunkIds: \"named\"` 在生产环境中使用，但要确保不要不小心暴露模块名的敏感信息。\r\n\r\n迁移时注意：如果你不喜欢在开发中改变文件名，你可以通过 `chunkIds: \"natural\"` 来使用旧的 **数字模式**。\r\n\r\n### 模块联邦\r\nv5 增加了一个新的功能 `模块联邦`，它允许多个 webpack 构建一起工作。\r\n从运行时的角度来看，多个构建的模块将表现得像一个巨大的连接模块图。\r\n从开发者的角度来看，模块可以从指定的远程构建中导入，并以最小的限制来使用。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 5. 支持 Web 的新特性\r\n### JSON 模块\r\nJSON 模块现在与提案保持一致，并在使用非默认导出时发出警告。\r\n当从严格的 ECMAScript 模块导入时，JSON 模块不再有命名的导出。\r\n\r\n即使使用默认导出，未使用的属性也会被 optimization.usedExports 优化丢弃，属性会被 optimization.mangleExports 优化打乱。\r\n\r\n可以在 `Rule.parser.parse` 中指定一个自定义的 JSON 解析器来导入类似 JSON 的文件（例如针对 toml、yaml、json5 等）。\r\n\r\n### import.meta\r\n\r\n- `import.meta.webpackHot` 是 `module.hot` 的别名，在严格的 ESM 中也可以使用。\r\n- `import.meta.webpack` 是 webpack 的主要版本号。\r\n- `import.meta.url` 是当前文件的 `file:` url(类似于__filename，但作为文件 url)。\r\n\r\n### 资源模块\r\nv5 现在已经对表示资源的模块提供了内置支持。 \r\n这些模块可以向输出文件夹发送一个文件，或者向 javascript 包注入一个 DataURI。 \r\n无论哪种方式，它们都会给出一个 URL 来工作。\r\n\r\n它们可以通过多种方式被使用：\r\n\r\n- **老方法**：`import url from \"./image.png\"` 和在 `module.rule` 中设置 `type: \"asset\"` 当匹配这样的导入时。\r\n- **新方法**：`new URL(\"./image.png\", import.meta.url)` \r\n\r\n选择 **新方法** 是为了允许在没有打包工具的情况下运行代码。\r\n这种语法也可以在浏览器中的原生 ECMAScript 模块中使用。\r\n\r\n### 原生 Worker 支持\r\n当把资源的 `new URL` 和 `new Worker/new SharedWorker/navigator.serviceWorker.register` 结合起来时，\r\nwebpack 会自动为 `web worker` 创建一个新的入口点（entrypoint）。\r\n\r\n```javascript\r\nnew Worker(new URL(\"./worker.js\", import.meta.url))\r\n```\r\n\r\n选择这种语法也是为了允许在没有打包工具的情况下运行代码。\r\n这种语法在浏览器的原生 ECMAScript 模块中也可以使用。\r\n\r\n### URIs\r\nv5 支持在请求中处理协议。\r\n\r\n- 支持 `data:`\r\n支持 Base64 或原始编码。\r\nMimetype 可以在 `module.rule` 中被映射到加载器和模块类型。\r\n例如：`import x from \"data:text/javascript,export default 42\"`。\r\n- 支持 `file:`\r\n- 支持 `http(s):`\r\n但需要通过 `new webpack.experiments.s schemesHttp(s)UriPlugin()` 选择加入。\r\n- 默认情况下，当目标为 \"web \"时，这些 URI 会导致对外部资源的请求（它们是外部资源）。\r\n- 支持请求中的片段。例如：`./file.js#fragment`。\r\n\r\n### 异步模块 \r\n异步模块的解析，是基于异步和 `Promise` 的。\r\n\r\n通过 `import` 导入它们会被自动处理，不需要额外的语法，而且几乎看不出区别。\r\n\r\n通过 `require()` 导入它们会返回一个解析到导出的 `Promise`。\r\n\r\n在 webpack 中，有多种方式来拥有异步模块：\r\n\r\n- 异步的外部资源(async externals)\r\n- 新规范中的 `WebAssembly` 模块\r\n- 使用顶层 `await` 的 ECMAScript 模块\r\n\r\n### 外部资源\r\nv5 增加了更多的外部引用类型：\r\n\r\n- **promise**: 一个评估为 `Promise` 的表达式。外部模块是一个异步模块，解析值作为模块导出使用。\r\n- **import**：原生的 `import()` 用于加载指定的请求，外部模块是一个异步模块，解析值作为模块导出。\r\n外部模块是一个异步模块。\r\n- **module**: 尚未实现，但计划通过 `import x from \"...\"` 加载模块。\r\n- **script**: 通过 `<script>` 标签加载一个 url，并从一个全局变量（以及它的可选属性）中获取输出。\r\n外部模块是一个异步模块。\r\n\r\n## 6. 支持 Node.js 生态新特性\r\n### 解析\r\n现在支持 `package.json` 中的 `exports` 和 `imports` 字段。\r\n\r\n原生支持 `Yarn PnP`。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 7. 开发体验\r\n### Stats\r\n改进了统计测试格式的可读性和冗余性。\r\n改进了默认值，使其不那么冗长，也适合大型构建。\r\n\r\n- 现在默认情况下，代码块关系是隐藏的，可以用 `stats.chunkRelations` 来切换。\r\n- `Stats` 现在可以区分 `files` 和 `auxiliaryFiles`。\r\n- `Stats` 现在默认隐藏模块和代码块的 id。这可以通过 `stats.ids` 来切换。\r\n- 现在所有模块的列表是按照到入口点的距离排序的。这可以通过 `stats.modulesSort` 来改变。\r\n- 代码块模块的列表现在按模块名称排序。这可以通过 `stats.chunkModulesSort` 来改变。\r\n- 嵌套模块的列表现在是按拓扑结构排序的。这可以通过 `stats.nestedModulesSort` 来改变。\r\n- 现在，代码块和资源会显示代码块 id 提示。\r\n- 资产和模块将以树状而不是列表/表格的形式显示。\r\n- 一般信息现在会在最后的摘要中显示。它显示了 webpack 版本，配置名称和警告/错误计数。\r\n- 哈希值现在默认是隐藏的。这可以通过 `stats.hash` 来改变。\r\n- 默认情况下不再显示构建的时间戳，这可以通过 `stats.builtAt` 开启。它会在摘要中显示时间戳。\r\n- 默认情况下，不再显示子编译。它们可以用 `stats.children` 来显示。\r\n\r\n### 进度条\r\n对 `ProgressPlugin` 做了一些改进，它被 CLI 在参数 `--progress` 开启时使用，但也可以作为插件手动使用。\r\n\r\n以前它只计算已处理的模块。现在它可以计算 \"入口\"、\"依赖\" 和 \"模块\"。 现在所有的模块都默认显示了。\r\n\r\n以前它只显示当前处理的模块。这造成了很多 stderr 输出，在一些控制台上产生了性能问题。\r\n现在这个功能被默认关闭（activeModules 选项）。\r\n这也减少了控制台的垃圾信息量。 \r\n现在，在构建模块的过程中，向 stderr 写入的时间被控制在 500ms 以内。\r\n\r\n剖析模式也得到了升级，将显示嵌套进度消息的时间。\r\n这使得它更容易弄清楚哪个插件导致了性能问题。\r\n\r\n新增加的 `percentBy` 选项告知 `ProgressPlugin` 如何计算进度百分比。\r\n```javascript\r\nnew webpack.ProgressPlugin({ percentBy: 'entries' });\r\n```\r\n\r\n为了使进度百分比更准确，`ProgressPlugin` 会缓存最后已知的总模块数，并在下一次构建时重新使用这个值。\r\n第一次构建将预热缓存，但后续构建将使用并更新这个值。\r\n\r\n### 自动添加唯一命名\r\n在 v4 中，多个 webpack 运行时可能会在同一个 HTML 页面上发生冲突，因为它们使用同一个全局变量进行代码块加载。\r\n为了解决这个问题，需要为 `output.jsonpFunction` 配置提供一个自定义的名称。\r\n\r\nv5 确实会从 `package.json` 的 `name` 自动推断出一个唯一的构建名称，并将其作为 `output.uniqueName` 的默认值。\r\n\r\n这个值用于使所有潜在的冲突的全局变量成为唯一。\r\n\r\n### 自动添加公共路径\r\nv 5 会在可能的情况下自动确定 `output.publicPath`。\r\n\r\n### Typescript 类型\r\nv5 从源码中生成 typescript 类型，并通过 npm 包暴露它们。\r\n\r\n迁移时注意，删除 `@types/webpack` 包。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 8. 构建优化\r\n### 嵌套的 tree-shaking\r\nwebpack 现在能够跟踪对导出的嵌套属性的访问。\r\n这可以改善重新导出命名空间对象时的 `Tree Shaking`（清除未使用的导出和混淆导出）。\r\n```javascript\r\n// inner.js\r\nexport const a = 1;\r\nexport const b = 2;\r\n\r\n// module.js\r\nexport * as inner from './inner';\r\n// 或 import * as inner from './inner'; export { inner };\r\n\r\n// user.js\r\nimport * as module from './module';\r\nconsole.log(module.inner.a);\r\n```\r\n\r\n在这个例子中，可以在生产模式下删除导出的b。\r\n\r\n### 内部模块 tree-shaking\r\nv4 没有分析模块的导出和引用之间的依赖关系。\r\nv5 有一个新的选项 `optimization.innerGraph`，在生产模式下是默认启用的，它可以对模块中的标志进行分析，找出导出和引用之间的依赖关系。\r\n\r\n在这样的模块中：\r\n\r\n```javascript\r\nimport { something } from './something';\r\n\r\nfunction usingSomething() {\r\n  return something;\r\n}\r\n\r\nexport function test() {\r\n  return usingSomething();\r\n}\r\n```\r\n\r\n内部依赖图算法会找出 `something` 只有在使用 `test` 导出时才会使用。\r\n这允许将更多的出口标记为未使用，并从代码包中省略更多的代码。\r\n\r\n当设置 `\"sideEffects\": false` 时，可以省略更多的模块。\r\n在这个例子中，当 `test` 导出未被使用时，`./something` 将被省略。\r\n\r\n要获得未使用的导出信息，需要使用 `optimization.usedExports`。\r\n要删除无副作用的模块，需要使用 `optimization.sideEffects`。\r\n\r\n可以分析以下标记：\r\n\r\n- 函数声明\r\n- 类声明\r\n- 默认导出export default 或定义变量以下的：\r\n  - 函数表达式\r\n  - 类表达式\r\n  - 顺序表达式\r\n  - /*#__PURE__*/ 表达式\r\n  - 局部变量\r\n  - 引入的捆绑(bindings)\r\n  \r\n注意：使用 `eval()` 将为一个模块放弃这个优化，因为经过 `eval` 的代码可以引用范围内的任何标记。\r\n这种优化也被称为深度范围分析。\r\n\r\n### CommonJs 的 tree-shaking\r\nwebpack 曾经不进行对 CommonJs 导出和 `require()` 调用时的导出使用分析。\r\nv5 增加了对一些 CommonJs 构造的支持，允许消除未使用的 CommonJs 导出，并从 `require()` 调用中跟踪引用的导出名称。\r\n\r\n支持以下构造：\r\n\r\n- `exports|this|module.exports.xxx = ...`\r\n- `exports|this|module.exports = require(\"...\")` (reexport)\r\n- `exports|this|module.exports.xxx = require(\"...\").xxx` (reexport)\r\n- `Object.defineProperty(exports|this|module.exports, \"xxx\", ...)`\r\n- `require(\"abc\").xxx`\r\n- `require(\"abc\").xxx()`\r\n- 从 ESM 导入\r\n- `require()` 一个 ESM 模块\r\n- 被标记的导出类型 (对非严格 ESM 导入做特殊处理)\r\n\r\n  - Object.defineProperty(exports|this|module.exports, \"__esModule\", { value: true|!0 })\r\n  - exports|this|module.exports.__esModule = true|!0\r\n  \r\n当检测到不可分析的代码时，webpack 会放弃，并且完全不跟踪这些模块的导出信息（出于性能考虑）。\r\n\r\n### 副作用分析\r\n在 `package.json` 中的 `sideEffects` 标志允许手动将模块标记为无副作用，这就允许在不使用时放弃它们。\r\n\r\nv5 也可以根据对源代码的静态分析，自动将模块标记为无副作用。\r\n\r\n### 每个运行时的优化\r\nv5 现在能够分析和优化每个运行时的模块。\r\n这允许只在真正需要的地方导出这些入口点。\r\n入口点之间不会相互影响。\r\n\r\n### 模块合并\r\n模块合并也可以在每个运行时工作，允许每个运行时进行不同的合并\r\n\r\n模块合并已经成为一等公民，现在任何模块和依赖都可以实现它。\r\n现已经添加了对 ExternalModules 和 json 模块的支持。\r\n\r\n### 通用 Tree Shaking 改进\r\n`export *` 已经得到改进，可以跟踪更多的信息，并且不再将默认导出标记为使用。\r\n\r\n`export *` 现在会在 webpack 确定有冲突的导出时显示警告。\r\n\r\n`import()` 允许通过 `/* webpackExports: [\"abc\", \"default\"] */` 该魔法注释手动 `tree shake` 模块。\r\n\r\n### 开发与生产保持一致性\r\nv5 试图通过改善两种模式的相似性，在开发模式的构建性能和避免仅在生产模式的产生的问题之间找到一个很好的平衡点。\r\nv5 默认在两种模式下都启用了 `sideEffects` 优化。\r\n在 v4 中，由于 `package.json` 中的 `sideEffects` 标记不正确，这种优化导致了一些只在生产模式下出现的错误。\r\n在开发过程中启用这个优化可以更快更容易地发现这些问题。\r\n\r\n在很多情况下，开发和生产都是在不同的操作系统上进行的，文件系统的大小写敏感度不同，所以 v5 增加了一些奇怪的大小写的警告/错误。\r\n\r\n### 改进代码生成\r\n当 ASI 发生时，webpack 会检测到，当没有分号插入时，会生成更短的代码。\r\n```javascript\r\nObject(...)->(0, ...)\r\n```\r\n\r\nwebpack 将多个导出的 getters 合并为一个运行时函数调用。\r\n```javascript\r\nr.d(x, \"a\", () => a); r.d(x, \"b\", () => b); -> r.d(x, {a: () => a, b: () => b});\r\n```\r\n\r\n现在在 `output.environment` 中有额外的选项。\r\n它们允许指定哪些 ECMAScript 特性可以用于 webpack 生成的运行时代码。\r\n\r\n通常人们不会直接指定这个选项，而是会使用 `target` 选项。\r\n\r\nv4 之前只生成 ES5 的代码。 \r\nv5 则现在既可以生成 ES5 又可以生成 ES6/ES2015 代码。\r\n\r\n只支持现代浏览器，将使用箭头函数生成更短的代码，使用 `const` 声明与 `export default` 生成更符合规范的代码。\r\n\r\n### 改进 target 配置\r\n在 v4 中，`target` 是在 `web` 和 `node` 之间的一个粗略的选择。 \r\nv5 有更多的选择。\r\n\r\n现在的 `target` 比以前影响了更多关于生成代码的事情。\r\n\r\n- 代码块加载方法\r\n- 代码块的格式\r\n- wasm 加载方法\r\n- 代码块与 wasm 在 workers 中加载方法\r\n- 被使用的全局对象\r\n- `publicPath` 是否应该被自动确定\r\n- 生成的代码中使用的 ECMAScript 特性/语法\r\n- `externals` 是否默认被启用\r\n- 一些 Node.js 兼容层的行为(`global`, `__filename`, `__dirname`)\r\n- 模块解析(`browser` 字段、`exports` 和 `imports` 条件)\r\n- 一些 `loader` 可能会基于此改变行为\r\n\r\n指定最低版本，例如 `node10.13`，并推断出更多关于目标环境的属性。\r\n\r\n允许指定多个值，例如 `target: [\"web\", \"es2020\"]`。\r\n\r\n当项目中存在可用的 `browserslist` 配置时，这个目标也会被默认使用。\r\n当没有可用的配置时，默认使用 `web` 目标。\r\n\r\n### 代码块拆分与模块大小\r\n现在模块的尺寸比单一的数字更好的表达方式。现在有不同类型的大小。\r\n\r\n`SplitChunksPlugin` 现在知道如何处理这些不同的大小，并将它们用于 `minSize` 和 `maxSize`。\r\n默认情况下，只有 javascript 大小被处理，但你现在可以传递多个值来管理它们：\r\n```javascript\r\n// webpack.config.js\r\n\r\nmodule.exports = {\r\n  optimization: {\r\n    splitChunks: {\r\n      minSize: {\r\n        javascript: 30000,\r\n        webassembly: 50000,\r\n      },\r\n    },\r\n  },\r\n};\r\n```\r\n\r\n你仍然可以使用一个数字来表示大小。在这种情况下，webpack 会自动使用默认的大小类型。\r\n\r\n`mini-css-extract-plugin` 使用 `css/mini-extra` 作为大小类型，并将此大小类型自动添加到默认类型中。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 9. 性能优化\r\n现在有一个文件系统缓存。它是可选的，可以通过以下配置启用：\r\n```javascript\r\nmodule.exports = {\r\n  cache: {\r\n    // 1. 将缓存类型设置为文件系统\r\n    type: 'filesystem',\r\n\r\n    buildDependencies: {\r\n      // 2. 将你的 config 添加为 buildDependency，以便在改变 config 时获得缓存无效\r\n      config: [__filename],\r\n\r\n      // 3. 如果你有其他的东西被构建依赖，你可以在这里添加它们\r\n      // 注意，webpack、加载器和所有从你的配置中引用的模块都会被自动添加\r\n    },\r\n  },\r\n};\r\n```\r\n\r\n重要说明：\r\n默认情况下，webpack 假定 webpack 所在的 `node_modules` 目录只会被包管理器修改。\r\n对 `node_modules` 来说，哈希值和时间戳会被跳过。\r\n出于性能考虑，只使用包名和版本。\r\n只要不指定 `resolve.symlinks: false`，Symlinks(即 `npm/yarn link` )就没有问题。\r\n不要直接编辑 `node_modules` 中的文件，除非你用 `snapshot.managedPaths: []` 以剔除该优化。\r\n当使用 `Yarn PnP` 时，webpack 假设 yarn 缓存是不可改变的。\r\n你可以使用 `snapshot.immutablePaths: []` 来退出这个优化。\r\n\r\n缓存将默认存储在 `node_modules/.cache/webpack`（当使用 node_modules 时）或 `.yarn/.cache/webpack`（当使用 Yarn PnP 时）中。 \r\n当所有的插件都正确处理缓存时，你可能永远都不需要手动删除它。\r\n\r\n许多内部插件也会使用持久性缓存。\r\n例如 `SourceMapDevToolPlugin` (缓存 SourceMap 的生成)或 `ProgressPlugin` (缓存模块数量)\r\n\r\n持久性缓存将根据使用情况自动创建多个缓存文件，以优化对缓存的读写访问。\r\n\r\n默认情况下，时间戳将用于开发模式的快照，而文件哈希将用于生产模式。 \r\n文件哈希也允许在 CI 中使用持久性缓存。\r\n\r\n### 编译器闲置和关闭\r\n编译器现在需要在使用后关闭。\r\n编译器现在会进入和离开空闲状态，并且有这些状态的钩子。\r\n插件可能会使用这些钩子来做不重要的工作。(即将持久缓存缓慢地将缓存存储到磁盘上)。\r\n在编译器关闭时--所有剩余的工作应该尽可能快地完成。\r\n一个回调标志着关闭完成。\r\n\r\n插件和它们各自的作者应该预料到，有些用户可能会忘记关闭编译器。\r\n所以，所有的工作最终也应该在空闲状态下完成。\r\n当工作正在进行时，应该防止进程退出。\r\n\r\n`webpack()` 用法在被传递回调时自动调用 `close`。\r\n\r\n迁移时注意：在使用 Node.js API 时，一定要在完成工作后调用 `Compiler.close`。\r\n\r\n### 文件生成\r\nwebpack 过去总是在第一次构建时发出所有的输出文件，但在增量（观察）构建时跳过了写入未更改的文件。\r\n假设在 webpack 运行时，没有任何其他东西改变输出文件。\r\n\r\n增加了持久性缓存后，即使在重启 webpack 进程时，也应该会有类似监听的体验，但如果认为即使在 webpack 不运行时也没有其他东西改变输出目录，那这个假设就太强了。\r\n\r\n所以 webpack 现在会检查输出目录中现有的文件，并将其内容与内存中的输出文件进行比较。\r\n只有当文件被改变时，它才会写入文件。\r\n这只在第一次构建时进行。任何增量构建都会在运行中的 webpack 进程中生成新的资产时写入文件。\r\n\r\n我们假设 webpack 和插件只有在内容被改变时才会生成新的资产。\r\n应该使用缓存来确保在输入相同时不会生成新的资产。\r\n不遵循这个建议会降低性能。\r\n\r\n被标记为 **不可变** 的文件（包括内容哈希），当已经存在一个同名文件时，将永远不会被写入。\r\n我们假设当文件内容发生变化时，内容哈希会发生变化。\r\n这在一般情况下是正确的，但在 webpack 或插件开发过程中可能并不总是如此。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 10. 长期未解决的问题\r\n### 单一文件目标的代码分割\r\n只允许启动单个文件的目标（如 node、WebWorker、electron main）现在支持运行时自动加载引导所需的依赖代码片段。\r\n\r\n这允许对这些目标使用 `chunks: \"all\"` 和 `optimization.runtimeChunk`。\r\n\r\n请注意，如果目标的代码块加载是异步的，这使得初始评估也是异步的。\r\n当使用 `output.library` 时，这可能是一个问题，因为现在导出的值是一个 `Promise`。\r\n\r\n### 更新了解析器\r\n`enhanced-resolve` 更新到了 v5，有以下改进：\r\n\r\n- 追踪更多的依赖关系，比如丢失的文件。\r\n- 别名可能有多种选择\r\n- 现在可以别名为 false 了。\r\n- 支持 `exports` 和 `imports` 字段等功能。\r\n- 性能提高\r\n\r\n### 没有 JS 的代码块\r\n不包含 JS 代码的块，将不再生成 JS 文件。\r\n这就允许有只包含 CSS 的代码块。\r\n\r\n## 11. 实验特性\r\n在 v5 中，有一个新的 `experiments` 配置选项，允许启用实验性功能。\r\n以下的实验功能将随 v5 一起发布：\r\n\r\n- 旧的 WebAssembly 支持，就像 v4 一样 (`experiments.syncWebAssembly`)\r\n- 根据 **更新的规范**，新增 WebAssembly 支持。\r\n  - 这使得一个 WebAssembly 模块成为一个异步模块。\r\n- **顶层的 Await** 第三阶段提案(`experiments.topLevelAwait`)\r\n  - 在顶层使用 `await` 使该模块成为一个异步模块。\r\n- 以模块的形式生成代码包 (`experiments.outputModule`)\r\n  - 这就从代码包中移除了包装器 IIFE，执行严格模式，通过 `<script type=\"module\">` 进行懒惰加载，并在模块模式下最小化压缩。\r\n\r\n请注意，这也意味着 WebAssembly 的支持现在被默认禁用。\r\n\r\n### 最小 Node.js 版本\r\n最低支持的 Node.js 版本从 6 增加到 10.13.0(LTS)。\r\n\r\n迁移时注意：升级到最新的 Node.js 版本。\r\n\r\n## 12. loader 相关变更\r\n### this.getOptions\r\n这个新的 API 应该可以简化加载器中选项的使用。 它允许传递 JSON 模式进行验证。\r\n\r\n### this.exec\r\n这一点已从加载器上下文中删除\r\n\r\n迁移时注意：这可以在 loader 内自行实现。\r\n\r\n### this.getResolve\r\n`loader API` 中的 `getResolve(options)` 将以另一种方式合并选项，参见 `module.rule.resolve`。\r\n\r\n由于 v5 在不同的发布依赖关系之间存在差异，所以传递一个 `dependencyType` 作为选项可能是有意义的（例如 `esm`，`commonjs`，或者其他）。"}]},{"number":91,"title":"【Q091】loader","labels":["webpack"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/91","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. loader\r\n`loader` 用于对 **模块源代码** 进行转换。\r\n`loader` 可以使你在 `import` 或 **加载模块** 时预处理文件。\r\n因此，`loader` 类似于其他构建工具中 `task`，并提供了处理前端构建步骤的得力方式。\r\n`loader` 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript 或将内联图像转换为 `data URL`。\r\n`loader` 甚至允许你直接在 JavaScript 模块中 `import` CSS 文件！\r\n\r\n## 2. 示例\r\n例如，你想要加载 CSS 文件、讲TypeScript 转为 JavaScript。\r\n为此，首先安装相对应的 loader：\r\n```bash\r\nnpm install --save-dev css-loader ts-loader\r\n```\r\n\r\n然后对每个 `.css` 文件 使用 `css-loader`，对每个 `.ts` 文件使用 `ts-loader`：\r\n```javascript\r\n// webpack.config.js\r\nmodule.exports = {\r\n  module: {\r\n    rules: [\r\n      { test: /\\.css$/, use: 'css-loader' },\r\n      { test: /\\.ts$/, use: 'ts-loader' },\r\n    ],\r\n  },\r\n};\r\n```\r\n\r\n## 3. 使用 loader\r\n`loader` 有两种使用的方式：\r\n\r\n- **配置方式**（推荐）：在 `webpack.config.js` 文件中指定 `loader`。\r\n- **内联方式**：在每个 `import` 语句中显式指定 `loader`。\r\n\r\n### 配置方式 Configuration\r\n`module.rules` 允许你在 `webpack` 配置中指定多个 `loader`。\r\n这种方式是展示 `loader` 的一种简明方式，并且有助于使代码变得简洁和易于维护。\r\n\r\n`loader` 的执行顺序是从上到下。\r\n```javascript\r\nmodule.exports = {\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.css$/,\r\n        use: [\r\n          // [style-loader](/loaders/style-loader)\r\n          { loader: 'style-loader' },\r\n          // [css-loader](/loaders/css-loader)\r\n          {\r\n            loader: 'css-loader',\r\n            options: {\r\n              modules: true\r\n            }\r\n          },\r\n          // [sass-loader](/loaders/sass-loader)\r\n          { loader: 'sass-loader' }\r\n        ]\r\n      }\r\n    ]\r\n  }\r\n};\r\n```\r\n\r\n### 内联方式\r\n可以在 `import` 语句或任何 **与 \"import\" 方法同等的引用方式** 中指定 `loader`。\r\n使用 `!` 将资源中的 `loader` 分开。每个部分都会相对于当前目录解析。\r\n```javascript\r\nimport Styles from 'style-loader!css-loader?modules!./styles.css';\r\n```\r\n\r\n通过为内联 `import` 语句添加前缀，可以覆盖 `configuration` 中的所有 `loader`, `preLoader` 和 `postLoader`：\r\n\r\n- 使用 `!` 前缀，将禁用所有已配置的 **普通 loader**。\r\n```javascript\r\nimport Styles from '!style-loader!css-loader?modules!./styles.css';\r\n```\r\n- 使用 `!!` 前缀，将禁用所有已配置的 `loader`（preLoader, loader, postLoader）。\r\n```javascript\r\nimport Styles from '!!style-loader!css-loader?modules!./styles.css';\r\n```\r\n- 使用 `-!` 前缀，将禁用所有已配置的 `preLoader` 和 `loader`，但是不禁用 `postLoaders`。\r\n```javascript\r\nimport Styles from '-!style-loader!css-loader?modules!./styles.css';\r\n```\r\n\r\n### 注意：尽可能使用 `module.rules`，这样可以减少源码中样板文件的代码量。并且可以在出错时快速定位 `loader` 的问题。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 4. loader 特性\r\n- `loader` 支持链式调用。\r\n- `loader` 支持同步，也支持异步。\r\n- 可以在 `package.json` 的 `main` 指定 npm包 为 `loader`，还可以在 `module.rules` 中使用 `loader` 字段直接引用一个模块。\r\n- `plugin` 可以为 `loader` 带来更多特性。\r\n- `loader` 能够产生额外的文件。\r\n\r\n可以通过 `loader` 的预处理函数，进行压缩、打包、编译等功能。\r\n\r\n## 5. 解析 loader\r\n`loader` 遵循标准 **模块解析** 规则。\r\n多数情况下，`loader` 将从 **模块路径** 加载（通常是从 npm install, node_modules 进行加载）。\r\n\r\n预期 `loader` 模块导出为一个函数，并且编写为 Node.js 兼容的 JavaScript。\r\n通常使用 npm 进行管理 `loader`，但是也可以将应用程序中的文件作为自定义 `loader`。\r\n按照约定，`loader` 通常被命名为 xxx-loader（例如 json-loader）。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 6. 编写 loader\r\n`loader` 是导出为一个函数的 node 模块。\r\n该函数在 `loader` 转换资源的时候调用。\r\n给定的函数将调用 `Loader API`，并通过 `this` 上下文访问。\r\n\r\n### 匹配 loader\r\n匹配单个 `loader`，你可以通过在 `rule` 对象使用 `path.resolve` 指定一个本地文件：\r\n```javascript\r\n// webpack.config.js\r\n\r\nconst path = require('path');\r\n\r\nmodule.exports = {\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.js$/,\r\n        use: [\r\n          {\r\n            loader: path.resolve('path/to/loader.js'),\r\n            options: {},\r\n          },\r\n        ],\r\n      },\r\n    ],\r\n  },\r\n};\r\n```\r\n\r\n匹配多个 `loaders`，你可以使用 `resolveLoader.modules` 配置，`webpack` 将会从这些目录中搜索这些 `loaders`。\r\n例如，如果你的项目中有一个 `/loaders` 本地目录：\r\n```javascript\r\n// webpack.config.js\r\n\r\nconst path = require('path');\r\n\r\nmodule.exports = {\r\n  resolveLoader: {\r\n    modules: ['node_modules', path.resolve(__dirname, 'loaders')],\r\n  },\r\n};\r\n```\r\n\r\n### 简单用法\r\n当一个 `loader` 在资源中使用，这个 `loader` 只能传入一个参数 - 一个包含资源文件内容的字符串。\r\n\r\n同步 `loader` 可以 `return` 一个代表已转换模块的单一值。\r\n在更复杂的情况下，`loader` 也可以通过使用 `this.callback(err, values...)` 函数，返回任意数量的值。\r\n错误要么传递给这个 `this.callback` 函数，要么抛给同步 `loader `。\r\n\r\n`loader` 会返回一个或者两个值。\r\n第一个值的类型是 JavaScript 代码的字符串或者 buffer。\r\n第二个可选值是 `SourceMap`，它是个 JavaScript 对象。\r\n\r\n### 复杂用法\r\n当链式调用多个 `loader` 的时候，请记住它们是倒序执行的。\r\n\r\n最后的 `loader` 最早调用，将会传入原始资源内容。\r\n第一个 `loader` 最后调用，期望值是传出 JavaScript 和 `source map`（可选）。\r\n中间的 `loader` 执行时，会传入前一个 `loader` 的结果。\r\n\r\n在下例中，`foo-loader` 被传入原始资源，`bar-loader` 将接收 `foo-loader` 的产出，\r\n返回最终转化后的模块和一个 `source map`（可选）。\r\n```javascript\r\n// webpack.config.js\r\n\r\nmodule.exports = {\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.js/,\r\n        use: ['bar-loader', 'foo-loader'],\r\n      },\r\n    ],\r\n  },\r\n};\r\n```\r\n\r\n### 用法准则\r\n编写 `loader` 时应该遵循以下准则：\r\n\r\n- 保持 **简单**\r\n- 使用 **链式** 传递\r\n- **模块化** 的输出\r\n- 确保 **无状态**\r\n- 使用 **loader-utils包**\r\n- 记录 **loader 的依赖**\r\n- 解析 **模块依赖关系**\r\n- 提取 **通用代码**\r\n- 避免 **绝对路径**\r\n- 使用 **同一个依赖**（peerDependency）\r\n\r\n### 简单\r\n`loaders` 应该只做单一任务。\r\n这不仅使每个 `loader` 易维护，也可以在更多场景链式调用。\r\n\r\n### 链式\r\n利用 `loader` 可以链式调用的优势。\r\n写五个简单的 `loader` 实现五项任务，而不是一个 `loader` 实现五项任务。\r\n功能隔离不仅使 `loader` 更简单，还利于后续维护与开发。\r\n\r\n以通过 `loader` 选项或者查询参数得到的数据渲染模板为例。\r\n可以把源代码编译为模板，执行并输出包含 HTML 代码的字符串写到一个 `loader` 中。\r\n但是根据用法准则，已经存在这样一个 `apply-loader`，可以将它和其他开源 `loader` 串联在一起调用。\r\n\r\n- `pug-loader`: 导出一个函数，把模板转换为模块。\r\n- `apply-loader`: 根据 loader 选项执行函数，返回原生 HTML。\r\n- `html-loader`: 接收 HTML，输出一个合法的 JS 模块。\r\n\r\n注意：`loader` 可以被链式调用意味着不一定要输出 JavaScript。只要下一个 `loader` 可以处理这个输出，这个 `loader` 就可以返回任意类型的模块。\r\n\r\n### 模块化\r\n保证输出模块化。\r\n`loader` 生成的模块与普通模块遵循相同的设计原则。\r\n\r\n### 无状态\r\n确保 `loader` 在不同模块转换之间不保存状态。\r\n每次运行都应该独立于其他编译模块以及相同模块之前的编译结果。\r\n\r\n### loader 工具库\r\n充分利用 `loader-utils` 包。\r\n它提供了许多有用的工具，但最常用的一种工具是获取传递给 `loader` 的选项。\r\n\r\n`schema-utils` 包配合 `loader-utils`，用于保证 `loader` 选项，进行与 JSON Schema 结构一致的校验。\r\n这里有一个简单使用两者的例子：\r\n```javascript\r\n// loader.js\r\n\r\nimport { urlToRequest } from 'loader-utils';\r\nimport { validate } from 'schema-utils';\r\n\r\nconst schema = {\r\n  type: 'object',\r\n  properties: {\r\n    test: {\r\n      type: 'string',\r\n    },\r\n  },\r\n};\r\n\r\nexport default function (source) {\r\n  const options = this.getOptions();\r\n\r\n  validate(schema, options, {\r\n    name: 'Example Loader',\r\n    baseDataPath: 'options',\r\n  });\r\n  \r\n  console.log('请求文件路径：', urlToRequest(this.resourcePath));\r\n\r\n  // 对资源应用一些转换……\r\n\r\n  return `export default ${JSON.stringify(source)}`;\r\n}\r\n```\r\n\r\n### loader 依赖\r\n如果一个 `loader` 使用外部资源（例如，从文件系统读取），必须声明它。\r\n这些信息用于使缓存 `loaders` 无效，以及在 **观察模式** 下重编译。\r\n下面是一个简单示例，说明如何使用 `addDependency` 方法实现上述声明：\r\n```javascript\r\n// loader.js\r\n\r\nimport path from 'path';\r\n\r\nexport default function (source) {\r\n  var callback = this.async();\r\n  var headerPath = path.resolve('header.js');\r\n\r\n  this.addDependency(headerPath);\r\n\r\n  fs.readFile(headerPath, 'utf-8', function (err, header) {\r\n    if (err) return callback(err);\r\n    callback(null, header + '\\n' + source);\r\n  });\r\n}\r\n```\r\n\r\n### 模块依赖\r\n根据模块类型，可能会有不同的模式指定依赖关系。\r\n例如在 CSS 中，使用 `@import` 和 `url(...)` 语句来声明依赖。\r\n这些依赖关系应该由模块系统解析。\r\n\r\n可以通过以下两种方式中的一种来实现：\r\n\r\n- 通过把它们转化成 `require` 语句。\r\n- 使用 `this.resolve` 函数解析路径。\r\n\r\n`css-loader`包 是第一种方式的一个例子。\r\n它将 `@import` 语句替换为 `require` 其他样式文件，将 `url(...)` 替换为 `require` 引用文件，\r\n从而实现将依赖关系转化为 `require` 声明。\r\n\r\n而`less-loader`包，无法将每个 `@import` 转化为 `require`，因为所有 `.less` 的文件中的变量和混合跟踪必须一次编译。\r\n因此，`less-loader` 将 less 编译器进行了扩展，自定义路径解析逻辑。\r\n然后，利用第二种方式，通过 `webpack` 的 `this.resolve` 解析依赖。\r\n\r\n### 通用代码\r\n避免在 `loader` 处理的每个模块中生成通用代码。\r\n你应该在 `loader` 中创建一个运行时文件，并生成 `require` 语句以引用该共享模块：\r\n\r\n**src/loader-runtime.js**\r\n```javascript\r\nconst { someOtherModule } = require('./some-other-module');\r\n\r\nmodule.exports = function runtime(params) {\r\n  const x = params.y * 2;\r\n\r\n  return someOtherModule(params, x);\r\n};\r\n```\r\n\r\n**src/loader.js**\r\n```javascript\r\nimport runtime from './loader-runtime.js';\r\n\r\nexport default function loader(source) {\r\n  // 自定义的 loader 逻辑\r\n\r\n  return `${runtime({\r\n    source,\r\n    y: Math.random(),\r\n  })}`;\r\n}\r\n```\r\n\r\n### 绝对路径\r\n不要在模块代码中插入 **绝对路径**，因为当项目根路径变化时，文件绝对路径也会变化。\r\n`loader-utils` 中的 `stringifyRequest` 方法，可以将绝对路径转化为相对路径。\r\n\r\n### 同一个依赖\r\n如果你的 `loader` 简单包裹另外一个包，你应该把这个包作为一个 `peerDependency` 引入。\r\n这种方式允许应用程序开发者在必要情况下，在 `package.json` 中指定所需的确定版本。\r\n\r\n例如，`sass-loader` 指定 `node-sass` 作为同等依赖，引用如下：\r\n**saas-loader/package.json**\r\n```json\r\n{\r\n  \"peerDependencies\": {\r\n    \"node-sass\": \"^4.0.0\"\r\n  }\r\n}\r\n```\r\n\r\n### 测试\r\n我们将使用 [Jest](https://jestjs.io/) 框架。\r\n然后还需要安装 `babel-jest` 和允许我们使用 `import / export` 和 `async / await` 的一些预设环境（presets）。\r\n让我们开始安装，并且将这些依赖保存为 `devDependencies`：\r\n\r\n```bash\r\nnpm install --save-dev jest babel-jest @babel/core @babel/preset-env\r\n```\r\n\r\n**babel.config.js**\r\n```javascript\r\nmodule.exports = {\r\n  presets: [\r\n    [\r\n      '@babel/preset-env',\r\n      {\r\n        targets: {\r\n          node: 'current',\r\n        },\r\n      },\r\n    ],\r\n  ],\r\n};\r\n```\r\n\r\n我们的 `loader` 将会处理 .txt 文件，并且将任何实例中的 name 直接替换为 `loader` 选项中设置的 name。\r\n然后返回包含默认导出文本的 JavaScript 模块：\r\n\r\n**src/loader.js**\r\n```javascript\r\nexport default function loader(source) {\r\n  const options = this.getOptions();\r\n\r\n  source = source.replace(/\\[name\\]/g, options.name);\r\n\r\n  return `export default ${JSON.stringify(source)}`;\r\n}\r\n\r\n```\r\n\r\n使用[memfs](https://github.com/streamich/memfs) 去执行 `webpack`。\r\n```bash\r\nnpm install --save-dev webpack memfs\r\n```\r\n\r\n**test/compiler.js**\r\n```javascript\r\nimport path from 'path';\r\nimport webpack from 'webpack';\r\nimport { createFsFromVolume, Volume } from 'memfs';\r\n\r\nexport default (fixture, options = {}) => {\r\n  const compiler = webpack({\r\n    context: __dirname,\r\n    entry: `./${fixture}`,\r\n    output: {\r\n      path: path.resolve(__dirname),\r\n      filename: 'bundle.js',\r\n    },\r\n    module: {\r\n      rules: [\r\n        {\r\n          test: /\\.txt$/,\r\n          use: {\r\n            loader: path.resolve(__dirname, '../src/loader.js'),\r\n            options,\r\n          },\r\n        },\r\n      ],\r\n    },\r\n  });\r\n\r\n  compiler.outputFileSystem = createFsFromVolume(new Volume());\r\n  compiler.outputFileSystem.join = path.join.bind(path);\r\n\r\n  return new Promise((resolve, reject) => {\r\n    compiler.run((err, stats) => {\r\n      if (err) reject(err);\r\n      if (stats.hasErrors()) reject(stats.toJson().errors);\r\n\r\n      resolve(stats);\r\n    });\r\n  });\r\n};\r\n```\r\n\r\n注意：这种情况下，我们可以内联 `webpack` 配置，也可以把配置作为参数传给导出的函数。这允许我们使用相同的编译模块测试多个设置。\r\n\r\n最后，我们来编写测试，并且添加 npm script 运行它：\r\n**test/loader.test.js**\r\n```javascript\r\n/**\r\n * @jest-environment node\r\n */\r\nimport compiler from './compiler.js';\r\n\r\ntest('Inserts name and outputs JavaScript', async () => {\r\n  const stats = await compiler('example.txt', { name: 'Alice' });\r\n  const output = stats.toJson({ source: true }).modules[0].source;\r\n\r\n  expect(output).toBe('export default \"Hey Alice!\\\\n\"');\r\n});\r\n```\r\n\r\n**package.json**\r\n```json\r\n{\r\n  \"scripts\": {\r\n    \"test\": \"jest\"\r\n  },\r\n  \"jest\": {\r\n    \"testEnvironment\": \"node\"\r\n  }\r\n}\r\n```\r\n\r\n准备就绪后，我们可以运行它，然后看新的 `loader` 是否能通过测试：\r\n```bash\r\n PASS  test/loader.test.js\r\n  ✓ Inserts name and outputs JavaScript (229ms)\r\n\r\nTest Suites: 1 passed, 1 total\r\nTests:       1 passed, 1 total\r\nSnapshots:   0 total\r\nTime:        1.853s, estimated 2s\r\nRan all test suites.\r\n```"}]},{"number":92,"title":"【Q092】plugin","labels":["webpack"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/92","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. plugin\r\n`plugin` 是 `webpack` 的主要功能。\r\n`plugin` 目的在于解决 `loader` 无法实现的其他事。\r\n\r\n## 2. 剖析\r\n`plugin` 是一个具有 `apply` 方法的 JavaScript 对象。\r\n`apply` 方法会被 `webpack compiler` 调用，并且在 **整个** 编译生命周期都可以访问 `compiler` 对象。\r\n\r\n```javascript\r\n// ConsoleLogOnBuildWebpackPlugin.js\r\nconst pluginName = 'ConsoleLogOnBuildWebpackPlugin';\r\n\r\nclass ConsoleLogOnBuildWebpackPlugin {\r\n  apply(compiler) {\r\n    compiler.hooks.run.tap(pluginName, (compilation) => {\r\n      console.log('webpack 构建正在启动！');\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = ConsoleLogOnBuildWebpackPlugin;\r\n```\r\n\r\n`tap` 方法的第一个参数，应该是驼峰式命名的插件名称。\r\n建议为此使用一个常量，以便它可以在所有 `hook` 中重复使用。\r\n\r\n## 3. 用法\r\n由于 `plugin` 可以携带参数，你必须在 `webpack` 配置中，向 `plugins` 属性传入一个 new 实例。\r\n\r\n取决于你的 `webpack` 用法，对应有多种使用插件的方式。\r\n\r\n### 配置方式\r\n```javascript\r\n// webpack.config.js\r\n\r\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\r\nconst webpack = require('webpack'); // 访问内置的插件\r\nconst path = require('path');\r\n\r\nmodule.exports = {\r\n  entry: './path/to/my/entry/file.js',\r\n  output: {\r\n    filename: 'my-first-webpack.bundle.js',\r\n    path: path.resolve(__dirname, 'dist'),\r\n  },\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.(js|jsx)$/,\r\n        use: 'babel-loader',\r\n      },\r\n    ],\r\n  },\r\n  plugins: [\r\n    new webpack.ProgressPlugin(),\r\n    new HtmlWebpackPlugin({ template: './src/index.html' }),\r\n  ],\r\n};\r\n```\r\n\r\n`ProgressPlugin` 用于自定义编译过程中的进度报告。\r\n`HtmlWebpackPlugin` 将生成一个 HTML 文件，并在其中使用 script 引入一个名为 `my-first-webpack.bundle.js` 的文件。\r\n\r\n### Node API 方式\r\n在使用 Node API 时，还可以通过配置中的 `plugins` 属性传入插件。\r\n```javascript\r\n// some-node-script.js\r\n\r\nconst webpack = require('webpack'); // 访问 webpack 运行时(runtime)\r\nconst configuration = require('./webpack.config.js');\r\n\r\nlet compiler = webpack(configuration);\r\n\r\nnew webpack.ProgressPlugin().apply(compiler);\r\n\r\ncompiler.run(function (err, stats) {\r\n  // ...\r\n});\r\n```"}]},{"number":93,"title":"【Q093】tree shaking","labels":["webpack"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/93","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. tree shaking\r\n`tree shaking` 是一个术语，通常用于描述移除 JavaScript 上下文中的 **未引用代码**(dead-code)。\r\n它依赖于 ES2015 模块语法的 **静态结构** 特性，例如 `import` 和 `export`。\r\n这个术语是由打包工具 `rollup` 普及起来的。\r\n\r\n## 2. 添加一个通用模块\r\n在我们的项目中添加一个新的通用模块文件 `src/math.js`，并导出两个函数：\r\n\r\n**project**\r\n```javascript\r\nwebpack-demo\r\n|- package.json\r\n|- package-lock.json\r\n|- webpack.config.js\r\n|- /dist\r\n  |- bundle.js\r\n  |- index.html\r\n|- /src\r\n  |- index.js\r\n |- math.js\r\n|- /node_modules\r\n```\r\n\r\n**src/math.js**\r\n```javascript\r\nexport function square(x) {\r\n  return x * x;\r\n}\r\n\r\nexport function cube(x) {\r\n  return x * x * x;\r\n}\r\n```\r\n\r\n需要将 `mode` 配置设置成 `development`，以确定 `bundle` 不会被压缩：\r\n\r\n**webpack.config.js**\r\n```javascript\r\nconst path = require('path');\r\n\r\nmodule.exports = {\r\n  entry: './src/index.js',\r\n  output: {\r\n    filename: 'bundle.js',\r\n    path: path.resolve(__dirname, 'dist'),\r\n  },\r\n mode: 'development',\r\n optimization: {\r\n   usedExports: true,\r\n },\r\n};\r\n```\r\n\r\n配置完这些后，更新入口脚本，使用其中一个新方法，并且为了简化示例，我们先将 `lodash` 删除：\r\n```javascript\r\n // import _ from 'lodash';\r\n import { cube } from './math.js';\r\n\r\n  function component() {\r\n   // const element = document.createElement('div');\r\n   const element = document.createElement('pre');\r\n\r\n   // Lodash, now imported by this script\r\n   // element.innerHTML = _.join(['Hello', 'webpack'], ' ');\r\n   element.innerHTML = [\r\n     'Hello webpack!',\r\n     '5 cubed is equal to ' + cube(5)\r\n   ].join('\\n\\n');\r\n\r\n    return element;\r\n  }\r\n\r\n  document.body.appendChild(component());\r\n```\r\n\r\n注意，我们没有从 `src/math.js` 模块中 `import` 另外一个 `square` 方法。\r\n这个函数就是所谓的 **未引用代码**，也就是说，应该删除掉未被引用的 `export`。\r\n现在打包，并查看输出的 `bundle`：\r\n\r\n**dist/bundle.js**\r\n```javascript\r\n/* 1 */\r\n/***/ (function (module, __webpack_exports__, __webpack_require__) {\r\n  'use strict';\r\n  /* unused harmony export square */\r\n  /* harmony export (immutable) */ __webpack_exports__['a'] = cube;\r\n  function square(x) {\r\n    return x * x;\r\n  }\r\n\r\n  function cube(x) {\r\n    return x * x * x;\r\n  }\r\n});\r\n```\r\n\r\n注意，上面的 `unused harmony export square` 注释。\r\n如果你观察它下面的代码，你会注意到虽然我们没有引用 `square`，但它仍然被包含在 `bundle` 中。\r\n我们将在下一节解决这个问题。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 3. 将文件标记为 side-effect-free(无副作用)\r\n在一个纯粹的 ESM 模块世界中，很容易识别出哪些文件有副作用。\r\n然而，我们的项目无法达到这种纯度，所以，此时有必要提示 `webpack compiler` 哪些代码是 **纯粹部分**。\r\n\r\n通过 `package.json` 的 `sideEffects` 属性，来实现这种方式。\r\n```javascript\r\n{\r\n  \"name\": \"your-project\",\r\n  \"sideEffects\": false\r\n}\r\n```\r\n\r\n如果所有代码都不包含副作用，我们就可以简单地将该属性标记为 false，来告知 `webpack` 它可以安全地删除未用到的 `export`。\r\n\r\n如果你的代码确实有一些副作用，可以改为提供一个数组：\r\n```javascript\r\n{\r\n  \"name\": \"your-project\",\r\n  \"sideEffects\": [\"./src/some-side-effectful-file.js\"]\r\n}\r\n```\r\n\r\n此数组支持简单的 glob 模式匹配相关文件。\r\n其内部使用了 **glob-to-regexp**（支持：*，**，{a,b}，[a-z]）。\r\n如果匹配模式为 `*.css`，且不包含 `/`，将被视为 `**/*.css`。\r\n```javascript\r\n{\r\n  \"name\": \"your-project\",\r\n  \"sideEffects\": [\"./src/some-side-effectful-file.js\", \"*.css\"]\r\n}\r\n```\r\n\r\n最后，还可以在 `module.rules` 配置选项中设置 `sideEffects`。\r\n\r\n## 4. 解释 tree shaking 和 sideEffects\r\n`sideEffects` 和 `usedExports`（tree shaking）是两种不同的优化方式。\r\n\r\n`sideEffects` 更为有效 是因为它允许跳过整个模块/文件和整个文件子树。\r\n\r\n`usedExports` 依赖于 `terser` 去检测语句中的副作用。\r\n它是一个 JavaScript 任务而且没有像 `sideEffects` 一样简单直接。\r\n而且它不能跳转子树/依赖由于细则中说副作用需要被评估。\r\n尽管导出函数能运作如常，但 React 框架的 `HOC` 在这种情况下是会出问题的。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 5. 将函数调用标记为无副作用\r\n可以告诉 webpack 一个函数调用是无副作用的，只要通过 /*#__PURE__*/ 注释。\r\n它可以被放到函数调用之前，用来标记它们是无副作用的。\r\n传到函数中的入参是无法被刚才的注释所标记，需要单独每一个标记才可以。\r\n如果一个没被使用的变量定义的初始值被认为是无副作用的，它会被标记为死代码，不会被执行且会被压缩工具清除掉。\r\n这个行为被会开启当 `optimization.innerGraph` 压缩输出结果被设置成 true。\r\n\r\n**file.js**\r\n```javascript\r\n/*#__PURE__*/ double(55);\r\n```\r\n\r\n## 6. 压缩输出结果\r\n通过 `import` 和 `export` 语法，我们已经找出需要删除的 **未引用代码**。\r\n然而，不仅仅是要找出，还要在 `bundle` 中删除它们。\r\n为此，我们需要将 `mode` 配置选项设置为 `production`。\r\n\r\n**webpack.config.js**\r\n```javascript\r\nconst path = require('path');\r\n\r\nmodule.exports = {\r\n  entry: './src/index.js',\r\n  output: {\r\n    filename: 'bundle.js',\r\n    path: path.resolve(__dirname, 'dist'),\r\n  },\r\n // mode: 'development',\r\n // optimization: {\r\n //   usedExports: true,\r\n // }\r\n mode: 'production',\r\n};\r\n```\r\n\r\n## 7. 总结\r\n我们学到为了利用 `tree shaking` 的优势， 你必须...\r\n\r\n- 使用 ES2015 模块语法（即 import 和 export）。\r\n- 确保没有编译器将您的 ES2015 模块语法转换为 CommonJS 的。\r\n- 在项目的 `package.json` 文件中，添加 `sideEffects` 属性。\r\n- 使用 `mode` 为 `production` 的配置项以启用 **更多优化项**，包括 **压缩代码** 与 `tree shaking`。\r\n\r\n你可以将应用程序想象成一棵树。\r\n绿色表示实际用到的 source code(源码) 和 library(库)，是树上活的树叶。\r\n灰色表示未引用代码，是秋天树上枯萎的树叶。\r\n为了除去死去的树叶，你必须摇动这棵树，使它们落下。"}]},{"number":94,"title":"【Q094】常见的配置项","labels":["webpack"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/94","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 模块热替换\r\n### 启用 HMR\r\n启用此功能需要更新 `webpack-dev-server` 的配置，和使用 webpack 内置的 HMR 插件。\r\n\r\n**webpack.config.js**\r\n```javascript\r\nmodule.exports = {\r\n    devServer: {\r\n        hot: true\r\n    }\r\n};\r\n```\r\n\r\n**worker.js**\r\n```javascript\r\nif (module.hot) {\r\n  module.hot.accept('./print.js', function() {\r\n    console.log('模块更新');\r\n  })\r\n}\r\n```\r\n\r\n### HMR 修改样式表\r\nCSS 的模块热更新，借助于 `style-loader`。\r\n\r\n## 2. Tree shaking\r\n### 设置 sideEffects\r\n在 `package.json` 中：\r\n```json\r\n{\r\n  \"name\": \"your-project\",\r\n  \"sideEffects\": [\r\n    \"./src/some-side-effectful-file.js\",\r\n    \"*.css\"\r\n  ]\r\n}\r\n```\r\n\r\nsideEffects 可选值：\r\n\r\n- false ，所有文件代码都没有副作用\r\n- 数组，指定文件代码是有副作用\r\n\r\n「副作用」的定义是，在导入时会执行特殊行为的代码，而不是仅仅暴露一个 `export` 或多个 `export`。\r\n举例说明，例如 polyfill，它影响全局作用域，并且通常不提供 `export`。有副作用的不能 `tree sharking`!\r\n\r\n**注意**，任何导入的文件都会受到 `tree shaking` 的影响。\r\n这意味着，如果在项目中使用类似 `css-loader` 并导入 CSS 文件，则需要将其添加到 `sideEffect` 列表中，以免在生产模式中无意中将它删除。\r\n\r\n还可以在 `module.rules` 配置选项 中设置 `sideEffects`\r\n\r\n### 压缩输出\r\n从 v4 开始，也可以通过 `mode` 配置选项轻松切换到压缩输出，只需设置为 `production`。\r\n```javascript\r\n// webpack.config.js\r\n\r\nmodule.exports = {\r\n  mode: \"production\"\r\n};\r\n```\r\n\r\n### tree sharking 条件\r\n\r\n- 使用 ES2015 模块语法（即 `import` 和 `export`）\r\n- 在项目 `package.json` 文件中，添加一个 `sideEffects` 入口\r\n- 引入一个能够删除未引用代码(dead code)的压缩工具(minifier)（例如 `UglifyJSPlugin`,  v4 开始可以设置 `mode: \"production\"`来代替）"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 3. devtool\r\n**生产环境**，在使用 `uglifyjs-webpack-plugin` 时，你必须提供 `sourceMap：true` 选项来启用 source map 支持。\r\n**鼓励你在生产环境中启用 source map**，因为它们对调试源码(debug)和运行基准测试(benchmark tests)很有帮助。\r\n\r\n### 开发环境\r\n\r\n- `eval`：映射到转换后的代码\r\n- `eval-source-map`：行数能够正确映射，会映射到原始代码中。\r\n- `cheap-eval-source-map`：类似 `eval-source-map`，每个模块使用 `eval()` 执行。\r\n这是 **低开销** 的 source map，因为它没有生成列映射，只是映射行数。\r\n它会忽略源自 `loader` 的 source map，并且仅显示转译后的代码，就像 `eval devtool`。\r\n- `cheap-module-eval-source-map` ：类似 `cheap-eval-source-map`。\r\n并且，在这种情况下，源自 `loader` 的 source map 会得到更好的处理结果。\r\n然而，`loader` source map 会被简化为每行一个映射。\r\n\r\n### 生产环境\r\n\r\n- `none`（省略 devtool 选项）：不生成 source map。这是一个不错的选择。\r\n- `source-map`：整个 source map 作为一个单独的文件生成。\r\n它为 `bundle` 添加了一个引用注释，以便开发工具知道在哪里可以找到它。\r\n**你应该将你的服务器配置为，不允许普通用户访问 source map 文件！**\r\n- `hidden-source-map` ：与 `source-map` 相同，但不会为 `bundle` 添加引用注释。\r\n如果你只想 source map 映射那些源自错误报告的错误堆栈跟踪信息，但不想为浏览器开发工具暴露你的 source map，这个选项会很有用。\r\n**你不应将 source map 文件部署到 web 服务器。而是只将其用于错误报告工具。**\r\n- `nosources-source-map`：创建的 source map 不包含 **源代码内容**。\r\n它可以用来映射客户端上的堆栈跟踪，而无须暴露所有的源代码。\r\n你可以将 source map 文件部署到 web 服务器。\r\n**这仍然会暴露反编译后的文件名和结构，但它不会暴露原始代码。**\r\n\r\n### 特定场景\r\n以下选项对于开发环境和生产环境并不理想。\r\n他们是一些特定场景下需要的，例如，针对一些第三方工具。\r\n\r\n- `inline-source-map`：source map 转换为 DataUrl 后添加到 `bundle` 中。\r\n- `cheap-source-map`：没有列映射的 source map，忽略 `loader` source map。\r\n- `inline-cheap-source-map`：类似 `cheap-source-map`，但是 source map 转换为 DataUrl 后添加到 `bundle` 中。\r\n- `cheap-module-source-map`：没有列映射的 source map，将 `loader` source map 简化为每行一个映射。\r\n- `inline-cheap-module-source-map`：类似 `cheap-module-source-map`，但是 source map 转换为 DataUrl 添加到 `bundle` 中。\r\n\r\n## 4. 指定环境变量\r\n### 基本使用\r\n`NODE_ENV` 属性：\r\n\r\n这个变量并不是 `pocess.env` 直接就有的，而是通过设置得到的。\r\n可以通过判断这个变量区分开发环境或生产环境。\r\n\r\n我们可以使用 webpack 内置的 `DefinePlugin` 为所有的依赖定义这个变量：\r\n```javascript\r\n// webpack.prod.js\r\n\r\nconst webpack = require('webpack');\r\nconst merge = require('webpack-merge');\r\nconst common = require('./webpack.common.js');\r\n\r\nmodule.exports = merge(common, {\r\n  plugins: [\r\n    new webpack.DefinePlugin({\r\n      'process.env.NODE_ENV': JSON.stringify('production')\r\n    })\r\n  ]\r\n});\r\n```\r\n\r\n任何位于 `/src` 的本地代码都可以关联到 `process.env.NODE_ENV` 环境变量，所以以下检查也是有效的：\r\n```javascript\r\n// src/worker.js\r\n\r\nimport { cube } from './math.js';\r\n\r\nif (process.env.NODE_ENV !== 'production') {\r\n  console.log('Looks like we are in development mode!');\r\n}\r\n```\r\n\r\n### 如何在 webpack 配置文件里获取 NODE_ENV 的值\r\n在 `package.json` 配置 `corss-env`：\r\n```json\r\n\"scripts\": {\r\n    \"build-prod\":\"cross-env NODE_ENV=production webpack\"\r\n}\r\n```\r\n\r\n通过 `cross-env NODE_ENV=production`，信息传递给了 webpack 的配置文件, src 文件下面不能访问。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 5. 代码分离\r\n### 概述\r\n把代码分离到不同的 bundle 中，然后可以 **按需加载或并行加载 **这些文件。\r\n代码分离可以用于获取 **更小的 bundle**，以及 **控制资源加载优先级**，如果使用合理，会极大缩小加载时间。\r\n\r\n有三种常用的代码分离方法：\r\n\r\n- **入口起点**：使用 `entry` 配置手动地分离代码。\r\n- **防止重复**：使用 `CommonsChunkPlugin` 去重和分离 chunk。\r\n- **动态导入**：通过模块的内联函数调用来分离代码。\r\n\r\n### 动态导入(dynamic imports)\r\n当涉及到动态代码拆分时，webpack 提供了两个类似的技术：\r\n\r\n- 使用符合 **ECMAScript 提案** 的 `import() 语法`。优先选择的方式。\r\n- 使用 webpack 特定的 `require.ensure`。已被 `import()` 取代。\r\n\r\n重点讲第一种。\r\n**worker.js**\r\n```javascript\r\n// 方式一\r\nconst _ = await import(/* webpackChunkName: \"lodash\" */ 'lodash');\r\n\r\n// 方式二\r\nimport(/* webpackChunkName: \"print\" */ './print').then(module => {\r\n      var print = module.default;\r\n      // ...\r\n});\r\n```\r\n\r\n注意：当调用 ES6 模块的 `import()` 方法时，必须指向模块的 `.default` 值，因为它才是 promise 被处理后返回的实际的 `module` 对象。\r\n\r\n**webpack.config.js**\r\n```javascript\r\noutput: {\r\n    filename: '[name].bundle.js',\r\n    chunkFilename: '[name].bundle.js',\r\n    path: path.resolve(__dirname, 'dist')\r\n}\r\n```\r\n\r\n### bundle 分析\r\n介绍几种常用分析工具：\r\n\r\n- [官方分析工具](https://github.com/webpack/analyse)\r\n- [webpack-chart](https://alexkuz.github.io/webpack-chart/): webpack stats 可交互饼图。\r\n- [webpack-visualizer](https://chrisbateman.github.io/webpack-visualizer/): 可视化并分析你的 bundle，检查哪些模块占用空间，哪些可能是重复使用的。\r\n- [webpack-bundle-analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer)：一个 plugin 和 CLI 工具，它将 bundle 内容展示为一个便捷的、交互式、可缩放的树状图形式。\r\n- [webpack bundle optimize helper](https://webpack.jakoblind.no/optimize)：这个工具会分析你的 bundle，并提供可操作的改进措施，以减少 bundle 的大小。\r\n- [bundle-stats](https://github.com/bundle-stats/bundle-stats)：生成一个 bundle 报告（bundle 大小、资源、模块），并比较不同构建之间的结果。\r\n\r\n## 6. 缓存\r\n### hash、chunkhash 和 contenthash 三者的区别\r\n在 webpack 中有时需要使用 hash 来做静态资源实现增量更新方案之一，文件名的 hash 值可以有三种 hash 生成方式，每一种都有不同应用场景，那么三者有何区别呢？\r\n\r\nhash 一般是结合CDN缓存来使用，通过 webpack 构建之后，生成对应文件名自动带上对应的 MD5 值。\r\n如果文件内容发生改变的话，那么对应文件 hash 值也会改变，对应的 HTML 引用的 URL 地址也会改变，\r\n触发 CDN 服务器从原服务器上拉取对应数据，进而更新本地缓存。\r\n但是实际使用时，这三种 hash 计算还是有一定区别。\r\n\r\n#### hash\r\n`hash` 是跟整个项目的构建相关，构建生成的文件 hash 值都是一样的，所以 `hash` 计算是跟整个项目的构建相关。\r\n同一次构建过程中生成的 `hash` 都是一样的，只要项目里有文件更改，整个项目构建的 hash 值都会更改。\r\n\r\n如果出口是 `hash`，那么一旦针对项目中任何一个文件的修改，都会构建整个项目，重新获取 hash 值，缓存的目的将失效。\r\n\r\n#### chunkhash\r\n采用 `hash` 计算的话，每一次构建后生成的 hash 值都不一样，即使文件内容压根没有改变。\r\n这样子是没办法实现缓存效果，我们需要另一种 hash 值计算方法，即 `chunkhash`。\r\n\r\n`chunkhash` 和 `hash` 不一样，它根据不同的入口文件(Entry)进行依赖文件解析、构建对应的 chunk，生成对应的 hash 值。\r\n我们在生产环境里把一些公共库和程序入口文件区分开，单独打包构建，接着我们采用 `chunkhash` 的方式生成 hash 值，那么只要我们不改动公共库的代码，就可以保证其 hash 值不会受影响。\r\n\r\n由于采用 `chunkhash`，所以项目主入口文件 `main.js` 及其对应的依赖文件 `main.css` 由于被打包在同一个模块，\r\n所以共用相同的 `chunkhash`，但是公共库由于是不同的模块，所以有单独的 `chunkhash`。\r\n这样子就保证了在线上构建时只要文件内容没有更改就不会重复构建。\r\n```javascript\r\nentry:{\r\n    main: path.join(__dirname,'./main.js'),\r\n    vendor: ['vue']\r\n},\r\noutput:{\r\n    path:path.join(__dirname,'./dist'),\r\n    publicPath: '/dist/',\r\n    filname: 'bundle.[chunkhash].js'\r\n}\r\n```\r\n\r\n#### contenthash\r\n`contenthash` 表示由文件内容产生的 hash 值，内容不同产生的 `contenthash` 值也不一样。\r\n在项目中，通常做法是把项目中 css 都抽离出对应的 css 文件来加以引用。\r\n\r\n在这里我用 `mini-css-extract-plugin` 替代了 `extract-text-webpack-plugin`。\r\n```javascript\r\nconst miniCssExtractPlugin=require(\"mini-css-extract-plugin\");\r\n \r\nmodule.exports={\r\n    module:{\r\n        rules:[\r\n            {\r\n                test: /\\.css$/,\r\n                use:[\r\n                    miniCssExtractPlugin.loader,\r\n                    'css-loader'\r\n                ]\r\n            }\r\n        ]\r\n    },\r\n    plugins:[\r\n        new miniExtractPlugin({\r\n            filename: 'main.[contenthash:7].css'\r\n        })\r\n    }\r\n}\r\n```\r\n\r\n打包后即使 css 文件所处的模块里就算其他文件内容改变，只要 css 文件内容不变，那么就不会重复构建。\r\n\r\n#### 注意：\r\n如果对 css 使用了 `chunkhash` 之后，它与依赖它的 chunk 共用 `chunkhash`，\r\n测试后会发现，css 与 js 文件名的 `chunkhash` 值是一样的，如果我修改了 js 文件，js 的 hash 值会变化，\r\ncss 的文件名的 hash 还是和变化后的 js 文件的 hash 值一样，如果我修改了 css 文件，也会导致重新构建，css 的 hash 值和 js 的 hash 值还是一样的，即使 js 文件没有被修改。\r\n这样会导致缓存作用失效，所以 css 文件最好使用 `contenthash`。\r\n\r\n### 实现图片/字体的缓存\r\n对于图片、字体等静态资源，生成对应的文件 hash 值是由对应的 `file-loader` 来计算的。\r\n\r\n那么这些静态文件的 hash 值使用的是什么 hash 值呢？\r\n\r\n其实就是 hash 属性值。\r\n此 hash 非 webpack 每次项目构建的 `hash`，它是由 `file-loader` 根据文件内容计算出来的，不是 webpack 构建的 `hash`。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 7. 多种 webpack 配置方式(configuration types)\r\n### 导出为一个函数\r\n```javascript\r\n module.exports = function(env, argv) {\r\n   return {\r\n     mode: env.production ? 'production' : 'development',\r\n     devtool: env.production ? 'source-maps' : 'eval',\r\n     plugins: [\r\n       new webpack.optimize.UglifyJsPlugin({\r\n         compress: argv['optimize-minimize'] // 只有传入 -p 或 --optimize-minimize\r\n       })\r\n     ]\r\n   };\r\n};\r\n```\r\n\r\n当 webpack 配置为 **导出为一个函数** 时，可以向起传入一个 `环境对象(environment)`。\r\n也可以通过 `指定环境变量` 中的 `cross-env NODE_ENV=production webpack` 配置。\r\n```bash\r\nwebpack --env.NODE_ENV=local --env.production --progress\r\n```\r\n\r\n注意：如果设置 `env` 变量，却没有赋值，默认将 `--env.production` 设置为 `true`。\r\n还有其他可以使用的语法。有关详细信息，请查看 [webpack CLI](https://link.juejin.cn/?target=https%3A%2F%2Fwww.webpackjs.com%2Fapi%2Fcli%2F%23environment-options) 文档。\r\n\r\n### 导出一个 Promise\r\nwebpack 将运行由配置文件导出的函数，并且等待 Promise 返回。\r\n便于需要异步地加载所需的配置变量。\r\n```javascript\r\nmodule.exports = () => {\r\n  return new Promise((resolve, reject) => {\r\n    setTimeout(() => {\r\n      resolve({\r\n        entry: './app.js',\r\n        /* ... */\r\n      })\r\n    }, 5000)\r\n  })\r\n}\r\n```\r\n\r\n### 导出一个配置对象\r\n\r\n### 导出数组，多个配置对象\r\n\r\n## 8. webpack-dev-server 的刷新模式 inline 和 iframe 详解\r\n### iframe\r\n\r\n- 在网页中嵌入了一个 `iframe`，将我们自己的应用注入到这个 `iframe` 当中去。\r\n- 在页面头部有一个提示框，用于显示构建过程的状态信息。\r\n- 加载了 `live.bundle.js` 文件，其不但创建了 `iframe` 标签，同时包含 `socket.io的client` 代码，以和 `webpack-dev-server` 进行 `websocket` 通讯，从而完成自动编译打包、页面自动刷新的功能。\r\n\r\n### inline\r\n\r\n- 构建消息在浏览器控制台显示。\r\n- `socket.io` 的 `client` 代码被打包进了你的包(bundle)中，以此来与 `webpack-dev-server` 进行 `websocket` 通讯，从而完成自动编译打包、页面自动刷新的功能。\r\n- 但是，每一个入口文件都会被插入上述的一段脚本，使得打包后的 `bundle` 文件很臃肿。\r\n\r\n### 总结\r\n\r\n- `iframe` 和 `inline` 实现的效果都是一样的，都是监听文件的变化，然后再将编译后的文件推送到前端，完成页面的 `reload` 的。\r\n- 通过设置 `devServer.inline` 切换两种模式，默认为 `inline` 模式。\r\n- 当使用 `HMR` 功能时，推荐使用 `inline`。\r\n\r\n## 9. 模式\r\n设置 `NODE_ENV` 时，不会自动设置 `mode`。\r\n### 用法\r\n只在配置中提供 `mode` 选项：\r\n```javascript\r\n// webpack.config.js\r\n\r\nmodule.exports = {\r\n  mode: 'production'\r\n};\r\n```\r\n\r\n或者从 CLI 参数中传递：\r\n```bash\r\nwebpack --mode=production\r\n```\r\n\r\n### 生产环境 production\r\n```javascript\r\n// webpack.production.config.js\r\n\r\nmodule.exports = {\r\n+  mode: 'production',\r\n-  plugins: [\r\n-    new UglifyJsPlugin(/* ... */),\r\n-    new webpack.DefinePlugin({ \"process.env.NODE_ENV\": JSON.stringify(\"production\") }),\r\n-    new webpack.optimize.ModuleConcatenationPlugin(),\r\n-    new webpack.NoEmitOnErrorsPlugin()\r\n-  ]\r\n}\r\n```\r\n\r\n### 开发环境\r\n```javascript\r\n// webpack.development.config.js\r\n\r\nmodule.exports = {\r\n+ mode: 'development'\r\n- plugins: [\r\n-   new webpack.NamedModulesPlugin(),\r\n-   new webpack.DefinePlugin({ \"process.env.NODE_ENV\": JSON.stringify(\"development\") }),\r\n- ]\r\n}\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 10. output\r\n### output.library\r\n对于用途广泛的 library，我们希望它能够兼容不同的环境，例如 CommonJS，AMD，Node.js 或者作为一个全局变量。\r\n为了让你的 library 能够在各种用户环境(consumption)中可用，需要在 `output` 中添加 `library` 属性。\r\n\r\n为了让 library 和其他环境兼容，还需要在配置文件中添加 `libraryTarget `属性。\r\n这是可以控制 library 如何以不同方式暴露的选项，`output.libraryTarget` 的默认选项是 `var`。\r\n```javascript\r\n  output: {\r\n    path: path.resolve(__dirname, 'dist'),\r\n    filename: 'webpack-numbers.js',\r\n    library: 'webpackNumbers'\r\n    library: 'webpackNumbers',\r\n    libraryTarget: 'umd'\r\n  },\r\n```\r\n\r\n### output.publicPath 和 devServer.publicPath 的区别\r\n`devServer.publicPath` 的意义就是决定外部能以怎样的路径通过 `devServer` 来访问构建在内存中的文件，\r\n这个字段未显式设定时，则会去沿用 `output.publicPath` 字段的显式值（如果 `output.publicPath` 有值的话，否则就用自己的 default 值）。\r\n`output.publicPath` 的意义是用来为构建的文件生成满足特定需求的前缀，并将这个前缀提供给需要的 `resolver`、`plugin` 或者其他的配置字段。\r\n\r\n注意：`HtmlWebpackPlugin` 中的 `filename` 也会依赖于 `public.publicPath`。\r\n\r\n### output.path\r\n这个字段只在 `production` 配置下有效。\r\n另外，它的 default 值是 `path.resolve(__dirname, './dist')`。\r\n\r\n## 11. webpack.optimize.ModuleConcatenationPlugin\r\n过去 webpack 打包时的一个取舍是将 bundle 中各个模块单独 **打包成闭包**。\r\n这些打包函数使你的 JavaScript 在浏览器中 **处理的更慢**。\r\n相比之下，一些工具像 `Closure Compiler` 和 `RollupJS` 可以提升(hoist)或者 **预编译所有模块到一个闭包中**，提升你的代码在浏览器中的执行速度。\r\n这个插件会在 webpack 中实现以上的预编译功能。\r\n\r\n## 12. devServer\r\n`devServer` 构建的文件是在内存里的，而非你电脑的磁盘上，但是如果内存中找不到想要的文件时，`devServer` 会根据文件的路径尝试去电脑的磁盘上找，如果这样还找不到才会 404。\r\n\r\n开发时在内存和 `contentBase` 下真实的磁盘路径中存在着同样文件名的文件，那么 `devServer` 返回的是内存的那个。\r\n\r\n### devServer.historyApiFallback\r\n```javascript\r\n historyApiFallback: {\r\n     rewrites: [\r\n         { from: /.*/, to: path.posix.join(devConfig.assetsPublicPath, 'index.html') },\r\n     ],\r\n },\r\n```\r\n\r\n当使用 `HTML5 History API` 时，任意的 404 响应都可能需要被替代为 `index.html`。通过传入以下启用：\r\n```javascript\r\nhistoryApiFallback: true\r\n```\r\n\r\n通过传入一个对象，比如使用 `rewrites` 这个选项，此行为可进一步地控制：\r\n```javascript\r\nhistoryApiFallback: {\r\n  rewrites: [\r\n    { from: /^\\/$/, to: '/views/landing.html' },\r\n    { from: /^\\/subpage/, to: '/views/subpage.html' },\r\n    { from: /./, to: '/views/404.html' }\r\n  ]\r\n}\r\n```\r\n\r\n### devServer.publicPath\r\n决定外部能够以什么样的路径访问到构建的文件。\r\n\r\n与 `output.publicPath` 的关系，参考第10小节的 **[output.publicPath 和 devServer.publicPath 的区别]**。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 13. 监听文件\r\nwebpack 可以监听文件变化，当它们修改后会重新编译。\r\n\r\n### watch\r\n`boolean = false`\r\n\r\n启用 Watch 模式。这意味着在初始构建之后，webpack 将继续监听任何已解析文件的更改。\r\n```javascript\r\n// webpack.config.js\r\n\r\nmodule.exports = {\r\n  watch: true,\r\n};\r\n```\r\n\r\n注意：`webpack-dev-server` 和 `webpack-dev-middleware` 里 Watch 模式默认开启。\r\n\r\n### watchOptions\r\n`object`\r\n\r\n一组用来定制 watch 模式的选项：\r\n```javascript\r\n// webpack.config.js\r\n\r\nmodule.exports = {\r\n  watchOptions: {\r\n    aggregateTimeout: 200,\r\n    poll: 1000,\r\n  },\r\n};\r\n```\r\n\r\n### watchOptions.aggregateTimeout\r\n`number = 20`\r\n\r\n当第一个文件更改，会在重新构建前增加延迟。\r\n这个选项允许 webpack 将这段时间内进行的任何其他更改都聚合到一次重新构建里。以毫秒为单位：\r\n```javascript\r\n// webpack.config.js\r\n\r\nmodule.exports = {\r\n  watchOptions: {\r\n    aggregateTimeout: 600,\r\n  },\r\n};\r\n```\r\n\r\n### watchOptions.ignored\r\n`RegExp` `string` `[string]`\r\n\r\n对于某些系统，监听大量文件会导致大量的 CPU 或内存占用。\r\n所以可以选择下面一种方法来排除文件/目录：\r\n```javascript\r\n// webpack.config.js\r\n\r\nconst path = require('path');\r\n\r\nmodule.exports = {\r\n  watchOptions: {\r\n    ignored: /node_modules/, // 正则模式\r\n    ignored: '**/node_modules', // glob 模式\r\n    ignored: ['**/files/**/*.js', '**/node_modules'], // 多 glob 匹配模式\r\n    ignored: [path.posix.resolve(__dirname, './ignored-dir')], // 绝对路径\r\n  },\r\n};\r\n```\r\n\r\n当使用 glob 模式时，我们使用 [glob-to-regexp](https://github.com/fitzgen/glob-to-regexp) 将其转为正则表达式。\r\n因此，在使用 `watchOptions.ignored` 的 glob 模式之前，请确保自己熟悉它。\r\n\r\n注意：如果你使用 `require.context`，webpack 会监听你的整个目录。\r\n你应该忽略一些文件和目录，以便那些不需要监听的文件修改后不会触发重新构建。\r\n\r\n\r\n### watchOptions.poll\r\n`boolean = false` `number`\r\n\r\n通过传递 true 开启 `polling`，或者指定毫秒为单位进行轮询。\r\n```javascript\r\n// webpack.config.js\r\n\r\nconst path = require('path');\r\n\r\nmodule.exports = {\r\n  watchOptions: {\r\n    poll: 1000, // 每秒检查一次变动\r\n  },\r\n};\r\n```\r\n\r\n### watchOptions.followSymlinks\r\n`boolean`\r\n\r\n根据软链接查找文件。这通常是不需要的，因为 webpack 已经使用 `resolve.symlinks` 解析了软链接。\r\n```javascript\r\n// webpack.config.js\r\n\r\nconst path = require('path');\r\n\r\nmodule.exports = {\r\n  watchOptions: {\r\n    followSymlinks: true,\r\n  },\r\n};\r\n```\r\n\r\n### watchOptions.stdin\r\n`boolean`\r\n\r\n当 stdin 流结束时停止监听。\r\n```javascript\r\n// webpack.config.js\r\n\r\nconst path = require('path');\r\n\r\nmodule.exports = {\r\n  watchOptions: {\r\n    stdin: true,\r\n  },\r\n};\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 14. SplitChunksPlugin\r\n`SplitChunksPlugin` 是拆分模块的插件。\r\n\r\n开箱即用的 `SplitChunksPlugin` 对于大部分用户来说非常友好。\r\n\r\n默认情况下，它只会影响到按需加载的 chunks，因为修改 initial chunks 会影响到项目的 HTML 文件中的脚本标签。\r\n\r\nwebpack 将根据以下条件自动拆分 chunks：\r\n\r\n- 新的 chunk 可以被共享，或者模块来自于 `node_modules` 文件夹\r\n- 新的 chunk 体积大于 20kb（在进行 min+gz 之前的体积）\r\n- 当按需加载 chunks 时，并行请求的最大数量小于或等于 30\r\n- 当加载初始化页面时，并发请求的最大数量小于或等于 30\r\n- 当尝试满足最后两个条件时，最好使用较大的 chunks。\r\n\r\n### optimization.splitChunks\r\n下面这个配置对象代表 `SplitChunksPlugin` 的默认参数。\r\n```javascript\r\n// webpack.config.js\r\n\r\nmodule.exports = {\r\n  optimization: {\r\n    splitChunks: {\r\n      chunks: 'async',\r\n      minSize: 20000,\r\n      minRemainingSize: 0,\r\n      minChunks: 1,\r\n      maxAsyncRequests: 30,\r\n      maxInitialRequests: 30,\r\n      enforceSizeThreshold: 50000,\r\n      cacheGroups: {\r\n        defaultVendors: {\r\n          test: /[\\\\/]node_modules[\\\\/]/,\r\n          priority: -10,\r\n          reuseExistingChunk: true,\r\n        },\r\n        default: {\r\n          minChunks: 2,\r\n          priority: -20,\r\n          reuseExistingChunk: true,\r\n        },\r\n      },\r\n    },\r\n  },\r\n};\r\n```"}]},{"number":95,"title":"【Q095】publicPath 是干什么的","labels":["webpack"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/95","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. output. publicPath\r\n`output.publicPath` 用于指定 **按需加载** 或 **加载外部资源** 的目录。\r\n如果指定了一个错误的值，则在加载这些资源时会收到 404 错误。\r\n\r\n该选项的值是以 `runtime` 或 `loader` 所创建的每个 URL 为前缀。\r\n因此，在多数情况下，此选项的值都会以 `/` 结束。\r\n\r\n根据不同需求，选择其中一项配置：\r\n```javascript\r\n// webpack.config.js\r\n\r\nmodule.exports = {\r\n  output: {\r\n    publicPath: 'auto', // 按照以下顺序取：`import.meta.url`、`document.currentScript`、`<script />`、`self.location`\r\n    publicPath: 'https://cdn.example.com/assets/', // CDN（HTTPS）\r\n    publicPath: '//cdn.example.com/assets/', // CDN\r\n    publicPath: '/assets/', // 相对于服务\r\n    publicPath: 'assets/', // 相对于 HTML 页面\r\n    publicPath: '../assets/', // 相对于 HTML 页面\r\n    publicPath: '', // 相对于 HTML 页面\r\n  },\r\n};\r\n```\r\n\r\n在 **编译时** 无法知道输出文件的 `publicPath` 的情况下，可以留空，\r\n然后在 **入口文件** 处使用自由变量 `__webpack_public_path__`，以便在 **运行时** 进行动态设置。\r\n```javascript\r\n__webpack_public_path__ = myRuntimePublicPath;\r\n\r\n// ...入口文件的其他代码\r\n```"}]},{"number":96,"title":"【Q096】打包很慢，怎么解决","labels":["webpack"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/96","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 分析打包速度\r\n优化 webpack 构建速度的第一步是知道将精力集中在哪里。\r\n我们可以通过 `speed-measure-webpack-plugin` 测量你的 webpack 构建期间各个阶段花费的时间：\r\n```javascript\r\n// 分析打包时间\r\nconst SpeedMeasurePlugin = require(\"speed-measure-webpack-plugin\");\r\nconst smp = new SpeedMeasurePlugin();\r\n// ...\r\nmodule.exports = smp.wrap(prodWebpackConfig)\r\n```\r\n\r\n每一个项目，都有自己的打包性能问题，下面我们对打包的每一个环节进行优化。\r\n\r\n## 2. 分析影响打包速度环节\r\n打包就是从入口文件开始将所有的依赖模块打包到一个文件中的过程。\r\n当然，在打包过程中涉及各种编译、优化过程。\r\n\r\n打包过程中，常见影响构建速度的地方有哪些？\r\n\r\n### 1. 开始打包，我们需要获取所有的依赖模块\r\n搜索所有的依赖项，这需要占用一定的时间，即搜索时间，那么我们就确定了：\r\n\r\n我们需要优化的第一个时间就是 **搜索时间**。\r\n\r\n### 2. 解析所有的依赖模块（解析成浏览器可运行的代码）\r\nwebpack 根据我们配置的 `loader` 解析相应的文件。\r\n日常开发中我们需要使用 `loader` 对 js ，css ，图片，字体等文件做转换操作，并且转换的文件数据量也是非常大。\r\n由于 nodejs 单线程的特性使得这些转换操作不能并发处理文件，而是需要一个个文件进行处理。\r\n\r\n我们需要优化的第二个时间就是 **解析时间**。\r\n\r\n### 3. 将所有的依赖模块打包到一个文件\r\n将所有解析完成的代码，打包到一个文件中，为了使浏览器加载的包更新（减小白屏时间），所以 webpack 会对代码进行优化。\r\nJS 压缩是发布编译的最后阶段，通常 webpack 需要卡好一会，这是因为压缩  JS 需要先将代码解析成 AST 语法树，然后需要根据复杂的规则去分析和处理 AST，最后将 AST 还原成  JS，这个过程涉及到大量计算，因此比较耗时，打包就容易卡住。\r\n\r\n我们需要优化的第三个时间就是 **压缩时间**。\r\n\r\n### 4. 二次打包\r\n当更改项目中一个小小的文件时，我们需要重新打包，所有的文件都必须要重新打包，需要花费同初次打包相同的时间，但项目中大部分文件都没有变更，尤其是第三方库。\r\n\r\n我们需要优化的第四个时间就是 **二次打包时间**。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 3. 优化解析时间 - 开启多进程打包\r\n运行在 Node.js 之上的 webpack 是单线程模式的，也就是说，webpack 打包只能逐个文件处理，\r\n当 webpack 需要打包大量文件时，打包时间就会比较漫长。\r\n\r\n### 1. thread-loader（webpack4 官方推荐）\r\n把这个 `loader` 放置在其他 `loader` 之前， \r\n放置在这个 `loader `之后的 `loader` 就会在一个单独的 worker【worker pool】 池里运行，\r\n一个 worker 就是一个 nodeJS 进程【node.js proces】，\r\n每个单独进程处理时间上限为600ms，各个进程的数据交换也会限制在这个时间内。\r\n\r\n`thread-loader` 使用起来也非常简单，只要把 `thread-loader` 放置在其他 `loader` 之前， 那 `thread-loader` 之后的 `loader` 就会在一个单独的 worker 池(worker pool)中运行。\r\n\r\n```javascript\r\nmodule.exports = {\r\n  // ...\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.js$/,\r\n        exclude: /node_modules/,\r\n        // 创建一个 js worker 池\r\n        use: [ \r\n          'thread-loader',\r\n          'babel-loader'\r\n        ] \r\n      },\r\n      {\r\n        test: /\\.s?css$/,\r\n        exclude: /node_modules/,\r\n        // 创建一个 css worker 池\r\n        use: [\r\n          'style-loader',\r\n          'thread-loader',\r\n          {\r\n            loader: 'css-loader',\r\n            options: {\r\n              modules: true,\r\n              localIdentName: '[name]__[local]--[hash:base64:5]',\r\n              importLoaders: 1\r\n            }\r\n          },\r\n          'postcss-loader'\r\n        ]\r\n      }\r\n      // ...\r\n    ]\r\n    // ...\r\n  }\r\n  // ...\r\n}\r\n```\r\n\r\n注意：`thread-loader` 放在了 `style-loader` 之后，这是因为 `thread-loader` 后的 `loader` 没法存取文件也没法获取 webpack 的选项设置。\r\n\r\n官方上说每个 worker 大概都要花费 600ms ，所以官方为了防止启动 worker 时的高延迟，提供了对 worker 池的优化：**预热**：\r\n```javascript\r\n// ...\r\nconst threadLoader = require('thread-loader');\r\n\r\nconst jsWorkerPool = {\r\n  // options\r\n  \r\n  // 产生的 worker 的数量，默认是 (cpu 核心数 - 1)\r\n  // 当 require('os').cpus() 是 undefined 时，则为 1\r\n  workers: 2,\r\n  \r\n  // 闲置时定时删除 worker 进程\r\n  // 默认为 500ms\r\n  // 可以设置为无穷大， 这样在监视模式(--watch)下可以保持 worker 持续存在\r\n  poolTimeout: 2000\r\n};\r\n\r\nconst cssWorkerPool = {\r\n  // 一个 worker 进程中并行执行工作的数量\r\n  // 默认为 20\r\n  workerParallelJobs: 2,\r\n  poolTimeout: 2000\r\n};\r\n\r\nthreadLoader.warmup(jsWorkerPool, ['babel-loader']);\r\nthreadLoader.warmup(cssWorkerPool, ['css-loader', 'postcss-loader']);\r\n\r\n\r\nmodule.exports = {\r\n  // ...\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.js$/,\r\n        exclude: /node_modules/,\r\n        use: [\r\n          {\r\n            loader: 'thread-loader',\r\n            options: jsWorkerPool\r\n          },\r\n          'babel-loader'\r\n        ]\r\n      },\r\n      {\r\n        test: /\\.s?css$/,\r\n        exclude: /node_modules/,\r\n        use: [\r\n          'style-loader',\r\n          {\r\n            loader: 'thread-loader',\r\n            options: cssWorkerPool\r\n          },\r\n          {\r\n            loader: 'css-loader',\r\n            options: {\r\n              modules: true,\r\n              localIdentName: '[name]__[local]--[hash:base64:5]',\r\n              importLoaders: 1\r\n            }\r\n          },\r\n          'postcss-loader'\r\n        ]\r\n      }\r\n      // ...\r\n    ]\r\n    // ...\r\n  }\r\n  // ...\r\n}\r\n```\r\n\r\n注意：请仅在耗时的 `loader` 上使用。\r\n\r\n### 2. HappyPack\r\n注意：包作者推荐使用 `thread-loader`，并宣布将不再继续维护 `happypack`，所以不推荐使用它。\r\n\r\n在 webpack 构建过程中，实际上耗费时间大多数用在 `loader` 解析转换以及代码的压缩中，\r\n`HappyPack` 可利用多进程对文件进行打包(默认cpu核数-1)，对多核cpu利用率更高。\r\n`HappyPack` 可以让 webpack 同一时间处理多个任务，发挥多核 CPU 的能力，\r\n将任务分解给多个子进程去并发的执行，子进程处理完后，再把结果发送给主进程。\r\n\r\n`Happypack` 的处理思路是将原有的 webpack 对 `loader` 的执行过程从单一进程的形式扩展多进程模式，原本的流程保持不变。\r\n使用 `HappyPack` 也有一些限制，它只兼容部分主流的 `loader`，具体可以查看官方给出的 [兼容性列表](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Famireh%2Fhappypack%2Fwiki%2FLoader-Compatibility-List)。\r\n\r\n```javascript\r\nconst path = require('path')\r\nconst webpack = require(\"webpack\");\r\nconst HappyPack = require('happypack'); // 多进程loader\r\n// node 提供的系统操作模块\r\nconst os = require('os');\r\n//  构造出共享进程池，根据系统的内核数量，指定进程池个数，也可以其他数量\r\nconst happyThreadPool = HappyPack.ThreadPool({ size: os.cpus().length });\r\nconst createHappyPlugin = (id, loaders) => new HappyPack({\r\n  // 用唯一的标识符 id 来代表当前的 HappyPack 是用来处理一类特定的文件\r\n  id: id,\r\n  // 如何处理 .js 文件，用法和 Loader 配置中一样\r\n  loaders: loaders,\r\n  // 其它配置项(可选)\r\n  // 代表共享进程池，即多个 HappyPack 实例都使用同一个共享进程池中的子进程去处理任务，以防止资源占用过多\r\n  threadPool: happyThreadPool,\r\n  // 是否允许 HappyPack 输出日志，默认是 true\r\n  verbose: true\r\n  // threads：代表开启几个子进程去处理这一类型的文件，默认是3个，类型必须是整数\r\n});\r\n\r\nconst clientWebpackConfig = {\r\n  // ...\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.(js|jsx)$/,\r\n        // 把对 .js .jsx 文件的处理转交给 id 为 happy-babel 的 HappyPack 实例\r\n        use: [\"happypack/loader?id=happy-babel\"],\r\n        // 排除 node_modules 目录下的文件\r\n        // node_modules 目录下的文件都是采用的 ES5 语法，没必要再通过 Babel 去转换\r\n        exclude: /node_modules/,\r\n      }\r\n    ]\r\n  },\r\n  // ...\r\n  plugins: [\r\n    createHappyPlugin('happy-babel', [{\r\n      loader: 'babel-loader',\r\n      options: {\r\n        presets: ['@babel/preset-env', \"@babel/preset-react\"],\r\n        plugins: [\r\n          [\"import\", { \"libraryName\": \"antd\", \"style\": true }],\r\n          ['@babel/plugin-proposal-class-properties',{loose:true}]\r\n        ],\r\n        cacheDirectory: true,\r\n        // Save disk space when time isn't as important\r\n        cacheCompression: true,\r\n        compact: true,\r\n      }\r\n    }]),\r\n    // ...\r\n  ]\r\n}\r\n```\r\n\r\n注意，当项目较小时，多进程打包反而会使打包速度变慢。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 4. 合理利用缓存（缩短连续构建时间，增加初始构建时间）\r\n使用 webpack 缓存的方法有几种，例如使用 `cache-loader`，`HardSourceWebpackPlugin` 或 `babel-loader` 的 `cacheDirectory` 标志。 \r\n所有这些缓存方法都有启动的开销。\r\n重新运行期间在本地节省的时间很大，但是初始（冷）运行实际上会更慢。\r\n\r\n如果你的项目生产版本每次都必须进行初始构建的话，缓存会增加构建时间，减慢你的速度。\r\n如果不是，那它们就会大大缩减你二次构建的时间。\r\n\r\n### 1. cache-loader\r\n`cache-loader` 和 `thread-loader` 一样，使用起来也很简单，仅仅需要在一些性能开销较大的 `loader` 之前添加此 `loader`，以将结果缓存到磁盘里，显著提升二次构建速度。\r\n```javascript\r\nmodule.exports = {\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.ext$/,\r\n        use: ['cache-loader', ...loaders],\r\n        include: path.resolve('src'),\r\n      },\r\n    ],\r\n  },\r\n};\r\n```\r\n\r\n注意：保存和读取这些缓存文件会有一些时间开销，所以请只对性能开销较大的 `loader` 使用。\r\n\r\n### 2. HardSourceWebpackPlugin\r\n`HardSourceWebpackPlugin` 的效果是：\r\n\r\n- 第一次构建将花费正常的时间\r\n- 第二次构建将显着加快（大概提升90%的构建速度）。\r\n\r\n```javascript\r\nconst HardSourceWebpackPlugin = require('hard-source-webpack-plugin')\r\nconst clientWebpackConfig = {\r\n  // ...\r\n  plugins: [\r\n    new HardSourceWebpackPlugin({\r\n      // cacheDirectory是在高速缓存写入。默认情况下，将缓存存储在node_modules下的目录中\r\n      // 'node_modules/.cache/hard-source/[confighash]'\r\n      cacheDirectory: path.join(__dirname, './lib/.cache/hard-source/[confighash]'),\r\n      // configHash在启动webpack实例时转换webpack配置，\r\n      // 并用于cacheDirectory为不同的webpack配置构建不同的缓存\r\n      configHash: function(webpackConfig) {\r\n        // node-object-hash on npm can be used to build this.\r\n        return require('node-object-hash')({sort: false}).hash(webpackConfig);\r\n      },\r\n      // 当加载器、插件、其他构建时脚本或其他动态依赖项发生更改时，\r\n      // hard-source需要替换缓存以确保输出正确。\r\n      // environmentHash被用来确定这一点。如果散列与先前的构建不同，则将使用新的缓存\r\n      environmentHash: {\r\n        root: process.cwd(),\r\n        directories: [],\r\n        files: ['package-lock.json', 'yarn.lock'],\r\n      },\r\n      // An object. 控制来源\r\n      info: {\r\n        // 'none' or 'test'.\r\n        mode: 'none',\r\n        // 'debug', 'log', 'info', 'warn', or 'error'.\r\n        level: 'debug',\r\n      },\r\n      // Clean up large, old caches automatically.\r\n      cachePrune: {\r\n        // Caches younger than `maxAge` are not considered for deletion. They must\r\n        // be at least this (default: 2 days) old in milliseconds.\r\n        maxAge: 2 * 24 * 60 * 60 * 1000,\r\n        // All caches together must be larger than `sizeThreshold` before any\r\n        // caches will be deleted. Together they must be at least this\r\n        // (default: 50 MB) big in bytes.\r\n        sizeThreshold: 50 * 1024 * 1024\r\n      },\r\n    }),\r\n    new HardSourceWebpackPlugin.ExcludeModulePlugin([\r\n      {\r\n        test: /.*\\.DS_Store/\r\n      }\r\n    ]),\r\n  ]\r\n}\r\n```\r\n\r\n## 5. 优化压缩时间\r\nwebpack4 默认内置使用 `terser-webpack-plugin` 插件压缩优化代码，而该插件使用 `terser` 来缩小 JavaScript 。\r\n\r\n### terser 是什么？\r\n用于 ES6+ 的 JavaScript 解析器、mangler/compressor（压缩器）工具包。\r\n\r\n### terser 启动多进程\r\n使用多进程并行运行来提高构建速度。并发运行的默认数量为 `os.cpus().length - 1`。\r\n```javascript\r\nmodule.exports = {\r\n  optimization: {\r\n    minimizer: [\r\n      new TerserPlugin({\r\n        parallel: true,\r\n      }),\r\n    ],\r\n  },\r\n};\r\n```\r\n\r\n可以显著加快构建速度，因此强烈推荐开启多进程。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 6. 优化搜索时间- 缩小文件搜索范围 减小不必要的编译工作\r\nwebpack 打包时，会从配置的 `entry` 触发，解析入口文件的导入语句，再递归的解析，在遇到导入语句时 webpack 会做两件事情：\r\n\r\n- 根据导入语句去寻找对应的要导入的文件。\r\n例如 `require('react')` 导入语句对应的文件是 `./node_modules/react/react.js`，`require('./util')` 对应的文件是 `./util.js`。\r\n- 根据找到的要导入文件的后缀，使用配置中的 `loader` 去处理文件。\r\n例如使用 ES6 开发的 JavaScript 文件需要使用 `babel-loader` 去处理。\r\n\r\n以上两件事情虽然对于处理一个文件非常快，但是当项目大了以后文件量会变的非常多，这时候构建速度慢的问题就会暴露出来。\r\n虽然以上两件事情无法避免，但需要尽量减少以上两件事情的发生，以提高速度。\r\n\r\n接下来一一介绍可以优化它们的途径。\r\n\r\n### 1. 优化 loader 配置\r\n使用 loader 时可以通过 `test`、`include`、`exclude` 三个配置项来缩小 `loader` 执行的范围。\r\n\r\n### 2. 优化 resolve.module 配置\r\n`resolve.modules` 用于配置 webpack 去哪些目录下寻找第三方模块，\r\n`resolve.modules` 的默认值是 `['node_modules']` ，含义是先去当前目录下的 `./node_modules` 目录下去找想找的模块，\r\n如果没找到就去上一级目录 `../node_modules` 中找，再没有就去 `../../node_modules` 中找，以此类推。\r\n\r\n### 3. 优化 resolve.alias 配置\r\n`resolve.alias` 配置项通过别名来把原导入路径映射成一个新的导入路径，减少耗时的递归解析操作。\r\n\r\n### 4. 优化 resolve.extensions 配置\r\n在导入语句没带文件后缀时，webpack 会根据 `resolve.extension` 自动带上后缀后去尝试询问文件是否存在，所以在配置 `resolve.extensions` 应尽可能注意以下几点：\r\n\r\n- `resolve.extensions` 列表要尽可能的小，不要把项目中不可能存在的情况写到后缀尝试列表中。\r\n- 频率出现最高的文件后缀要优先放在最前面，以做到尽快的退出寻找过程。\r\n- 在源码中写导入语句时，要尽可能的带上后缀，从而可以避免寻找过程。\r\n\r\n### 5. 优化 resolve.mainFields 配置\r\n有一些第三方模块会针对不同环境提供几分代码。 例如分别提供采用 ES5 和 ES6 的2份代码，配置如下：\r\n\r\n**package.json**\r\n```js\r\n{\r\n  \"jsnext:main\": \"es/index.js\",// 采用 ES6 语法的代码入口文件\r\n  \"main\": \"lib/index.js\" // 采用 ES5 语法的代码入口文件\r\n}\r\n```\r\n\r\nwebpack 会根据 `mainFields` 的配置去决定优先采用那份代码，`mainFields` 默认如下：\r\n```javascript\r\nmainFields: ['browser', 'main']\r\n```\r\n\r\nwebpack 会按照数组里的顺序去 `package.json`文件里寻找，只会使用找到的第一个。\r\n假如你想优先采用 ES6 的那份代码，可以这样配置：\r\n```javascript\r\nmainFields: ['jsnext:main', 'browser', 'main']\r\n```\r\n\r\n### 6. 优化 module.noParse 配置\r\n`module.noParse` 配置项可以让 Webpack 忽略对部分没采用模块化的文件的递归解析处理，这样做的好处是能提高构建性能。 原因是一些库，\r\n例如 `jQuery` 、`ChartJS`， 它们庞大又没有采用模块化标准，让 Webpack 去解析这些文件耗时又没有意义。\r\n\r\n### 7. 详细配置\r\n```javascript\r\n// 编译代码的基础配置\r\nmodule.exports = {\r\n  // ...\r\n  module: {\r\n    // 项目中使用的 jquery 并没有采用模块化标准，webpack 忽略它\r\n    noParse: /jquery/,\r\n    rules: [\r\n      {\r\n        // 这里编译 js、jsx\r\n        // 注意：如果项目源码中没有 jsx 文件就不要写 /\\.jsx?$/，提升正则表达式性能\r\n        test: /\\.(js|jsx)$/,\r\n        // babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启\r\n        use: ['babel-loader?cacheDirectory'],\r\n        // 排除 node_modules 目录下的文件\r\n        // node_modules 目录下的文件都是采用的 ES5 语法，没必要再通过 Babel 去转换\r\n        exclude: /node_modules/,\r\n      },\r\n    ]\r\n  },\r\n  resolve: {\r\n    // 设置模块导入规则，import/require时会直接在这些目录找文件\r\n    // 可以指明存放第三方模块的绝对路径，以减少寻找\r\n    modules: [\r\n      path.resolve(`${project}/client/components`), \r\n      path.resolve('h5_commonr/components'), \r\n      'node_modules'\r\n    ],\r\n    // import导入时省略后缀\r\n    // 注意：尽可能的减少后缀尝试的可能性\r\n    extensions: ['.js', '.jsx', '.react.js', '.css', '.json'],\r\n    // import导入时别名，减少耗时的递归解析操作\r\n    alias: {\r\n      '@compontents': path.resolve(`${project}/compontents`),\r\n    }\r\n  },\r\n};\r\n```"}]},{"number":97,"title":"【Q097】打包出来的文件很大，怎么解决？","labels":["webpack"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/97","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 优化 devtool 中的 source-map\r\n`devtool` 提供了很多种选项，用来增强我们 debug 的能力。\r\n熟知的有：`source-map`, `inline-source-map`, `cheap-source-map` 等。\r\n\r\n建议在 **生产环境** 下关闭 `source-map`：\r\n```javascript\r\nmodule.exports = {\r\n devtool: false,\r\n};\r\n```\r\n\r\n## 2. 剥离 css 文件，单独打包\r\n安装 webpack 插件 `extract-text-webpack-plugin`：\r\n```bash\r\nnpm install extract-text-webpack-plugin --save-dev\r\n```\r\n\r\n使用方法：\r\n```javascript\r\nmodule.exports = {\r\n  plugins:[\r\n   new ExtractTextPlugin('static/css/styles.[contenthash].css'),\r\n  ]\r\n};\r\n```\r\n\r\n## 3. 使用 UglifyJSPlugin 压缩。\r\n通过 `UglifyJSPlugin` 可以压缩我们的 `*.js` 文件。 \r\n```bash\r\nnpm install uglifyjs-webpack-plugin --save-dev\r\n```\r\n\r\n使用方法：\r\n```javascript\r\nconst UglifyJsPlugin = require('uglifyjs-webpack-plugin');\r\n\r\nmodule.exports = {\r\n  plugins: [\r\n     new UglifyJSPlugin({\r\n            parallel: 4,\r\n            uglifyOptions: {\r\n                output: {\r\n                    comments: false,\r\n                    beautify: false,\r\n                },\r\n                compress: {\r\n                    warnings: false\r\n                },\r\n            },\r\n            cache: true,\r\n        }),\r\n  ]\r\n}\r\n```\r\n\r\n## 3. 提取公共依赖\r\n使用 `CommonsChunkPlugin` 插件，将多个 js 文件进行提取，建立一个独立的文件。\r\n这个文件包含一些共用模块，浏这样览器只在刚开始的时候加载一次，便缓存起来供后续使用。\r\n而不用每次访问一个新界面时，再去加载一个更大的文件。\r\n\r\n```javascript\r\nmodule.exports = {\r\n entry:{\r\n\tapp:'./entry',\r\n\tvendor:['react','other-lib'],\r\n },\r\n plugins:[\r\n\t new Webpack.optimize.CommonsChunkPlugin({\r\n\t     name: 'vendor',\r\n\t }),\r\n ]\r\n};\r\n```\r\n\r\n## 4. 开启 gzip 压缩\r\n我们使用 `compression-webpack-plugin` 插件进行压缩。\r\n```bash\r\nnpm install compression-webpack-plugin --save-dev\r\n``` \r\n\r\n使用方法：\r\n```javascript\r\nconst CompressionPlugin = require(\"compression-webpack-plugin\");\r\n\r\nmodule.exports = {\r\n  plugins:[\r\n    new CompressionPlugin({\r\n\t     asset: '[path].gz[query]', // 目标资源名称。[file] 会被替换成原资源。[path] 会被替换成原资源路径，[query] 替换成原查询字符串\r\n         algorithm: 'gzip', // 算法\r\n         test: new RegExp(\r\n              '\\\\.(js|css)$'    // 压缩 js 与 css\r\n         ),\r\n         threshold: 10240, // 只处理比这个值大的资源。按字节计算\r\n         minRatio: 0.8, // 只有压缩率比这个值小的资源才会被处理\r\n    })\r\n  ]\r\n};\r\n```\r\n\r\n## 5. 开启 html 压缩，自动添加上面生成的静态资源\r\n添加插件 `html-webpack-plugin`：\r\n```bash\r\nnpm install html-webpack-plugin --save-dev\r\n```\r\n\r\n使用方法：\r\n```javascript\r\nconst UglifyJsPlugin = require('uglifyjs-webpack-plugin');\r\n\r\nmodule.exports = {\r\n  plugins:[\r\n    new HtmlWebpackPlugin({\r\n        title: '',\r\n           template: __dirname + '/../public/index.html',\r\n           minify: {\r\n               removeComments: true,\r\n               collapseWhitespace: true,\r\n               removeRedundantAttributes: true,\r\n               useShortDoctype: true,\r\n               removeEmptyAttributes: true,\r\n               removeStyleLinkTypeAttributes: true,\r\n               keepClosingSlash: true,\r\n               minifyJS: true,\r\n               minifyCSS: true,\r\n               minifyURLs: true,\r\n           },\r\n           chunksSortMode:'dependency'\r\n       }),\r\n  ]\r\n}\r\n```"}]},{"number":98,"title":"【Q098】模块联邦","labels":["webpack"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/98","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 为什么使用模块联邦？\r\n多个独立的构建可以组成一个应用程序，这些独立的构建之间不应该存在依赖关系，因此可以单独开发和部署它们。\r\n\r\n这通常被称作 **微前端**，但并不仅限于此。\r\n\r\n## 2. 底层原理\r\n我们区分 **本地模块** 和 **远程模块**。\r\n本地模块即为普通模块，是当前构建的一部分。\r\n远程模块不属于当前构建，并在运行时从所谓的容器加载。\r\n\r\n加载远程模块被认为是异步操作。\r\n当使用远程模块时，这些异步操作将被放置在远程模块和入口之间的下一个 chunk 的加载操作中。\r\n如果没有 chunk 加载操作，就不能使用远程模块。\r\n\r\nchunk 的加载操作通常是通过调用 `import()` 实现的，但也支持像 `require.ensure` 或 `require([...])` 之类的旧语法。\r\n\r\n容器是由容器入口创建的，该入口暴露了对特定模块的异步访问。暴露的访问分为两个步骤：\r\n\r\n1. 加载模块（异步的）\r\n2. 执行模块（同步的）\r\n\r\n步骤 1 将在 chunk 加载期间完成。\r\n步骤 2 将在与其他（本地和远程）的模块交错执行期间完成。\r\n这样一来，执行顺序不受模块从本地转换为远程或从远程转为本地的影响。\r\n\r\n容器可以嵌套使用，容器可以使用来自其他容器的模块。容器之间也可以循环依赖。\r\n\r\n## 3. 高级原理\r\n每个构建都充当一个容器，也可将其他构建作为容器。\r\n通过这种方式，每个构建都能够通过从对应容器中加载模块来访问其他容器暴露出来的模块。\r\n\r\n共享模块是指既可重写的又可作为向嵌套容器提供重写的模块。\r\n它们通常指向每个构建中的相同模块，例如相同的库。\r\n\r\n`packageName` 选项允许通过设置包名来查找所需的版本。\r\n默认情况下，它会自动推断模块请求，当想禁用自动推断时，请将 `requiredVersion` 设置为 `false` 。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 4. 构建块(Building blocks)\r\n### ContainerPlugin (low level)\r\n该插件使用指定的公开模块来创建一个额外的容器入口。\r\n\r\n### ContainerReferencePlugin (low level)\r\n该插件将特定的引用添加到作为外部资源（externals）的容器中，并允许从这些容器中导入远程模块。\r\n它还会调用这些容器的 `override API` 来为它们提供重载。\r\n本地的重载（当构建也是一个容器时，通过 `__webpack_override__` 或 `override API`）和指定的重载被提供给所有引用的容器。\r\n\r\n### ModuleFederationPlugin (high level)\r\n`ModuleFederationPlugin` 组合了 `ContainerPlugin` 和 `ContainerReferencePlugin`。\r\n\r\n## 5. 概念目标\r\n- 它既可以暴露，又可以使用 webpack 支持的任何模块类型\r\n- 代码块加载应该并行加载所需的所有内容(web:到服务器的单次往返)\r\n- 从使用者到容器的控制\r\n  - 重写模块是一种单向操作\r\n  - 同级容器不能重写彼此的模块。\r\n- 概念适用于独立于环境\r\n  - 可用于 web、Node.js 等\r\n- 共享中的相对和绝对请求\r\n  - 会一直提供，即使不使用\r\n  - 会将相对路径解析到 `config.context`\r\n  - 默认不会使用 `requiredVersion`\r\n- 共享中的模块请求\r\n  - 只在使用时提供\r\n  - 会匹配构建中所有使用的相等模块请求\r\n  - 将提供所有匹配模块\r\n  - 将从图中这个位置的 `package.json` 提取 `requiredVersion`\r\n  - 当你有嵌套的 node_modules 时，可以提供和使用多个不同的版本\r\n- 共享中尾部带有 `/` 的模块请求将匹配所有具有这个前缀的模块请求\r\n\r\n## 6. 使用场景\r\n### 每个页面单独构建\r\n单页应用的每个页面都是在单独的构建中从容器暴露出来的。\r\n主体应用程序(application shell)也是独立构建，会将所有页面作为远程模块来引用。\r\n通过这种方式，可以单独部署每个页面。\r\n在更新路由或添加新路由时部署主体应用程序。\r\n主体应用程序将常用库定义为共享模块，以避免在页面构建中出现重复。\r\n\r\n### 将组件库作为容器\r\n许多应用程序共享一个通用的组件库，可以将其构建成暴露所有组件的容器。\r\n每个应用程序使用来自组件库容器的组件。\r\n可以单独部署对组件库的更改，而不需要重新部署所有应用程序。\r\n应用程序自动使用组件库的最新版本。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 7. 动态远程容器\r\n该容器接口支持 `get`  和 `init` 方法。\r\n`init` 是一个兼容 `async` 的方法，调用时，只含有一个参数：共享作用域对象(shared scope object)。\r\n此对象在远程容器中用作共享作用域，并由 host 提供的模块填充。 \r\n可以利用它在运行时动态地将远程容器连接到 host 容器。\r\n\r\n**init.js**\r\n```javascript\r\n(async () => {\r\n  // 初始化共享作用域（shared scope）用提供的已知此构建和所有远程的模块填充它\r\n  await __webpack_init_sharing__('default');\r\n  const container = window.someContainer; // 或从其他地方获取容器\r\n  // 初始化容器 它可能提供共享模块\r\n  await container.init(__webpack_share_scopes__.default);\r\n  const module = await container.get('./module');\r\n})();\r\n```\r\n\r\n容器尝试提供共享模块，但是如果共享模块已经被使用，则会发出警告，并忽略所提供的共享模块。\r\n容器仍能将其作为降级模块。\r\n\r\n你可以通过动态加载的方式，提供一个共享模块的不同版本，从而实现 A/B 测试。\r\n\r\n注意：在尝试动态连接远程容器之前，确保已加载容器。\r\n\r\n使用示例：\r\n\r\n**init.js**\r\n```javascript\r\nfunction loadComponent(scope, module) {\r\n  return async () => {\r\n    // 初始化共享作用域（shared scope）用提供的已知此构建和所有远程的模块填充它\r\n    await __webpack_init_sharing__('default');\r\n    const container = window[scope]; // 或从其他地方获取容器\r\n    // 初始化容器 它可能提供共享模块\r\n    await container.init(__webpack_share_scopes__.default);\r\n    const factory = await window[scope].get(module);\r\n    const Module = factory();\r\n    return Module;\r\n  };\r\n}\r\n\r\nloadComponent('abtests', 'test123');\r\n```\r\n\r\n## 8. 基于 Promise 的动态 Remote\r\n一般来说，remote 是使用 URL 配置的，示例如下：\r\n```javascript\r\nmodule.exports = {\r\n  plugins: [\r\n    new ModuleFederationPlugin({\r\n      name: 'host',\r\n      remotes: {\r\n        app1: 'app1@http://localhost:3001/remoteEntry.js',\r\n      },\r\n    }),\r\n  ],\r\n};\r\n```\r\n\r\n但是你也可以向 remote 传递一个 promise，其会在运行时被调用。\r\n你应该用任何符合上面描述的 `get/init` 接口的模块来调用这个 promise。\r\n例如，如果你想传递你应该使用哪个版本的联邦模块，你可以通过一个查询参数做以下事情：\r\n```javascript\r\nmodule.exports = {\r\n  plugins: [\r\n    new ModuleFederationPlugin({\r\n      name: 'host',\r\n      remotes: {\r\n        app1: `promise new Promise(resolve => {\r\n      const urlParams = new URLSearchParams(window.location.search)\r\n      const version = urlParams.get('app1VersionParam')\r\n      // This part depends on how you plan on hosting and versioning your federated modules\r\n      const remoteUrlWithVersion = 'http://localhost:3001/' + version + '/remoteEntry.js'\r\n      const script = document.createElement('script')\r\n      script.src = remoteUrlWithVersion\r\n      script.onload = () => {\r\n        // the injected script has loaded and is available on window\r\n        // we can now resolve this Promise\r\n        const proxy = {\r\n          get: (request) => window.app1.get(request),\r\n          init: (arg) => {\r\n            try {\r\n              return window.app1.init(arg)\r\n            } catch(e) {\r\n              console.log('remote container already initialized')\r\n            }\r\n          }\r\n        }\r\n        resolve(proxy)\r\n      }\r\n      // inject this script with the src set to the versioned remoteEntry.js\r\n      document.head.appendChild(script);\r\n    })\r\n    `,\r\n      },\r\n      // ...\r\n    }),\r\n  ],\r\n};\r\n```\r\n\r\n请注意当使用该 API 时，你 必须 resolve 一个包含 `get/init` API 的对象。\r\n\r\n## 9. 动态 Public Path\r\n### 提供一个 host api 以设置 publicPath\r\n可以允许 host 在运行时通过公开远程模块的方法来设置远程模块的 `publicPath`。\r\n\r\n当你在 host 域的子路径上挂载独立部署的子应用程序时，这种方法特别有用。\r\n\r\n使用场景：\r\n你在 `https://my-host.com/app/*` 上有一个 host 应用，并且在 `https://foo-app.com` 上有一个子应用。\r\n子应用程序也挂载在 host 域上, 因此， `https://foo-app.com` 可以通过 `https://my-host.com/app/foo-app` 访问，\r\n并且 `https://my-host.com/app/foo-app/*` 可以通过代理重定向到 `https://foo-app.com/*`。\r\n\r\n使用示例：\r\n**webpack.config.js (remote)**\r\n```javascript\r\nmodule.exports = {\r\n  entry: {\r\n    remote: './public-path',\r\n  },\r\n  plugins: [\r\n    new ModuleFederationPlugin({\r\n      name: 'remote', // 该名称必须与入口名称相匹配\r\n      exposes: ['./public-path'],\r\n      // ...\r\n    }),\r\n  ],\r\n};\r\n```\r\n\r\n**public-path.js (remote)**\r\n```javascript\r\nexport function set(value) {\r\n  __webpack_public_path__ = value;\r\n}\r\n```\r\n\r\n**src/index.js (host)**\r\n```javascript\r\nconst publicPath = await import('remote/public-path');\r\npublicPath.set('/your-public-path');\r\n```\r\n\r\n### 从 script 中推断出 publicPath\r\n我们可以从 `document.currentScript.src` 的 script 标签中推断出 `publicPath`，并在运行时用 `__webpack_public_path__`模块变量来设置它。\r\n\r\n示例：\r\n**webpack.config.js (remote)**\r\n```javascript\r\nmodule.exports = {\r\n  entry: {\r\n    remote: './setup-public-path',\r\n  },\r\n  plugins: [\r\n    new ModuleFederationPlugin({\r\n      name: 'remote', // 该名称必须与入口名称相匹配\r\n      // ...\r\n    }),\r\n  ],\r\n};\r\n```\r\n\r\n**setup-public-path.js (remote)**\r\n```javascript\r\n// 使用你自己的逻辑派生 publicPath，并使用 __webpack_public_path__ API 设置它\r\n__webpack_public_path__ = document.currentScript.src + '/../';\r\n```\r\n\r\n注意：`output.publicPath` 配置项也可设置为 `auto`，它将为你自动决定一个 `publicPath`。"}]},{"number":99,"title":"【Q099】HMR 原理","labels":["webpack"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/99","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. HMR\r\n模块热替换(hot module replacement 或 HMR)是 webpack 提供的最有用的功能之一。\r\n它允许在运行时更新所有类型的模块，而无需完全刷新。\r\n\r\n注意：HMR 不适用于 **生产环境**，这意味着它应当用于 **开发环境**。\r\n\r\n## 2. 启用 HMR\r\n此功能可以很大程度提高生产效率。我们要做的就是更新 [webpack-dev-server](https://github.com/webpack/webpack-dev-server) 配置， 然后使用 webpack 内置的 `HMR` 插件。\r\n我们还要删除掉 `print.js` 的入口起点， 因为现在已经在 `index.js` 模块中引用了它。\r\n\r\n从 `webpack-dev-server` v4.0.0 开始，热模块替换是默认开启的。\r\n\r\n注意：如果你在技术选型中使用了 `webpack-dev-middleware` 而没有使用 `webpack-dev-server`，\r\n请使用 [webpack-hot-middleware](https://github.com/webpack-contrib/webpack-hot-middleware) 依赖包，以在你的自定义服务器或应用程序上启用 `HMR`。\r\n\r\n**webpack.config.js**\r\n```javascript\r\n  const path = require('path');\r\n  const HtmlWebpackPlugin = require('html-webpack-plugin');\r\n\r\n  module.exports = {\r\n    entry: {\r\n       app: './src/index.js',\r\n       // print: './src/print.js', 删除 print 入口\r\n    },\r\n    devtool: 'inline-source-map',\r\n    devServer: {\r\n      static: './dist',\r\n      hot: true, // 开启 HMR\r\n    },\r\n    plugins: [\r\n      new HtmlWebpackPlugin({\r\n        title: 'Hot Module Replacement',\r\n      }),\r\n    ],\r\n    output: {\r\n      filename: '[name].bundle.js',\r\n      path: path.resolve(__dirname, 'dist'),\r\n      clean: true,\r\n    },\r\n  };\r\n```\r\n\r\n你也可以为 `HMR` 提供入口：\r\n**webpack.config.js**\r\n```javascript\r\n  const path = require('path');\r\n  const HtmlWebpackPlugin = require('html-webpack-plugin');\r\n const webpack = require(\"webpack\");\r\n\r\n  module.exports = {\r\n    entry: {\r\n       app: './src/index.js',\r\n      // print: './src/print.js', // 删除 print 入口\r\n      // 指定 HMR 的运行时\r\n      hot: 'webpack/hot/dev-server.js',\r\n      // 指定 重新加载 方式\r\n      client: 'webpack-dev-server/client/index.js?hot=true&live-reload=true',\r\n    },\r\n    devtool: 'inline-source-map',\r\n    devServer: {\r\n      static: './dist',\r\n     // 指定 重新加载 方式\r\n     hot: false,\r\n     client: false,\r\n    },\r\n    plugins: [\r\n      new HtmlWebpackPlugin({\r\n        title: 'Hot Module Replacement',\r\n      }),\r\n     // HMR 的插件\r\n     new webpack.HotModuleReplacementPlugin(),\r\n    ],\r\n    output: {\r\n      filename: '[name].bundle.js',\r\n      path: path.resolve(__dirname, 'dist'),\r\n      clean: true,\r\n    },\r\n  };\r\n```\r\n\r\n注意：你可以通过以下命令来修改 [webpack-dev-server](https://github.com/webpack/webpack-dev-server) 的配置：webpack serve --hot-only。\r\n\r\n现在，我们来修改 `index.js` 文件，以便当 `print.js` 内部发生变更时可以告诉 webpack 接受更新的模块。\r\n**index.js**\r\n```javascript\r\n  import _ from 'lodash';\r\n  import printMe from './print.js';\r\n\r\n  function component() {\r\n    const element = document.createElement('div');\r\n    const btn = document.createElement('button');\r\n\r\n    element.innerHTML = _.join(['Hello', 'webpack'], ' ');\r\n\r\n    btn.innerHTML = 'Click me and check the console!';\r\n    btn.onclick = printMe;\r\n\r\n    element.appendChild(btn);\r\n\r\n    return element;\r\n  }\r\n\r\n  document.body.appendChild(component());\r\n  \r\n if (module.hot) {\r\n   module.hot.accept('./print.js', function() {\r\n     console.log('接受更新的模块');\r\n     printMe();\r\n   })\r\n }\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 3. HMR 原理\r\nHMR 功能会在应用程序运行过程中，替换、添加或删除 **模块**，而无需重新加载整个页面。\r\n主要是通过以下几种方式，来显著加快开发速度：\r\n\r\n- 保留在完全重新加载页面期间丢失的应用程序状态。\r\n- 只更新变更内容，以节省宝贵的开发时间。\r\n- 在源代码中 CSS/JS 产生修改时，会立刻在浏览器中进行更新，这几乎相当于在浏览器 devtools 直接更改样式。\r\n\r\n### 这一切是如何运行的？\r\n让我们从一些不同的角度观察，以了解 HMR 的工作原理。\r\n\r\n### 在应用程序中\r\n通过以下步骤，可以做到在应用程序中置换(swap in and out)模块：\r\n\r\n1. 应用程序要求 HMR runtime 检查更新。\r\n2. HMR runtime 异步地下载更新，然后通知应用程序。\r\n3. 应用程序要求 HMR runtime 应用更新。\r\n4. HMR runtime 同步地应用更新。\r\n\r\n你可以设置 HMR，以使此进程自动触发更新，或者你可以选择要求在用户交互时进行更新。\r\n\r\n### 在 compiler 中\r\n除了普通资源，compiler 需要发出 \"update\"，将之前的版本更新到新的版本。\r\n\"update\" 由两部分组成：\r\n\r\n1. 更新后的 `manifest.json`\r\n2. 一个或多个 updated chunk\r\n\r\nmanifest 包括新的 compilation hash 和所有的 updated chunk 列表。\r\n每个 chunk 都包含着全部更新模块的最新代码（或一个 flag 用于表明此模块需要被移除）。\r\n\r\ncompiler 会确保在这些构建之间的模块 ID 和 chunk ID 保持一致。\r\n通常将这些 ID 存储在内存中（例如使用 `webpack-dev-server` 时），但是也可能会将它们存储在一个 JSON 文件中。\r\n\r\n### 在模块中\r\nHMR 是可选功能，只会影响包含 HMR 代码的模块。\r\n举个例子，通过 [style-loader](https://github.com/webpack-contrib/style-loader) 为 style 追加补丁。\r\n为了运行追加补丁，style-loader 实现了 HMR 接口；当它通过 HMR 接收到更新，它会使用新的样式替换旧的样式。\r\n\r\n类似的，当在一个模块中实现了 HMR 接口，你可以描述出当模块被更新后发生了什么。\r\n然而在多数情况下，不需要在每个模块中强行写入 HMR 代码。\r\n如果一个模块没有 HMR 处理函数，更新就会冒泡(bubble up)。\r\n这意味着某个单独处理函数能够更新整个模块树。\r\n如果在模块树的一个单独模块被更新，那么整组依赖模块都会被重新加载。\r\n\r\n### 在 runtime 中\r\n对于模块系统运行时(module system runtime)，会发出额外代码，来跟踪模块 `parents` 和 `children` 关系。\r\n在管理方面，runtime 支持两个方法 `check` 和 `apply`。\r\n\r\n`check` 方法，发送一个 HTTP 请求来更新 manifest。\r\n如果请求失败，说明没有可用更新。\r\n如果请求成功，会将 updated chunk 列表与当前的 loaded chunk 列表进行比较。\r\n每个 loaded chunk 都会下载相应的 updated chunk。\r\n当所有更新 chunk 完成下载，runtime 就会切换到 `ready` 状态。\r\n\r\n`apply` 方法，将所有 updated module 标记为无效。\r\n对于每个无效 module，都需要在模块中有一个 update handler，或者在此模块的父级模块中有 update handler。\r\n否则，会进行无效标记冒泡，并且父级也会被标记为无效。\r\n继续每个冒泡，直到到达应用程序入口起点，或者到达带有 update handler 的 module（以最先到达为准，冒泡停止）。\r\n如果它从入口起点开始冒泡，则此过程失败。\r\n\r\n之后，所有无效 module 都会被（通过 dispose handler）处理和解除加载。\r\n然后更新当前 hash，并且调用所有 `accept` handler。\r\nruntime 切换回 `idle` 状态，一切照常继续。"}]},{"number":100,"title":"【Q100】有了解过现在流行的 bundleless 构建工具吗？","labels":["webpack"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/100","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. bundle-less\r\n随着项目的规模发展，webpack 的构建速度越来越慢。\r\n\r\n- 项目冷启动时必须递归打包整个项目的依赖树，\r\n- Nodejs 语言本身(解释执行、单线程执行)的限制，导致构建性能遇到瓶颈。\r\n\r\n因此，`Bundleless` 构建工具应运而生，诸如 `Snowpack`、`Vite`。\r\n\r\n和 Webpack 这种传统的打包工具相比，Vite 主要有两大主要优势:\r\n\r\n- 利用浏览器内置 ES Module 的支持。\r\n(script 标签加上属性 type=\"module\" 即可)，浏览器直接向 dev server 逐个请求各个模块，而不需要提前把所有文件打包。\r\n- 借助 esbuild 超快的编译速度把第三方库进行 **预构建**。\r\n一方面将零散的文件打到一起，减少网络请求，另一方面全面转换为 ESM 模块语法，以适配浏览器内置的 ESM 支持。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. bundle-less 做了什么？\r\n- **拆包**。\r\n弱化传统意义上的打包概念，由单 bundle 拆分为数十或者上百个 bundle，这样可以更好地利用 HTTP2 的多路复用优势和提升缓存命中率。\r\n- **对源代码不进行打包**。\r\n在开发阶段可以省略 bundle 的开销，如 Vite、Snowpack、WMR。\r\n- **依赖产物的模块化分发**。\r\n对于庞大的外部依赖，一方面打包成本比较高，另一方面文件数量可能非常多，打包几乎是一个必选项，甚至需要多个 NPM 包合并打包。\r\n因此，针对依赖的打包也是非常重要的优化点，一般可以通过预打包 + 模块化缓存来进行优化，\r\n目前也有一些优化案例，如 Vite 中基于 Esbuild 的预打包器、基于 ESM 的 CDN 服务，如 Skypack、esm.sh、jspm 等。\r\n\r\n## 3. 拆多少包更合适？\r\n打的包太多或者太少都可能出现加载性能的问题。\r\n比如过多的嵌套 `import` 导致网络瀑布流的产生、bundle 太少不能充分利用 HTTP2 下并发请求的优势。\r\n\r\n针对这个问题，我们曾做过一系列的性能测试，最后得出的结论如下：\r\n\r\n- 对于总产物资源大小相同的情况，资源加载分成的 chunk 数量在 10 - 25 之间进行并行加载性能最佳。\r\n- 一次资源加载需要的依赖引用深度尽量等于 1 时加载性能最好。\r\n- 由于不打包的情况下项目的请求数量和请求深度问题都不可控，因此不适合在生产构建中采用 no-bundle 方案。\r\n\r\n## 4. no-bundle 服务\r\n### 代表方案 Vite\r\n在开发环境中，Vite 主要做了两件事情:\r\n\r\n- 基于 esbuild 打包外部依赖。\r\n- 创建 HTTP Server 以响应浏览器中 `<script type=\"module\">` 所发起的一系列模块请求。\r\n\r\n而生产环境下直接使用 `Rollup` 进行打包。\r\nVite 整体的优势是在于开发阶段，服务启动快、热更新快，明显地优化了开发者体验。\r\n\r\n### 劣势及解决方案\r\nno-bundle 方案虽然省去了 bundle 的开销，但仍然需要进行单文件的编译(如 TS、JSX、Less、Sass)，编译的时长仍然可能会比较长(某些业务项目编译要 20 s 左右)。\r\nVite 在二次请求时会采用 Etag 标识返回协商缓存的内容，可以跳过编译消耗的时间，但服务重启后仍然需要进行全量的编译，体验不太好。\r\n对此，一个比较好的解决方法是在服务退出时将 ModuleGraph 的内容缓存到本地，然后重启的时候激活缓存(hydrate)，那么二次启动时仍然会使用协商缓存，达到比较快的首屏加载效果。\r\n\r\n### 海量请求的加载性能问题\r\n请求数量达到一定量级(1000 +)的时候，no-bundle 服务都会遇到加载性能问题，对 Vite 而言，尽管二次请求会使用协商缓存，但实际上请求仍然会发送，在开发环境中(一般的业务项目会使用代理进行本地开发)表现仍然不容乐观，以之前接入 Vite 的某个业务项目为例:\r\n\r\n|  | 项目第一次构建 | 页面加载时间 | 热更新 |\r\n|  ----  | ----  | ----  | ----  |\r\n| webpack | 80 s 构建 | 3~4 s | 5 s  |\r\n| vite | 10 s 构建 | 10 s | 1 s  |\r\n| 时间缩短 | 50% | -50% | 80% 以上  |\r\n\r\n经过一系列的尝试，最后发现 Service Worker 缓存可以很好地解决这一类问题，思路如下：\r\n\r\n![Alt](http://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/346860e2f8af40c998a754d89516ae1b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)\r\n\r\n简单来说就是把 Vite 的编译结果缓存到 Service Worker，并对于 HMR 的模块及其依赖模块禁用缓存，保证模块的编译结果永远是最新的。\r\n优化之后页面加载时间由 10s 降低到了 5 s 以内，可以追的上 webpack 的速度。\r\n\r\n### (Vite 独有)开发/生产表现不一致\r\n有不少人会吐槽 Vite 开发/生产环境的不一致性，因为开发环境使用 Esbuild + Dev Server 架构，而生产环境直接用 Rollup。\r\n但由于生产环境的构建场景和开发阶段存在天然差异，开发和生产表现一致是不现实的。\r\n所以问题的核心在于保证生产环境构建的稳定性。\r\n\r\n而影响生产构建稳定性最主要的部分在于依赖的处理上，进一步说是对于 CommonJS 格式的依赖处理上面，\r\n开发环境使用 esbuild 而生产环境下使用 `@rollup/plugin-commonjs`，就容易导致生产构建出现一些奇怪的问题，\r\n如 `@rollup/plugin-commonjs` ignoreTryCatch行为 try-catch 代码块中的 require 语法转换，\r\n这样对于某些依赖(如 jspdf-autotable)就会出现问题，而开发阶段使用 Esbuild 就不会出现。\r\n\r\n解决这类问题有两种方案:\r\n\r\n- 生产环境也使用 esbuild 来进行依赖的打包，确保 CommonJS 的处理规则和开发阶段一致。\r\n该 feature 已经实现，将在 Vite 3.0 发布。\r\n- 开发和生产阶段使用 ESM CDN 方案，用同一套依赖产物。\r\n"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 5. 依赖产物的模块化分发\r\n对于第三方依赖，我们可以将其进行预构建，然后将产物进行分发，这样所有的依赖可以被 external 掉了，可以很大程度上降低项目 bundle 的开销。\r\n\r\n总体而言，这类方案有几大关键要素：\r\n\r\n- 预构建产物。\r\n- 模块化方案。\r\n- 产物分发机制。\r\n\r\n接下来我们可以对照现有的案例来分析。\r\n\r\n### 现有方案概览\r\n首先是 Vite 的依赖预构建方案，使用 esbuild 对第三方依赖进行打包，\r\n基于浏览器原生 ESM 特性来加载第三方包的产物，同时将产物存储在本地，可以通过 Dev Server 访问产物资源。\r\n\r\n其次包括开源社区的一些 ESM CDN 方案，如 Skypack、esm.sh。\r\n前者服务并未开源，后者使用 esbuild 进行模块打包或者单文件转译。\r\n这类方案也是依赖于浏览器原生 ESM 特性实现产物加载，通过第三方的 CDN 来进行产物分发，如通过 `https://esm.sh/react@18.0.2` 即可访问到对应的 react 包产物。\r\n\r\n### 问题分析\r\n当然，现有的依赖 Bundleless 方案并不能很好地运用到业务项目中，尤其是生产环境，因为以下的几个关键问题没有得到根本的解决：\r\n\r\n- 产物语法和 Polyfill 安全问题。\r\n- 产物线上加载性能问题。\r\n- 模块化加载方案的兼容性问题。\r\n- 产物本地化调试问题。\r\n\r\n#### 产物语法和 Polyfill 安全问题\r\n无论是 Vite 预构建还是社区开源的 Skypack 和 esm.sh 等 ESM CDN 方案，都不支持 ES3/ES5 语法降级，也没有基于 browserlist 的 polyfill 方案，\r\n这样一来就很无法兼容旧版本浏览器，如大部分需要支持 Android 4.4 / iOS 9 机型的业务就无法使用这些方案。\r\n\r\n#### 产物的性能问题\r\nVite 会把项目中所有的依赖(包括 lodash/add 这种 subpath)各自打包为一个 bundle 文件，在大型项目中依赖产物的数量仍然很大(100 +)。\r\n根据之前 Bundleless 性能测试的结果，巨大的文件请求数量显然会带来页面加载的性能问题。\r\n\r\n而对于开源的 ESM CDN 方案，一般有两种构建模式，分别的 bundle 模式和非 bundle 模式。\r\n在非 bundle 模式下会存在严重的网络瀑布流问题，而 bundle 模式下会把所有的间接依赖都打包进去，容易造成某些公共依赖重复打包的问题，使产物性能变差。\r\n同时，这些 ESM CDN 方案都不支持产物的 Tree Shaking，对于任何包都只能全量引入依赖产物，无法做到按需加载。\r\n\r\n#### 模块化方案的兼容性问题\r\n如果在生产环境也使用 ESM 格式的产物，那么很可能会产生兼容性问题，目前浏览器对于原生 ESM 的兼容性如下图：\r\n\r\n![Alt](http://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8aae22d5cd1c4d47adbfa7411b9f3e03~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)\r\n\r\n对于需要兼容 IE11 或者低版本移动端机型的项目，现有的 ESM CDN 方案就无法使用了。\r\n\r\n#### 产物本地化调试问题\r\nVite 的预构建产物可以在本地使用，通过 Dev Server 分发，但也有一定的弊端：\r\n\r\n- 如果要调试产物，则需要开发者手动清除浏览器缓存。\r\n- 产物仅存在本地，团队成员之间无法共享产物。\r\n\r\n而现有的 ESM CDN 产物本地化方面也显得捉襟见肘：\r\n\r\n- 本地开发只能使用第三方 CDN，调试产物会比较困难。\r\n- 项目线上部署时也只能使用第三方 CDN 的资源，无法做到私有化部署。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"6. ### 依赖产物的模块化分发 的解决方案\r\n面对如上的核心问题，我们可以逐个展开思考，各个击破，解决思路分别如下:\r\n\r\n- **对于产物语法和 Polyfill 安全问题**。\r\n在预构建阶段，可通过 babel/swc 编译出特定 target (视项目情况而定)下的安全产物。\r\n- **对于产物线上加载性能问题**。\r\n我们需要完成一套项目依赖分析工具，对项目的模块依赖图进行分析，将项目使用到的依赖进行合并(combo)打包，使最后依赖的产物 chunk 数量保持在性能最佳的范围之内。\r\n- **对于模块化加载方案的兼容性问题**。\r\n我们可以在无需兼容旧版本浏览器的项目使用原生 ESM 特性，否则降级为 SystemJS 加载方案。\r\n- **对于产物本地化调试和部署问题**。\r\n我们一方面需要维护一份第三方 CDN 服务，类似 Skypack、esm.sh，另一方面需要支持将 CDN 产物下载至本地，并通过特定的模块化加载方案来加载这些本地的产物。\r\n\r\n根据如上的业界方案问题分析与解决思路，我们自研了一套依赖 Bundleless 的方案，整体架构如下:\r\n\r\n![Alt](http://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00ad359bd1534b8fb8d3327e4ff9e020~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)\r\n\r\n### 基于 Import Map\r\n在现有的社区方案中，一般用路径重写的方式来管理 CDN 依赖的路径，比如：\r\n```javascript\r\nimport React from 'react'\r\n// 改写为\r\nimport React from '/-/v70/react@v17.0.1'\r\n```\r\n\r\n这么做导致一些问题：\r\n\r\n- **多实例问题**。\r\n在产物代码中将路径写死，这样对于 peerDependencies 不太友好，\r\n比如某个组件库的 React 引用路径被改写为/v1/react@16.14，而项目依赖的 React 版本为 17.0.2，那么就会产生 React 多实例问题。\r\n- **缓存命中率比较低**。\r\n如果 A 依赖 B，B 的代码发生变化，那么 A 里面对应的 import 代码也发生变化，A 的缓存也会失效。\r\n\r\n我们希望用一个集中的空间来管理依赖关系，并避免多实例的问题，而 Import Map 就可以解决这些问题。接入原理如下：\r\n```html\r\n<script type=\"importmap\">\r\n{\r\n\"imports\": {\r\n    // 保证单实例\r\n    \"react\": \"https://tosv.byted.org/obj/eden-internal/ulkl_lm_zlp/ljhwZthlaukjlkulzlp/npm_cdn/dev/react/17.0.2/0636c3a4.js\",\r\n    \"react-dom\": \"https://tosv.byted.org/obj/eden-internal/ulkl_lm_zlp/ljhwZthlaukjlkulzlp/npm_cdn/dev/lodash/4.17.21/8ba9d138.js\"\r\n  }\r\n}\r\n</script>\r\n<script type=\"module\">\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom'\r\n</script>\r\n```\r\n\r\n### 模块合并\r\n首先基于 esbuild 将项目进行预打包(性能考虑)，需要开启 metafile 配置，在 onEnd 钩子或者 build API 的返回值中可以获取构建元信息，即 meta 对象，由 inputs 字段可以解析出模块依赖图。\r\n```javascript\r\n// meta 对象\r\n{  \r\n  \"inputs\": {\r\n    // 当前模块路径\r\n    \"../node_modules/.pnpm/object-assign@4.1.1/node_modules/object-assign/index.js\": {\r\n      // 模块大小\r\n      \"bytes\": 2108,\r\n      // 依赖模块数组\r\n      \"imports\": []\r\n    },\r\n    \"../node_modules/.pnpm/react@17.0.2/node_modules/react/cjs/react.development.js\": {\r\n      \"bytes\": 72141,\r\n      \"imports\": [\r\n        {\r\n          \"path\": \"../node_modules/.pnpm/object-assign@4.1.1/node_modules/object-assign/index.js\",\r\n          \"kind\": \"require-call\"\r\n        }\r\n      ]\r\n    },\r\n  }\r\n}\r\n```\r\n\r\n根据当前的模块依赖图信息，我们可以将项目中用到的依赖进行分组，通过特定的依赖分组算法产出一些依赖组的信息。\r\n\r\n### 多包(combo)模式打包\r\nCombo 模式打包即把多个依赖包打包到一起，主要会产生如下的问题：\r\n\r\n- 多包出现导出名称冲突。\r\n- Subpath 问题大量出现的问题。\r\n\r\n解决方案：\r\n#### 不同包的导出名冲突问题\r\n首先需要解决命名导出的问题，整体由两部分构成。\r\n在构建时阶段注入一些带有包名前缀的 specifier，运行时根据包名取出这些 specifier，从根本上解决导出名冲突问题。\r\n\r\n1. 构建时注水\r\n在构建之前需要探测 NPM 包所有的导出，包含以下的情况：\r\n\r\n- ESM\r\n  - `Named/Default export`，通过 `es-module-lexer` 扫描。\r\n  - `export * from 'xxx'`，通过 esbuild 预打包，开启 metafile 模式，在 metafile 中获取所有的 export 名。\r\n- CJS\r\n  - 尝试通过直接 require 拿到所有的导出名。\r\n  - 若 require 失败，降级到 AST 解析，分析所有的导出名。\r\n  \r\n在拿到所有导出名的基础之上，构建虚拟模块，交由 bundler 进行打包，格式如下：\r\n```javascript\r\nexport { 包名_导出字段名 } from '包名';\r\n```\r\n\r\n也就是在 NPM 包每个导出名前面加上 `包名_`，完成注水过程，以防止重名。\r\n\r\n2. 运行时脱水 (Hydrate)\r\n如上 `包名_导出字段名` 的这种导出在业务中是直接使用的，我们需要在模块系统中进行运行时拦截(脱水过程)，把真正的导出字段名取出。\r\n\r\n如以下的导入：\r\n```javascript\r\n// 在以 esm 的方式对依赖进行 external 后，webpack 产物中的引入代码\r\nimport * as __WEBPACK_EXTERNAL_MODULE_react_router_ from 'react-reouter'\r\n```\r\n\r\n我们将会改写成以下的代码：\r\n```javascript\r\n// 1. 换成临时变量\r\nimport * as __WEBPACK_EXTERNAL_MODULE_react_router_$0 from \"react-router\";\r\n// 2. 对原来的变量重新赋值，通过 __EDEN_COMBO_HYDRATE__ 工具函数将导出名去掉包名前缀\r\n// 如 react_router_Router => Router\r\nvar __WEBPACK_EXTERNAL_MODULE_react_router_ = __EDEN_COMBO_HYDRATE__(\r\n  __WEBPACK_EXTERNAL_MODULE_react_router_$0,\r\n  \"react_router\"\r\n);\r\n```\r\n\r\n#### 大量 subpath 问题\r\n做实际落地项目的过程中发现第三方包中使用大量的 subpath，如下图的依赖分组结果所示：\r\n\r\n![Alt](http://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd93e2ec0ec04cf2806c8b2413e706c7~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)\r\n\r\n这种情况下 import map 的体积会很大，因为每个 subpath 都会对应一个远程地址。\r\n解决方案是进行 subpath 合并打包，如 `@babel/runtime/helper/esm/assertThisInitialized`、`@babel/runtime/helpers/esm/inheritsLoose`，原始产物中的引入代码如下:\r\n```javascript\r\nimport * as __WEBPACK_EXTERNAL_MODULE_babel_runtime_helers_esm_inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';\r\nimport * as __WEBPACK_EXTERNAL_MODULE_babel_runtime_helers_esm_assertThisInitialized from '@babel/runtime/helpers/esm/assertThisInitialized';\r\n```\r\n\r\n这样对于 `@babel/runtime` 只留下一个 importmap 的 key-value 对，有效减少 import map 的体积。\r\n\r\n### 产物 Tree Shaking\r\n在 esbuild 预打包阶段扫描源文件所用到的 specifier，然后构建对应的虚拟模块交给打包器进行打包：\r\n```javascript\r\nexport { cloneDeep } from 'lodash-es'\r\nexport { Spin } from '@douyinfe/semi-ui'\r\n```\r\n\r\n这样可以做到一定程度的 Tree Shaking。\r\n\r\n### Polyfill 安全\r\n根据不同的 runtimeTarget 要求(Eden 默认自带以下前三种 runtimeTarget，包括 Modern、PCLegacy、MobileLegacy)和产物模块格式，注入不同的 Polyfill 内容：\r\n\r\n- **现代浏览器**：注入 import map 的 polyfill 即可\r\n- **PC 端老旧浏览器**：[PC 端默认 browserlist ](https://browserslist.dev/?q=SUUgMTEsID4gMC41JSwgbm90IGRlYWQ%3D)下所有第三方包所需的 Polyfill + Systemjs 产物\r\n- **移动端老旧浏览器**：[移动端默认 browserlist](https://browserslist.dev/?q=aU9TIDksIEFuZHJvaWQgNC40LCBsYXN0IDIgdmVyc2lvbnMsID4gMC4yJSwgbm90IGRlYWQ%3D) 下所有第三方包所需的 Polyfill + Systemjs 产物\r\n- **自定义 runtimeTarget 或模块格式**：指定 browserlist 下所有第三方包所需的 Polyfill，如果是 Systemjs 格式，则加入 Systemjs 的 Polyfill\r\n\r\nPolyfill 内容在所有第三方包编译完成后进行累计去重，然后统一打包成一个 Chunk，通过 script 标签注入到页面中：\r\n\r\n![Alt](http://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4127b37a8089428781077669a337f48a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)\r\n\r\n### 产物本地化\r\n依赖产物本地化有两个好处:\r\n\r\n- 可以在本地调试依赖的产物代码。\r\n- 可以将依赖产物代码同业务代码一同部署(私有化部署)。\r\n\r\n具体的做法如下：\r\n在使用编译服务将依赖包打包完成并上传 CDN 后，构建插件会重新请求 CDN 的资源，并将资源写入到本地磁盘中。\r\n\r\n![Alt](http://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e9b77852a8d4511a7b4baa0deea4eff~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)\r\n\r\n然后，构建插件通过在本地 Dev Server 加入中间件来对本地临时目录启用静态资源服务。\r\n与此同时，插入到 HTML 中的 import map 的远程 CDN 产物被改写为本地静态资源服务的地址。\r\n因此，最后项目中访问到的第三方包资源即为临时目录中的产物代码。"}]},{"number":101,"title":"【Q101】vite 原理","labels":["webpack"],"body":"为什么这么快？生产环境能用吗？","url":"https://github.com/kangyana/daily-question/issues/101","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. Vite\r\n### Vite 是什么？\r\nVite 是新一代的前端构建工具，在尤雨溪开发 Vue3.0 的时候诞生。\r\n类似于 Webpack + Webpack-dev-server。\r\n其主要利用浏览器 ESM 特性导入组织代码，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随起随用。\r\n生产中利用 Rollup 作为打包工具，号称下一代的前端构建工具。\r\n\r\nVite 有如下特点：\r\n\r\n- **快速的冷启动**：No Bundle + esbuild 预构建。\r\n- **即时的模块热更新**：基于 ESM 的 HMR，同时利用浏览器缓存策略提升速度。\r\n- **真正的按需加载**：利用浏览器ESM支持，实现真正的按需加载。\r\n\r\n### Vite 和传统打包方式的对比\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4af911f09d442b2a711bcea101c2fd7~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)\r\n\r\n#### Vite VS Webapck\r\nWebpack 是近年来使用量最大，同时社区最完善的前端打包构建工具，新出的5.x版本对构建细节进行了优化，在部分场景下打包速度提升明显。\r\nWebpack 在启动时，会先构建项目模块的依赖图，如果在项目中的某个地方改动了代码，Webpack 则会对相关的依赖重新打包，随着项目的增大，其打包速度也会下降。\r\n\r\nVite 相比于 Webpack 而言，没有打包的过程，而是直接启动了一个开发服务器 devServer。\r\nVite 劫持浏览器的 HTTP 请求，在后端进行相应的处理将项目中使用的文件通过简单的分解与整合，然后再返回给浏览器(整个过程没有对文件进行打包编译)。\r\n所以编译速度很快。\r\n\r\n#### Vite VS SnowPack\r\nSnowpack 首次提出利用浏览器原生 ESM 能力的打包工具，其理念就是减少或避免整个 bundle 的打包。\r\n默认在 dev 和 production 环境都使用 unbundle 的方式来部署应用。\r\n但是它的构建时却是交给用户自己选择，整体的打包体验显得有点支离破碎。\r\n\r\n而 Vite 直接整合了 Rollup，为用户提供了完善、开箱即用的解决方案，并且由于这些集成，也方便扩展更多的高级功能。\r\n两者较大的区别是在需要 bundle 打包的时候 Vite 使用 Rollup 内置配置，而 Snowpack 通过其他插件将其委托给 webpack。\r\n\r\n## 2. 前置知识\r\n### ESM\r\n在了解 Vite 之前，需要先了解下 ESM。\r\n\r\nESM 是 JavaScript 提出的官方标准化模块系统，不同于之前的 CJS，AMD，CMD 等等，ESM 提供了更原生以及更动态的模块加载方案。\r\n最重要的就是它是浏览器原生支持的，也就是说我们可以直接在浏览器中去执行 `import`，动态引入我们需要的模块，而不是把所有模块打包在一起。\r\n\r\n目前 ESM 模块化已经支持92%以上的浏览器，而且且作为 ECMA 标准，未来会有更多浏览器支持 ECMA 规范。\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6dc9ba15c9d4936b164582f3f544575~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)\r\n\r\n当我们在使用模块开发时，其实就是在构建一张模块依赖关系图，当模块加载时，就会从入口文件开始，最终生成完整的模块实例图。\r\n\r\nESM 的执行可以分为三个步骤：\r\n\r\n- **构建**：确定从哪里下载该模块文件、下载并将所有的文件解析为模块记录。\r\n- **实例化**：将模块记录转换为一个模块实例，为所有的模块分配内存空间，依照导出、导入语句把模块指向对应的内存地址。\r\n- **运行**：运行代码，将内存空间填充。\r\n\r\n从上面实例化的过程可以看出，ESM 使用实时绑定的模式，导出和导入的模块都指向相同的内存地址，也就是值引用。\r\n而 CJS 采用的是值拷贝，即所有导出值都是拷贝值。\r\n\r\n### Esbuild\r\nVite 底层使用 Esbuild 实现对 `.ts`、`.jsx`、`.js` 代码文件的转化，所以先看下什么是 es-build。\r\n\r\nEsbuild是一个JavaScript``  Bundler 打包和压缩工具，它提供了与 Webpack、Rollup 等工具相似的资源打包能力。\r\n可以将J avaScript 和 TypeScript 代码打包分发在网页上运行。\r\n但其打包速度却是其他工具的10～100倍。\r\n\r\n目前他支持以下的功能：\r\n\r\n- 加载器\r\n- 压缩\r\n- 打包\r\n- `Tree shaking`\r\n- `Source map` 生成\r\n\r\nesbuild 总共提供了四个函数：`transform`、`build`、`buildSync`、`Service`。\r\n\r\n### Rollup\r\n在生产环境下，Vite 使用 Rollup 来进行打包。\r\n\r\nRollup 是基于 ESM 的 JavaScript 打包工具。\r\n相比于其他打包工具如 Webpack，他总是能打出更小、更快的包。\r\n因为 Rollup 基于 ESM 模块，比 Webpack 和 Browserify 使用的 CommonJS 模块机制更高效。\r\nRollup 的亮点在于同一个地方，一次性加载。\r\n能针对源码进行 `Tree Shaking` (去除那些已被定义但没被使用的代码)，以及 `Scope Hoisting` 以减小输出文件大小提升运行性能。\r\n\r\nRollup 分为 build（构建）阶段和 output generate（输出生成）阶段。\r\n主要过程如下：\r\n\r\n- 获取入口文件的内容，包装成 `module`，生成抽象语法树\r\n- 对入口文件抽象语法树进行依赖解析\r\n- 生成最终代码\r\n- 写入目标文件\r\n\r\n如果你的项目只有JavaScript，而没有其他的静态资源文件，使用 Webpack 就有点大才小用了。\r\n因为 Webpack 打包的文件的体积略大，运行略慢，可读性略低。\r\n这时候建议使用 Rollup。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 3. 核心原理\r\n详细阐述下：\r\n\r\n1. 当声明一个 script 标签类型为 `module` 时，如：\r\n```javascript\r\n<script type=\"module\" src=\"/src/main.js\"></script>\r\n```\r\n2. 当浏览器解析资源时，会往当前域名发起一个 GET 请求 `main.js` 文件：\r\n```javascript\r\n// main.js\r\nimport { createApp } from 'vue'\r\nimport App from './App.vue'\r\ncreateApp(App).mount('#app')\r\n```\r\n3. 请求到了 `main.js` 文件，会检测到内部含有 `import` 引入的包，又会 `import` 引用发起 HTTP 请求获取模块的内容文件，如`App.vue`、`vue`文件。\r\n\r\nVite 其核心原理是利用浏览器现在已经支持 ES6 的 `import`，碰见 `import` 就会发送一个 HTTP 请求去加载文件。\r\nVite 启动一个 koa 服务器拦截这些请求，并在后端进行相应的处理将项目中使用的文件通过简单的分解与整合，然后再以 ESM 格式返回返回给浏览器。\r\nVite 整个过程中没有对文件进行打包编译，做到了真正的按需加载，所以其运行速度比原始的 webpack 开发编译速度快出许多！\r\n\r\n### 基于 ESM 的 Dev server\r\n在 Vite 出来之前，传统的打包工具如 Webpack 是先解析依赖、打包构建再启动开发服务器，\r\nDev Server 必须等待所有模块构建完成，当我们修改了 bundle模块中的一个子模块， 整个 bundle 文件都会重新打包然后输出。\r\n项目应用越大，启动时间越长。\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75cc6d8f467a40f78f0b01f10f5ae5e0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)\r\n\r\n而 Vite 利用浏览器对 ESM 的支持，当 `import` 模块时，浏览器就会下载被导入的模块。\r\n先启动开发服务器，当代码执行到模块加载时再请求对应模块的文件，本质上实现了动态加载。\r\n灰色部分是暂时没有用到的路由，所有这部分不会参与构建过程。\r\n随着项目里的应用越来越多，增加 `route`，也不会影响其构建速度。\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4b6fdbc052849b991dc309e0114b6d7~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)\r\n\r\n### 基于ESM 的 HMR 热更新\r\n\r\n目前所有的打包工具实现热更新的思路都大同小异：主要是通过 WebSocket 创建浏览器和服务器的通信监听文件的改变，当文件被修改时，服务端发送消息通知客户端修改相应的代码，客户端对应不同的文件进行不同的操作的更新。\r\n\r\n### Vite VS Webpack\r\n\r\n- **Webpack**：重新编译，请求变更后模块的代码，客户端重新加载。\r\n- **Vite**：请求变更的模块，再重新加载。\r\n- Vite 通过 chokidar 来监听文件系统的变更，只用对发生变更的模块重新加载， 只需要精确的使相关模块与其临近的 HMR 边界连接失效即可，这样 HMR 更新速度就不会因为应用体积的增加而变慢。\r\n而 Webpack 还要经历一次打包构建。所以 HMR 场景下，Vite 表现也要好于 Webpack。\r\n\r\n### 核心流程\r\nVite 整个热更新过程可以分成四步：\r\n\r\n- 创建一个 websocket 服务端和 client 文件，启动服务。\r\n- 通过 chokidar 监听文件变更。\r\n- 当代码变更后，服务端进行判断并推送到客户端。\r\n- 客户端根据推送的信息执行不同操作的更新。\r\n\r\n![Alt](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa4444159ea14eb583dc787d5f399b56~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)\r\n\r\n#### 启动热更新：createWebSocketServer\r\n在 Vite dev server 启动之前，Vite 会为 HMR 做一些准备工作：\r\n比如创建 websocket 服务，利用 chokidar 创建一个监听对象 watcher 用于对文件修改进行监听等等，具体核心代码：\r\n\r\n**packages/vite/src/node/server/index.ts**\r\n```javascript\r\nexport async function createServer(\r\n  inlineConfig: InlineConfig = {}\r\n): Promise<ViteDevServer> {\r\n  ....\r\n  const ws = createWebSocketServer(httpServer, config, httpsOptions)\r\n  const { ignored = [], ...watchOptions } = serverConfig.watch || {}\r\n  const watcher = chokidar.watch(path.resolve(root), {\r\n    ignored: [\r\n      '**/node_modules/**',\r\n      '**/.git/**',\r\n      ...(Array.isArray(ignored) ? ignored : [ignored])\r\n    ],\r\n    ignoreInitial: true,\r\n    ignorePermissionErrors: true,\r\n    disableGlobbing: true,\r\n    ...watchOptions\r\n  }) as FSWatcher\r\n  ....\r\n  watcher.on('change', async (file) => {\r\n\r\n  })\r\n  watcher.on('add', (file) => {\r\n  })\r\n  watcher.on('unlink', (file) => {\r\n  })\r\n  ...\r\n  return server\r\n}\r\n```\r\n\r\n`createWebSocketServer `这个方法主是创建 WebSocket 服务并对错误进行一些处理，最后返回封装好的 `on`、`off`、 `send` 和 `close` 方法，用于后续服务端推送消息和关闭服务。\r\n\r\n**packages/vite/src/node/server/ws.ts**\r\n```javascript\r\nexport function createWebSocketServer(\r\n  server: Server | null,\r\n  config: ResolvedConfig,\r\n  httpsOptions?: HttpsServerOptions\r\n): WebSocketServer {\r\n  let wss: WebSocket\r\n  let httpsServer: Server | undefined = undefined\r\n  // 热更新配置\r\n  const hmr = isObject(config.server.hmr) && config.server.hmr\r\n  const wsServer = (hmr && hmr.server) || server\r\n  // 普通模式\r\n  if (wsServer) {\r\n    wss = new WebSocket({ noServer: true })\r\n    wsServer.on('upgrade', (req, socket, head) => {\r\n      // 监听通过vite客户端发送的websocket消息，通过HMR_HEADER区分\r\n      if (req.headers['sec-websocket-protocol'] === HMR_HEADER) {\r\n        wss.handleUpgrade(req, socket as Socket, head, (ws) => {\r\n          wss.emit('connection', ws, req)\r\n        })\r\n      }\r\n    })\r\n  } else { // 中间件模式\r\n    // vite dev server in middleware mode\r\n    wss = new WebSocket(websocketServerOptions)\r\n  }\r\n  wss.on('connection', (socket) => {\r\n    ...\r\n  })\r\n  // 错误处理\r\n  wss.on('error', (e: Error & { code: string }) => {\r\n    ...\r\n  })\r\n  // 返回\r\n  return {\r\n    on: wss.on.bind(wss),\r\n    off: wss.off.bind(wss),\r\n    send(payload: HMRPayload) {\r\n      ...\r\n    },\r\n    close() {\r\n      ...\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### 执行热更新：moduleGraph + handleHMRUpdate 模块\r\n接收到文件改动执行的回调，这里主要两个操作：`moduleGraph.onFileChange` 修改文件的缓存和 `handleHMRUpdate` 执行热更新：\r\n\r\n**packages/vite/src/node/server/index.ts**\r\n```javascript\r\n watcher.on('change', async (file) => {\r\n    file = normalizePath(file)\r\n    if (file.endsWith('/package.json')) {\r\n      return invalidatePackageData(packageCache, file)\r\n    }\r\n    // invalidate module graph cache on file change\r\n    moduleGraph.onFileChange(file)\r\n    if (serverConfig.hmr !== false) {\r\n      try {\r\n        await handleHMRUpdate(file, server)\r\n      } catch (err) {\r\n        ws.send({\r\n          type: 'error',\r\n          err: prepareError(err)\r\n        })\r\n      }\r\n    }\r\n  })\r\n```\r\n\r\n#### moduleGraph\r\n`moduleGraph` 是 Vite 定义的用来记录整个应用的模块依赖图的类，除此之外还有 `moduleNode`。\r\n\r\n**packages/vite/src/node/server/moduleGraph.ts**\r\n```javascript\r\n watcher.on('change', async (file) => {\r\n    file = normalizePath(file)\r\n    if (file.endsWith('/package.json')) {\r\n      return invalidatePackageData(packageCache, file)\r\n    }\r\n    // invalidate module graph cache on file change\r\n    moduleGraph.onFileChange(file)\r\n    if (serverConfig.hmr !== false) {\r\n      try {\r\n        await handleHMRUpdate(file, server)\r\n      } catch (err) {\r\n        ws.send({\r\n          type: 'error',\r\n          err: prepareError(err)\r\n        })\r\n      }\r\n    }\r\n  })\r\n```\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/255b00da11d44a5cbe1cbc077e57cc10~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5963a5b23e542679409493f1e3022dc~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)\r\n\r\n`moduleGraph` 是由一系列 map 组成，而这些 map 分别是 `url`、`id`、`file` 等与 `ModuleNode` 的映射，\r\n而 `ModuleNode` 是 Vite 中定义的 **最小模块单位**。\r\n通过这两个类可以构建下面的模块依赖图：\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b3cdbaa8c164503a397fd317b3f5f3f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)\r\n\r\n可以看看 `moduleGraph.onFileChange` 这个函数：主要是用来清空被修改文件对应的 `ModuleNode` 对象的 \r\n `transformResult` 属性，使之前的模块已有的转换缓存失效。\r\n这块也就是 Vite 在热更新里的缓存机制。\r\n\r\n**packages/vite/src/node/server/moduleGraph.ts**\r\n```javascript\r\nonFileChange(file: string): void {\r\n    const mods = this.getModulesByFile(file)\r\n    if (mods) {\r\n      const seen = new Set<ModuleNode>()\r\n      mods.forEach((mod) => {\r\n        this.invalidateModule(mod, seen)\r\n      })\r\n    }\r\n  }\r\n\r\n  invalidateModule(mod: ModuleNode, seen: Set<ModuleNode> = new Set()): void {\r\n    mod.info = undefined\r\n    mod.transformResult = null\r\n    mod.ssrTransformResult = null\r\n    invalidateSSRModule(mod, seen)\r\n  }\r\n```\r\n\r\n#### handleHMRUpdate\r\n`handleHMRUpdate` 模块主要是监听文件的更改，进行处理和判断通过 WebSocket 给客户端发送消息通知客户端去请求新的模块代码。\r\n\r\n**packages/vite/packages/vite/src/node/server/hmr.ts**\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d193a0ce12fd4dcc9ff61f59a7391877~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)\r\n\r\n#### 客户端：websocket通信和更新处理\r\n客户端：当我们配置了热更新且不是 ssr 的时候，Vite 底层在处理 html 的时候会把 HMR 相关的客户端代码写入在我们的代码中，如下：\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fc364f458444311bb7f0982d762b77a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)\r\n\r\n当接收到服务端推送的消息，通过不同的消息类型做相应的处理，如(`connected`、`update`、`custom`...)，\r\n在实际开发热更新中使用最频繁的是 `update` (动态加载热更新模块)和 `full-reload` (刷新整个页面)事件。\r\n\r\n**packages/vite/packages/vite/src/client/client.ts**\r\n\r\n![Alt](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2288c655ae0d48119992c036cb7882d3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)\r\n\r\n#### 优化：浏览器的缓存策略提高响应速度\r\n同时，Vite 还利用 HTTP 加速整个页面的重新加载。\r\n设置响应头使得依赖模块(dependency module)进行强缓存，而源码文件通过设置 `304 Not Modified` 而变成可依据条件而进行更新。\r\n若需要对依赖代码模块做改动可手动操作使缓存失效：\r\n```bash\r\nvite --force\r\n```\r\n\r\n或者手动删除 `node_modules/.vite` 中的缓存文件。\r\n\r\n### 基于esbuild的依赖预编译优化\r\n#### 为什么需要预构建？\r\n\r\n- 支持 commonJS 依赖。\r\n- 上面提到 Vite 是基于浏览器原生支持 ESM 的能力实现的，但要求用户的代码模块必须是ESM模块，因此必须将 commonJs 的文件提前处理，转化成 ESM 模块并缓存入 `node_modules/.vite`\r\n- 减少模块和请求数量。\r\n\r\n除此之外，我们常用的 `lodash` 工具库，里面有很多包通过单独的文件相互导入，\r\n而 `lodash-es` 这种包会有几百个子模块，当代码中出现 `import { debounce } from 'lodash-es'` 会发出几百个 HTTP 请求，\r\n这些请求会造成网络堵塞，影响页面的加载。\r\n\r\nVite 将有许多内部模块的 ESM 依赖关系转换为单个模块，以提高后续页面加载性能。\r\n通过预构建 `lodash-es` 成为一个模块，也就只需要一个 HTTP 请求了！\r\n\r\n#### 为什么使用 Esbuild?\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6306c038f7343f69a505ffc15b4d274~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)\r\n\r\n引用尤大的一句话：“快”就一个字。\r\n\r\n这是 Esbuild 首页的图。\r\n新一代的打包工具，提供了与 Webpack、Rollup、Parcel 等工具相似的资源打包能力，但在时速上达到10～100倍的差距，耗时是 Webpack 2%~3%。\r\n\r\n- 编译运行 VS 解释运行\r\n- 大多数前端打包工具都是基于 JavaScript 实现的，大家都知道 JavaScript 是解释型语言，边运行边解释。\r\n而 Esbuild 则选择使用 Go 语言编写，该语言可以编译为原生代码,在编译的时候都将语言转为机器语言，在启动的时候直接执行即可，在 CPU 密集场景下，Go 更具性能优势。\r\n- 多线程 VS 单线程\r\n- JavaScript 本质上是一门单线程语言，直到引入 WebWorker 之后才有可能在浏览器、Node 中实现多线程操作。\r\n而 Webpack 源码也并未使用 WebWorker 提供的多线程能力。\r\n而 GO 天生的多线程优势。\r\n- 对构建流程进行了优化，充分利用 CPU 资源\r\n\r\n#### 实现原理？\r\nVite 预编译之后，将文件缓存在 `node_modules/.vite/` 文件夹下。根据以下地方来决定是否需要重新执行预构建。\r\n\r\n- `package.json` 中：`dependencies`发生变化。\r\n- 包管理器的 `lockfile`。\r\n\r\n如果想强制让 Vite 重新预构建依赖，可以使用 `--force` 启动开发服务器，或者直接删掉 `node_modules/.vite/` 文件夹。\r\n\r\n#### 核心代码实现\r\n\r\n- 通过 `createServer` 创建 `server` 对象后，当服务器启动会执行 `httpServer.listen` 方法。\r\n- 在执行 `createServer` 时，Vite 底层会重写 `server.listen` 方法：首先调用插件的 `buildStart` 再执行 `runOptimize()` 方法。\r\n- `runOptimize()` 调用 `optimizeDeps()` 和 `createMissingImporterRegisterFn()`方法。\r\n- `optimizeDeps()` 主要是根据配置文件生成 hash，获取上次预购建的内容(存放在 `_metadata.json` 文件)。\r\n如果不是强预构建就对比 `_metadata.json` 文件的 hash 和新生成的 hash：\r\n一致就返回 `_metadata.json` 文件的内容，否则清空缓存文件调用 Esbuild 构建模块再次存入 `_metadata.json` 文件。\r\n\r\n```javascript\r\nconst runOptimize = async () => {\r\n    if (config.cacheDir) {\r\n      server._isRunningOptimizer = true\r\n      try {\r\n        server._optimizeDepsMetadata = await optimizeDeps(\r\n          config,\r\n          config.server.force || server._forceOptimizeOnRestart\r\n        )\r\n      } finally {\r\n        server._isRunningOptimizer = false\r\n      }\r\n      server._registerMissingImport = createMissingImporterRegisterFn(server)\r\n    }\r\n  }\r\nif (!middlewareMode && httpServer) {\r\n  let isOptimized = false\r\n  // overwrite listen to run optimizer before server start\r\n  const listen = httpServer.listen.bind(httpServer)\r\n  httpServer.listen = (async (port: number, ...args: any[]) => {\r\n    if (!isOptimized) {\r\n      try {\r\n        await container.buildStart({})\r\n        await runOptimize()\r\n        isOptimized = true\r\n      } catch (e) {\r\n        httpServer.emit('error', e)\r\n        return\r\n      }\r\n    }\r\n    return listen(port, ...args)\r\n  }) as any\r\n} else {\r\n  await container.buildStart({})\r\n  await runOptimize()\r\n}\r\n```\r\n\r\n#### 整体的流程图\r\n核心代码都在 `packages/vite/src/node/optimizer/index.ts` 里面。\r\n\r\n- 自动搜寻依赖主要模块：`esbuildScanPlugin`。\r\n- 预构建编译主要模块：`esbuildDepPlugin`。\r\n\r\n![Alt](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65b8b81442b14ed8a0a1738fba03cfe9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)\r\n\r\n### 基于 Rollup 的 Plugins\r\nVite 从 preact 的 `WMR` 中得到了启发，将 Vite Plugins 继承 `Rollup Plugins API`，\r\n在其基础上进行了一些扩展(如 Vite 特有的钩子等)，同时 Vite 也基于 Rollup plugins 机制提供了强大的插件 API。\r\n目前和 Vite 兼容或者内置的插件，可以查看 `vite-rollup-plugins`。\r\n\r\n#### Vite 插件是什么\r\n使用 Vite 插件可以扩展 Vite 能力，通过暴露一些构建打包过程的一些时机配合工具函数，让用户可以自定义地写一些配置代码，执行在打包过程中。\r\n比如解析用户自定义的文件输入，在打包代码前转译代码，或者查找。\r\n\r\n在实际的实现中，Vite 仅仅需要基于 Rollup 设计的接口进行扩展，在保证兼容 Rollup 插件的同时再加入一些 Vite 特有的钩子和属性来进行扩展。\r\n\r\n#### Vite 独有钩子\r\n\r\n- `config`：可以在 Vite 被解析之前修改 Vite 的相关配置。\r\n钩子接收原始用户配置 `config` 和一个描述配置环境的变量 `env`。\r\n- `configResolved`：解析 Vite 配置后调用，配置确认。\r\n- `configureserver`：主要用来配置开发服务器，为 dev-server 添加自定义的中间件。\r\n- `transformindexhtml`：主要用来转换 `index.html`，钩子接收当前的 HTML 字符串和转换上下文。\r\n- `handlehotupdate`：执行自定义 `HMR` 更新，可以通过 ws 往客户端发送自定义的事件。\r\n\r\n具体使用请[移步这里](https://cn.vitejs.dev/guide/api-plugin.html#vite-specific-hooks)。\r\n\r\n#### 通用钩子\r\n\r\n- 服务启动时调用一次\r\n  - `options`：获取、操纵 Rollup 选项\r\n  - `buildstart`：开始创建\r\n- 在每个传入模块请求时被调用\r\n  - `resolveId`：创建自定义确认函数，可以用来定位第三方依赖\r\n  - `load`：可以自定义加载器，可用来返回自定义的内容\r\n  - `transform`：在每个传入模块请求时被调用，主要是用来转换单个模块\r\n- 服务关闭时调用一次\r\n  - `buildend`：在服务器关闭时被调用\r\n  - `closeBundle`\r\n\r\n其它钩子使用请[移步这里](https://cn.vitejs.dev/guide/api-plugin.html#universal-hooks)。\r\n\r\n#### 钩子的调用顺序\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/564ebefb5e304704b2dba4b132129d94~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)\r\n\r\nVite 的官网可以看出：\r\nVite 插件可以用一个 `enforce` 属性（类似于 Webpack 加载器）来调整它的应用顺序。\r\n`enforce` 的值可以是 `pre` 或 `post`。\r\n解析后的插件将按照以下顺序排列：\r\n\r\n- `Alias`\r\n- `enforce:'pre'` 的自定义插件\r\n- Vite 核心插件\r\n- 没有 `enforce` 的自定义插件\r\n- Vite 构建用的插件\r\n- `enforce:'post'` 的自定义插件\r\n- Vite 后置构建插件\r\n\r\n#### 自定义插件\r\n\r\n- 编写插件代码\r\n```javascript\r\nexport default function myVitePlugin () {\r\n  // 定义vite插件唯一id\r\n  const virtualFileId = '@my-vite-plugin'\r\n  // 返回的整个插件对象\r\n  return {\r\n    // 必须的，将会显示在 warning 和 error 中\r\n    name: 'vite-plugin',\r\n    // 钩子\r\n    // config\r\n    config: (config, env) => ({\r\n       console.log('config',config)\r\n       return {}\r\n    }),\r\n    // 确认config\r\n    configResolved: config => ({}),\r\n    options: options => ({}),\r\n    buildStart: options => ({}),\r\n    transformIndexHtml: (html, ctx) => ({\r\n        return html\r\n    }),\r\n    //确认\r\n    resolveId: (source, importer) => ({}),\r\n    // 转换\r\n    transform: (code, id) => ({})\r\n  }\r\n}\r\n```\r\n- 引入插件：`vite.config.js/ts` 中引用\r\n```javascript\r\n// vite.config.js/ts\r\n\r\nimport myVitePlugin from '...'\r\n\r\nexport default defineConfig{\r\n    plugins:[vue(),myVitePlugin()]\r\n}\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 4. 总结\r\n最后总结下 Vite 相关的优缺点：\r\n\r\n- 优点：\r\n  - **快速的冷启动**: 采用 `No Bundle` 和 esbuild 预构建，速度远快于 Webpack。\r\n  - **高效的热更新**：基于 ESM 实现，同时利用 HTTP 头来加速整个页面的重新加载，增加缓存策略。\r\n  - **真正的按需加载**: 基于浏览器 ESM 的支持，实现真正的按需加载。\r\n- 缺点：\r\n  - **生态**：目前 Vite 的生态不如 Webapck，不过我觉得生态也只是时间上的问题。\r\n  - **生产环境** 由于 esbuild 对 css 和代码分割不友好使用 Rollup 进行打包。\r\n\r\nVite.js 虽然才在构建打包场景兴起，但在很多场景下基本都会优于现有的解决方案。\r\n如果有生态、想要丰富的 `loader`、`plugins` 的要求可以考虑成熟的 Webpack。\r\n在其余情况下，Vite.js 不失为一个打包构建工具的好选择。"}]},{"number":102,"title":"【Q102】sourceMap","labels":["webpack"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/102","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. source-map\r\n`source-map` 是 **转译后的代码** 和 **源代码** 的映射关系。\r\n\r\n## 2. 如何开启 source-map\r\n`devtool` 选项控制是否生成，以及如何生成 source map。\r\n\r\n`string = 'eval'` `false`\r\n\r\n选择一种 source map 风格来增强调试过程。\r\n不同的值会明显影响到构建和重新构建的速度。\r\n\r\n| 可选值 | 构建性能 | 重构建性能 | 生产环境 | 品质 | 注释 |\r\n| -- | -- | -- | -- | -- | -- |\r\n| false | 最快 | 最快 | ✅  | 打包后代码 | 不做处理 |\r\n| **eval** | 快 | 最快 | ❌ | 生成后代码 | 性能最优 |\r\n| **eval-source-map** | 最慢 | 一般 | ❌ | 源代码 | 开发环境优解 |\r\n| **source-map** | 最慢 | 最慢 | ✅ | 源代码 | 生成环境优解 |\r\n\r\n## 3. 品质说明\r\n\r\n- **打包后代码**：将所有生成的代码视为一大块代码。\r\n你看不到相互分离的模块。\r\n- **生成后代码**：每个模块相互分离，并用模块名称进行注释。\r\n可以看到 webpack 生成的代码。\r\n示例：你会看到类似 `var module__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(42); module__WEBPACK_IMPORTED_MODULE_1__.a();`，而不是 `import {test} from \"module\"; test();`。\r\n- **转换过代码**：每个模块相互分离，并用模块名称进行注释。\r\n可以看到 webpack 转换前、`loader` 转译后的代码。\r\n示例：你会看到类似 `import {test} from \"module\"; var A = function(_test) { ... }(test);`，\r\n而不是 `import {test} from \"module\"; class A extends test {}`。\r\n- **源代码**：每个模块相互分离，并用模块名称进行注释。\r\n你会看到转译之前的代码，正如编写它时。这取决于 `loader` 支持。\r\n- **无源代码内容**：source map 中不包含源代码内容。\r\n浏览器通常会尝试从 web 服务器或文件系统加载源代码。\r\n你必须确保正确设置 `output.devtoolModuleFilenameTemplate`，以匹配源代码的 url。\r\n- **仅限行**：source map 被简化为每行一个映射。\r\n这通常意味着每个语句只有一个映射。\r\n这会妨碍你在语句级别上调试执行，也会妨碍你在每行的一些列上设置断点。\r\n与压缩后的代码组合后，映射关系是不可能实现的，因为压缩工具通常只会输出一行。\r\n\r\n## 4. 对于开发环境\r\n以下选项非常适合开发环境：\r\n### eval\r\n每个模块都使用 `eval()` 执行，并且都有 `//# sourceURL`。\r\n此选项会非常快地构建。\r\n主要缺点是，由于会映射到转换后的代码，而不是映射到原始代码（没有从 loader 中获取 source map），所以不能正确的显示行数。\r\n\r\n### eval-source-map\r\n每个模块使用 `eval()` 执行，并且 source map 转换为 DataUrl 后添加到 `eval()` 中。\r\n初始化 source map 时比较慢，但是会在重新构建时提供比较快的速度，并且生成实际的文件。\r\n行数能够正确映射，因为会映射到原始代码中。它会生成用于开发环境的最佳品质的 source map。\r\n\r\n### eval-cheap-source-map\r\n类似 `eval-source-map`，每个模块使用 `eval()` 执行。\r\n这是 **低开销** 的 source map，因为它没有生成列映射(column mapping)，只是映射行数。\r\n它会忽略源自 `loader` 的 source map，并且仅显示转译后的代码，就像 `devtool = eval`。\r\n\r\n### eval-cheap-module-source-map\r\n类似 `eval-cheap-source-map`，并且，在这种情况下，源自 `loader` 的 source map 会得到更好的处理结果。\r\n然而，`loader` 的 source map 会被简化为每行一个映射(mapping)。\r\n\r\n## 5. 对于生产环境\r\n这些选项通常用于生产环境中：\r\n### false（省略 devtool 选项）\r\n不生成 source map。这是一个不错的选择。\r\n\r\n### source-map\r\n整个 source map 作为一个单独的文件生成。\r\n它为 bundle 添加了一个引用注释，以便开发工具知道在哪里可以找到它。\r\n\r\n注意：你应该将你的服务器配置为，不允许普通用户访问 source map 文件！\r\n\r\n### hidden-source-map\r\n与 `source-map` 相同，但不会为 bundle 添加引用注释。\r\n如果你只想 source map 映射那些源自错误报告的错误堆栈跟踪信息，但不想为浏览器开发工具暴露你的 source map，这个选项会很有用。\r\n\r\n注意：你不应将 source map 文件部署到 web 服务器。而是只将其用于错误报告工具。\r\n\r\n### nosources-source-map\r\n创建的 source map 不包含 **源代码**。\r\n它可以用来映射客户端上的堆栈跟踪，而无须暴露所有的源代码。\r\n你可以将 source map 文件部署到 web 服务器。\r\n\r\n注意：这仍然会暴露反编译后的文件名和结构，但它不会暴露源代码。\r\n\r\n## 6. 特定场景\r\n以下选项对于开发环境和生产环境并不理想。\r\n他们是一些特定场景下需要的，例如，针对一些第三方工具。\r\n\r\n### inline-source-map\r\nsource map 转换为 DataUrl 后添加到 bundle 中。\r\n\r\n### cheap-source-map\r\n没有列映射(column mapping)的 source map，忽略 `loader` 的 source map。\r\n\r\n### inline-cheap-source-map\r\n类似 `cheap-source-map`，但是 source map 转换为 DataUrl 后添加到 bundle 中。\r\n\r\n### cheap-module-source-map\r\n没有列映射(column mapping)的 source map，将 `loader` 的 source map 简化为每行一个映射(mapping)。\r\n\r\n### inline-cheap-module-source-map\r\n类似 `cheap-module-source-map`，但是 source mapp 转换为 DataUrl 添加到 bundle 中。"}]}],"工程化":[{"number":103,"title":"【Q103】打包时 cjs、es、umd 模块有何不同","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/103","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. cjs (commonjs)\r\n`commonjs` 是 Node 中的模块规范，通过 `require` 和 `exports` 进行导入导出 。\r\n(进一步延伸的话，`module.exports` 属于 `commonjs2`)\r\n\r\n同时，webpack 也对 `cjs` 模块得以解析，因此 `cjs` 模块可以运行在 node 环境及 webpack 环境下的，但不能在浏览器中直接使用。\r\n但如果你写前端项目在 webpack 中，也可以理解为它在浏览器和 Node 都支持。\r\n\r\n比如，著名的全球下载量前十 10 的模块 [ms (opens new window)](https://npm.devtool.tech/ms)只支持 `commonjs`，\r\n但并不影响它在前端项目中使用(通过 webpack)，但是你想通过 cdn 的方式直接在浏览器中引入，估计就会出问题了。\r\n\r\n基本使用方法：\r\n```javascript\r\n// sum.js\r\nexports.sum = (x, y) => x + y;\r\n\r\n// index.js\r\nconst { sum } = require(\"./sum.js\");\r\n```\r\n\r\n由于 `cjs` 为动态加载，可直接 `require` 一个变量：\r\n```javascript\r\nrequire(`./${a}`);\r\n```\r\n\r\n## 2. esm (es module)\r\n`esm` 是 tc39 对于 ESMAScript 的模块话规范，正因是语言层规范，因此 **在 Node 及 浏览器中均会支持**。\r\n\r\n它使用 `import/export` 进行模块导入导出：\r\n```javascript\r\n// sum.js\r\nexport const sum = (x, y) => x + y;\r\n\r\n// index.js\r\nimport { sum } from \"./sum\";\r\n```\r\n\r\n`esm` 为静态导入，正因如此，可在编译期进行 `Tree Shaking`，减少 js 体积。\r\n\r\n如果需要动态导入，tc39 为动态加载模块定义了 API：`import(module) `。\r\n```javascript\r\nconst ms = await import(\"https://cdn.skypack.dev/ms@latest\");\r\n\r\nms.default(1000);\r\n```\r\n\r\n`esm` 是未来的趋势，目前一些 CDN 厂商，前端构建工具均致力于 `cjs` 模块向 `esm` 的转化，比如 `skypack`、 `snowpack`、`vite` 等。\r\n\r\n目前，在浏览器与 node.js 中均原生支持 `esm`。\r\n\r\n`cjs` 模块输出的是一个值的拷贝，`esm` 输出的是值的引用。\r\n`cjs` 模块是运行时加载，`esm` 是编译时加载。\r\n\r\n示例: [array-uniq](https://cdn.jsdelivr.net/npm/array-uniq/index.js)\r\n\r\n## 3. umd（Universal Module Definition）\r\n一种兼容 `cjs` 与 `amd` 的模块，既可以在 `node/webpack` 环境中被 `require` 引用，也可以在浏览器中直接用 CDN 被 `script.src` 引入。\r\n\r\n```javascript\r\n(function (root, factory) {\r\n  if (typeof define === \"function\" && define.amd) {\r\n    // AMD\r\n    define([\"jquery\"], factory);\r\n  } else if (typeof exports === \"object\") {\r\n    // CommonJS\r\n    module.exports = factory(require(\"jquery\"));\r\n  } else {\r\n    // 全局变量\r\n    root.returnExports = factory(root.jQuery);\r\n  }\r\n})(this, function ($) {\r\n  // ...\r\n});\r\n```\r\n\r\n示例: [react-table (opens new window)](https://cdn.jsdelivr.net/npm/react-table/), [antd](https://cdn.jsdelivr.net/npm/antd/)\r\n\r\n这三种模块方案大致如此，部分 npm package 也会同时打包出 `commonjs/esm/umd` 三种模块化格式，供不同需求的业务使用，比如 [antd (opens new window)](https://cdn.jsdelivr.net/npm/antd/)。\r\n\r\n[antd 的 cjs(opens new window)](https://cdn.jsdelivr.net/npm/antd@4.17.2/lib/index.js)\r\n[antd 的 umd(opens new window)](https://cdn.jsdelivr.net/npm/antd@4.17.2/dist/antd.js)\r\n[antd 的 esm](https://cdn.jsdelivr.net/npm/antd@4.17.2/es/index.js)"}]},{"number":104,"title":"【Q104】什么是 AST，及其应用","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/104","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 什么是 AST\r\n`AST` 是 Abstract Syntax Tree 的简称，是前端工程化绕不过的一个名词。\r\n它涉及到工程化诸多环节的应用，比如:\r\n\r\n- 如何将 Typescript 转化为 Javascript (typescript)\r\n- 如何将 SASS/LESS 转化为 CSS (sass/less)\r\n- 如何将 ES6+ 转化为 ES5 (babel)\r\n- 如何将 Javascript 代码进行格式化 (eslint/prettier)\r\n- 如何识别 React 项目中的 JSX (babel)\r\n- GraphQL、MDX、Vue SFC 等等\r\n\r\n而在语言转换的过程中，实质上就是对其 AST 的操作，核心步骤就是 AST 三步走：\r\n\r\n- Code -> AST (Parse)\r\n- AST -> AST (Transform)\r\n- AST -> Code (Generate)\r\n\r\n![Alt](https://raw.githubusercontent.com/shfshanyue/assets/master/2021-12-13/AST.37256a.webp)\r\n\r\n以下是一段代码：\r\n```javascript\r\nconst a = 4;\r\n```\r\n\r\n转换为 AST：\r\n```json\r\n{\r\n  \"type\": \"Program\",\r\n  \"start\": 0,\r\n  \"end\": 11,\r\n  \"body\": [\r\n    {\r\n      \"type\": \"VariableDeclaration\",\r\n      \"start\": 0,\r\n      \"end\": 11,\r\n      \"declarations\": [\r\n        {\r\n          \"type\": \"VariableDeclarator\",\r\n          \"start\": 6,\r\n          \"end\": 11,\r\n          \"id\": {\r\n            \"type\": \"Identifier\",\r\n            \"start\": 6,\r\n            \"end\": 7,\r\n            \"name\": \"a\"\r\n          },\r\n          \"init\": {\r\n            \"type\": \"Literal\",\r\n            \"start\": 10,\r\n            \"end\": 11,\r\n            \"value\": 4,\r\n            \"raw\": \"4\"\r\n          }\r\n        }\r\n      ],\r\n      \"kind\": \"const\"\r\n    }\r\n  ],\r\n  \"sourceType\": \"module\"\r\n}\r\n```\r\n\r\n不同的语言拥有不同的解析器，比如 Javascript 的解析器和 CSS 的解析器就完全不同。\r\n\r\n对相同的语言，也存在诸多的解析器，也就会生成多种 AST，如 `babel` 与 `espree`。\r\n\r\n在 [AST Explorer (opens new window)](https://astexplorer.net/)中，列举了诸多语言的解析器(Parser)，及转化器(Transformer)。\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96e2f4eba4e5475faab8068d7c06c43c~tplv-k3u1fbpfcp-zoom-1.image)"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. AST 的生成\r\nAST 的生成这一步骤被称为 **解析(Parser)**，而该步骤也有两个阶段：\r\n\r\n- 词法分析(Lexical Analysis)\r\n- 语法分析(Syntactic Analysis)\r\n\r\n### 词法分析（Lexical Analysis）\r\n词法分析用以将代码转化为 `Token` 流，维护一个关于 Token 的数组。\r\n\r\n![Alt](https://raw.githubusercontent.com/shfshanyue/assets/master/2021-12-13/Parse.050e33.webp)\r\n\r\n```javascript\r\n// Code\r\na = 3\r\n\r\n// 转换为 Token\r\n[\r\n  { type: { ... }, value: \"a\", start: 0, end: 1, loc: { ... } },\r\n  { type: { ... }, value: \"=\", start: 2, end: 3, loc: { ... } },\r\n  { type: { ... }, value: \"3\", start: 4, end: 5, loc: { ... } },\r\n  ...\r\n]\r\n```\r\n\r\n词法分析后的 Token 流也有诸多应用，如:\r\n\r\n- 代码检查，如 `eslint` 判断是否以分号结尾，判断是否含有分号的 token\r\n- 语法高亮，如 `highlight/prism` 使之代码高亮\r\n- 模板语法，如 ejs 等模板也离不开\r\n\r\n### 语法分析 (Syntactic Analysis)\r\n语法分析将 Token 流转化为结构化的 AST，方便操作：\r\n```javascript\r\n{\r\n  \"type\": \"Program\",\r\n  \"start\": 0,\r\n  \"end\": 5,\r\n  \"body\": [\r\n    {\r\n      \"type\": \"ExpressionStatement\",\r\n      \"start\": 0,\r\n      \"end\": 5,\r\n      \"expression\": {\r\n        \"type\": \"AssignmentExpression\",\r\n        \"start\": 0,\r\n        \"end\": 5,\r\n        \"operator\": \"=\",\r\n        \"left\": {\r\n          \"type\": \"Identifier\",\r\n          \"start\": 0,\r\n          \"end\": 1,\r\n          \"name\": \"a\"\r\n        },\r\n        \"right\": {\r\n          \"type\": \"Literal\",\r\n          \"start\": 4,\r\n          \"end\": 5,\r\n          \"value\": 3,\r\n          \"raw\": \"3\"\r\n        }\r\n      }\r\n    }\r\n  ],\r\n  \"sourceType\": \"module\"\r\n}\r\n```\r\n\r\n## 3. 实践\r\n可通过自己写一个解析器，将语言 (DSL) 解析为 AST 进行练手，以下两个示例是不错的选择：\r\n\r\n- 解析简单的 HTML 为 AST\r\n- 解析 Marktodwn List 为 AST\r\n\r\n或可参考一个最简编译器的实现 [the super tiny compiler](https://github.com/jamiebuilds/the-super-tiny-compiler)"}]},{"number":105,"title":"【Q105】webpack 的 runtime 做了什么事情","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/105","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. Webpack Runtime\r\nwebpack 的 runtime，也就是 webpack 最后生成的 **运行时代码**，做了以下三件事:\r\n\r\n- **__webpack_modules__**：维护一个所有模块的数组。\r\n将入口模块解析为 AST，根据 AST 深度优先搜索所有的模块，并构建出这个模块数组。\r\n每个模块都由一个包裹函数 (`module`, `module.exports`, `__webpack_require__`) 对模块进行包裹构成。\r\n- **__webpack_require__(moduleId)**：手动实现加载一个模块。\r\n对已加载过的模块进行缓存，对未加载过的模块，执行 id 定位到 `__webpack_modules__` 中的包裹函数，执行并返回`module.exports`，并缓存。\r\n- **__webpack_require__(0)**：运行第一个模块，即运行入口模块。\r\n\r\n另外，当涉及到多个 chunk 的打包方式中，比如 `code spliting`，webpack 中会使用 jsonp 加载 chunk 的运行时代码。\r\n\r\n以下是 webpack runtime 的最简代码，配置示例可见 [node-examples](https://github.com/shfshanyue/node-examples/blob/master/engineering/webpack/cjs/example/main.js)\r\n\r\n```javascript\r\n/******/ var __webpack_modules__ = [\r\n  ,\r\n  /* 0 */ /* 1 */\r\n  /***/ (module) => {\r\n    module.exports = (...args) => args.reduce((x, y) => x + y, 0);\r\n\r\n    /***/\r\n  },\r\n  /******/\r\n];\r\n/************************************************************************/\r\n/******/ // The module cache\r\n/******/ var __webpack_module_cache__ = {};\r\n/******/\r\n/******/ // The require function\r\n/******/ function __webpack_require__(moduleId) {\r\n  /******/ // Check if module is in cache\r\n  /******/ var cachedModule = __webpack_module_cache__[moduleId];\r\n  /******/ if (cachedModule !== undefined) {\r\n    /******/ return cachedModule.exports;\r\n    /******/\r\n  }\r\n  /******/ // Create a new module (and put it into the cache)\r\n  /******/ var module = (__webpack_module_cache__[moduleId] = {\r\n    /******/ // no module.id needed\r\n    /******/ // no module.loaded needed\r\n    /******/ exports: {},\r\n    /******/\r\n  });\r\n  /******/\r\n  /******/ // Execute the module function\r\n  /******/ __webpack_modules__[moduleId](\r\n    module,\r\n    module.exports,\r\n    __webpack_require__\r\n  );\r\n  /******/\r\n  /******/ // Return the exports of the module\r\n  /******/ return module.exports;\r\n  /******/\r\n}\r\n/******/\r\n/************************************************************************/\r\nvar __webpack_exports__ = {};\r\n// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\r\n(() => {\r\n  const sum = __webpack_require__(1);\r\n\r\n  sum(3, 8);\r\n})();\r\n```\r\n\r\n对 webpack runtime 做进一步的精简，代码如下：\r\n```javascript\r\nconst __webpack_modules__ = [() => {}];\r\nconst __webpack_require__ = (id) => {\r\n  const module = { exports: {} };\r\n  const m = __webpack_modules__[id](module, __webpack_require__);\r\n  return module.exports;\r\n};\r\n\r\n__webpack_require__(0);\r\n```\r\n\r\n使用动画表示 Webpack 的输入输出：\r\n\r\n![Alt](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-12-28/bundle-webpack.0693ce.gif)"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. Rollup\r\n在 Rollup 中，并不会将所有模块置于 `modules` 中使用 Module Wrapper 进行维护，**它仅仅将所有模块铺平展开**。\r\n\r\n试举一例：\r\n**index.js**\r\n```javascript\r\nimport name from \"./name\";\r\nconsole.log(name);\r\n```\r\n\r\n**name.js**\r\n```javascript\r\nconst name = \"shanyue\";\r\nexport default name;\r\n```\r\n\r\n在打包后，直接把所有模块平铺展开即可，可见[实时示例](https://rollupjs.org/repl/?version=2.62.0&shareable=JTdCJTIybW9kdWxlcyUyMiUzQSU1QiU3QiUyMm5hbWUlMjIlM0ElMjJtYWluLmpzJTIyJTJDJTIyY29kZSUyMiUzQSUyMmltcG9ydCUyMG5hbWUlMjBmcm9tJTIwJy4lMkZuYW1lJyU1Q25jb25zb2xlLmxvZyhuYW1lKSUyMiUyQyUyMmlzRW50cnklMjIlM0F0cnVlJTdEJTJDJTdCJTIybmFtZSUyMiUzQSUyMm5hbWUuanMlMjIlMkMlMjJjb2RlJTIyJTNBJTIyY29uc3QlMjBuYW1lJTIwJTNEJTIwJ3NoYW55dWUnJTVDbmV4cG9ydCUyMGRlZmF1bHQlMjBuYW1lJTIyJTJDJTIyaXNFbnRyeSUyMiUzQWZhbHNlJTdEJTVEJTJDJTIyb3B0aW9ucyUyMiUzQSU3QiUyMmZvcm1hdCUyMiUzQSUyMmVzJTIyJTJDJTIybmFtZSUyMiUzQSUyMm15QnVuZGxlJTIyJTJDJTIyYW1kJTIyJTNBJTdCJTIyaWQlMjIlM0ElMjIlMjIlN0QlMkMlMjJnbG9iYWxzJTIyJTNBJTdCJTdEJTdEJTJDJTIyZXhhbXBsZSUyMiUzQW51bGwlN0Q=)\r\n\r\n**output.js**\r\n```javascript\r\nconst name = \"shanyue\";\r\nconsole.log(name);\r\n```\r\n\r\n对于 Rollup 这种方案，当两个模块中发生变量冲突如何解决？\r\n很简单，直接重新命名，看示例：\r\n\r\n![Alt](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-12-28/clipboard-9429.b9ad82.webp)\r\n\r\n使用动画表示 Rollup 的输入输出：\r\n\r\n![Alt](https://raw.githubusercontent.com/shfshanyue/assets/master/2021-12-28/bundle-rollup.60cb6a.gif)"}]},{"number":106,"title":"【Q106】webpack 中的 code spliting 是如何动态加载 chunk 的？","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/106","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 一个 webpack 的运行时，包括最重要的两个数据结构：\r\n\r\n- **__webpack_modules__**：维护一个所有模块的数组。\r\n将入口模块解析为 AST，根据 AST 深度优先搜索所有的模块，并构建出这个模块数组。\r\n每个模块都由一个包裹函数 (`module`, `module.exports`, `__webpack_require__`) 对模块进行包裹构成。\r\n- **__webpack_require__(moduleId)**：手动实现加载一个模块。\r\n对已加载过的模块进行缓存，对未加载过的模块，根据 id 定位到 `__webpack_modules__` 中的包裹函数，执行并返回 `module.exports`，并缓存。\r\n\r\n## 2. code spliting\r\n在 webpack 中，通过 `import()` 可实现 code spliting。\r\n假设我们有以下文件：\r\n\r\n**index.js**\r\n```javascript\r\nimport(\"./sum\").then((m) => {\r\n  m.default(3, 4);\r\n});\r\n```\r\n\r\n**sum**\r\n```javascript\r\nconst sum = (x, y) => x + y;\r\nexport default sum;\r\n```\r\n\r\n我们将使用以下简单的 webpack 配置进行打包，具体示例可参考 [node-examples:code-spliting(opens new window)](https://github.com/shfshanyue/node-examples/blob/master/engineering/webpack/code-spliting/build.js)\r\n\r\n```javascript\r\n{\r\n  entry: './index.js',\r\n  mode: 'none',\r\n  output: {\r\n    filename: '[name].[contenthash].js',\r\n    chunkFilename: 'chunk.[name].[id].[contenthash].js',\r\n    path: path.resolve(__dirname, 'dist/deterministic'),\r\n    clean: true\r\n  },\r\n  optimization: {\r\n    moduleIds: 'deterministic',\r\n    chunkIds: 'deterministic'\r\n  }\r\n}\r\n```\r\n\r\n## 3. 运行时解析\r\n通过观察打包后的文件 `dist/deterministic/main.xxxxxx.js`，可以发现：\r\n使用 `import()` 加载数据时，以上代码将被 webpack 编译为以下代码：\r\n```javascript\r\n__webpack_require__\r\n  .e(/* import() | sum */ 644)\r\n  .then(__webpack_require__.bind(__webpack_require__, 709))\r\n  .then((m) => {\r\n    m.default(3, 4);\r\n  });\r\n```\r\n\r\n此时 `644` 为 chunkId，观察 `chunk.sum.xxxx.js` 文件，以下为 `sum` 函数所构建而成的 chunk：\r\n```javascript\r\n\"use strict\";\r\n(self[\"webpackChunk\"] = self[\"webpackChunk\"] || []).push([\r\n  [644],\r\n  {\r\n    /***/ 709: /***/ (\r\n      __unused_webpack_module,\r\n      __webpack_exports__,\r\n      __webpack_require__\r\n    ) => {\r\n      __webpack_require__.r(__webpack_exports__);\r\n      /* harmony export */ __webpack_require__.d(__webpack_exports__, {\r\n        /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,\r\n        /* harmony export */\r\n      });\r\n      const sum = (x, y) => x + y;\r\n\r\n      /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = sum;\r\n\r\n      /***/\r\n    },\r\n  },\r\n]);\r\n```\r\n\r\n以下两个数据结构是加载 chunk 的关键:\r\n\r\n- **__webpack_require__.e**：加载 chunk。\r\n该函数将使用 `document.createElement('script')` 异步加载 chunk 并封装为 Promise。\r\n- **self[\"webpackChunk\"].push**：JSONP cllaback。\r\n收集 modules 至 `__webpack_modules__`，并将 `__webpack_require__.e` 的 Promise 进行 resolve。\r\n\r\n实际上，在 webpack 中可配置 `output.chunkLoading` 来选择加载 chunk 的方式，比如选择通过 `import() `的方式进行加载。\r\n(由于在生产环境需要考虑 `import` 的兼容性，目前还是 JSONP 方式较多)\r\n```javascript\r\n{\r\n  entry: './index.js',\r\n  mode: 'none',\r\n  output: {\r\n    filename: 'main.[contenthash].js',\r\n    chunkFilename: '[name].chunk.[chunkhash].js',\r\n    path: path.resolve(__dirname, 'dist/import'),\r\n    clean: true,\r\n    // 默认为 `jsonp`\r\n    chunkLoading: 'import'\r\n  }\r\n})\r\n```\r\n\r\n可参考示例 [webpack 运行时代码 (opens new window)](https://github.com/shfshanyue/node-examples/blob/master/engineering/webpack/code-spliting/example/runtime.js)中查看加载一个 chunk 的实现。"}]},{"number":107,"title":"【Q107】打包器 如何加载 json、image 等非 Javascript 资源","labels":["工程化"],"body":"打包器(webpack/rollup)","url":"https://github.com/kangyana/daily-question/issues/107","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"在前端中，网页只能加载 javascript 脚本资源，即便在 node，也只能加载 javascript 与 json 资源。\r\n那类似 webpack、rollup 及 vite 这类工具是如何加载图片、JSON 资源的呢？\r\n\r\n在 webpack 等打包工具中，号称 **一切皆是模块**。\r\n\r\n当 webpack 在这类打包器中，需要加载 JSON 等非 Javascript 资源时，则通过 **模块加载器(loader)** 将它们转化为模块的形式。\r\n\r\n## 1. 加载 JSON\r\n**user.json**\r\n```json\r\n{\r\n  \"id\": 0,\r\n  \"name\": \"kangyana\",\r\n  \"github\": \"https://github.com/kangyana\"\r\n}\r\n```\r\n\r\n在现代前端中，我们把它视为 `module` 时，使用 `import` 引入资源：\r\n```javascript\r\nimport user from \"./user.json\";\r\n```\r\n\r\n而我们的打包器，如 webpack 与 rollup，将通过以下方式来加载 JSON 资源。\r\n这样它将被视为普通的 Javascript：\r\n```javascript\r\n// 实际上的 user.json 被编译为以下内容\r\n\r\nexport default {\r\n  id: 0,\r\n  name: \"kangyana\",\r\n  github: \"https://github.com/kangyana\",\r\n};\r\n```\r\n\r\n在 webpack 中通过 `loader` 处理此类非 JS 资源，以下为一个 `json-loader` 的示例：\r\n\r\n```javascript\r\nmodule.exports = function (source) {\r\n  const json = typeof source === \"string\" ? source : JSON.stringify(source);\r\n  return `module.exports = ${json}`;\r\n};\r\n```\r\n\r\n## 2. 加载图片\r\n那图片是如何处理的呢？\r\n\r\n更简单，它将替换为它自身的路径。示例如下：\r\n```javascript\r\nexport default `$PUBLIC_URL/assets/image/main.png`;\r\n```\r\n\r\n而我们在 `import image` 时，其实是图片的自身路径，将它置于 `src` 属性即可：\r\n```javascript\r\nimport mainImage from \"main.png\";\r\n\r\n<img src={mainImage} />;\r\n```"}]},{"number":108,"title":"【Q108】打包器 如何加载 style 样式资源","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/108","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"在打包器，比如 webpack 中，需要借用 `loader` 将非 JS 资源转化成可识别为 Javascript 的 `module`。\r\n\r\n## 1. 现状\r\n在 webpack 中，处理 css 稍微比较费劲，需要借用两个 `loader` 来做成这件事情：\r\n```javascript\r\nmodule.exports = {\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.css$/,\r\n        use: [\"style-loader\", \"css-loader\"],\r\n      },\r\n    ],\r\n  },\r\n};\r\n```\r\n\r\n- [css-loader (opens new window)](https://github.com/webpack-contrib/css-loader)：处理 CSS 中的 `url()` 与 `@import`，并将其视为模块引入，此处是通过 postcss 来解析处理，postcss 对于工程化中 css 处理的影响力可见一斑。\r\n- [style-loader (opens new window)](https://github.com/webpack-contrib/style-loader)：将样式注入到 DOM 中\r\n\r\n```javascript\r\n@import url(./basic.css);\r\n\r\n.bg {\r\n  background: url(./shanyue.png);\r\n}\r\n```\r\n\r\n## 2. 原理\r\n如果说现代前端中 Javascript 与 CSS 是其中最重要的两种资源，那么 `Babel` 与 `PostCSS` 就是前端工程化中最有影响力的两个编译器。\r\n\r\n`css-loader` 的原理就是 `postcss`，借用 `postcss-value-parser` 解析 CSS 为 AST，并将 CSS 中的 `url()` 与 `@import` 解析为模块。\r\n\r\n`style-loader` 用以将 CSS 注入到 DOM 中，原理为使用 DOM API 手动构建 style 标签，并将 CSS 内容注入到 style 中。\r\n\r\n在其源码实现中，借用了许多运行时代码 [style loader runtime (opens new window)](https://github.com/webpack-contrib/style-loader/tree/master/src/runtime)，而最简单的实现仅仅需要几行代码：\r\n```javascript\r\nmodule.exports = function (source) {\r\n  return `\r\nfunction injectCss(css) {\r\n  const style = document.createElement('style')\r\n  style.appendChild(document.createTextNode(css))\r\n  document.head.appendChild(style)\r\n}\r\n\r\ninjectCss(\\`${source}\\`)\r\n  `;\r\n};\r\n```\r\n\r\n使用 DOM API 加载 CSS 资源，由于 CSS 需要在 JS 资源加载完后通过 DOM API 控制加载，容易出现页面抖动，在线上低效且性能低下。且对于 SSR 极度不友好。\r\n\r\n由于性能需要，在线上通常需要单独加载 CSS 资源，这要求打包器能够将 CSS 打包，此时需要借助于 [mini-css-extract-plugin (opens new window)](https://github.com/webpack-contrib/mini-css-extract-plugin)将 CSS 单独抽离出来。\r\n\r\n深入 webpack 中如何抽离 CSS 的源码有助于加深对 webpack 的理解。"}]},{"number":109,"title":"【Q109】打包器 如何将打包后的 js 资源注入 html 中","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/109","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"如果最终打包生成的 `main.js` 既没有做 code spliting，也没有做 `hash` 化路径。\r\n大可以通过在 `index.html` 中手动控制 JS 资源。\r\n```javascript\r\n<body>\r\n  <script src=\"main.js\" defer />\r\n</body>\r\n```\r\n\r\n但往往事与愿违：\r\n\r\n- `main.js` 即我们最终生成的文件带有 `hash` 值，如 `main.8a9b3c.js`。\r\n- 由于长期缓存优化的需要，入口文件不仅只有一个，还包括由第三方模块打包而成的 `verdor.js`，同样带有 `hash`。\r\n- 脚本地址同时需要注入 `publicPath`，而在生产环境与测试环境的 `publicPath` 并不一致。\r\n\r\n因此需要有一个插件自动做这种事情。在 webpack 的世界里，它是 [html-webpak-plugin (opens new window)](https://github.com/jantimon/html-webpack-plugin)，\r\n在 rollup 的世界里，它是 [@rollup/plugin-html (opens new window)](https://github.com/rollup/plugins/tree/master/packages/html)。\r\n\r\n### 而注入的原理为当打包器已生成 entryPoint 文件资源后，获得其文件名及 `publicPath`，并将其注入到 html 中。\r\n\r\n以 `html-webpack-plugin` 为例，它在 `compilation` 处理资源的 `processAssets` 获得其打包生成的资源。\r\n最小实现如下，可在 [mini-node:html-webpack-plugin (opens new window)](https://github.com/shfshanyue/mini-code/tree/master/code/html-webpack-plugin)获得源码并运行示例。\r\n\r\n```javascript\r\nclass HtmlWebpackPlugin {\r\n  constructor(options) {\r\n    this.options = options || {};\r\n  }\r\n\r\n  apply(compiler) {\r\n    const webpack = compiler.webpack;\r\n\r\n    compiler.hooks.thisCompilation.tap(\"HtmlWebpackPlugin\", (compilation) => {\r\n      // compilation 是 webpack 中最重要的对象，文档见 [compilation-object](https://webpack.js.org/api/compilation-object/#compilation-object-methods)\r\n\r\n      compilation.hooks.processAssets.tapAsync(\r\n        {\r\n          name: \"HtmlWebpackPlugin\",\r\n\r\n          // processAssets 处理资源的时机，此阶段为资源已优化后，更多阶段见文档\r\n          // https://webpack.js.org/api/compilation-hooks/#list-of-asset-processing-stages\r\n          stage: webpack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE,\r\n        },\r\n        (compilationAssets, callback) => {\r\n          // compilationAssets 将得到所有生成的资源，如各个 chunk.js、各个 image、css\r\n\r\n          // 获取 webpac.output.publicPath 选项，(PS: publicPath 选项有可能是通过函数设置)\r\n          const publicPath = getPublicPath(compilation);\r\n\r\n          // 本示例仅仅考虑单个 entryPoint 的情况\r\n          // compilation.entrypoints 可获取入口文件信息\r\n          const entryNames = Array.from(compilation.entrypoints.keys());\r\n\r\n          // entryPoint.getFiles() 将获取到该入口的所有资源，并能够保证加载顺序！！！如 runtime-chunk -> main-chunk\r\n          const assets = entryNames\r\n            .map((entryName) =>\r\n              compilation.entrypoints.get(entryName).getFiles()\r\n            )\r\n            .flat();\r\n          const scripts = assets.map((src) => publicPath + src);\r\n          const content = html({\r\n            title: this.options.title || \"Demo\",\r\n            scripts,\r\n          });\r\n\r\n          // emitAsset 用以生成资源文件，也是最重要的一步\r\n          compilation.emitAsset(\r\n            \"index.html\",\r\n            new webpack.sources.RawSource(content)\r\n          );\r\n          callback();\r\n        }\r\n      );\r\n    });\r\n  }\r\n}\r\n```\r\n"}]},{"number":110,"title":"【Q110】webpack 中什么是 HMR，原理是什么","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/110","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"`HMR`，Hot Module Replacement，热模块替换，见名思意，即无需刷新在内存环境中即可替换掉过旧模块。\r\n与 Live Reload 相对应。\r\n\r\n> Live Reload，当代码进行更新后，在浏览器自动刷新以获取最新前端代码。\r\n\r\n在 webpack 的运行时中 `__webpack__modules__` 用以维护所有的模块。\r\n\r\n而热模块替换的原理，即通过 `chunk` 的方式加载最新的 `modules`，找到 `__webpack__modules__` 中对应的模块逐一替换，并删除其上下缓存。\r\n\r\n其精简数据结构用以下代码表示：\r\n```javascript\r\n// webpack 运行时代码\r\nconst __webpack_modules = [\r\n  (module, exports, __webpack_require__) => {\r\n    __webpack_require__(0);\r\n  },\r\n  () => {\r\n    console.log(\"这是一号模块\");\r\n  },\r\n];\r\n\r\n// HMR Chunk 代码\r\n// JSONP 异步加载的所需要更新的 modules，并在 __webpack_modules__ 中进行替换\r\nself[\"webpackHotUpdate\"](0, {\r\n  1: () => {\r\n    console.log(\"这是最新的一号模块\");\r\n  },\r\n});\r\n```\r\n\r\n其下为更具体更完整的流程，每一步都涉及众多，有兴趣的可阅读 `webpack-dev-server` 及开发环境 webpack 运行时的源码。\r\n\r\n- `webpack-dev-server` 将打包输出 bundle 使用内存型文件系统控制，而非真实的文件系统。\r\n此时使用的是 [memfs (opens new window)](https://github.com/streamich/memfs)模拟 node.js fs API\r\n- 每当文件发生变更时，webpack 将会重新编译，`webpack-dev-server` 将会监控到此时文件变更事件，并找到其对应的 module。\r\n此时使用的是 [chokidar (opens new window)](https://github.com/paulmillr/chokidar)监控文件变更。\r\n- `webpack-dev-server` 将会把变更模块通知到浏览器端，此时使用 websocket 与浏览器进行交流。\r\n此时使用的是 [ws(opens new window)](https://github.com/websockets/ws)。\r\n- 浏览器根据 websocket 接收到 hash，并通过 hash 以 JSONP 的方式请求更新模块的 chunk。\r\n- 浏览器加载 chunk，并使用新的模块对旧模块进行热替换，并删除其缓存。"}]},{"number":111,"title":"【Q111】如何提升 webpack 构建资源的速度","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/111","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"使用 [speed-measure-webpack-plugin (opens new window)](https://github.com/stephencookdev/speed-measure-webpack-plugin)可评估每个 `loader/plugin` 的执行耗时。\r\n\r\n## 1. 更快的 loader：swc\r\n在 webpack 中耗时最久的当属负责 AST 转换的 loader。\r\n\r\n当 loader 进行编译时的 AST 操作均为 CPU 密集型任务，使用 Javascript 性能低下，此时可采用高性能语言 rust 编写的 `swc`。\r\n\r\n比如 Javascript 转化由 babel 转化为更快的 [swc (opens new window)](https://swc.rs/)。\r\n```javascript\r\nmodule: {\r\n  rules: [\r\n    {\r\n      test: /\\.m?js$/,\r\n      exclude: /(node_modules)/,\r\n      use: {\r\n        loader: \"swc-loader\",\r\n      },\r\n    },\r\n  ];\r\n}\r\n```\r\n\r\n## 2. 持久化缓存：cache\r\nwebpack5 内置了关于缓存的插件，可通过 [cache 字段 (opens new window)](https://webpack.js.org/configuration/cache/)配置开启。\r\n\r\n它将 `Module`、`Chunk`、`ModuleChunk` 等信息序列化到磁盘中，二次构建避免重复编译计算，编译速度得到很大提升。\r\n```javascript\r\n{\r\n  cache: {\r\n    type: \"filesystem\";\r\n  }\r\n}\r\n```\r\n\r\n如对一个 JS 文件配置了 `eslint`、`typescript`、`babel` 等 loader，他将有可能执行五次编译，被五次解析为 AST：\r\n\r\n| 包名 | 作用 | 解析为什么AST |\r\n| -- | -- | -- |\r\n| acorn | 依赖分析 | acorn |\r\n| eslint-parser | 支持lint | espree |\r\n| typescript | 支持ts | ts |\r\n| babel | 转化为低版本 | @babel/parser |\r\n| terser | 压缩混淆 | acorn |\r\n\r\n而当开启了持久化缓存功能，最耗时的 AST 解析将能够从磁盘的缓存中获取，再次编译时无需再次进行解析 AST。\r\n\r\n### 得益于持久化缓存，二次编译甚至可得到与 Unbundle 的 vite 等相近的开发体验。\r\n\r\n在 webpack4 中，可使用 [cache-loader (opens new window)](https://github.com/webpack-contrib/cache-loader)仅仅对 loader 进行缓存。\r\n> 注意该 loader 目前已是 `@deprecated` 状态。\r\n```javascript\r\nmodule.exports = {\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.ext$/,\r\n        use: [\"cache-loader\", ...loaders],\r\n        include: path.resolve(\"src\"),\r\n      },\r\n    ],\r\n  },\r\n};\r\n```\r\n\r\n## 3. 多进程：thread-loader\r\n[thread-loader (opens new window)](https://github.com/webpack-contrib/thread-loader)为官方推荐的开启多进程的 loader，可对 babel 解析 AST 时开启多线程处理，提升编译的性能。\r\n```javascript\r\nmodule.exports = {\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.js$/,\r\n        use: [\r\n          {\r\n            loader: \"thread-loader\",\r\n            options: {\r\n              workers: 8,\r\n            },\r\n          },\r\n          \"babel-loader\",\r\n        ],\r\n      },\r\n    ],\r\n  },\r\n};\r\n```\r\n\r\n在 webpack4 中，可使用 [happypack plugin (opens new window)](https://github.com/amireh/happypack)，但需要注意的是 `happypack` 已经久不维护了。"}]},{"number":112,"title":"【Q112】如何分析前端打包体积","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/112","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"在 webpack 中，可以使用 [webpack-bundle-analyzer (opens new window)](https://github.com/webpack-contrib/webpack-bundle-analyzer)分析打包后体积分析。\r\n\r\n其原理是根据 webpack 打包后的 [Stats (opens new window)](https://webpack.js.org/api/stats/#root)数据进行分析，在 webpack compiler 的 [done hook (opens new window)](https://webpack.js.org/api/compiler-hooks/#done)进行处理，见[源码](https://github.com/webpack-contrib/webpack-bundle-analyzer/blob/master/src/BundleAnalyzerPlugin.js#L75)\r\n```javascript\r\ncompiler.hooks.done.tapAsync(\"webpack-bundle-analyzer\", (stats) => {});\r\n```\r\n\r\n在默认配置下，[webpack-bundle-analyzer (opens new window)](https://github.com/webpack-contrib/webpack-bundle-analyzer)将会启动服务打开一个各个 chunk 下各个 module 占用体积的可视化图。\r\n\r\n![Alt](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/538692bbcc8d485b893ebeac02cc90a5~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n**你可以通过它，找到在在打包中占用体积最大的模块，并进行优化。**\r\n\r\n在查看页面中，有三个体积选项：\r\n\r\n- **stat**：每个模块的原始体积\r\n- **parsed**：每个模块经 webpack 打包处理之后的体积，比如 terser 等做了压缩，便会体现在上边\r\n- **gzip**：经 gzip 压缩后的体积\r\n\r\n## 1. ANALYZE 环境变量\r\n在实际项目中，往往通过环境变量 ANALYZE 配置该插件，代码如下，可见[bundle-analyze/build.js (opens new window)](https://github.com/shfshanyue/node-examples/blob/master/engineering/webpack/bundle-analyzer/build.js)。\r\n```javascript\r\nconst webpack = require(\"webpack\");\r\nconst BundleAnalyzerPlugin =\r\n  require(\"webpack-bundle-analyzer\").BundleAnalyzerPlugin;\r\n\r\n// 1. BundleAnalyzerPlugin 是如何工作的？\r\n// 2. Stat、Parsed、Gziped 分别是何意义？\r\n// 3. terserplugin 对此结果有影响吗？\r\n\r\nfunction f1() {\r\n  return webpack({\r\n    entry: \"./index.js\",\r\n    mode: \"none\",\r\n    plugins: [process.env.ANALYZE && new BundleAnalyzerPlugin()],\r\n  });\r\n}\r\n\r\nf1().run((err, stat) => {});\r\n```\r\n\r\n在打包时，通过制定环境变量即可分析打包体积\r\n```javascript\r\nANALYZE=true npm run build\r\n```"}]},{"number":113,"title":"【Q113】js 代码压缩 minify 的原理是什么","labels":["工程化"],"body":"我们知道 javascript 代码经压缩 (uglify) 后，可以使体积变得更小，那它代码压缩的原理是什么。\r\n\r\n如果你来做这么一个功能的话，你会怎么去压缩一段 js 代码的体积","url":"https://github.com/kangyana/daily-question/issues/113","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"通过 AST 分析，根据选项配置一些策略，来生成一颗更小体积的 AST 并生成代码。\r\n\r\n目前前端工程化中使用 [terser (opens new window)](https://terser.org/docs/api-reference#compress-options)和 [swc (opens new window)](https://swc.rs/docs/configuration/minification)进行 JS 代码压缩，他们拥有相同的 API。\r\n\r\n常见用以压缩 AST 的几种方案如下：\r\n\r\n## 1. 去除多余字符：空格，换行及注释\r\n```javascript\r\n// 对两个数求和\r\nfunction sum (a, b) {\r\n  return a + b;\r\n}\r\n```\r\n\r\n此时文件大小是 `62 Byte`， 一般来说中文会占用更大的空间。\r\n\r\n多余的空白字符会占用大量的体积，如空格，换行符，另外注释也会占用文件体积。当我们把所有的空白符合注释都去掉之后，代码体积会得到减少。\r\n\r\n去掉多余字符之后，文件大小已经变为 `30 Byte`。 压缩后代码如下：\r\n```javascript\r\nfunction sum(a,b){return a+b}\r\n```\r\n\r\n替换掉多余字符后会有什么问题产生呢？\r\n\r\n**有，比如多行代码压缩到一行时要注意行尾分号。**\r\n\r\n## 2. 压缩变量名：变量名，函数名及属性名\r\n```javascript\r\nfunction sum (first, second) {\r\n  return first + second;  \r\n}\r\n```\r\n\r\n如以上 `first` 与 `second` 在函数的作用域中，在作用域外不会引用它，此时可以让它们的变量名称更短。\r\n但是如果这是一个 `module` 中，`sum` 这个函数也不会被导出呢？那可以把这个函数名也缩短。\r\n```javascript\r\n// 压缩: 缩短变量名\r\nfunction sum (x, y) {\r\n  return x + y;  \r\n}\r\n\r\n// 再压缩: 去除空余字符\r\nfunction s(x,y){return x+y}\r\n```\r\n\r\n在这个示例中，当完成代码压缩 (compress) 时，代码的混淆 (mangle) 也捎带完成。 \r\n**但此时缩短变量的命名也需要 AST 支持，不至于在作用域中造成命名冲突。**\r\n\r\n## 3. 解析程序逻辑：合并声明以及布尔值简化\r\n通过分析代码逻辑，可对代码改写为更精简的形式。\r\n\r\n合并声明的示例如下：\r\n```javascript\r\n// 压缩前\r\nconst a = 3;\r\nconst b = 4;\r\n\r\n// 压缩后\r\nconst a = 3, b = 4;\r\n```\r\n\r\n布尔值简化的示例如下：\r\n```javascript\r\n// 压缩前\r\n!b && !c && !d && !e\r\n\r\n// 压缩后\r\n!(b||c||d||e)\r\n```\r\n\r\n## 4. 解析程序逻辑：编译预计算\r\n在编译期进行计算，减少运行时的计算量，如下示例：\r\n```javascript\r\n// 压缩前\r\nconst ONE_YEAR = 365 * 24 * 60 * 60\r\n\r\n// 压缩后\r\nconst ONE_YAAR = 31536000\r\n```\r\n\r\n以及一个更复杂的例子，简直是杀手锏级别的优化。\r\n```javascript\r\n// 压缩前\r\nfunction hello () {\r\n  console.log('hello, world')\r\n}\r\n\r\nhello()\r\n\r\n// 压缩后\r\nconsole.log('hello, world')\r\n```"}]},{"number":114,"title":"【Q114】Tree Shaking 的原理是什么","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/114","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"`Tree Shaking` 指基于 ES Module 进行静态分析，通过 AST 将用不到的函数进行移除，从而减小打包体积。\r\n\r\n有例为证：\r\n\r\n```javascript\r\n/* TREE-SHAKING */\r\nimport { sum } from \"./maths.js\";\r\n\r\nconsole.log(sum(5, 5)); // 10\r\n```\r\n\r\n**maths.js**\r\n```javascript\r\nexport function sum(x, y) {\r\n  return x + y;\r\n}\r\n\r\n// 由于 sub 函数没有引用到，最终将不会对它进行打包\r\nexport function sub(x, y) {\r\n  return x - y;\r\n}\r\n```\r\n\r\n最终打包过程中，`sub` 没有被引用到，将不会对它进行打包。以下为打包后代码：\r\n\r\n```javascript\r\n// maths.js\r\n\r\nfunction sum(x, y) {\r\n  return x + y;\r\n}\r\n\r\n/* TREE-SHAKING */\r\n\r\nconsole.log(sum(5, 5));\r\n```\r\n\r\n## 1. import *\r\n当使用语法 `import *` 时，Tree Shaking 依然生效。\r\n```javascript\r\nimport * as maths from \"./maths\";\r\n\r\n// Tree Shaking 依然生效\r\nmaths.sum(3, 4);\r\nmaths[\"sum\"](3, 4);\r\n```\r\n\r\n`import * as maths`，其中 `maths` 的数据结构是固定的，无复杂数据，通过 AST 分析可查知其引用关系。\r\n```javascript\r\nconst maths = {\r\n  sum() {},\r\n  sub() {},\r\n};\r\n```\r\n\r\n## 2. JSON TreeShaking\r\nTree Shaking 甚至可对 JSON 进行优化。\r\n原理是因为 JSON 格式简单，通过 AST 容易预测结果，不像 JS 对象有复杂的类型与副作用。\r\n**main.json**\r\n```javascript\r\n{\r\n  \"a\": 3,\r\n  \"b\": 4\r\n}\r\n```\r\n\r\n```javascript\r\nimport obj from \"./main.json\";\r\n\r\n// obj.b 由于未使用到，仍旧不会被打包\r\nconsole.log(obj.a);\r\n```\r\n\r\n## 3. 引入支持 Tree Shaking 的 Package\r\n为了减小生产环境体积，我们可以**使用一些支持 ES 的 package，比如使用 `lodash-es` 替代 `lodash`**。\r\n\r\n我们可以在 [npm.devtool.tech (opens new window)](https://npm.devtool.tech/lodash-es)中查看某个库是否支持 Tree Shaking。\r\n\r\n![Alt](https://cdn.jsdelivr.net/gh/shfshanyue/assets@master/src/lodash-es.60xosee62440.png)"}]},{"number":115,"title":"【Q115】core-js 是做什么用的？","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/115","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"[core-js (opens new window)](https://github.com/zloirock/core-js)是关于 ES 标准最出名的 polyfill，polyfill 意指当浏览器不支持某一最新 API 时，它将帮你实现，中文叫做垫片。\r\n你也许每天都与它打交道，但你毫不知情。\r\n\r\n由于垫片的存在，打包后体积便会增加，所需支持的浏览器版本 ​ 越高，垫片越少，体积就会越小。\r\n\r\n以下代码便是 `Array.from(ES6)` 的垫片代码，有了它的存在，在任意浏览器中都可以使用 `Array.from` 这个 API：\r\n```javascript\r\n// Production steps of ECMA-262, Edition 6, 22.1.2.1\r\nif (!Array.from) {\r\n  Array.from = () => { // 省略若干代码 }\r\n}\r\n```\r\n\r\n而 `core-js` 的伟大之处是它包含了所有 ES6+ 的 polyfill，并集成在 babel 等编译工具之中。\r\n\r\n## 1. 试举一例\r\n你在开发环境使用了 [Promise.any (opens new window)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/any)，而它属于 ES2021 新出的 API，在部分浏览器里尚未实现，同时，你又使用了 ES2020 新出的操作符 `?.`。\r\n\r\n为了使代码能够在大部分浏览器里能够实现，你将会使用 `babel` 或者 `swc` 将代码编译为 ES5。\r\n\r\n**但是此时你会发现问题，如果不做任何配置，babel/swc 只能处理操作符，而无法处理新的 API。以下代码会报错**\r\n\r\n![Alt](https://cdn.jsdelivr.net/gh/shfshanyue/assets@master/src/babel.j056lzjd1g0.png)\r\n\r\n好消息是，`core-js` 已集成到了 `babel/swc` 之中，你可以使用 `@babel/preset-env` 或者 `@babel/polyfill` 进行配置，详见文档 [core-js (opens new window)](https://github.com/zloirock/core-js)。\r\n通过配置，`babel` 编译代码后将会自动包含所需的 polyfill，如下所示。\r\n\r\n![Alt](https://raw.githubusercontent.com/shfshanyue/assets/master/src/babel-preset.4rbb4gbe77o0.png)"}]},{"number":116,"title":"【Q116】browserslist 是做什么的？","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/116","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"[browserslist (opens new window)](https://github.com/browserslist/browserslist)用特定的语句来查询浏览器列表，如 `last 2 Chrome versions`。\r\n```bash\r\n$ npx browserslist \"last 2 Chrome versions\"\r\nchrome 100\r\nchrome 99\r\n```\r\n\r\n它是现代前端工程化不可或缺的工具，无论是处理 JS 的 `babel`，还是处理 CSS 的 `postcss`，凡是与垫片相关的，他们背后都有 `browserslist` 的身影。\r\n\r\n- `babel`，在 `@babel/preset-env` 中使用 `core-js` 作为垫片\r\n- `postcss` 使用 `autoprefixer `作为垫片\r\n\r\n关于前端打包体积与垫片关系，我们有以下几点共识：\r\n\r\n- 由于低浏览器版本的存在，垫片是必不可少的\r\n- 垫片越少，则打包体积越小\r\n- 浏览器版本越新，则垫片越少\r\n\r\n那在前端工程化实践中，当我们确认了浏览器版本号，那么它的垫片体积就会确认。\r\n\r\n假设项目只需要支持最新的两个谷歌浏览器。那么关于 browserslist 的查询，可以写作 `last 2 Chrome versions`。\r\n\r\n而随着时间的推移，该查询语句将会返回更新的浏览器，垫片体积便会减小。\r\n\r\n如使用以上查询语句，一年前可能还需要 `Promise.any` 的垫片，但目前肯定不需要了。\r\n\r\n## 1. 原理\r\n最终，谈一下 browserslist 的原理：\r\nbrowserslist 根据正则解析查询语句，对浏览器版本数据库 `caniuse-lite` 进行查询，返回所得的浏览器版本列表。\r\n\r\n> PS: caniuse-lite 这个库也由 browserslist 团队进行维护，它是基于 [caniuse (opens new window)](https://caniuse.com/)的数据库进行的数据整合。\r\n\r\n因为 browserslist 并不维护数据库，因此它会经常提醒你去更新 `caniuse-lite` 这个库，由于 lock 文件的存在，因此需要使用以下命令手动更新数据库。\r\n```bash\r\n$ npx browserslist@latest --update-db\r\n```\r\n\r\n该命令将会对 `caniuse-lite` 进行升级，可体现在 lock 文件中。\r\n```javascript\r\n     \"caniuse-lite\": {\r\n-      \"version\": \"1.0.30001265\",\r\n-      \"resolved\": \"https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001265.tgz\",\r\n-      \"integrity\": \"sha512-YzBnspggWV5hep1m9Z6sZVLOt7vrju8xWooFAgN6BA5qvy98qPAPb7vNUzypFaoh2pb3vlfzbDO8tB57UPGbtw==\",\r\n+      \"version\": \"1.0.30001332\",\r\n+      \"resolved\": \"https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001332.tgz\",\r\n+      \"integrity\": \"sha512-10T30NYOEQtN6C11YGg411yebhvpnC6Z102+B95eAsN0oB6KUs01ivE8u+G6FMIRtIrVlYXhL+LUwQ3/hXwDWw==\",\r\n       \"dev\": true\r\n     },\r\n```\r\n\r\n## 2. 常用的查询语法\r\n### 根据用户份额\r\n\r\n- `> 5%`：在全球用户份额大于 5% 的浏览器\r\n- `> 5% in CN`：在中国用户份额大于 5% 的浏览器\r\n\r\n### 根据最新浏览器版本\r\n- `last 2 versions`：所有浏览器的最新两个版本\r\n- `last 2 Chrome versions`：Chrome 浏览器的最新两个版本\r\n\r\n### 不再维护的浏览器\r\n- `dead`：官方不在维护已过两年，比如 IE10\r\n\r\n### 浏览器版本号\r\n- `Chrome > 90`：Chrome 大于 90 版本号的浏览器\r\n- `not ie <= 10`：IE 不小于等于 10 版本号的浏览器"}]},{"number":117,"title":"【Q117】浏览器中如何使用原生的 ESM","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/117","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. import from URL\r\n通过 `script[type=module]`，可直接在浏览器中使用原生 ESM。\r\n这也使得前端不打包 (Bundless) 成为可能。\r\n```html\r\n<script type=\"module\">\r\n  import lodash from \"https://cdn.skypack.dev/lodash\";\r\n</script>\r\n```\r\n\r\n由于前端跑在浏览器中，因此它也只能从 URL 中引入 Package\r\n\r\n- **绝对路径**：`https://cdn.sykpack.dev/lodash`\r\n- **相对路径**：`./lib.js`\r\n\r\n现在打开浏览器控制台，把以下代码粘贴在控制台中。\r\n由于 http `import` 的引入，你发现你调试 `lodash` 此列工具库更加方便了。\r\n```javascript\r\nvar lodash = await import('https://cdn.skypack.dev/lodash')\r\n\r\nlodash.get({ a: 3 }, 'a')\r\n```\r\n\r\n![Alt](https://raw.githubusercontent.com/shfshanyue/assets/master/2021-11-22/clipboard-2865.638ba7.webp)\r\n\r\n## 2. importMap\r\n但 http `import` 每次都需要输入完全的 URL，相对以前的裸导入 (bare import specifiers)，很不太方便，如下例：\r\n```javascript\r\nimport lodash from \"lodash\";\r\n```\r\n\r\n它不同于 Node.JS 可以依赖系统文件系统，层层寻找 node_modules\r\n```bash\r\n/home/app/packages/project-a/node_modules/lodash/index.js\r\n/home/app/packages/node_modules/lodash/index.js\r\n/home/app/node_modules/lodash/index.js\r\n/home/node_modules/lodash/index.js\r\n```\r\n\r\n在 ESM 中，可通过 `importmap` 使得裸导入可正常工作：\r\n```html\r\n<script type=\"importmap\">\r\n  {\r\n    \"imports\": {\r\n      \"lodash\": \"https://cdn.skypack.dev/lodash\",\r\n      \"ms\": \"https://cdn.skypack.dev/ms\"\r\n    }\r\n  }\r\n</script>\r\n```\r\n\r\n此时可与以前同样的方式进行模块导入\r\n```javascript\r\nimport lodash from 'lodash'\r\n\r\nimport(\"lodash\").then(_ => ...)\r\n```\r\n\r\n那么通过裸导入如何导入子路径呢？\r\n```javascript\r\n<script type=\"importmap\">\r\n  {\r\n    \"imports\": {\r\n      \"lodash\": \"https://cdn.skypack.dev/lodash\",\r\n      \"lodash/\": \"https://cdn.skypack.dev/lodash/\"\r\n    }\r\n  }\r\n</script>\r\n<script type=\"module\">\r\n  import get from \"lodash/get.js\";\r\n</script>\r\n```\r\n\r\n## 3. import Assertion\r\n通过 `script[type=module]`，不仅可引入 Javascript 资源，甚至可以引入 JSON/CSS，示例如下\r\n```html\r\n<script type=\"module\">\r\n  import data from \"./data.json\" assert { type: \"json\" };\r\n\r\n  console.log(data);\r\n</script>\r\n```"}]},{"number":118,"title":"【Q118】如何将 CommonJS 转化为 ESM","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/118","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"由于 Bundless 构建工具的兴起，要求所有的模块都是 ESM 模块化格式。\r\n\r\n目前社区有一部分模块同时支持 ESM 与 CommonJS，但仍有许多模块仅支持 CommonJS/UMD，因此将 CommonJS 转化为 ESM 是全部模块 ESM 化的过渡阶段。\r\n\r\n## 1. ESM 与 CommonJS 的导入导出的不同\r\n在 ESM 中，导入导出有两种方式:\r\n\r\n- 具名导出/导入：Named Import/Export\r\n- 默认导出/导入：Default Import/Export\r\n\r\n代码示例如下：\r\n```javascript\r\n// Named export/import\r\nexport { sum };\r\nimport { sum } from \"sum\";\r\n\r\n// Default export/import\r\nexport default sum;\r\nimport sum from \"sum\";\r\n```\r\n\r\n而在 CommonJS 中，导入导出的方法只有一种：\r\n```javascript\r\n// 实际上的 exports\r\nexports = module.exports;\r\n\r\n// 以下两个是等价的\r\nexports.a = 3;\r\nmodule.exports.a = 3;\r\n```\r\n\r\n正因为有二者的不同，因此在二者转换的时候有一些兼容问题需要解决。\r\n\r\n## 2. exports 的转化\r\n正因为，二者有所不同，当 exports 转化时，既要转化为 `export {}`，又要转化为 `export default {}`\r\n```javascript\r\n// Input:  index.cjs\r\nexports.a = 3;\r\n\r\n// Output: index.mjs\r\n// 此处既要转化为默认导出，又要转化为具名导出！\r\nexport const a = 3;\r\nexport default { a };\r\n```\r\n\r\n如果仅仅转为 `export const a = 3` 的具名导出，而不转换 `export default { a }`，将会出现什么问题？以下为例：\r\n```javascript\r\n// Input: CJS\r\nexports.a = 3; // index.cjs\r\n\r\nconst o = require(\".\"); // foo.cjs\r\nconsole.log(o.a); // foo.cjs\r\n\r\n// Output: ESM\r\n// 这是有问题的错误转换示例:\r\n// 此处 a 应该再 export default { a } 一次\r\nexport const a = 3; // index.mjs\r\n\r\nimport o from \".\"; // foo.mjs\r\nconsole.log(o.a); // foo.mjs 这里有问题，这里有问题，这里有问题\r\n```\r\n\r\n## 3. module.exports 的转化\r\n对于 `module.exports`，我们可以遍历其中的 key (通过 AST)，将 key 转化为 `Named Export`，将 `module.exports` 转化为 `Default Export`\r\n```javascript\r\n// Input:  index.cjs\r\nmodule.exports = {\r\n  a: 3,\r\n  b: 4,\r\n};\r\n\r\n// Output: index.mjs\r\n// 此处既要转化为默认导出，又要转化为具名导出！\r\nexport default {\r\n  a: 3,\r\n  b: 4,\r\n};\r\nexport const a = 3;\r\nexport const b = 4;\r\n```\r\n\r\n如果 `module.exports` 导出的是函数如何处理呢，特别是 `exports` 与 `module.exports` 的程序逻辑混合在一起？\r\n以下是一个正确的转换结果：\r\n```javascript\r\n// Input: index.cjs\r\nmodule.exports = () => {}\r\nexports.a = 3\r\nexports.b = 4\r\n\r\n// Output: index.mjs\r\nconst sum = () => {}\r\nsum.a = 3\r\nsum.b = 4\r\nexport const a = 3\r\nexport const b = 4\r\nexport default = sum\r\n```\r\n\r\n也可以这么处理，将 `module.exports` 与 `exports` 的代码使用函数包裹起来，此时我们无需关心其中的逻辑细节。\r\n```javascript\r\nvar esm$1 = { exports: {} };\r\n\r\n(function (module, exports) {\r\n  module.exports = () => {};\r\n  exports.a = 3;\r\n  exports.b = 4;\r\n})(esm$1, esm$1.exports);\r\n\r\nvar esm = esm$1.exports;\r\n\r\nexport { esm as default };\r\n```\r\n\r\n## 4. 一些复杂的转化\r\nESM 与 CommonJS 不仅仅是简单的语法上的不同，它们在思维方式上就完全不同，因此还有一些较为复杂的转换。\r\n\r\n- 如何处理 `__dirname`\r\n- 如何处理 `require(dynamicString)`\r\n- 如何处理 CommonJS 中的编程逻辑，如下\r\n\r\n以下代码涉及到编程逻辑，由于 `exports` 是一个动态的 Javascript 对象，而它自然可以使用两次，那应该如何正确编译为 ESM 呢？\r\n```javascript\r\n// input: index.cjs\r\nexports.sum = 0;\r\nPromise.resolve().then(() => {\r\n  exports.sum = 100;\r\n});\r\n```\r\n\r\n以下是一种不会出问题的代码转换结果：\r\n```javascript\r\n// output: index.mjs\r\nconst _default = {};\r\nlet sum = (_default.sum = 0);\r\nPromise.resolve().then(() => {\r\n  sum CommonJS 向 ESM 转化，自然有构建工具的参与，比如= _default.sum = 100;\r\n});\r\nexport default _default;\r\nexport { sum };\r\n```\r\n\r\n## 5. CommonJS 向 ESM 的构建工具\r\n- [@rollup/plugin-commonjs](https://github.com/rollup/plugins/tree/master/packages/commonjs)\r\n甚至把一些 CommonJS 库转化为 ESM，并且置于 CDN 中，使得我们可以直接使用，而无需构建工具参与。\r\n- [https://cdn.skypack.dev/(opens new window)](https://cdn.skypack.dev/)\r\n- https://jspm.org/"}]},{"number":119,"title":"【Q119】简述 bundless 的优势与不足","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/119","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. Bundleless 的优势：\r\n\r\n- 项目启动快。因为不需要过多的打包，只需要处理修改后的单个文件，所以响应速度是 O(1) 级别，刷新即可即时生效，速度很快。\r\n- 浏览器加载块。利用浏览器自主加载的特性，跳过打包的过程。\r\n- 本地文件更新，重新请求单个文件。\r\n\r\n![Alt](https://camo.githubusercontent.com/4cee203f26f59056cdc973195b65b0ed4e65ea3f603b580352e1447105acc057/687474703a2f2f6f73732e7469616e6d6173706f72742e636f6d2f67782f73697a652f323032322d30332d31312f3139362f3935313830333232353333363434363937362e706e67)"}]},{"number":120,"title":"【Q120】什么是 semver，~1.2.3 与 ^1.2.3 的版本号范围是多少","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/120","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"`semver`，`Semantic Versioning` 语义化版本的缩写，文档可见 [https://semver.org/ (opens new window)](https://semver.org/)，它由 `[major, minor, patch]` 三部分组成，其中\r\n\r\n- `major`：当你发了一个含有 Breaking Change 的 API\r\n- `minor`：当你新增了一个向后兼容的功能时\r\n- `patch`：当你修复了一个向后兼容的 Bug 时\r\n\r\n假设你的版本库中含有一个函数\r\n```javascript\r\n// 假设原函数\r\nexport const sum = (x: number, y: number): number => x + y;\r\n\r\n// Patch Version，修复小 Bug\r\nexport const sum = (x: number, y: number): number => x + y;\r\n\r\n// Minor Version，向后兼容\r\nexport const sum = (...rest: number[]): number =>\r\n  rest.reduce((s, x) => s + x, 0);\r\n\r\n// Marjor Version，出现 Breaking Change\r\nexport const sub = () => {};\r\n```\r\n\r\n对于 `~1.2.3` 而言，它的版本号范围是 `>=1.2.3 <1.3.0`\r\n\r\n对于 `^1.2.3` 而言，它的版本号范围是 `>=1.2.3 <2.0.0`\r\n\r\n当我们 `npm i` 时，默认的版本号是 `^`，可最大限度地在向后兼容与新特性之间做取舍，但是有些库有可能不遵循该规则，我们在项目时应当使用 `yarn.lock/package-lock.json` 锁定版本号。\r\n\r\n我们看看 `package-lock` 的工作流程。\r\n\r\n- `npm i webpack`，此时下载最新 webpack 版本 `5.58.2`，在 `package.json` 中显示为 `webpack: ^5.58.2`，版本号范围是 `>=5.58.2 < 6.0.0`\r\n- 在 `package-lock.json` 中全局搜索 webpack，发现 webpack 的版本是被锁定的，也是说它是确定的 `webpack: 5.58.2`\r\n- 经过一个月后，webpack 最新版本为 `5.100.0`，但由于 webpack 版本在 `package-lock.json` 中锁死，每次上线时仍然下载 `5.58.2` 版本号\r\n- 经过一年后，webpack 最新版本为 `6.0.0`，但由于 webpack 版本在 `package-lock.json` 中锁死，且 `package.json` 中 webpack 版本号为 `^5.58.2`，与 `package-lock.json` 中为一致的版本范围。每次上线时仍然下载 `5.58.2` 版本号\r\n- 支线剧情：经过一年后，webpack 最新版本为 `6.0.0`，需要进行升级，此时手动改写 `package.json` 中 webpack 版本号为 `^6.0.0`，与 `package-lock.json` 中不是一致的版本范围。\r\n此时 `npm i` 将下载 `6.0.0` 最新版本号，并重写 `package-lock.json` 中锁定的版本号为 `6.0.0`\r\n\r\n## 经典八股文\r\n`npm i` 某个 package 时会修改 `package-lock.json` 中的版本号吗？\r\n\r\n当 `package-lock.json` 该 package 锁死的版本号符合 `package.json `中的版本号范围时，将以 `package-lock.json` 锁死版本号为主。\r\n\r\n当 `package-lock.json` 该 package 锁死的版本号不符合 `package.json` 中的版本号范围时，将会安装该 package 符合 `package.json` 版本号范围的最新版本号，并重写 `package-lock.json`"}]},{"number":121,"title":"【Q121】package.json 中 main/module/browser/exports 字段","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/121","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. main\r\n`main` 指 npm package 的入口文件，当我们对某个 package 进行导入时，实际上导入的是 `main` 字段所指向的文件。\r\n\r\n`main` 是 CommonJS 时代的产物，也是最古老且最常用的入口文件。\r\n```javascript\r\n// package.json 内容\r\n{\r\n  name: 'midash',\r\n  main: './dist/index.js'\r\n}\r\n\r\n// 关于如何引用 package\r\nconst midash = require('midash')\r\n\r\n// 实际上是通过 main 字段来找到入口文件，等同于该引用\r\nconst midash = require('midash/dist/index.js')\r\n```\r\n\r\n## 2. module\r\n随着 ESM 且打包工具的发展，许多 package 会打包 N 份模块化格式进行分发，如 `antd` 既支持 ES，也支持 umd，将会打包两份。\r\n\r\n![Alt](https://raw.githubusercontent.com/shfshanyue/assets/master/src/antd.50lzknb7r000.png)\r\n\r\n如果使用 `import` 对该库进行导入，则首次寻找 `module` 字段引入，否则引入 `main` 字段。\r\n\r\n基于此，许多前端友好的库，都进行了以下分发操：\r\n\r\n- 对代码进行两份格式打包：commonjs 与 es module\r\n- `module` 字段作为 es module 入口\r\n- `main` 字段作为 commonjs 入口\r\n\r\n```javascript\r\n{\r\n  name: 'midash',\r\n  main: './dist/index.js',\r\n  module: './dist/index.mjs'\r\n}\r\n\r\n// 以下两者等同\r\nimport midash from 'midash'\r\nimport midash from 'midash/dist/index.mjs'\r\n```\r\n\r\n如果你的代码只分发一份 es module 模块化方案，则直接置于 `main` 字段之中。\r\n\r\n## 3. exports\r\n如果说以上两个是刀剑，那 `exports` 至少得是瑞士军刀。\r\n\r\n`exports` 可以更容易地控制子目录的访问路径，也被称为 export map。\r\n\r\n假设我们 Package 的目录如下所示：\r\n```sh\r\n├── package.json\r\n├── index.js\r\n└── src\r\n    └── get.js\r\n```\r\n\r\n不在 `exports` 字段中的模块，即使直接访问路径，也无法引用！\r\n```javascript\r\n// package.json\r\n{\r\n  name: 'midash',\r\n  main: './index.js',\r\n  exports: {\r\n    '.': './dist/index.js',\r\n    'get': './dist/get.js'\r\n  }\r\n}\r\n\r\n// 正常工作\r\nimport get from 'midash/get'\r\n\r\n// 无法正常工作，无法引入\r\nimport get from 'midash/dist/get'\r\n```\r\n\r\n`exports` 不仅可根据模块化方案不同选择不同的入口文件，还可以根据环境变量(NODE_ENV)、运行环境(nodejs/browser/electron) 导入不同的入口文件。\r\n\r\n```javascript\r\n{\r\n  \"type\": \"module\",\r\n  \"exports\": {\r\n    \"electron\": {\r\n      \"node\": {\r\n        \"development\": {\r\n          \"module\": \"./index-electron-node-with-devtools.js\",\r\n          \"import\": \"./wrapper-electron-node-with-devtools.js\",\r\n          \"require\": \"./index-electron-node-with-devtools.cjs\"\r\n        },\r\n        \"production\": {\r\n          \"module\": \"./index-electron-node-optimized.js\",\r\n          \"import\": \"./wrapper-electron-node-optimized.js\",\r\n          \"require\": \"./index-electron-node-optimized.cjs\"\r\n        },\r\n        \"default\": \"./wrapper-electron-node-process-env.cjs\"\r\n      },\r\n      \"development\": \"./index-electron-with-devtools.js\",\r\n      \"production\": \"./index-electron-optimized.js\",\r\n      \"default\": \"./index-electron-optimized.js\"\r\n    },\r\n    \"node\": {\r\n      \"development\": {\r\n        \"module\": \"./index-node-with-devtools.js\",\r\n        \"import\": \"./wrapper-node-with-devtools.js\",\r\n        \"require\": \"./index-node-with-devtools.cjs\"\r\n      },\r\n      \"production\": {\r\n        \"module\": \"./index-node-optimized.js\",\r\n        \"import\": \"./wrapper-node-optimized.js\",\r\n        \"require\": \"./index-node-optimized.cjs\"\r\n      },\r\n      \"default\": \"./wrapper-node-process-env.cjs\"\r\n    },\r\n    \"development\": \"./index-with-devtools.js\",\r\n    \"production\": \"./index-optimized.js\",\r\n    \"default\": \"./index-optimized.js\"\r\n  }\r\n}\r\n```"}]},{"number":122,"title":"【Q122】dependencies 与 devDependencies 有何区别","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/122","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 对于业务代码而讲，它俩区别不大\r\n当进行业务开发时，严格区分 `dependencies` 与 `devDependencies` 并无必要，实际上，大部分业务对二者也并无严格区别。\r\n\r\n当打包时，依靠的是 Webpack/Rollup 对代码进行模块依赖分析，与该模块是否在 `dep/devDep` 并无关系，只要在 `node_modules` 上能够找到该 Package 即可。\r\n\r\n以至于在 CI 中 `npm i --production` 可加快包安装速度也无必要，因为在 CI 中仍需要 lint、test、build 等。\r\n\r\n## 2. 对于库 (Package) 开发而言，是有严格区分的\r\n\r\n- `dependencies`：在生产环境中使用\r\n- `devDependencies`：在开发环境中使用，如 webpack/babel/eslint 等\r\n\r\n### 当在项目中安装一个依赖的 Package 时，该依赖的 `dependencies` 也会安装到项目中，即被下载到 `node_modules` 目录中。但是 `devDependencies` 不会。\r\n\r\n因此当我们开发 Package 时，需要注意到我们所引用的 `dependencies` 会被我们的使用者一并下载，而 `devDependencies` 不会。\r\n\r\n一些 Package 宣称自己是 **zero dependencies**，一般就是指不依赖任何 `dependencies`，如 [highlight](https://github.com/highlightjs/highlight.js)。"}]},{"number":123,"title":"【Q123】如何为一个项目指定 node 版本号","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/123","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"指定一个项目所需的 node 最小版本，这属于一个项目的质量工程。\r\n\r\n如果对于版本不匹配将会报错(yarn)或警告(npm)，那我们需要在 `package.json` 中的 `engines` 字段中指定 Node 版本号：\r\n```json\r\n{\r\n  \"engines\": {\r\n    \"node\": \">=14.0.0\"\r\n  }\r\n}\r\n```\r\n\r\n### 一个示例：\r\n\r\n我在本地把项目所需要的 node 版本号改成 `>=16.0.0`，而本地的 node 版本号为 `v10.24.1`。\r\n\r\n此时，npm 将会发生警告，提示你本地的 node 版本与此项目不符：\r\n```bash\r\nnpm WARN EBADENGINE Unsupported engine { package: 'next-app@1.0.0',\r\nnpm WARN EBADENGINE   required: { node: '>=16.0.0' },\r\nnpm WARN EBADENGINE   current: { node: 'v10.24.1', npm: '7.14.0' } }\r\n```\r\n\r\n而 yarn 将会直接报错，提示：\r\n```bash\r\nerror next-app@1.0.0: The engine \"node\" is incompatible with this module. Expected version \">=16.0.0\". Got \"10.24.1\"\r\n```\r\n\r\n最为重要的是，项目中某些依赖所需要的 Node 版本号与项目运行时的 Node 版本号不匹配，也会报错(在 yarn 中)，此时无法正常运行项目，可避免意外发生。\r\n\r\n可看一个示例，[engines 示例 (opens new window)](https://github.com/shfshanyue/node-examples/tree/master/engineering/package/engines)，其中 `ansi-regex` 该依赖所需的 node 版本号为 `12+`，而此时本地的 node 版本号为 `10`，使用 yarn 安装报错！\r\n```javascript\r\n// 在 package.json 中，所需 node 版本号需要 >=10\r\n{\r\n  \"engines\": {\r\n    \"node\": \">=10.0.0\"\r\n  }\r\n}\r\n\r\n// 在 package-lock.json 中，所需 node 版本号需要 >=12\r\n{\r\n  \"node_modules/ansi-regex\": {\r\n    \"version\": \"6.0.1\",\r\n    \"engines\": {\r\n      \"node\": \">=12\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n![Alt](https://raw.githubusercontent.com/shfshanyue/assets/master/2021-12-25/clipboard-2084.d06897.webp)\r\n\r\n> PS: 如果项目的 `package.json` 中没有 `engines` 字段，可查看 Dockerfile 中 node 镜像确定项目所需的 node 版本号。"}]},{"number":124,"title":"【Q124】简述 npm script 的生命周期","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/124","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"在 npm 中，使用 `npm scripts` 可以组织整个前端工程的工具链。\r\n```json\r\n{\r\n  \"start\": \"serve ./dist\",\r\n  \"build\": \"webpack\",\r\n  \"lint\": \"eslint\"\r\n}\r\n```\r\n\r\n除了可自定义 `npm script` 外，npm 附带许多内置 scripts，他们无需带 `npm run`，可直接通过 `npm <script>` 执行。\r\n```bash\r\n$ npm install\r\n$ npm test\r\n$ npm publish\r\n```\r\n\r\n我们在实际工作中会遇到以下几个问题：\r\n\r\n- 在某个 npm 库安装结束后，自动执行操作如何处理？\r\n- `npm publish` 发布 npm 库时将发布打包后文件，如果遗漏了打包过程如何处理，如何在发布前自动打包？\r\n\r\n这就要涉及到一个 npm script 的生命周期。\r\n\r\n## 1. npm script 的生命周期\r\n当我们执行任意 `npm run` 脚本时，将自动触发 `pre/post` 的生命周期。\r\n\r\n当手动执行 `npm run abc` 时，将在此之前自动执行 `npm run preabc`，在此之后自动执行 `npm run postabc`。\r\n```bash\r\n// 自动执行\r\nnpm run preabc\r\n\r\nnpm run abc\r\n\r\n// 自动执行\r\nnpm run postabc\r\n```\r\n\r\n[patch-package (opens new window)](https://github.com/ds300/patch-package)一般会放到 `postinstall` 中。\r\n```json\r\n{\r\n  \"postinstall\": \"patch-package\"\r\n}\r\n```\r\n\r\n而发包的生命周期更为复杂，当执行 `npm publish`，将自动执行以下脚本：\r\n\r\n- `prepublishOnly`：最重要的一个生命周期。\r\n- `prepack`\r\n- `prepare`\r\n- `postpack`\r\n- `publish`\r\n- `postpublish`\r\n\r\n当然你无需完全记住所有的生命周期，如果你需要在发包之前自动做一些事情，如测试、构建等，请在 `prepulishOnly` 中完成。\r\n```json\r\n{\r\n  \"prepublishOnly\": \"npm run test && npm run build\"\r\n}\r\n```\r\n\r\n## 2. 最常用的生命周期\r\n### prepare\r\n\r\n- npm install 之后自动执行\r\n- npm publish 之前自动执行\r\n\r\n比如 `husky`：\r\n```json\r\n{\r\n  \"prepare\": \"husky install\"\r\n}\r\n```\r\n\r\n## 3. npm script 钩子的风险\r\n假设某一个第三方库的 `npm postinstall` 为 `rm -rf /`，那岂不是又很大的风险？\r\n```json\r\n{\r\n  \"postinstall\": \"rm -rf /\"\r\n}\r\n```\r\n\r\n实际上，确实有很多 npm package 被攻击后，就是通过 `npm postinstall` 自动执行一些事，比如挖矿等。\r\n\r\n如果 npm 可以限制某些库的某些 hooks 执行，则可以解决这个问题。"}]},{"number":125,"title":"【Q125】如何对 npm package 进行发包","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/125","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 准备工作：一个账号\r\n在发布公共 package 之前，需要在 [npm 官网 (opens new window)](https://www.npmjs.com/)进行注册一个账号。\r\n\r\n随后，在本地(需要发包的地方)执行命令 npm login，进行交互式操作并且登录。\r\n```bash\r\n$ npm login\r\n```\r\n\r\n## 2. 发包\r\n发布一个 npm 包之前，填写 `package.json` 中以下三项最重要的字段。\r\n``` json\r\n{\r\n  \"name\": \"@shanyue/just-demo\",\r\n  \"version\": \"1.0.0\",\r\n  \"main\": \"./index.js\"\r\n}\r\n```\r\n\r\n之后执行 npm publish 发包即可。\r\n```bash\r\n$ npm publish\r\n```\r\n\r\n一旦发布完成，在任意地方通过 npm i 均可依赖该包。\r\n```bash\r\nconst x = require(\"@shanyue/just-demo\");\r\n\r\nconsole.log(x);\r\n```\r\n\r\n如若该包进行更新后，需要再次发包，可 npm version 控制该版本进行升级，记住需要遵守 [Semver 规范](https://github.com/kangyana/daily-question/issues/120)：\r\n```bash\r\n# 增加一个修复版本号: 1.0.1 -> 1.0.2 (自动更改 package.json 中的 version 字段)\r\n$ npm version patch\r\n\r\n# 增加一个小的版本号: 1.0.1 -> 1.1.0 (自动更改 package.json 中的 version 字段)\r\n$ npm version minor\r\n\r\n# 将更新后的包发布到 npm 中\r\n$ npm publish\r\n```\r\n\r\n## 3. 实际发包的内容\r\n在 npm 发包时，实际发包内容为 `package.json` 中 `files` 字段，一般只需将构建后资源(如果需要构建)进行发包，源文件可发可不发。\r\n```json\r\n{\r\n  \"files\": [\"dist\"]\r\n}\r\n```\r\n\r\n若需要查看一个 package 的发包内容，可直接在 `node_modules/${package}` 进行查看，将会发现它和源码有很大不同。\r\n也可以在 CDN 中进行查看，以 React 为例：\r\n\r\n- **jsdelivr**：[https://cdn.jsdelivr.net/npm/react/(opens new window)](https://cdn.jsdelivr.net/npm/react/)\r\n- **unpkg**：https://unpkg.com/browse/react/\r\n\r\n![Alt](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-11-27/clipboard-7248.4f8241.webp)\r\n\r\n## 4. 发包的实际流程\r\n`npm publish` 将自动走过以下生命周期：\r\n\r\n- prepublishOnly：如果发包之前需要构建，可以放在这里执行\r\n- prepack\r\n- prepare：如果发包之前需要构建，可以放在这里执行 (该周期也会在 npm i 后自动执行)\r\n- postpack\r\n- publish\r\n- postpublish\r\n\r\n发包实际上是将本地 package 中的所有资源进行打包，并上传到 npm 的一个过程。你可以通过 `npm pack` 命令查看详情：\r\n```bash\r\n$ npm pack\r\nnpm notice\r\nnpm notice 📦  midash@0.2.6\r\nnpm notice === Tarball Contents ===\r\nnpm notice 1.1kB  LICENSE\r\nnpm notice 812B   README.md\r\nnpm notice 5.7kB  dist/midash.cjs.development.js\r\nnpm notice 13.4kB dist/midash.cjs.development.js.map\r\nnpm notice 3.2kB  dist/midash.cjs.production.min.js\r\nnpm notice 10.5kB dist/midash.cjs.production.min.js.map\r\nnpm notice 5.3kB  dist/midash.esm.js\r\nnpm notice 13.4kB dist/midash.esm.js.map\r\nnpm notice 176B   dist/omit.d.ts\r\n......\r\nnpm notice === Tarball Details ===\r\nnpm notice name:          midash\r\nnpm notice version:       0.2.6\r\nnpm notice filename:      midash-0.2.6.tgz\r\nnpm notice package size:  11.5 kB\r\nnpm notice unpacked size: 67.8 kB\r\nnpm notice shasum:        c89d8c1aa96f78ce8b1dcf8f0f058fa7a6936a6a\r\nnpm notice integrity:     sha512-lyx8khPVkCHvH[...]kBL6K6VqOG6dQ==\r\nnpm notice total files:   46\r\nnpm notice\r\nmidash-0.2.6.tgz\r\n```\r\n\r\n当你发包成功后，也可以前往 [npm devtool (opens new window)](https://npm.devtool.tech/react)查看各项数据。\r\n\r\n![Alt](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-11-27/clipboard-8735.9e7628.webp)"}]},{"number":126,"title":"【Q126】package-lock.json 有什么作用","labels":["工程化"],"body":"如果项目中没有它会怎么样，举例说明","url":"https://github.com/kangyana/daily-question/issues/126","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"`packagelock.json/yarn.lock` 用以锁定版本号，保证开发环境与生产环境的一致性，避免出现不兼容 API 导致生产环境报错。\r\n\r\n在这个问题之前，需要了解下什么是 semver：[什么是 semver (opens new window)](https://github.com/shfshanyue/Daily-Question/issues/534)。\r\n\r\n当我们在 `npm i` 某个依赖时，默认的版本号是最新版本号 `^1.2.3`，以 `^` 开头可最大限度地使用新特性，但是某些库不遵循该依赖可能出现问题。\r\n\r\n> ^1.2.3 指 >=1.2.3 <2.0.0，可查看 [semver checker](https://devtool.tech/semver)\r\n\r\n## 1. 当项目中没有 lock 文件时，生产环境的风险是如何产生的？\r\n演示风险过程如下：\r\n\r\n- `pkg 1.2.3`：首次在开发环境安装 pkg 库，为此时最新版本 `1.2.3`，dependencies 依赖中显示 `^1.2.3`，实际安装版本为 `1.2.3`\r\n- `pkg 1.19.0`：在生产环境中上线项目，安装 pkg 库，此时最新版本为 `1.19.0`，满足 `dependencies` 中依赖 `^1.2.3` 范围，实际安装版本为 `1.19.0`，但是 pkg 未遵从 semver 规范，在此过程中引入了 Breaking Change，如何此时 `1.19.0` 有问题的话，那生产环境中的 `1.19.0` 将会导致 bug，且难以调试。\r\n\r\n而当有了 lock 文件时，每一个依赖的版本号都被锁死在了 lock 文件，每次依赖安装的版本号都从 lock 文件中进行获取，避免了不可测的依赖风险。\r\n\r\n- `pkg 1.2.3`：首次在开发环境安装 pkg 库，为此时最新版本 `1.2.3`，dependencies 依赖中显示 `^1.2.3`，实际安装版本为 `1.2.3`，在 lock 中被锁定版本号。\r\n- `pkg 1.2.3`：在生产环境中上线项目，安装 pkg 库，此时 lock 文件中版本号为 `1.2.3`，符合 dependencies 中 `^1.2.3` 的范围，将在生产环境安装 `1.2.3`，完美上线。"}]},{"number":127,"title":"【Q127】npm 第三方库需要提交 lockfile 吗","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/127","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"> 该观点仅对第三方库的 dependencies 有效。\r\n答：你自己项目中所有依赖都会根据 lockfile 被锁死，但并不会依照你第三方依赖的 lockfile。\r\n\r\n试举一例：\r\n\r\n- 项目中依赖 `react@^17.0.2`\r\n- 而 `react@17.0.2` 依赖 `object-assign@^4.1.0`\r\n\r\n在 React 自身的 `yarn.lock` 中版本锁定依赖如下：\r\n```bash\r\nreact@17.0.2\r\n└── object-assign@4.1.0 (PS: 请注意该版本号)\r\n```\r\n\r\n而在个人业务项目中 `yarn.lock` 中版本锁定依赖如下：\r\n```bash\r\nApplication\r\n└── react@17.0.2\r\n    └── object-assign@4.99.99 (PS: 请注意该版本号)\r\n```\r\n\r\n此时个人业务项目中 `object-assign@4.99.99` 与 React 中 `object-assign@4.1.0` 不符，将有可能出现问题。\r\n\r\n此时，即使第三方库存在 lockfile，但也有着间接依赖(如此时的 `object-assign`，是第三方的依赖，个人业务项目中的依赖的依赖)不可控的问题。\r\n\r\n## 1. 第三方库如何解决潜在的间接依赖不可控问题\r\n可参考 `next.js` 的解决方案。\r\n\r\n- 将所有依赖中的版本号在 `package.json` 中锁死。可见 [package.json(opens new window)](https://github.com/vercel/next.js/tree/canary/packages/next/package.json)\r\n- 将部分依赖直接编译后直接引入，而非通过依赖的方式，如 webpack、babel 等。可见目录 [next/compiled](https://github.com/vercel/next.js/tree/canary/packages/next/compiled)\r\n```\r\n\r\n以下是一部分 `package.json`\r\n\r\n```javascript\r\n{\r\n  \"dependencies\": {\r\n    \"@babel/runtime\": \"7.15.4\",\r\n    \"@hapi/accept\": \"5.0.2\",\r\n    \"@napi-rs/triples\": \"1.0.3\"\r\n  }\r\n}\r\n```\r\n\r\n除了参考 `next.js` 直接锁死版本号方式外，还可以仍然按照 `^x.x.x` 加勤加维护并时时更新 `depencencies`。\r\n\r\n## 2. 总结\r\nlockfile 对于第三方库仍然必不可少。可见 react、next.js、webpack 均有 `yarn.lock`。(PS：可见 yarn 的受欢迎程度，另外 vue3 采用了 pnpm)\r\n\r\n- 第三方库的 `devDependencies` 必须在 lockfile 中锁定，这样 Contributor 可根据 lockfile 很容易将项目跑起来。\r\n- 第三方库的 `dependencies` 虽然有可能存在不可控问题，但是可通过锁死 `package.json` 依赖或者勤加更新的方式来解决。"}]},{"number":128,"title":"【Q128】简述 npm cache","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/128","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"npm 会把所有下载的包，保存在用户文件夹下面。\r\n\r\n默认值：`~/.npm` 在Posix上 或 `%AppData%/npm-cache` 在Windows上。根缓存文件夹。\r\n\r\n`npm install` 之后会计算每个包的 sha1 值(PS:安全散列算法(Secure Hash Algorithm))，然后将包与他的 sha1 值关联保存在 `package-lock.json` 里面，下次 `npm install` 时，会根据 `package-lock.json` 里面保存的 sha1 值去文件夹里面寻找包文件，如果找到就不用从新下载安装了。\r\n\r\n这个命令是重新计算，磁盘文件是否与 sha1 值匹配，如果不匹配可能删除。\r\n```bash\r\nnpm cache verify\r\n```\r\n> 要对现有缓存内容运行脱机验证，请使用 npm cache verify。\r\n\r\n这个命令是删除磁盘所有缓存文件。\r\n```bash\r\nnpm cache clean --force\r\n```"}]},{"number":129,"title":"【Q129】node_modules 的目录结构(拓扑结构)","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/129","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 基础\r\n当 `require('package-hello')` 时，假设 `package-hello` 是一个 npm 库，我们是如何找到该 package 的？\r\n\r\n- 寻找当前目录的 `node_modules/package-hello` 目录\r\n- 如果未找到，寻找上一级的 `../node_modules/package-hello` 目录，以此递归查找\r\n\r\n## 2. 很久以前: 嵌套结构\r\n在 npmv2 时，`node_modules` 对于各个 package 的拓扑为嵌套结构。\r\n\r\n假设:\r\n\r\n- 项目依赖 `package-a` 与 `package-b` 两个 package\r\n- `package-a` 与 `package-b` 均依赖 `lodash@4.17.4`\r\n\r\n依赖关系以 Markdown 列表表示：\r\n```\r\n- package-a\r\n  - `lodash@4.17.4`\r\n- package-b\r\n  - `lodash@4.17.4`\r\n```\r\n\r\n此时 `node_modules` 目录结构如下：\r\n```\r\ngraph\r\n  app(node_modules) ---> A(package-a)\r\n  app          ---> B(package-b)\r\n  A            ---> C(\"lodash@4.17.4\")\r\n  B            ---> D(\"lodash@4.17.4\")\r\n```\r\n\r\n此时最大的问题：\r\n\r\n- 嵌套过深\r\n- 占用空间过大\r\n\r\n## 3. 现在阶段: 平铺结构\r\n> 目前在 npm/yarn 中仍然为平铺结构，但 pnpm 使用了更省空间的方法，以后将会提到\r\n在 npmv3 之后 `node_modules` 为平铺结构，拓扑结构如下：\r\n```\r\ngraph\r\n  app(node_modules) ---> A(package-a)\r\n  app          ---> B(package-b)\r\n  app          ---> C(\"lodash@4.17.4\")\r\n```\r\n\r\n### 情况1：以下依赖最终 node_modules 结果如何？\r\n> 可参考[该示例](https://github.com/shfshanyue/node-examples/tree/master/engineering/package/topology)\r\n依赖关系以 Markdown 列表表示：\r\n```\r\n- package-a\r\n  - `lodash@^4.17.4`\r\n- package-b\r\n  - `lodash@^4.16.1`\r\n```\r\n\r\n答：与上拓扑结构一致，因为二者为 `^` 版本号，他们均会下载匹配该版本号范围的最新版本，比如 `@4.17.4`，因此二者依赖一致。\r\n\r\n> 注意：此时如果有 lock，会有一点小问题，待稍后讨论\r\n\r\n`node_modules` 目录结构如下图：\r\n```\r\ngraph\r\n  app(node_modules) ---> A(package-a)\r\n  app          ---> B(package-b)\r\n  app          ---> C(\"lodash@4.17.4\")\r\n```\r\n\r\n### 情况2：以下依赖最终 node_modules 结果如何？\r\n> 可参考[该示例](https://github.com/shfshanyue/node-examples/tree/master/engineering/package/topology-dup)\r\n```\r\n- package-a\r\n  - `lodash@4.17.4`\r\n- package-b\r\n  - `lodash@4.16.1`\r\n```\r\n\r\n答：`package-b` 先从自身 `node_modules` 下寻找 `lodash`，找到 `lodash@4.16.1`\r\n\r\n`node_modules` 目录结构如下图：\r\n```\r\ngraph\r\n  app(node_modules) ---> A(package-a)\r\n  app          ---> B(package-b)\r\n  app          ---> C(\"lodash@4.17.4\")\r\n  B            ---> D(\"lodash@4.16.1\")\r\n```\r\n\r\n### 情况3：以下依赖最终 `node_modules` 结果如何？\r\n```\r\n- package-a\r\n  - `lodash@4.0.0`\r\n- package-b\r\n  - `lodash@4.0.0`\r\n- package-c\r\n  - `lodash@3.0.0`\r\n- package-d\r\n  - `lodash@3.0.0`\r\n```\r\n\r\n答：`package-d` 只能从自身的 `node_modules` 下寻找 `lodash@3.0.0`，而无法从 `package-c` 下寻找，此时 `lodash@3.0.0` 不可避免地会被安装两次。\r\n\r\n`node_modules` 目录结构如下图：\r\n```\r\ngraph\r\n  app(node_modules) ---> A(package-a)\r\n  app          ---> B(package-b)\r\n  app          ---> C(package-c)\r\n  app          ---> D(package-d)\r\n  app          ---> X(\"lodash@4.0.0\")\r\n  C            ---> Y(\"lodash@3.0.0\")\r\n  D            ---> Z(\"lodash@3.0.0\")\r\n```\r\n\r\n## 4. 重复的版本依赖有什么问题？\r\n可参考 [npm doppelgangers](https://rushjs.io/pages/advanced/npm_doppelgangers/)\r\n\r\n- Install Size，安装体积变大，浪费磁盘空间\r\n- Build Size，构建打包体积变大，浪费带宽，网站打开延迟，破坏用户体验 (PS: 支持 Tree Shaking 会好点)\r\n- 破坏单例模式，破坏缓存，如 postcss 的许多插件将 postcss 扔进 dependencies，重复的版本将导致解析 AST 多次"}]},{"number":130,"title":"【Q130】pnpm 有什么优势","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/130","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 软链接和硬链接\r\n假设我们有一个文件，称为 `hello`\r\n\r\n通过 `ln -s` 创建一个软链接，通过 `ln` 可以创建一个硬链接。\r\n```bash\r\n$ ln -s hello hello-soft\r\n$ ln hello hello-hard\r\n\r\n$ ls -lh\r\ntotal 768\r\n45459612 -rw-r--r--  2 xiange  staff   153K 11 19 17:56 hello\r\n45459612 -rw-r--r--  2 xiange  staff   153K 11 19 17:56 hello-hard\r\n45463415 lrwxr-xr-x  1 xiange  staff     5B 11 19 19:40 hello-soft -> hello\r\n```\r\n\r\n他们的区别有以下几点:\r\n\r\n- 软链接可理解为指向源文件的指针，它是单独的一个文件，仅仅只有几个字节，它拥有独立的 `inode`\r\n- 硬链接与源文件同时指向一个物理地址，它与源文件共享存储数据，它俩拥有相同的 `inode`\r\n\r\n## 2. pnpm 为何节省空间\r\n它解决了 npm/yarn 平铺 node_modules 带来的依赖项重复的问题 (doppelgangers)\r\n\r\n假设存在依赖依赖：\r\n```\r\n.\r\n├── package-a\r\n│   └── lodash@4.0.0\r\n├── package-b\r\n│   └── lodash@4.0.0\r\n├── package-c\r\n│   └── lodash@3.0.0\r\n└── package-d\r\n    └── lodash@3.0.0\r\n```\r\n\r\n那么不可避免地在 npm 或者 yarn 中，`lodash@3.0.0` 会被多次安装，无疑造成了空间的浪费与诸多问题。\r\n```\r\n./node_modules/lodash\r\n./node_modules/package-a\r\n./node_modules/package-b\r\n./node_modules/package-c\r\n./node_modules/package-c/node_mdoules/lodash\r\n./node_modules/package-d\r\n./node_modules/package-d/node_mdoules/lodash\r\n```\r\n\r\n```\r\ngraph\r\n  app(node_modules) ---> A(package-a)\r\n  app          ---> B(package-b)\r\n  app          ---> C(package-c)\r\n  app          ---> D(package-d)\r\n  app          ---> X(\"lodash@4.0.0\")\r\n  C            ---> Y(\"lodash@3.0.0\")\r\n  D            ---> Z(\"lodash@3.0.0\")\r\n```\r\n\r\n这里有一个来自 [Rush (opens new window)](https://rushjs.io/images/home/card-doppel.svg)的图可以很形象的说明问题。\r\n\r\n这是一个较为常见的场景，在平时项目中有些库相同版本甚至会安装七八次，如 `postcss`、`ansi-styles`、`ansi-regex`、`braces` 等，你们可以去你们的 `yarn.lock/package-lock.json` 中搜索一下。\r\n\r\n而在 pnpm 中，它改变了 npm/yarn 的目录结构，采用软链接的方式，避免了 doppelgangers 问题更加节省空间。\r\n\r\n它最终生成的 node_modules 如下所示，从中也可以看出它解决了幽灵依赖的问题。\r\n```\r\n./node_modules/package-a       ->  .pnpm/package-a@1.0.0/node_modules/package-a\r\n./node_modules/package-b       ->  .pnpm/package-b@1.0.0/node_modules/package-b\r\n./node_modules/package-c       ->  .pnpm/package-c@1.0.0/node_modules/package-c\r\n./node_modules/package-d       ->  .pnpm/package-d@1.0.0/node_modules/package-d\r\n./node_modules/.pnpm/lodash@3.0.0\r\n./node_modules/.pnpm/lodash@4.0.0\r\n./node_modules/.pnpm/package-a@1.0.0\r\n./node_modules/.pnpm/package-a@1.0.0/node_modules/package-a\r\n./node_modules/.pnpm/package-a@1.0.0/node_modules/lodash     -> .pnpm/package-a@1.0.0/node_modules/lodash@4.0.0\r\n./node_modules/.pnpm/package-b@1.0.0\r\n./node_modules/.pnpm/package-b@1.0.0/node_modules/package-b\r\n./node_modules/.pnpm/package-b@1.0.0/node_modules/lodash     -> .pnpm/package-b@1.0.0/node_modules/lodash@4.0.0\r\n./node_modules/.pnpm/package-c@1.0.0\r\n./node_modules/.pnpm/package-c@1.0.0/node_modules/package-c\r\n./node_modules/.pnpm/package-c@1.0.0/node_modules/lodash     -> .pnpm/package-c@1.0.0/node_modules/lodash@3.0.0\r\n./node_modules/.pnpm/package-d@1.0.0\r\n./node_modules/.pnpm/package-d@1.0.0/node_modules/package-d\r\n./node_modules/.pnpm/package-d@1.0.0/node_modules/lodash     -> .pnpm/package-d@1.0.0/node_modules/lodash@3.0.0\r\n```\r\n\r\n如此，依赖软链接的方式，可解决重复依赖安装 (doppelgangers) 的问题，**如果一个项目占用 1000 MB，那么使用 pnpm 可能仅占用 800 MB**。\r\n\r\n然而它除此之外，还有一个最大的好处，**如果一个项目占用 1000 MB，传统方式十个项目占用 10000 MB，那么使用 pnpm 可能仅占用 3000 MB**，而它得益于硬链接。\r\n\r\n再借用以上示例，`lodash@3.0.0` 与 `lodash@4.0.0` 会生成一个指向全局目录(`~/.pnpm-store`)的硬链接，如果新项目依赖二者，则可复用存储空间。\r\n```\r\n./node_modules/.pnpm/lodash@3.0.0/node_modules/lodash   -> hardlink\r\n./node_modules/.pnpm/lodash@4.0.0/node_modules/lodash   -> hardlink\r\n```\r\n"}]},{"number":131,"title":"【Q131】请问什么是 CICD","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/131","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 什么是 CICD ？\r\n- `CI`，Continuous Integration，持续集成。\r\n- `CD`，Continuous Deployment，持续部署。\r\n\r\n`CICD` 一般合称，无需特意区分二者区别。\r\n从开发、测试到上线的过程中，借助于 CICD 进行一些自动化处理，保障项目质量。\r\n\r\n`CICD` 与 git 集成在一起，可理解为服务器端的 `git hooks`：当代码 push 到远程仓库后，借助 `WebHooks` 对当前代码在构建服务器(即 CI 服务器，也称作 Runner)中进行自动构建、测试及部署等。\r\n\r\n![Alt](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-11-17/clipboard-6509.1b9b98.webp)\r\n\r\n它有若干好处：\r\n\r\n- 功能分支提交后，通过 CICD 进行自动化测试、语法检查等，**如未通过 CICD，则无法 CodeReview，更无法合并到生产环境分支进行上线**。\r\n- 功能分支提交后，通过 CICD 检查 npm 库的风险、检查构建镜像容器的风险等。\r\n- 功能分支提交后，通过 CICD 对当前分支代码构建独立镜像并生成独立的分支环境地址进行测试，**如对每一个功能分支生成一个可供测试的地址，一般是 `<branch>.dev.shanyue.tech` 此种地址**。\r\n- 功能分支测试通过后，合并到主分支，自动构建镜像并部署到生成环境 (一般生成环境需要手动触发、自动部署)。\r\n\r\n![Alt](https://raw.githubusercontent.com/shfshanyue/assets/master/2021-11-17/pr-checks-final.26fba2.webp)\r\n\r\n由于近些年来 CICD 的全面介入，项目开发的工作流就是 CICD 的工作流，请看一个比较完善的 CICD Workflow。\r\n\r\n![Alt](https://raw.githubusercontent.com/shfshanyue/assets/master/2021-11-17/clipboard-7669.a41a94.webp)\r\n\r\n## 2. CICD 工具\r\n`CICD` 集成于 CICD 工具及代码托管服务。\r\nCICD 有时也可理解为进行 CICD 的构建服务器，而提供 CICD 的服务，如以下产品，将会提供构建服务与 github/gitlab 集成在一起。\r\n\r\n- jenkins\r\n- Travis CI\r\n\r\n如果你们公司没有 CICD 基础设置，那么你可以尝试 github 免费的 CICD 服务: [github actions (opens new window)](https://github.com/features/actions)。\r\n公司一般以 `gitlab CI` 作为 CICD 工具，此时需要自建 `gitlab Runner` 作为构建服务器。\r\n\r\n## 3. 一段简单的 CICD 配置\r\n每一家 CICD 产品，都有各自的配置方式，但是总体上用法差不多。\r\n以下 CI 脚本指当在 master 有代码变更时，自动部署上线。\r\n```yaml\r\ndeploy:\r\n  stage: deploy\r\n  only:\r\n    - master\r\n  script:\r\n    - docker build -t harbor.shanyue.tech/fe/devtools-app\r\n    - docker push harbor.shanyue.tech/fe/devtools-app\r\n    - helm upgrade -install devtools-app-chart .\r\n```"}]},{"number":132,"title":"【Q132】git hooks 原理是什么","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/132","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"git 允许在各种操作之前添加一些 hook 脚本，如未正常运行则 git 操作不通过。\r\n最出名的还是以下两个：\r\n\r\n- precommit\r\n- prepush\r\n\r\n而 hook 脚本置于目录 `~/.git/hooks` 中，以可执行文件的形式存在。\r\n```bash\r\n$ ls -lah .git/hooks\r\napplypatch-msg.sample     pre-merge-commit.sample\r\ncommit-msg.sample         pre-push.sample\r\nfsmonitor-watchman.sample pre-rebase.sample\r\npost-update.sample        pre-receive.sample\r\npre-applypatch.sample     prepare-commit-msg.sample\r\npre-commit.sample         update.sample\r\n```\r\n\r\n另外 git hooks 可使用 `core.hooksPath` 自定义脚本位置。\r\n```bash\r\n# 可通过命令行配置 core.hooksPath\r\n$ git config 'core.hooksPath' .husky\r\n\r\n# 也可通过写入文件配置 core.hooksPath\r\n$ cat .git/config\r\n[core]\r\n  ignorecase = true\r\n  precomposeunicode = true\r\n  hooksPath = .husky\r\n```\r\n\r\n在前端工程化中，`husky` 即通过自定义 `core.hooksPath` 并将 `npm scripts` 写入其中的方式来实现此功能。\r\n\r\n`~/.husky` 目录下手动创建 hook 脚本。\r\n```bash\r\n# 手动创建 pre-commit hook\r\n$ vim .husky/pre-commit\r\n```\r\n\r\n在 `pre-commit` 中进行代码风格校验。\r\n```bash\r\n#!/bin/sh\r\n\r\nnpm run lint\r\nnpm run test\r\n```"}]},{"number":133,"title":"【Q133】如何检测出你们安装的依赖是否安全","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/133","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"如何确保所有 `npm install` 的依赖都是安全的？\r\n\r\n当有一个库偷偷在你的笔记本后台挖矿怎么办？\r\n比如，不久前一个周下载量超过八百万的库被侵入，它在你的笔记本运行时会偷偷挖矿。\r\n\r\n## 1. Audit\r\n`Audit`，审计，检测你的所有依赖是否安全。`npm audit/yarn audit` 均有效。\r\n\r\n通过审计，可看出有风险的 package、依赖库的依赖链、风险原因及其解决方案。\r\n```bash\r\n$ npm audit\r\n┌───────────────┬──────────────────────────────────────────────────────────────┐\r\n│ high          │ Regular Expression Denial of Service in trim                 │\r\n├───────────────┼──────────────────────────────────────────────────────────────┤\r\n│ Package       │ trim                                                         │\r\n├───────────────┼──────────────────────────────────────────────────────────────┤\r\n│ Patched in    │ >=0.0.3                                                      │\r\n├───────────────┼──────────────────────────────────────────────────────────────┤\r\n│ Dependency of │ @mdx-js/loader                                               │\r\n├───────────────┼──────────────────────────────────────────────────────────────┤\r\n│ Path          │ @mdx-js/loader > @mdx-js/mdx > remark-mdx > remark-parse >   │\r\n│               │ trim                                                         │\r\n├───────────────┼──────────────────────────────────────────────────────────────┤\r\n│ More info     │ https://www.npmjs.com/advisories/1002775                     │\r\n└───────────────┴──────────────────────────────────────────────────────────────┘\r\n76 vulnerabilities found - Packages audited: 1076\r\nSeverity: 49 Moderate | 27 High\r\n✨  Done in 4.60s.\r\n```\r\n\r\n你可以在我的笔记本上挖矿，但绝不能在生产环境服务器下挖矿，此时可使用以下两条命令。\r\n```bash\r\n$ npm audit production\r\n\r\n$ yarn audit dependencies\r\n```\r\n\r\n![Alt](https://raw.githubusercontent.com/shfshanyue/assets/master/2021-11-03/clipboard-1904.f4c916.webp)\r\n\r\n通过 `npm audit fix` 可以自动修复该库的风险，原理就是升级依赖库，升级至已修复了风险的版本号。\r\n```bash\r\n$ npm audit fix\r\n```\r\n\r\n`yarn audit` 无法自动修复，需要使用 `yarn upgrade` 手动更新版本号，不够智能。\r\n\r\n[synk (opens new window)](https://snyk.io/)是一个高级版的 `npm audit`，可自动修复，且支持 CICD 集成与多种语言。\r\n```bash\r\n$ npx snyk\r\n\r\n$ npx wizard\r\n```\r\n\r\n![Alt](https://raw.githubusercontent.com/shfshanyue/assets/master/2021-11-03/clipboard-1409.96de76.webp)\r\n\r\n## 2. CI 机器人\r\n可通过 CI/gitlab/github 中配置机器人，使他们每天轮询一次检查仓库的依赖中是否有风险。\r\n\r\n![Alt](https://raw.githubusercontent.com/shfshanyue/assets/master/2021-11-03/clipboard-4186.0dac46.webp)\r\n\r\n在 Github 中，可单独设置 `dependabot` 机器人，在仓库设置中开启小机器人，当它检测到有问题时，会自动向该仓库提交 PR。\r\n\r\n![Alt](https://raw.githubusercontent.com/shfshanyue/assets/master/2021-11-03/clipboard-6581.08f1c2.webp)\r\n\r\n而它的解决方案也是升级版本号。\r\n\r\n![Alt](https://raw.githubusercontent.com/shfshanyue/assets/master/2021-11-03/clipboard-8617.e80863.webp)"}]},{"number":134,"title":"【Q134】在项目中，如何平滑升级 npm 包","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/134","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 如何对 npm 包进行升级\r\nnpm 的版本号为 `semver` 规范，由 [major, minor, patch] 三部分组成，其中\r\n\r\n- **major**：当你发了一个含有 Breaking Change 的 API\r\n- **minor**：当你新增了一个向后兼容的功能时\r\n- **patch**：当你修复了一个向后兼容的 Bug 时\r\n\r\n假设 react 当前版本号为 `17.0.1`，我们要升级到 `17.0.2` 应该如何操作？\r\n```\r\n- \"react\": \"17.0.1\",\r\n+ \"react\": \"17.0.2\",\r\n```\r\n\r\n## 2. 自动发现更新\r\n升级版本号，最不建议的事情就是手动在 `package.json` 中进行修改。\r\n```\r\n- \"react\": \"17.0.1\",\r\n+ \"react\": \"17.0.2\",\r\n```\r\n\r\n**毕竟，你无法手动发现所有需要更新的 package。**\r\n\r\n此时可借助于 `npm outdated`，发现有待更新的 package。\r\n\r\n![Alt](https://raw.githubusercontent.com/shfshanyue/assets/master/2021-11-10/clipboard-6918.0c6824.webp)\r\n\r\n使用 `npm outdated`，还可以列出其待更新 package 的文档。\r\n```bash\r\n$ npm outdated -l\r\nPackage                 Current    Wanted    Latest  Location                            Depended by  Package Type     Homepage\r\n@next/bundle-analyzer    10.2.0    10.2.3    12.0.3  node_modules/@next/bundle-analyzer  app          dependencies     https://github.com/vercel/next.js#readme\r\n```\r\n\r\n## 3. 自动更新版本号\r\n使用 `npm outdated` 虽能发现需要升级版本号的 package，但仍然需要手动在 `package.json` 更改版本号进行升级。\r\n\r\n此时推荐一个功能更强大的工具 `npm-check-updates`，比 `npm outdated` 强大百倍。\r\n`npm-check-updates -u`，可自动将 `package.json` 中待更新版本号进行重写。\r\n\r\n![Alt](https://raw.githubusercontent.com/shfshanyue/assets/master/2021-11-10/clipboard-3561.1b70dc.webp)\r\n\r\n升级 [minor] 小版本号，有可能引起 `Break Change`(破坏性升级)，可仅仅升级到最新的 patch 版本。\r\n```bash\r\n$ npx npm-check-updates --target patch\r\n```\r\n\r\n## 4. 一点小建议\r\n\r\n- 当一个库的 major 版本号更新后，不要第一时间去更新，容易踩坑，可再度过几个 patch 版本号再更新尝试新功能\r\n- 当遇到 major 版本号更新时，多看文档中的 ChangeLog，多看升级指导并多测试及审计"}]},{"number":135,"title":"【Q135】请简述下 eslint 的作用","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/135","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. eslint\r\neslint，对代码不仅有风格的校验，更有可读性、安全性、健壮性的校验。\r\n\r\n关于校验分号、冒号等，属于风格校验，与个人风格有关，遵循团队标准即可，可商量可妥协。\r\n```javascript\r\n// 这属于风格校验\r\n{\r\n  semi: [\"error\", \"never\"];\r\n}\r\n```\r\n\r\n与 `prettier` 不同，eslint 更多是关于代码健壮性校验，试举一例。\r\n\r\n- `Array.prototype.forEach` 不要求也不推荐回调函数返回值\r\n- `Array.prototype.map` 回调函数必须返回一个新的值用以映射\r\n\r\n当代码不遵守此两条要求时，通过 eslint 以下规则校验，则会报错。此种校验与代码健壮有关，不可商量不可妥协。\r\n```javascript\r\n// 这属于代码健壮性校验\r\n{\r\n  'array-callback-return': ['error', { checkForEach: true }]\r\n}\r\n```\r\n\r\n## 2. Rule\r\n在 eslint 中，使用 `Rule` 最为校验代码最小规则单元。\r\n```javascript\r\n{\r\n  rules: {\r\n    semi: [\"error\", \"never\"];\r\n    quotes: [\"error\", \"single\", { avoidEscape: true }];\r\n  }\r\n}\r\n```\r\n\r\n在 eslint 自身，内置大量 rules，比如分号冒号逗号等配置。\r\n\r\n> [eslint rules 源码位置](https://github.com/eslint/eslint/tree/main/lib/rules)\r\n\r\n校验 typescript、react 等规则，自然不会由 eslint 官方提供，那这些 Rules 如何维护？\r\n\r\n## 2. Plugin\r\n如 react、typescript、flow 等，需要自制 `Rule`，此类为 `Plugin`，他们维护了一系列 Rules。\r\n\r\n在命名时以 `eslint-plugin-` 开头并发布在 npm 仓库中，而执行的规则以 `react/`、`flow/` 等开头。\r\n```javascript\r\n{\r\n  'react/no-multi-comp': [error, { ignoreStateless: true }]\r\n}\r\n```\r\n\r\n- [React ESLint Rules(opens new window)](https://www.npmjs.com/package/eslint-plugin-react)\r\n- [TypeScript ESLint Rules](https://github.com/typescript-eslint/typescript-eslint/tree/master/packages/eslint-plugin/src/rules)\r\n\r\n## 3. Config\r\n在第三方库、公司业务项目中需要配置各种适应自身的规则、插件等，称为 `Config`。\r\n\r\n- 作为库发布，在命名时以 `elint-config-` 开头，并发布在 npm 仓库中。\r\n- 为项目服务，在项目中以 `.eslintrc` 命名或者置于项目 `package.json` 中的 `eslintConfig` 字段中，推荐第二种方案。\r\n\r\n- [eslint-config-react-app(opens new window)](https://github.com/facebook/create-react-app/tree/main/packages/eslint-config-react-app)\r\n- [eslint-config-airbnb](https://github.com/airbnb/javascript/tree/master/packages/eslint-config-airbnb)\r\n\r\n以下是 `eslint-config-airbnb` 的最外层配置。\r\n```javascript\r\nmodule.exports = {\r\n  extends: [\r\n    \"eslint-config-airbnb-base\",\r\n    \"./rules/react\",\r\n    \"./rules/react-a11y\",\r\n  ].map(require.resolve),\r\n  rules: {},\r\n};\r\n```\r\n\r\n在我们公司实际项目中，无需重新造轮子，只需要配置文件中的 `extends` 继承那些优秀的 `eslint-config` 即可。"}]},{"number":136,"title":"【Q136】如何修复某个 npm 包的紧急 bug","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/136","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"假设 `lodash` 有一个 Bug，影响线上开发，应该怎么办？\r\n\r\n![Alt](https://raw.githubusercontent.com/shfshanyue/assets/master/2021-11-11/clipboard-5920.ee51bc.webp)\r\n\r\n答: 三步走。\r\n\r\n1. 在 Github 提交 Pull Request，修复 Bug，等待合并\r\n2. 合并 PR 后，等待新版本发包\r\n3. 升级项目中的 lodash 依赖\r\n\r\n很合理很规范的一个流程，但是它一个最大的问题就是，太慢了，三步走完黄花菜都凉了。\r\n\r\n此时可直接上手修改 `node_modules` 中 lodash 代码，并修复问题！\r\n\r\n新问题：`node_modules` 未纳入版本管理，在生产环境并没有用。请看流程：\r\n\r\n1. 本地修改 `node_modules/lodash`，本地正常运行 ✅\r\n2. 线上 `npm i lodash`，lodash 未被修改，线上运行失败 ❌\r\n\r\n此时有一个简单的方案，临时将修复文件纳入工作目录，可以解决这个问题：\r\n\r\n1. 本地修改 `node_modules/lodash`，本地正常运行 ✅\r\n2. 将修改文件复制到 `${work_dir}/patchs/lodash` 中，纳入版本管理\r\n3. 线上 `npm i lodash`，并将修改文件再度复制到 `node_modules/lodash` 中，线上正常运行 ✅\r\n\r\n但此时并不是很智能，且略有小问题，演示如下：\r\n\r\n1. 本地修改 `node_modules/lodash`，本地正常运行 ✅\r\n2. 将修改文件复制到 `${work_dir}/patchs/lodash` 中，纳入版本管理 ✅\r\n3. 线上 `npm i lodash`，并将修改文件再度复制到 `node_modules/lodash` 中，线上正常运行 ✅\r\n4. 两个月后升级 lodash，该问题得以解决，而我们代码引用了 lodash 的新特性\r\n5. 线上 `npm i lodash`，并将修改文件再度复制到 `node_modules/lodash` 中，由于已更新了 lodash，并且依赖于新特性，线上运行失败 ❌\r\n\r\n此时有一个万能之策，那就是 [patch-package](https://github.com/ds300/patch-package)\r\n\r\n## 1. patch-package\r\n想要知道 `patch-package` 如何解决上述问题，请先了解下它的用法，流程如下：\r\n```bash\r\n# 修改 lodash 的一个小问题\r\n$ vim node_modules/lodash/index.js\r\n\r\n# 对 lodash 的修复生成一个 patch 文件，位于 patches/lodash+4.17.21.patch\r\n$ npx patch-package lodash\r\n\r\n# 将修复文件提交到版本管理之中\r\n$ git add patches/lodash+4.17.21.patch\r\n$ git commit -m \"fix 一点儿小事 in lodash\"\r\n\r\n# 此后的命令在生产环境或 CI 中执行\r\n# 此后的命令在生产环境或 CI 中执行\r\n# 此后的命令在生产环境或 CI 中执行\r\n\r\n# 在生产环境装包\r\n$ npm i\r\n\r\n# 为生产环境的 lodash 进行小修复\r\n$ npx patch-package\r\n\r\n# 大功告成！\r\n```\r\n\r\n再次看下 `patch-package` 自动生成 patch 文件的本来面目吧:\r\n\r\n它实际上是一个 diff 文件，在生产环境中可自动根据 diff 文件与版本号 (根据 patch 文件名存取) 将修复场景复原！\r\n```bash\r\n$ cat patches/lodash+4.17.21.patch\r\ndiff --git a/node_modules/lodash/index.js b/node_modules/lodash/index.js\r\nindex 5d063e2..fc6fa33 100644\r\n--- a/node_modules/lodash/index.js\r\n+++ b/node_modules/lodash/index.js\r\n@@ -1 +1,3 @@\r\n+console.log('DEBUG SOMETHING')\r\n+\r\n module.exports = require('./lodash');\r\n\\ No newline at end of file\r\n```"}]},{"number":137,"title":"【Q137】使用 webpack 打包时，如何更好地利用 long term cache","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/137","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. Long Term Cache\r\n使用 webpack 等打包器进行打包时，每个资源都可生成一个带有 hash 的路径。如\r\n\r\n- build/main.071b73.js\r\n- build/main.94474e.css\r\n- build/logo.18bac8.png\r\n\r\n此处对添加 hash 的资源设置永久缓存，可大幅度提高该网站的缓存能力，从而大幅度提高网站的二次加载性能。\r\n\r\n通过在服务器端/网关端对资源设置以下 Response Header，进行强缓存一年时间，称为永久缓存，即 `Long Term Cache`。\r\n```bash\r\nCache-Control: public,max-age=31536000,immutable\r\n```\r\n\r\n### 而当源文件内容发生变更时，资源的 hash 发生变化，生成新的可永久缓存的资源地址。\r\n\r\n因此在实践中，可对打包处理后带有 hash 资源的所有文件设置永久缓存。\r\n\r\n如果前端通过 docker/k8s/helm 进行部署，可由团队人员自行在构建 nginx 镜像时进行添加响应头字段。此处可作为前端性能优化的 kpi/okr。\r\n\r\n可在浏览器控制台 Network 中查看响应头来验证所属项目是否已成功添加永久缓存。\r\n\r\n![Alt](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-11-29/clipboard-1625.748311.webp)\r\n\r\n## 2. 一个问题与更强的永久缓存\r\n假设有两个文件: `index.js` 和 `lib.js`，且 index 依赖于 lib，其内容如下。\r\nindex.js\r\n```javascript\r\nimport(\"./lib\").then((o) => console.log(o));\r\n```\r\n\r\nlib.js\r\n```javascript\r\nexport const a = 3;\r\n```\r\n\r\n由 webpack 等打包器打包后将会生生两个 chunk (为了方便讲解，以下 aaaaaa 为 hash 值)\r\n\r\n- index.aaaaaa.js\r\n- lib.aaaaaa.js\r\n\r\n问：假设 `lib.js` 文件内容发生变更，`index.js` 由于引用了 `lib.js`，可能包含其文件名，那么它的 hash 是否会发生变动。\r\n\r\n答: 不一定。打包后的 `index.js` 中引用 lib 时并不会包含 `lib.aaaaaa.js`，而是采用 chunkId 的形式，如果 chunkId 是固定的话，则不会发生变更。\r\n```javascript\r\n// 打包前\r\nimport(\"./lib\");\r\n\r\n// 打包后，201 为固定的 chunkId (chunkIds = deterministic 时)\r\n__webpack_require__.e(/* import() | lib */ 201);\r\n```\r\n\r\n在 webpack 中，通过 `optimization.chunkIds` 可设置确定的 chunId，来增强 Long Term Cache 能力。\r\n```javascript\r\n{\r\n  optimization: {\r\n    chunkIds: 'deterministic'\r\n  }\r\n}\r\n```\r\n\r\n设置该选项且 `lib.js` 内容发生变更后，打包 chunk 如下，仅仅 `lib.js` 路径发生了变更。\r\n\r\n- index.aaaaaa.js\r\n- lib.bbbbbb.js"}]},{"number":138,"title":"【Q138】前端如何进行高效的分包","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/138","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 为什么需要分包？\r\n为什么需要进行分包，一个大的 `bundle.js` 不好吗？\r\n\r\n极其不建议，可从两方面进行考虑：\r\n\r\n- 一行代码将导致整个 `bundle.js` 的缓存失效\r\n- 一个页面仅仅需要 `bundle.js` 中 1/N 的代码，剩下代码属于其它页面，完全没有必要加载\r\n\r\n## 2. 如何更好的分包？\r\n### 打包工具运行时\r\n> webpack(或其他构建工具) 运行时代码不容易变更，需要单独抽离出来，比如 `webpack.runtime.js`。\r\n由于其体积小，必要时可注入 `index.html` 中，减少 HTTP 请求数，优化关键请求路径\r\n\r\n### 前端框架运行时\r\nReact(Vue) 运行时代码不容易变更，且每个组件都会依赖它，可单独抽离出来 `framework.runtime.js`。\r\n请且注意，务必将 React 及其所有依赖(react-dom/object-assign)共同抽离出来，否则有可能造成性能损耗，见下示例\r\n\r\n假设仅仅抽离 React 运行时(不包含其依赖)为单独 Chunk，且每个路由页面为单独 Chunk。某页面不依赖任何第三方库，则该页面会加载以下 Chunk\r\n\r\n| 文件 | 体积 | 必须加载\r\n| - | - | - |\r\n| webpack.runtime.js | 5KB | ✅ |\r\n| framework.runtime.js | 30KB | ✅ |\r\n| page-a.chunk.js | 50KB | ✅ |\r\n| vendor.chunk.js | 50KB | ❌ |\r\n\r\n因 webpack 依赖其 object-assign，而 object-assign 将被打入共同依赖 vendor.chunk.js，因此此时它必回加载，但是该页面并不依赖任何第三方库，完全没有必要全部加载 vendor.chunk.js\r\n\r\n将 React 运行时及其所有依赖，共同打包，修复结果如下，拥有了更完美的打包方案。\r\n\r\n| 文件 | 体积 | 必须加载\r\n| - | - | - |\r\n| webpack.runtime.js | 5KB | ✅ |\r\n| framework.runtime.js | 30KB | ✅ |\r\n| page-a.chunk.js | 50KB | ✅ |\r\n\r\n### 高频库\r\n一个模块被 N(2 个以上) 个 Chunk 引用，可称为公共模块，可把公共模块给抽离出来，形成 `vendor.js`。\r\n\r\n问：那如果一个模块被用了多次 (2 次以上)，但是该模块体积过大(1MB)，每个页面都会加载它(但是无必要，因为不是每个页面都依赖它)，导致性能变差，此时如何分包？\r\n\r\n答：如果一个模块虽是公共模块，但是该模块体积过大，可直接 `import()` 引入，异步加载，单独分包，比如 `echarts` 等\r\n\r\n问：如果公共模块数量多，导致 `vendor.js` 体积过大(1MB)，每个页面都会加载它，导致性能变差，此时如何分包\r\n\r\n答：有以下两个思路\r\n\r\n- 可对 `vendor.js` 改变策略，比如被引用了十次以上，被当做公共模块抽离成 `verdor-A.js`，五次的抽离为 `vendor-B.js`，两次的抽离为 `vendor-C.js`\r\n- 控制 `vendor.js` 的体积，当大于 100KB 时，再次进行分包，多分几个 `vendor-XXX.js`，但每个 `vendor.js` 都不超过 100KB\r\n\r\n## 3. 使用 webpack 分包\r\n在 webpack 中可以使用 [SplitChunksPlugin (opens new window)](https://webpack.js.org/plugins/split-chunks-plugin)进行分包，它需要满足三个条件:\r\n\r\n- `minChunks`：一个模块是否最少被 minChunks 个 chunk 所引用\r\n- `maxInitialRequests/maxAsyncRequests`：最多只能有 maxInitialRequests/maxAsyncRequests 个 chunk 需要同时加载 (如一个 Chunk 依赖 VendorChunk 才可正常工作，此时同时加载 chunk 数为 2)\r\n- `minSize/maxSize`：chunk 的体积必须介于 (minSize, maxSize) 之间\r\n\r\n以下是 next.js 的默认配置，可视作最佳实践\r\n> [源码位置: next/build/webpack-config.ts](https://github.com/vercel/next.js/blob/v12.0.5-canary.10/packages/next/build/webpack-config.ts#L728)\r\n\r\n```javascript\r\n{\r\n  // Keep main and _app chunks unsplitted in webpack 5\r\n  // as we don't need a separate vendor chunk from that\r\n  // and all other chunk depend on them so there is no\r\n  // duplication that need to be pulled out.\r\n  chunks: (chunk) =>\r\n    !/^(polyfills|main|pages\\/_app)$/.test(chunk.name) &&\r\n    !MIDDLEWARE_ROUTE.test(chunk.name),\r\n  cacheGroups: {\r\n    framework: {\r\n      chunks: (chunk: webpack.compilation.Chunk) =>\r\n        !chunk.name?.match(MIDDLEWARE_ROUTE),\r\n      name: 'framework',\r\n      test(module) {\r\n        const resource =\r\n          module.nameForCondition && module.nameForCondition()\r\n        if (!resource) {\r\n          return false\r\n        }\r\n        return topLevelFrameworkPaths.some((packagePath) =>\r\n          resource.startsWith(packagePath)\r\n        )\r\n      },\r\n      priority: 40,\r\n      // Don't let webpack eliminate this chunk (prevents this chunk from\r\n      // becoming a part of the commons chunk)\r\n      enforce: true,\r\n    },\r\n    lib: {\r\n      test(module: {\r\n        size: Function\r\n        nameForCondition: Function\r\n      }): boolean {\r\n        return (\r\n          module.size() > 160000 &&\r\n          /node_modules[/\\\\]/.test(module.nameForCondition() || '')\r\n        )\r\n      },\r\n      name(module: {\r\n        type: string\r\n        libIdent?: Function\r\n        updateHash: (hash: crypto.Hash) => void\r\n      }): string {\r\n        const hash = crypto.createHash('sha1')\r\n        if (isModuleCSS(module)) {\r\n          module.updateHash(hash)\r\n        } else {\r\n          if (!module.libIdent) {\r\n            throw new Error(\r\n              `Encountered unknown module type: ${module.type}. Please open an issue.`\r\n            )\r\n          }\r\n\r\n          hash.update(module.libIdent({ context: dir }))\r\n        }\r\n\r\n        return hash.digest('hex').substring(0, 8)\r\n      },\r\n      priority: 30,\r\n      minChunks: 1,\r\n      reuseExistingChunk: true,\r\n    },\r\n    commons: {\r\n      name: 'commons',\r\n      minChunks: totalPages,\r\n      priority: 20,\r\n    },\r\n    middleware: {\r\n      chunks: (chunk: webpack.compilation.Chunk) =>\r\n        chunk.name?.match(MIDDLEWARE_ROUTE),\r\n      filename: 'server/middleware-chunks/[name].js',\r\n      minChunks: 2,\r\n      enforce: true,\r\n    },\r\n  },\r\n  maxInitialRequests: 25,\r\n  minSize: 20000,\r\n}\r\n```"}]},{"number":139,"title":"【Q139】如何使用 docker 部署前端","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/139","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 有什么好处\r\n使用 docker 部署前端最大的好处是隔离环境，单独管理：\r\n\r\n- 前端项目依赖于 Node v16，而宿主机无法满足依赖，使用容器满足需求\r\n- 前端项目依赖于 npm v8，而宿主机无法满足依赖，使用容器满足需求\r\n- 前端项目需要将 8080 端口暴露出来，而容易与宿主机其它服务冲突，使用容器与服务发现满足需求\r\n\r\n## 2. 使用 docker 部署前端\r\n假设本地跑起一个前端项目，需要以下步骤，并最终可在 `localhost:8080` 访问服务。\r\n```bash\r\n$ npm i\r\n$ npm run build\r\n$ npm start\r\n```\r\n\r\n那在 docker 中部署前端，与在本地将如何将项目跑起来步骤大致一致，一个 Dockerfile 如下\r\n```dockerfile\r\n# 指定 node 版本号，满足宿主环境\r\nFROM node:16-alpine\r\n\r\n# 指定工作目录，将代码添加至此\r\nWORKDIR /code\r\nADD . /code\r\n\r\n# 如何将项目跑起来\r\nRUN npm install\r\nRUN npm run build\r\nCMD npm start\r\n\r\n# 暴露出运行的端口号，可对外接入服务发现\r\nEXPOSE 8080\r\n```\r\n\r\n此时，我们使用 `docker build` 构建镜像并把它跑起来。\r\n```bash\r\n# 构建镜像\r\n$ docker build -t fe-app .\r\n\r\n# 运行容器\r\n$ docker run -it --rm fe-app\r\n```\r\n\r\n恭喜你，能够写出以上的 Dockerfile，这说明你对 Docker 已经有了理解。但其中还有若干问题，我们对其进行一波优化\r\n\r\n- 使用 `node:16` 作为基础镜像过于奢侈，占用体积太大，而最终产物 (js/css/html) 无需依赖该镜像。可使用更小的 nginx 镜像做多阶段构建。\r\n- 多个 RUN 命令，不利于 Docker 的镜像分层存储。可合并为一个 RUN 命令\r\n- 每次都需要 `npm i`，可合理利用 Docker 缓存，ADD 命令中内容发生改变将会破坏缓存。可将 `package.json` 提前移至目标目录，只要 `package.json/lockfile` 不发生变动，将不会重新 `npm i`\r\n\r\n优化后 Dockerfile 如下：\r\n```dockerfile\r\nFROM node:16-alpine as builder\r\n\r\nWORKDIR /code\r\n\r\nADD package.json package-lock.json /code/\r\nRUN npm install\r\n\r\nADD . /code\r\n\r\nRUN npm run build\r\n\r\n# 选择更小体积的基础镜像\r\nFROM nginx:alpine\r\n\r\n# 将构建产物移至 nginx 中\r\nCOPY --from=builder code/build/ /usr/share/nginx/html/\r\n```"}]},{"number":140,"title":"【Q140】前端如何对分支环境进行部署","labels":["工程化"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/140","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"一种基于容器及 docker-compose 或者 k8s 的思路\r\n\r\n- 借用现有的 CICD 服务，如 `github actions` 或者 `gitlab CI` **获取当前分支信息**\r\n- 借用 Docker 快速部署前端或者后端，**根据分支信息启动不同的服务 (Service)，根据 Docker 启动服务并配置响应的标签 (Label)**\r\n- 根据容器的标签与当前 Git 分支对前端后端设置不同的域名\r\n\r\n\r\n以下是一个 Preview 的示例，其中服务名 `cra-preview-${COMMIT_REF_NAME}` 基于分支名称进行构建。\r\n```yaml\r\nversion: \"3\"\r\nservices:\r\n  cra-preview-${COMMIT_REF_NAME}:\r\n    build:\r\n      context: .\r\n      dockerfile: router.Dockerfile\r\n    labels:\r\n      # 配置域名: Preview\r\n      - \"traefik.http.routers.cra-preview-${COMMIT_REF_NAME}.rule=Host(`${COMMIT_REF_NAME}.cra.shanyue.tech`)\"\r\n      - traefik.http.routers.cra-preview-${COMMIT_REF_NAME}.tls=true\r\n      - traefik.http.routers.cra-preview-${COMMIT_REF_NAME}.tls.certresolver=le\r\n```\r\n\r\n在进行构建时，再通过 `envsub` 工具进行环境变量的替换\r\n```bash\r\ncat preview.docker-compose.yaml | envsubst > docker-compose.yaml\r\n```"}]}],"算法":[{"number":141,"title":"【Q141】阿里云笔试","labels":["算法"],"body":"一面","url":"https://github.com/kangyana/daily-question/issues/141","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 使用 promise 实现并发请求限制\r\n> 有 8 个图片资源的 url，已经存储在数组 `urls` 中，而且已经有一个函数 `loadImages`。\r\n> 要求：\r\n> 1. 任意时刻，同时下载的链接数量不可以超过 n 个。\r\n> 2. 尽可能快速地将所有图片下载完成。\r\n\r\n```javascript\r\nconst urls = [\r\n  \"https://www.kkkk1000.com/images/getImgData/getImgDatadata.jpg\",\r\n  \"https://www.kkkk1000.com/images/getImgData/gray.gif\",\r\n  \"https://www.kkkk1000.com/images/getImgData/Particle.gif\",\r\n  \"https://www.kkkk1000.com/images/getImgData/arithmetic.png\",\r\n  \"https://www.kkkk1000.com/images/getImgData/arithmetic2.gif\",\r\n  \"https://www.kkkk1000.com/images/getImgData/getImgDataError.jpg\",\r\n  \"https://www.kkkk1000.com/images/getImgData/arithmetic.gif\",\r\n  \"https://www.kkkk1000.com/images/wxQrCode2.png\",\r\n];\r\n\r\nfunction loadImages(urls,limit){}\r\n\r\nloadImages(urls, 3);\r\n```\r\n\r\n### 解析：该题主要考察对 `Promise` 的使用，重点需要理解 `Promise.race()` 和 `Promise.allSettled()` 的用法。\r\n```javascript\r\nconst urls = [\r\n  'https://www.kkkk1000.com/images/getImgData/getImgDatadata.jpg',\r\n  'https://www.kkkk1000.com/images/getImgData/gray.gif',\r\n  'https://www.kkkk1000.com/images/getImgData/Particle.gif',\r\n  'https://www.kkkk1000.com/images/getImgData/arithmetic.png',\r\n  'https://www.kkkk1000.com/images/getImgData/arithmetic2.gif',\r\n  'https://www.kkkk1000.com/images/getImgData/getImgDataError.jpg',\r\n  'https://www.kkkk1000.com/images/getImgData/arithmetic.gif',\r\n  'https://www.kkkk1000.com/images/wxQrCode2.png',\r\n];\r\n\r\n// 加载单个图片\r\nfunction loadSingleImg(url) {\r\n  return new Promise((resolve, reject) => {\r\n    const img = new Image();\r\n    img.onload = function () {\r\n      console.log(`加载成功：${url}`);\r\n      resolve(url);\r\n    };\r\n    img.onerror = function (err) {\r\n      console.log(`加载失败：${url}`);\r\n      reject(err);\r\n    };\r\n    img.src = url;\r\n  });\r\n}\r\n\r\n// 批量加载图片\r\nasync function loadImages(urls, limit) {\r\n  const promises = [];\r\n  const queue = urls.splice(0, limit).map((url, index) => {\r\n    const _p = loadSingleImg(url);\r\n    promises.push(_p);\r\n    return _p.then((res) => {\r\n      return [index, res];\r\n    });\r\n  });\r\n  for (const item of urls) {\r\n    const [index] = await Promise.race(queue);\r\n    const _p = loadSingleImg(item);\r\n    promises.push(_p);\r\n    queue[index] = _p.then((res) => {\r\n      return [index, res];\r\n    });\r\n  }\r\n\r\n  return Promise.allSettled(promises);\r\n}\r\n\r\n// 测试用例\r\nloadImages(urls, 3).then((res) => {\r\n  console.log('批量加载完毕');\r\n});\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. js补充日期\r\n> 数据可视化中，很多情况下都会以日期为横坐标，数据为纵坐标展示折线图，但接口下发的数据不一定是连续的。\r\n> 接口返回如下数据(数据已经按照日期由早到晚排序)：\r\n```javascript\r\nconst data = [\r\n  {date: '2021-12-25', cnt: 12},\r\n  {date: '2021-12-28', cnt: 7},\r\n  {date: '2021-12-30', cnt: 9},\r\n  {date: '2022-01-02', cnt: 4},\r\n  {date: '2022-01-03', cnt: 4}\r\n];\r\n```\r\n\r\n> 请写一个函数 pathDate()补全缺失的日期数据（默认为0即可），效果如下：\r\n```javascript\r\nconst result = pathDate(data);\r\n\r\n// result 结果为：\r\n[\r\n  {date: '2021-12-25', cnt: 12},\r\n  {date: '2021-12-26', cnt: 0}, // 新增\r\n  {date: '2021-12-27', cnt: 0}, // 新增\r\n  {date: '2021-12-28', cnt: 7},\r\n  {date: '2021-12-29', cnt: 0}, // 新增\r\n  {date: '2021-12-30', cnt: 9},\r\n  {date: '2021-12-31', cnt: 0}, // 新增\r\n  {date: '2022-01-01', cnt: 0}, // 新增\r\n  {date: '2022-01-02', cnt: 4},\r\n  {date: '2022-01-03', cnt: 4}\r\n];\r\n```\r\n\r\n### 解析：该题主要考察对 `Date API` 的运用。\r\n```javascript\r\nconst data = [\r\n  { date: '2021-12-25', cnt: 12 },\r\n  { date: '2021-12-28', cnt: 7 },\r\n  { date: '2021-12-30', cnt: 9 },\r\n  { date: '2022-01-02', cnt: 4 },\r\n  { date: '2022-01-03', cnt: 4 },\r\n];\r\n\r\n// 补全日期\r\nfunction pathDate(_date) {\r\n  // 开始时间戳\r\n  const start = data[0].date.replace(/-/g, '/');\r\n  const startTime = +new Date(start);\r\n  // 结束时间戳\r\n  const end = data[data.length - 1].date.replace(/-/g, '/');\r\n  const endTime = +new Date(end);\r\n  // 一天的时间戳\r\n  const dayTime = 86400000;\r\n  // 一共几天\r\n  const step = (endTime - startTime) / dayTime + 1;\r\n  // 时间范围\r\n  let dateRange = [];\r\n  for (let index = 0; index < step; index++) {\r\n    let date = formatDate(startTime + dayTime * index); // 当日时间\r\n    // 旧数据替换，新数据填充\r\n    const findIndex = data.findIndex((item) => item.date === date);\r\n    if (findIndex > -1) {\r\n      dateRange.push(data[findIndex]);\r\n    } else {\r\n      dateRange.push({ date, cnt: 0 });\r\n    }\r\n  }\r\n  return dateRange;\r\n}\r\n\r\n// 格式化日期\r\nfunction formatDate(time) {\r\n  const date = new Date(time);\r\n  const pad = (n) => (n < 10 ? `0${n}` : n);\r\n  const dateStr = `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}`;\r\n  return dateStr;\r\n}\r\n\r\n// 测试用例\r\nconst result = pathDate(data);\r\nconsole.log(result);\r\n```"}]},{"number":142,"title":"【Q142】CVTE笔试","labels":["算法"],"body":"二面","url":"https://github.com/kangyana/daily-question/issues/142","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 时间格式转换\r\n> 将一天24小时按每半小时划分成48段，我们用一个位图表示选中的时间区间，例如`110000000000000000000000000000000000000000000000`，表示第一个半小时和第二个半小时被选中了，其余时间段都没有被选中，也就是对应00:00~01:00这个时间区间。一个位图中可能有多个不连续的时间区间被选中，例如`110010000000000000000000000000000000000000000000`，表示00:00-1:00和02:00-02:30这两个时间区间被选中了。\r\n> \r\n> 要求：写一个函数timeBitmapToRanges，将上述规则描述的时间位图转换成一个选中时间区间的数组。\r\n示例输入：`\"110010000000000000000000000000000000000000000000\"`\r\n示例输出：`[\"00:00~01:00\", \"02:00~02:30\"]`\r\n\r\n### 解析：主要考察找规律能力\r\n```javascript\r\n/**\r\n * 将48位的时间位图格式化成字符串\r\n * 规律：1开始，1结束，0跳过。\r\n * @param {string} bitmap 时间位图，110001010101001010000\r\n **/\r\nfunction timeBitmapToRanges(bitmap) {\r\n  let index = 0; // 下标\r\n  const ranges = []; // 范围集合\r\n  // 遍历每一位（单位：半小时)\r\n  while (index < bitmap.length) {\r\n    // 0代表跳过\r\n    if (bitmap[index] === '0') {\r\n      index++;\r\n      continue;\r\n    }\r\n    // 1代表开始，记录下来\r\n    const curRange = {\r\n      start: index, // 初始时间\r\n      end: index, // 结束时间\r\n    };\r\n    // 1代表结束\r\n    while (bitmap[index] === '1') {\r\n      curRange.end = index;\r\n      index++;\r\n    }\r\n    ranges.push(curRange);\r\n  }\r\n\r\n  // 格式一下时间\r\n  const result = ranges.map((item) => {\r\n    const startTime = formatTime(item.start * 0.5); // *0.5 是半小时换算小时\r\n    const endTime = formatTime(item.end * 0.5 + 0.5);\r\n    return `${startTime}~${endTime}`;\r\n  });\r\n  return result;\r\n}\r\n\r\n/**\r\n * 格式化时间\r\n * @param {number} time 时间（格式是小时）\r\n * @returns {string} \r\n */\r\nfunction formatTime(time) {\r\n  const hour = Math.floor(time);\r\n  // 补全小时\r\n  const hourStr = hour < 10 ? `${0}${hour}` : hour;\r\n  // 补全分钟\r\n  const minute = time % 1 === 0.5 ? '30' : '00';\r\n  return `${hourStr}:${minute}`\r\n}\r\n\r\nconsole.log(timeBitmapToRanges('110001010101001010000'))\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. 数组随机取值\r\n> 已知有一个数组 const str = [1,2,3,4,5,6,7,8];\r\n要求实现一个取随机值的函数fn，可以连续从数组中取出不重复的随机值。可以一直取，当取值的数量超过原数组长度时，则开始新一轮随机。\r\n例如：\r\nfn(1) // 3\r\nfn(2) // 5,7\r\nfn(2) // 2,4\r\nfn(1) // 8\r\nfn(2) // 1,6\r\nfn(2) // 5,3\r\nfn(3) // 8,6,1\r\n\r\n### 解析：\r\n\r\n```javascript\r\nconst initialStack = [1,2,3,4,5,6,7,8]; // 初始栈\r\nlet stack = initialStack.slice(0); // 当前栈\r\n\r\nfunction fn(quantity) {\r\n  const randomArr = []; // 随机数组\r\n  let index = 0;\r\n  while (index < quantity) {\r\n    // 栈重置\r\n    if (stack.length === 0) {\r\n      stack = initialStack.slice(0);\r\n    }\r\n    // 取随机索引\r\n    const randomIndex = Math.floor(Math.random() * stack.length);\r\n    // 取随机值\r\n    randomArr.push(stack[randomIndex]);\r\n    // 删除取过的值\r\n    stack.splice(randomIndex, 1);\r\n    index++;\r\n  }\r\n  // 数组转字符串\r\n  const result = randomArr.join();\r\n  console.log(result);\r\n  return result;\r\n}\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 3. 逻辑题\r\n> 有8个小球，其中一个偏重一些，但是不知道是哪一个。有一个天平，请问最少多少次能够把这个小球找出来？\r\n\r\n### 二分法\r\n\r\n- 4 4\r\n- 2 2\r\n- 1 1\r\n\r\n3次。\r\n\r\n### 三分法\r\n\r\n- 3 3 2，33称一下：\r\n  - 平衡，称2\r\n  - 不平衡，称3\r\n- 1 1\r\n\r\n2次。\r\n\r\n### 解析：\r\n本质是：**用天平称重的结果，去解除所有不确定度**。\r\n\r\n在本问题中，所谓总不确定性，一共有8个等可能：\r\n\r\n- 第1个小球重\r\n- 第2个小球重\r\n- ……\r\n- 第8个小球重\r\n\r\n而天平每次能够提供三种结果：**左倾**，**右倾**，**平衡**。\r\n每一种结果，都提供一些信息，使得我们可以消解一部分不确定性。\r\n\r\n直观些表达，可以看做是在状态搜索时，走三个分叉，形如**三叉树**。\r\n\r\n![Alt](https://pic4.zhimg.com/80/v2-6ca0dacf33c3d18a0ac35f27aee50bcf_720w.webp)"}]},{"number":143,"title":"【Q143】阿里笔试","labels":["算法"],"body":"一面","url":"https://github.com/kangyana/daily-question/issues/143","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 实现 queryParse 函数，完成解析 URL 参数的功能\r\n> 用法：\r\n```javascript\r\nconst href = 'https://a.b.c?name=abc&age=24&code=%E6%B5%8B%E8%AF%95#main';\r\nconst params = queryParse(href);\r\nconsole.log(params); // {name: 'abc', age: 24, ...等 }\r\n```\r\n\r\n### 解析：此题考查 URL 结构 和 字符串操作\r\n\r\n```javascript\r\n/**\r\n * 问题：实现 queryParse 函数，完成解析 URL 参数的功能\r\n * @param url\r\n * @returns object\r\n */\r\nfunction queryParse(url) {\r\n  // 对 url 解码\r\n  const decodeUrl = decodeURIComponent(url);\r\n  // 取 ? 后面的字符串\r\n  const afterStr = decodeUrl.split(\"?\")[1] || \"\";\r\n  // 去掉 hash 值\r\n  const paramStr = afterStr.split(\"#\")[0];\r\n  // 对象数组转对象\r\n  const result = {};\r\n  paramStr.split(\"&\").reduce((prev, cur) => {\r\n    const [key, value] = cur.split(\"=\");\r\n    prev[key] = value;\r\n    return prev;\r\n  }, result);\r\n  return result;\r\n}\r\n\r\n// 测试用例\r\nconsole.log(queryParse(\"https://a.b.c?name=abc&age=24&code=%E6%B5%8B%E8%AF%95#main\"));\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. 请实现对二叉树节点的遍历访问函数，并按要求输出log。\r\n> 示例：使得二叉树如下时：\r\n输入数据：[1, [2], [3, [4, [5], [6]], [7]]]\r\n```\r\n   1\r\n  / \\\r\n 2   3\r\n    / \\\r\n   4   7\r\n  / \\\r\n 5   6\r\n```\r\n> console.log 输出的顺序为：\r\n```bash\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n```\r\n\r\n### 解析：此题考查 实现二叉树 和 遍历算法。此处以 `中序遍历` 为例：\r\n```javascript\r\nfunction binaryTreeAccess(arr) {\r\n  // 创建二叉树\r\n  var binaryTree = new BinaryTree();\r\n  // 扁平化，遍历插入节点\r\n  arr.flat(Infinity).forEach((item) => {\r\n    binaryTree.insert(item);\r\n  });\r\n  // 遍历访问节点，并打印\r\n  binaryTree.inOrderTraverse(console.log);\r\n}\r\n\r\n\r\n// 节点类\r\nclass Node {\r\n  constructor(key) {\r\n    this.key = key;\r\n    this.left = null;\r\n    this.right = null;\r\n  }\r\n}\r\n\r\n// 二叉树类\r\nclass BinaryTree {\r\n  constructor() {\r\n    this.root = null;\r\n  }\r\n\r\n  // 插入\r\n  insert(key) {\r\n    const node = new Node(key);\r\n    if (this.root === null) {\r\n      this.root = node;\r\n      return;\r\n    }\r\n    insertNode(this.root, node);\r\n  }\r\n\r\n  // 遍历\r\n  inOrderTraverse(callback) {\r\n    // 传 root 是因为要从根节点开始。\r\n    inOrderTraverseNode(this.root, callback);\r\n  }\r\n}\r\n\r\n// 插入节点\r\nfunction insertNode(node, newNode) {\r\n  if (newNode.key < node.key) {\r\n    if (node.left === null) {\r\n      node.left = newNode;\r\n    } else {\r\n      insertNode(node.left, newNode);\r\n    }\r\n  } else {\r\n    if (node.right === null) {\r\n      node.right = newNode;\r\n    } else {\r\n      insertNode(node.right, newNode);\r\n    }\r\n  }\r\n}\r\n\r\n// 中序遍历\r\nfunction inOrderTraverseNode(node, callback) {\r\n  if (node === null) return;\r\n  inOrderTraverseNode(node.left, callback);\r\n  callback(node.key);\r\n  inOrderTraverseNode(node.right, callback);\r\n}\r\n\r\n// 测试用例;\r\nbinaryTreeAccess([1, [2], [3, [4, [5], [6]], [7]]]);\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 3. 实现一个分组批量执行的任务调度函数 shipTasks\r\n> 使得任务队列里面的N条任务以每组 3 条异步并发执行，任务先进先出，每个分组依次串行执行\r\n注意：（后一组等前一组异步任务执行完之后才执行）\r\n\r\n### 解析：此题考查 `Promise.all`\r\n\r\n```javascript\r\nfunction mockTaskFn(task) {\r\n  // 假设这里做了网络请求\r\n  return Promise.resolve({\r\n    name: task.name,\r\n    data: {\r\n      status: 200,\r\n      x: Math.random(),\r\n    },\r\n  });\r\n}\r\n\r\nconst mockTaskPool = [\r\n  { name: \"task1\" },\r\n  { name: \"task2\" },\r\n  { name: \"task3\" },\r\n  { name: \"task4\" },\r\n  { name: \"task5\" },\r\n  { name: \"task6\" },\r\n  { name: \"task7\" },\r\n  { name: \"task8\" },\r\n  { name: \"task9\" },\r\n  { name: \"task10\" },\r\n];\r\n\r\nasync function shipTasks(tasks, amount = 3) {\r\n  const result = [];\r\n  // step 为 3\r\n  for (let i = 0; i < tasks.length; i += amount) {\r\n    await Promise.all(tasks.slice(i, i + amount))\r\n      .then((res) => {\r\n        console.log(\"批次成功：\", res);\r\n        result.push([...res]);\r\n      })\r\n      .catch((err) => {\r\n        console.log(\"加载失败：\", err);\r\n      });\r\n  }\r\n  return result;\r\n}\r\n\r\n// 输出任务mock返回值数组\r\nconst testFn = async () => {\r\n  const result = await shipTasks(mockTaskPool);\r\n  console.log(\"全部完毕：\", result);\r\n};\r\n\r\n// 测试用例\r\ntestFn();\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 4. 实现 compareVersion 方法，用于比较两个版本号（version1、version2）\r\n> 如果version1 > version2，返回1；\r\n如果version1 < version2，返回-1；\r\n其他情况，返回0。\r\n版本号规则`x.y.z`，xyz均为大于等于0的整数，至少有x位。\r\n示例：compareVersion('0.1', '1.1.1'); // 返回-1\r\ncompareVersion('13.37', '1.2 '); // 返回1\r\ncompareVersion('1.1', '1.1.0'); // 返回0\r\ncompareVersion('1.1', '1.1.1'); // 返回-1\r\n\r\n### 解析：双指针\r\n```javascript\r\nfunction compareVersion(version1, version2) {\r\n  // 版本号转位数组\r\n  let v1 = version1.split('.');\r\n  let v2 = version2.split('.');\r\n  let index = 0;\r\n  while (index < v1.length || index < v2.length) {\r\n    // 版本号长度补0\r\n    if (!v2[index]) {\r\n      v2[index] = 0;\r\n    }\r\n    if (!v1[index]) {\r\n      v1[index] = 0;\r\n    }\r\n    // 比较版本号大小\r\n    if (+v1[index] < +v2[index]) {\r\n      return -1;\r\n    } else if (+v1[index] > +v2[index]) {\r\n      return 1;\r\n    } else {\r\n      index++;\r\n    }\r\n  }\r\n  return 0;\r\n}\r\n\r\n// 测试用例\r\nconsole.log(compareVersion('0.1', '1.1.1')); // 返回-1\r\nconsole.log(compareVersion('13.37', '1.2 ')); // 返回1\r\nconsole.log(compareVersion('1.1', '1.1.0')); // 返回0\r\nconsole.log(compareVersion('1.1', '1.1.1')); // 返回-1\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 5. 井字棋游戏\r\n> 输入一个二维数组代表棋盘，其中『1』代表当前玩家的棋子，『0』代表没有棋子，『-1』代表对方玩家的棋子。\r\n若一方棋子在横、竖、斜方向连成排则为获胜，返回当前玩家是否胜出。\r\n示例：入参为 [[1,0,1],[1,-1,-1],[1,-1,0]] 时，返回 true\r\n\r\n### 解析：双循环暴力破解\r\n```javascript\r\nfunction gameCheck(arr) {\r\n  const len = arr.length; // 棋盘的长度\r\n  let sum1 = 0; // 横向\r\n  let sum2 = 0; // 纵向\r\n  let sum3 = 0; // 主对角线\r\n  let sum4 = 0; // 副对角线\r\n  // 一行一行画\r\n  for (let i = 0; i < len; i++) {\r\n    // 重画\r\n    sum1 = 0;\r\n    sum2 = 0;\r\n    // 计算对角线\r\n    sum3 += arr[i][i];\r\n    sum4 += arr[i][len - 1 - i];\r\n    for (let j = 0; j < len; j++) {\r\n      sum1 += arr[i][j];\r\n      sum2 += arr[j][i];\r\n    }\r\n    // 赢的条件（三点成线）\r\n    const isWin = sum1 === len || sum2 === len || sum3 === len || sum4 === len;\r\n    if (isWin) return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n// 测试用例\r\nconsole.log(\r\n  gameCheck([\r\n    [1, 0, 1],\r\n    [1, -1, -1],\r\n    [1, -1, 0],\r\n  ]),\r\n); // true\r\n```"}]}]}