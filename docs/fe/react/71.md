# 【Q071】官方自带的 Hooks


::: tip Issue
欢迎在 Gtihub Issue 中回答此问题: [Issue 71](https://github.com/kangyana/daily-question/issues/71)
:::

::: tip Author
回答者: [kangyana](https://github.com/kangyana)
:::
## 1. useState
```javascript
const [state, setState] = useState(initialState);
```
返回一个 `state`，以及更新函数 `setState`。

在初始渲染期间，返回的`state` 与传入的 `initialState` 值相同。

`setState` 函数用于更新 `state`。它接收一个新的 `state` 值并将组件的一次重新渲染加入队列。
```javascript
setState(newState);
```
在后续的重新渲染中，`useState` 返回的第一个值将始终是更新后最新的 `state`。

#### 注意
React 会确保 `setState` 函数的标识是稳定的，并且不会在组件重新渲染时发生变化。
这就是为什么可以安全地从 `useEffect` 或 `useCallback` 的依赖列表中省略 `setState`。

### 函数式更新
如果新的 `state` 需要通过使用先前的 `state` 计算得出，那么可以将函数传递给 `setState`。
该函数将接收先前的 `state`，并返回一个更新后的值。
下面的计数器组件示例展示了 `setState` 的两种用法：
```javascript
function Counter({initialCount}) {
  const [count, setCount] = useState(initialCount);
  return (
    <>
      Count: {count}
      <button onClick={() => setCount(initialCount)}>Reset</button>
      <button onClick={() => setCount(prevCount => prevCount - 1)}>-</button>
      <button onClick={() => setCount(prevCount => prevCount + 1)}>+</button>
    </>
  );
}
```

“+” 和 “-” 按钮采用函数式形式，因为被更新的 `state` 需要基于之前的 `state`。
但是“重置”按钮则采用普通形式，因为它总是把 `count` 设置回初始值。

如果你的更新函数返回值与当前 `state` 完全相同，则随后的重渲染会被完全跳过。

#### 注意：
与 `class` 组件中的 `setState` 方法不同，`useState` 不会自动合并更新对象。
你可以用函数式的 `setState` 结合展开运算符来达到合并更新对象的效果。
```javascript
const [state, setState] = useState({});
setState(prevState => {
  // 也可以使用 Object.assign
  return {...prevState, ...updatedValues};
});
```
`useReducer` 是另一种可选方案，它更适合用于管理包含多个子值的 `state` 对象。

### 惰性初始 state
`initialState` 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。
如果初始 `state` 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 `state`，此函数只在初始渲染时被调用：
```javascript
const [state, setState] = useState(() => {
  const initialState = someExpensiveComputation(props);
  return initialState;
});
```

### 跳过 state 更新
如果你更新 `State Hook` 后的 `state` 与当前的 `state` 相同时，React 将跳过子组件的渲染并且不会触发 `effect` 的执行。
React 使用 **Object.is 比较算法** 来比较 `state`。

需要注意的是，React 可能仍需要在跳过渲染前渲染该组件。
不过由于 React 不会对组件树的“深层”节点进行不必要的渲染，所以大可不必担心。
如果你在渲染期间执行了高开销的计算，则可以使用 `useMemo` 来进行优化。

### state 的批更新
React 可能会将几个 `state` 更新分组到一个重新渲染中，以提高性能。
通常情况下，这可以提高性能，且不影响你的应用程序的行为。

在 React 18 之前，只有 React 事件处理程序内是批更新。
从 React 18 开始，所有的更新都默认启用批处理。

在较少的情况下，你需要强制渲染组件，你可以用 `flushSync`包裹 `setState`。
然而，这可能会损害性能，所以只在需要时才这样做。
```javascript
import { flushSync } from 'react-dom';

flushSync(() => {
  setCount(c => c + 1);
  setFlag(f => !f);
});
```
::: tip Author
回答者: [kangyana](https://github.com/kangyana)
:::
## 2. useEffect
```javascript
useEffect(didUpdate);
```
该 `Hook` 接收一个包含命令式、且可能有副作用代码的函数。

在函数组件主体内改变 DOM、添加订阅、设置定时器、记录日志以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性。

使用 `useEffect` 完成副作用操作。
赋值给 `useEffect` 的函数会在组件渲染到屏幕之后执行。
你可以把 `effect` 看作从 React 的纯函数式世界通往命令式世界的逃生通道。

默认情况下，`effect` 将在每轮渲染结束后执行，但你可以选择让它 **在只有某些值改变的时候** 才执行。

### 清除 effect
通常，组件卸载时需要清除 `effect` 创建的诸如订阅或计时器 ID 等资源。
要实现这一点，`useEffect` 函数需返回一个清除函数。以下就是一个创建订阅的例子：
```javascript
useEffect(() => {
  const subscription = props.source.subscribe();
  return () => {
    // 清除订阅
    subscription.unsubscribe();
  };
});
```

为防止内存泄漏，清除函数会在组件卸载前执行。
另外，如果组件多次渲染，则 **在执行下一个 effect 之前，上一个 effect 就已被清除**。
在上述示例中，意味着组件的每一次更新都会创建新的订阅。
若想避免每次更新都触发 `effect` 的执行，请参阅下一小节。

### effect 的执行时机
与 `componentDidMount`、`componentDidUpdate` 不同的是，
传给 `useEffect` 的函数会在浏览器完成布局与绘制之后，在一个延迟事件中被调用。
这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因为绝大多数操作不应阻塞浏览器对屏幕的更新。

然而，并非所有 `effect` 都可以被延迟执行。
例如，一个对用户可见的 `DOM` 变更就必须在浏览器执行下一次绘制前被同步执行，这样用户才不会感觉到视觉上的不一致。
React 为此提供了一个额外的 `useLayoutEffect` 来处理这类 `effect`。
它和 `useEffect` 的结构相同，区别只是调用时机不同。

此外，从 React 18 开始，当它是离散的用户输入（如点击）的结果时，
或者当它是由 `flushSync` 包装的更新结果时，传递给 `useEffect` 的函数将在屏幕布局和绘制之前同步执行。
这种行为便于事件系统或 `flushSync` 的调用者观察该效果的结果。

#### 注意
这只影响传递给 `useEffect` 的函数被调用时 — 在这些 `effect` 中执行的更新仍会被推迟。
这与 `useLayoutEffect` 不同，后者会立即启动该函数并处理其中的更新。

即使在 `useEffect` 被推迟到浏览器绘制之后的情况下，它也能保证在任何新的渲染前启动。
React 在开始新的更新前，总会先刷新之前的渲染的 `effect`。

### effect 的条件执行
默认情况下，`effect` 会在每轮组件渲染完成后执行。
这样的话，一旦 `effect` 的依赖发生变化，它就会被重新创建。

然而，在某些场景下这么做可能会矫枉过正。
比如，在上一章节的订阅示例中，我们不需要在每次组件更新时都创建新的订阅，而是仅需要在 `source prop` 改变时重新创建。

要实现这一点，可以给 `useEffect` 传递第二个参数，它是 `effect` 所依赖的值数组。更新后的示例如下：
```javascript
useEffect(
  () => {
    const subscription = props.source.subscribe();
    return () => {
      subscription.unsubscribe();
    };
  },
  [props.source],
);
```
此时，只有当 `props.source` 改变后才会重新创建订阅。

#### 注意
如果你要使用此优化方式，请确保数组中包含了所有 **外部作用域中会发生变化且在 `effect` 中使用的变量**，
否则你的代码会引用到先前渲染中的旧变量。

如果想执行只运行一次的 `effect`（仅在组件挂载和卸载时执行），可以传递一个空数组 `[]` 作为第二个参数。
这就告诉 React 你的 `effect` 不依赖于 `props` 或 `state` 中的任何值，所以它永远都不需要重复执行。
这并不属于特殊情况 —— 它依然遵循输入数组的工作方式。

如果你传入了一个空数组 `[]`，`effect` 内部的 `props` 和 `state` 就会一直持有其初始值。
尽管传入 `[]` 作为第二个参数有点类似于 `componentDidMount` 和 `componentWillUnmount` 的思维模式，
但我们有 **更好的方式** 来避免过于频繁的重复调用 `effect`。
除此之外，请记得 React 会 **等待浏览器完成画面渲染之后才会延迟调用** `useEffect`，因此会使得处理额外操作很方便。

依赖项数组不会作为参数传给 `effect` 函数。
虽然从概念上来说它表现为：所有 `effect` 函数中引用的值都应该出现在依赖项数组中。
::: tip Author
回答者: [kangyana](https://github.com/kangyana)
:::
## 3. useContext
```javascript
const value = useContext(MyContext);
```

接收一个 `context` 对象（`React.createContext` 的返回值）并返回该 `context` 的当前值。
当前的 `context` 值由上层组件中距离当前组件最近的 `<MyContext.Provider>` 的 `value prop` 决定。

当组件上层最近的 `<MyContext.Provider>` 更新时，该 `Hook` 会触发重渲染，
并使用最新传递给 `MyContext provider` 的 `context value` 值。
即使祖先使用 `React.memo` 或 `shouldComponentUpdate`，也会在组件本身使用 `useContext` 时重新渲染。

别忘记 `useContext` 的参数必须是 `context` 对象本身：

- ✔ useContext(MyContext)
- ❌ useContext(MyContext.Consumer)
- ❌ useContext(MyContext.Provider)

调用了 `useContext` 的组件总会在 `context` 值变化时重新渲染。
如果重渲染组件的开销较大，你可以通过使用 `memoization` 来优化。

#### 提示
如果你在接触 `Hook` 前已经对 `context API` 比较熟悉，那应该可以理解，
`useContext(MyContext) 相当于 `class` 组件中的 `static contextType = MyContext` 或者 `<MyContext.Consumer>`。

`useContext(MyContext)` 只是让你能够读取 `context` 的值以及订阅 `context` 的变化。
你仍然需要在上层组件树中使用 `<MyContext.Provider>` 来为下层组件提供 `context`。

### 和 Context.Provider 一起使用
```javascript
const themes = {
  light: {
    foreground: "#000000",
    background: "#eeeeee"
  },
  dark: {
    foreground: "#ffffff",
    background: "#222222"
  }
};

const ThemeContext = React.createContext(themes.light);

function App() {
  return (
    <ThemeContext.Provider value={themes.dark}>
      <Toolbar />
    </ThemeContext.Provider>
  );
}

function Toolbar(props) {
  return (
    <div>
      <ThemedButton />
    </div>
  );
}

function ThemedButton() {
  const theme = useContext(ThemeContext);
  return (
    <button style={{ background: theme.background, color: theme.foreground }}>
      I am styled by theme context!
    </button>
  );
}
```
::: tip Author
回答者: [kangyana](https://github.com/kangyana)
:::
## 4. useReducer
```javascript
const [state, dispatch] = useReducer(reducer, initialArg, init);
```

`useState` 的替代方案。它接收一个形如 `(state, action) => newState` 的 `reducer`，
并返回当前的 `state` 以及与其配套的 `dispatch` 方法。

在某些场景下，`useReducer` 会比 `useState` 更适用，例如 `state` 逻辑较复杂且包含多个子值，
或者下一个 state 依赖于之前的 state 等。
并且，使用 `useReducer` 还能给那些会触发深更新的组件做性能优化，因为 **你可以向子组件传递 dispatch 而不是回调函数**。

以下是用 `reducer` 重写 `useState` 一节的计数器示例：
```javascript
const initialState = {count: 0};

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return {count: state.count + 1};
    case 'decrement':
      return {count: state.count - 1};
    default:
      throw new Error();
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);
  return (
    <>
      Count: {state.count}
      <button onClick={() => dispatch({type: 'decrement'})}>-</button>
      <button onClick={() => dispatch({type: 'increment'})}>+</button>
    </>
  );
}
```

#### 注意
React 会确保 `dispatch` 函数的标识是稳定的，并且不会在组件重新渲染时改变。
这就是为什么可以安全地从 `useEffect` 或 `useCallback` 的依赖列表中省略 `dispatch`。

### 指定初始 state
有两种不同初始化 `state` 的方式，你可以根据使用场景选择其中的一种。
将初始 `state` 作为第二个参数传入 `useReducer` 是最简单的方法：
```javascript
  const [state, dispatch] = useReducer(
    reducer,
    {count: initialCount}
  );
```

#### 注意
React 不使用 `state = initialState` 这一由 `Redux` 推广开来的参数约定。
有时候初始值依赖于 `props`，因此需要在调用 `Hook` 时指定。
如果你特别喜欢上述的参数约定，可以通过调用 `useReducer(reducer, undefined, reducer)` 来模拟 `Redux` 的行为，
但我们不鼓励你这么做。

### 惰性初始化
你可以选择惰性地创建初始 `state`。
为此，需要将 `init` 函数作为 `useReducer` 的第三个参数传入，这样初始 `state` 将被设置为 `init(initialArg)`。

这么做可以将用于计算 `state` 的逻辑提取到 `reducer` 外部，这也为将来对重置 `state` 的 `action` 做处理提供了便利：
```javascript
function init(initialCount) {
  return {count: initialCount};
}

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return {count: state.count + 1};
    case 'decrement':
      return {count: state.count - 1};
    case 'reset':
      return init(action.payload);
    default:
      throw new Error();
  }
}

function Counter({initialCount}) {
  const [state, dispatch] = useReducer(reducer, initialCount, init);
  return (
    <>
      Count: {state.count}
      <button
        onClick={() => dispatch({type: 'reset', payload: initialCount})}>
        Reset
      </button>
      <button onClick={() => dispatch({type: 'decrement'})}>-</button>
      <button onClick={() => dispatch({type: 'increment'})}>+</button>
    </>
  );
}
```

### 跳过 dispatch
如果 `Reducer` 的返回值与当前 `state` 相同，React 将跳过子组件的渲染及副作用的执行。
React 使用 **Object.is 比较算法** 来比较 state。

需要注意的是，React 可能仍需要在跳过渲染前再次渲染该组件。
不过由于 React 不会对组件树的“深层”节点进行不必要的渲染，所以大可不必担心。
如果你在渲染期间执行了高开销的计算，则可以使用 `useMemo` 来进行优化。
::: tip Author
回答者: [kangyana](https://github.com/kangyana)
:::
## 5. useCallback
```javascript
const memoizedCallback = useCallback(
  () => {
    doSomething(a, b);
  },
  [a, b],
);
```

返回一个 `memoized` 回调函数。

把内联回调函数及依赖项数组作为参数传入 `useCallback`，
它将返回该回调函数的 `memoized` 版本，该回调函数仅在某个依赖项改变时才会更新。
当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 `shouldComponentUpdate`）的子组件时，它将非常有用。

`useCallback(fn, deps)` 相当于 `useMemo(() => fn, deps)`。

#### 注意
依赖项数组不会作为参数传给回调函数。
虽然从概念上来说它表现为：所有回调函数中引用的值都应该出现在依赖项数组中。

### 6. useMemo
```javascript
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```
返回一个 `memoized` 值。

把“创建”函数和依赖项数组作为参数传入 `useMemo`，它仅会在某个依赖项改变时才重新计算 `memoized` 值。
这种优化有助于避免在每次渲染时都进行高开销的计算。

记住，传入 `useMemo` 的函数会在渲染期间执行。
请不要在这个函数内部执行不应该在渲染期间内执行的操作，
诸如副作用这类的操作属于 `useEffect` 的适用范畴，而不是 `useMemo`。

如果没有提供依赖项数组，`useMemo` 在每次渲染时都会计算新的值。

### 你可以把 useMemo 作为性能优化的手段，但不要把它当成语义上的保证。
将来，React 可能会选择“遗忘”以前的一些 `memoized` 值，并在下次渲染时重新计算它们，比如为离屏组件释放内存。
先编写在没有 `useMemo` 的情况下也可以执行的代码 —— 之后再在你的代码中添加 `useMemo`，以达到优化性能的目的。

#### 注意
依赖项数组不会作为参数传给“创建”函数。
虽然从概念上来说它表现为：所有“创建”函数中引用的值都应该出现在依赖项数组中。

## 7. useRef
```javascript
const refContainer = useRef(initialValue);
```
`useRef` 返回一个可变的 `ref` 对象，其 `.current` 属性被初始化为传入的参数 `initialValue`。
返回的 `ref` 对象在组件的整个生命周期内持续存在。

一个常见的用例便是命令式地访问子组件：
```javascript
function TextInputWithFocusButton() {
  const inputEl = useRef(null);
  const onButtonClick = () => {
    // `current` 指向已挂载到 DOM 上的文本输入元素
    inputEl.current.focus();
  };
  return (
    <>
      <input ref={inputEl} type="text" />
      <button onClick={onButtonClick}>Focus the input</button>
    </>
  );
}
```

本质上，`useRef` 就像是可以在其 `.current` 属性中保存一个可变值的“盒子”。

你应该熟悉 `ref` 这一种 **访问 DOM** 的主要方式。
如果你将 `ref` 对象以 `<div ref={myRef} />` 形式传入组件，则无论该节点如何改变，
React 都会将 `ref` 对象的 `.current` 属性设置为相应的 `DOM` 节点。

然而，`useRef()` 比 `ref` 属性更有用。
它可以 **很方便地保存任何可变值**，其类似于在 `class` 中使用实例字段的方式。

这是因为它创建的是一个普通 JS 对象。
而 `useRef()` 和自建一个 `{current: ...}` 对象的唯一区别是，`useRef` 会在每次渲染时返回同一个 `ref` 对象。

请记住，当 `ref` 对象内容发生变化时，`useRef` 并不会通知你。
变更 `.current` 属性不会引发组件重新渲染。
如果想要在 React 绑定或解绑 `DOM` 节点的 `ref` 时运行某些代码，则需要使用 **回调 ref** 来实现。
::: tip Author
回答者: [kangyana](https://github.com/kangyana)
:::
## 8. useImperativeHandle
```javascript
useImperativeHandle(ref, createHandle, [deps])
```

`useImperativeHandle` 可以让你在使用 `ref` 时自定义暴露给父组件的实例值。
在大多数情况下，应当避免使用 `ref` 这样的命令式代码。
`useImperativeHandle` 应当与 `forwardRef` 一起使用：

```javascript
function FancyInput(props, ref) {
  const inputRef = useRef();
  useImperativeHandle(ref, () => ({
    focus: () => {
      inputRef.current.focus();
    }
  }));
  return <input ref={inputRef} ... />;
}
FancyInput = forwardRef(FancyInput);
```

在本例中，渲染 `<FancyInput ref={inputRef} />` 的父组件可以调用 `inputRef.current.focus()`。

## 9. useLayoutEffect
其函数签名与 `useEffect` 相同，但它会在所有的 `DOM` 变更之后同步调用 `effect`。
可以使用它来读取 `DOM` 布局并同步触发重渲染。在浏览器执行绘制之前，`useLayoutEffect` 内部的更新计划将被同步刷新。

尽可能使用标准的 `useEffect` 以避免阻塞视觉更新。

#### 提示
如果你正在将代码从 `class` 组件迁移到使用 `Hook` 的函数组件，
则需要注意 `useLayoutEffect` 与 `componentDidMount`、`componentDidUpdate` 的调用阶段是一样的。
但是，我们推荐你一开始先用 `useEffect`，只有当它出问题的时候再尝试使用 `useLayoutEffect`。

如果你使用服务端渲染，请记住，无论 `useLayoutEffect` 还是 `useEffect` 都无法在 JS 代码加载完成之前执行。
这就是为什么在服务端渲染组件中引入 `useLayoutEffect` 代码时会触发 React 告警。
解决这个问题，需要将代码逻辑移至 `useEffect` 中（如果首次渲染不需要这段逻辑的情况下），
或是将该组件延迟到客户端渲染完成后再显示（如果直到 `useLayoutEffect` 执行之前 HTML 都显示错乱的情况下）。

若要从服务端渲染的 HTML 中排除依赖布局 `effect` 的组件，可以通过使用 `showChild && <Child />` 进行条件渲染，
并使用 `useEffect(() => { setShowChild(true); }, [])` 延迟展示组件。
这样，在客户端渲染完成之前，UI 就不会像之前那样显示错乱了。
::: tip Author
回答者: [kangyana](https://github.com/kangyana)
:::
## 10. useDebugValue
```javascript
useDebugValue(value)
```

`useDebugValue` 可用于在 React 开发者工具中显示自定义 `hook` 的标签。

例如，名为 `useFriendStatus` 的自定义 `Hook`：
```javascript
function useFriendStatus(friendID) {
  const [isOnline, setIsOnline] = useState(null);

  // 在开发者工具中的这个 Hook 旁边显示标签
  // e.g. "FriendStatus: Online"
  useDebugValue(isOnline ? 'Online' : 'Offline');

  return isOnline;
}
```

#### 提示
我们不推荐你向每个自定义 `Hook` 添加 `debug` 值。
当它作为共享库的一部分时才最有价值。

### 延迟格式化 debug 值
在某些情况下，格式化值的显示可能是一项开销很大的操作。
除非需要检查 `Hook`，否则没有必要这么做。

因此，`useDebugValue` 接受一个格式化函数作为可选的第二个参数。
该函数只有在 `Hook` 被检查时才会被调用。
它接受 `debug` 值作为参数，并且会返回一个格式化的显示值。

例如，一个返回 `Date` 值的自定义 `Hook` 可以通过格式化函数来避免不必要的 `toDateString` 函数调用：
```javascript
useDebugValue(date, date => date.toDateString());
```

## 11. useDeferredValue
```javascript
const deferredValue = useDeferredValue(value);
```

`useDeferredValue` 接受一个值，并返回该值的新副本，该副本将推迟到更紧急地更新之后。
如果当前渲染是一个紧急更新的结果，比如用户输入，React 将返回之前的值，然后在紧急渲染完成后渲染新的值。

该 `hook` 与使用防抖和节流去延迟更新的用户空间 `hooks` 类似。
使用 `useDeferredValue` 的好处是，React 将在其他工作完成（而不是等待任意时间）后立即进行更新，
并且像 `startTransition` 一样，延迟值可以暂停，而不会触发现有内容的意外降级。

### 缓存子组件
`useDeferredValue` 仅延迟你传递给它的值。
如果你想要在紧急更新期间防止子组件重新渲染，则还必须使用 `memo` 或 `useMemo` 缓存该子组件：
```javascript
function Typeahead() {
  const query = useSearchQuery('');
  const deferredQuery = useDeferredValue(query);

  // Memoizing 告诉 React 仅当 deferredQuery 改变，
  // 而不是 query 改变的时候才重新渲染
  const suggestions = useMemo(() =>
    <SearchSuggestions query={deferredQuery} />,
    [deferredQuery]
  );

  return (
    <>
      <SearchInput query={query} />
      <Suspense fallback="Loading results...">
        {suggestions}
      </Suspense>
    </>
  );
}
```

缓存该子组件告诉 React 它仅当 `deferredQuery` 改变而不是 `query` 改变的时候才需要去重新渲染。
这个限制不是 `useDeferredValue` 独有的，它和使用防抖或节流的 `hooks` 使用的相同模式。
::: tip Author
回答者: [kangyana](https://github.com/kangyana)
:::
## 12. useTransition
```javascript
const [isPending, startTransition] = useTransition();
```

返回一个状态值表示过渡任务的等待状态，以及一个启动该过渡任务的函数。

`startTransition` 允许你通过标记更新将提供的回调函数作为一个过渡任务：
```javascript
startTransition(() => {
  setCount(count + 1);
})
```

`isPending` 指示过渡任务何时活跃以显示一个等待状态：
```javascript
function App() {
  const [isPending, startTransition] = useTransition();
  const [count, setCount] = useState(0);
  
  function handleClick() {
    startTransition(() => {
      setCount(c => c + 1);
    })
  }

  return (
    <div>
      {isPending && <Spinner />}
      <button onClick={handleClick}>{count}</button>
    </div>
  );
}
```

#### 注意
过渡任务中触发的更新会让更紧急地更新先进行，比如点击。

过渡任务中的更新将不会展示由于再次挂起而导致降级的内容。
这个机制允许用户在 React 渲染更新的时候继续与当前内容进行交互。

## 13. useId
```javascript
const id = useId();
```
`useId` 是一个用于生成横跨服务端和客户端的稳定的唯一 ID 的同时避免 `hydration` 不匹配的 `hook`。

#### 注意
`useId` 不用于在列表中生成 `key`。`key` 应该从你的数据中生成。

一个最简单的例子，直接传递 `id` 给需要它的元素：
```javascript
function Checkbox() {
  const id = useId();
  return (
    <>
      <label htmlFor={id}>Do you like React?</label>
      <input id={id} type="checkbox" name="react"/>
    </>
  );
};
```

对于同一组件中的多个 ID，使用相同的 `id` 并添加后缀：

```javascript
function NameFields() {
  const id = useId();
  return (
    <div>
      <label htmlFor={id + '-firstName'}>First Name</label>
      <div>
        <input id={id + '-firstName'} type="text" />
      </div>
      <label htmlFor={id + '-lastName'}>Last Name</label>
      <div>
        <input id={id + '-lastName'} type="text" />
      </div>
    </div>
  );
}
```

#### 注意
`useId` 生成一个包含 `:` 的字符串 token。
这有助于确保 token 是唯一的，但在 CSS 选择器或 `querySelectorAll` 等 API 中不受支持。

`useId` 支持 `identifierPrefix` 以防止在多个根应用的程序中发生冲突。 
