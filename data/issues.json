{"javascript":[{"number":1,"title":"【Q001】js 有几种基本的数据类型","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/1","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"### 6种基本数据类型。\r\n\r\n- String 字符串\r\n- Number 数字\r\n- Boolean 布尔值\r\n- Null 空\r\n- Undefined 未定义\r\n- Symbol （es6新增）\r\n\r\n### 5种引用数据\r\n\r\n- Object 对象\r\n- Array 数组\r\n- Function 函数\r\n- RegExp 正则\r\n- Date 日期"}]},{"number":2,"title":"【Q002】如何判断 js 数据类型","labels":["javascript"],"body":"基础类型和复杂类型","url":"https://github.com/kangyana/daily-question/issues/2","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"### typeof用于判断基本数据类型，无法区分object、array、null\r\n```javascript\r\n    typeof 1 // 'number'\r\n    typeof \"1\" // 'string'\r\n    typeof undefined // 'undefined'\r\n    \r\n    typeof null // 'object'\r\n    typeof [] // 'object'\r\n    typeof {} // 'object'\r\n    typeof function() {} // 'function'\r\n```\r\n\r\n### 区分object和array，可以使用`Array.isArray()`\r\n```javascript\r\n    Array.isArray([1, 2, 3]); // true\r\n    Array.isArray({foo: 123}); // false\r\n    Array.isArray(\"foobar\"); // false\r\n    Array.isArray(undefined); // false\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"一条友善的评论"}]},{"number":3,"title":"【Q003】typeof和instanceof的区别","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/3","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 一、typeof\r\n`typeof`操作符返回一个字符串，表示未经计算的操作数的类型。\r\n\r\n语法：\r\n```javascript\r\ntypeof operand\r\n```\r\n\r\n|类型 | 结果 |\r\n| ---- | ---- |\r\n| undefined | `\"undefined\"` |\r\n| boolean | `\"boolean\"` |\r\n| string | `\"string\"` |\r\n| symbol | `\"symbol\"` |\r\n| bigInt | `\"bigint\"` |\r\n| function | `\"function\"` |\r\n| object \\| array \\| null | `\"object\"` |\r\n\r\n由上表可得知，`typeof`是无法区分`object` | `array` | `null`类型的。\r\n\r\n## 二、instanceof\r\n`instanceof` 运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。\r\n\r\n语法：\r\n```javascript\r\nobject instanceof constructor\r\n```\r\n\r\n只能用于构造函数，无法用于基础类型。\r\n\r\n## 三、总结区别\r\n`typeof`与`instanceof`都是判断数据类型的方法，区别如下：\r\n\r\n- `typeof`会返回一个变量的基本类型，instanceof返回的是一个布尔值。\r\n- `instanceof` 可以准确地判断复杂引用数据类型，但是无法判断基本类型。\r\n- `typeof`无法判断除了`function`外的引用类型。\r\n"}]},{"number":4,"title":"【Q004】如何判断一个变量是不是Array","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/4","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. instanceof 判断\r\n```javascript\r\nvar arr = [1,2,3];\r\narr instanceof Array; // true\r\narr instanceof Object; // false\r\n\r\nvar obj = {id:1};\r\nobj instanceof Array; // false\r\nobj instanceof Object; // true\r\n```\r\n\r\n## 2. 构造函数 判断\r\n```javascript\r\nvar arr = [1,2,3];\r\narr.__proto__.constructor === Array; //  true\r\n\r\nvar obj = {id:1};\r\nobj.__proto__.constructor === Object; // true\r\n```\r\n\r\n## 3. toString() 判断\r\n```javascript\r\nvar arr = [1,2,3];\r\nObject.prototype.toString.call(arr);  // [object Array]\r\n\r\nvar obj = {id:1};\r\nObject.prototype.toString.call(obj); // [object Object]\r\n```\r\n\r\n## 4. Array.isArray() 判断\r\n```javascript\r\nvar arr = [1,2,3];\r\nArray.isArray(arr); //  true\r\n\r\nvar obj = {id:1};\r\nArray.isArray(obj); // false\r\n```"}]},{"number":5,"title":"【Q005】==和===有什么不同","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/5","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. ==\r\n等于运算符 `==` 检查其两个操作数是否相等，并返回 `Boolean` 结果。\r\n同时会尝试强制类型转换。\r\n\r\n隐式转换：\r\n`string` 和 `number` 比较时，会自动转换为 `number` 类型。\r\n\r\n## 2. ===\r\n全等运算符 `===` 检查其两个操作数是否相等，并返回 `Boolean` 结果。\r\n它总是认为不同类型的操作数是不同的。\r\n\r\n## 3. 区别\r\n\r\n- `==` 不会比较数据类型，`===` 会检查类型\r\n- `==`会隐式转换"}]},{"number":6,"title":"【Q006】事件机制","labels":["javascript"],"body":"事件循环","url":"https://github.com/kangyana/daily-question/issues/6","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"JavaScript 有一个基于 **事件循环** 的并发模型，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。\r\n\r\n## 1. 可视化描述\r\n![Alt](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop/the_javascript_runtime_environment_example.svg)\r\n\r\n## 2. 栈（stack)\r\n栈是由多个 **函数调用** 形成的 **帧** 组成\r\n\r\n```javascript\r\nfunction foo(b) {\r\n  let a = 10;\r\n  return a + b + 11;\r\n}\r\n\r\nfunction bar(x) {\r\n  let y = 3;\r\n  return foo(x * y);\r\n}\r\n\r\nconsole.log(bar(7)); // 42\r\n```\r\n\r\n当调用 `bar` 时，第一个帧被创建并压入栈中，帧中包含了 `bar` 的参数和局部变量。\r\n当 `bar` 调用 `foo` 时，第二个帧被创建并被压入栈中，放在第一个帧之上，帧中包含 `foo` 的参数和局部变量。\r\n当 `foo` 执行完毕然后返回时，第二个帧就被弹出栈（剩下 `bar` 函数的调用帧 ）。\r\n当 `bar` 也执行完毕然后返回时，第一个帧也被弹出，栈就被清空了。\r\n\r\n## 3. 堆（heap）\r\n堆是放 **object** 的 **内存区域**\r\n\r\n## 4. 队列（queue）\r\n队列是 **待处理消息的消息队列**，每一个消息都关联着一个用以处理这个消息的回调函数。\r\n\r\n在 **事件循环** 期间的某个时刻，运行时会从最先进入队列的消息开始处理队列中的消息。\r\n被处理的消息会被移出队列，并作为输入参数来调用与之关联的函数。\r\n正如前面所提到的，调用一个函数总是会为其创造一个新的栈帧。\r\n\r\n函数的处理会一直进行到执行栈再次为空为止；然后事件循环将会处理队列中的下一个消息。\r\n\r\n## 5. 事件循环（event loop）\r\n之所以称之为 **事件循环**，是因为它经常按照类似如下的方式来被实现：\r\n\r\n```javascript\r\nwhile (queue.waitForMessage()) {\r\n  queue.processNextMessage();\r\n}\r\n```\r\n\r\n`queue.waitForMessage()` 会同步地等待消息到达 "}]},{"number":7,"title":"【Q007】事件委托","labels":["javascript"],"body":"事件流、事件冒泡","url":"https://github.com/kangyana/daily-question/issues/7","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 事件委托\r\n将事件侦听器添加到一个父级元素上。\r\n这样就只用添加一次事件侦听器，可以避免向很多 DOM 节点添加多个事件侦听器。\r\n\r\n## 2. 事件冒泡\r\n事件委托的实现是利用 **事件冒泡** 的机制。\r\n事件流：事件的触发会从最底层的 DOM 元素开始发生，一直向上传播，直到 document 对象。\r\n\r\n## 3. 优点\r\n\r\n- 减少了内存消耗，优化程序性能\r\n- 动态绑定事件，减少重复工作"}]},{"number":8,"title":"【Q008】e.preventDefault()是干什么的","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/8","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"- **e.preventDefault()** 取消默认事件\r\n- **e.stopPropagation()** 防止冒泡和捕获 \r\n"}]},{"number":9,"title":"【Q009】JS中this是如何工作的","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/9","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"**this** 永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。\r\n\r\n## 1. 全局环境中\r\n`this` 指向全局对象\r\n\r\n```javascript\r\n// 在浏览器中\r\nconsole.log(this === window); // true\r\n\r\n// 在 Node 中\r\nconsole.log(this === globalThis); // true\r\n```\r\n## 2. 函数内部\r\n`this` 的值取决于函数被调用的方式。\r\n\r\n非严格模式下，`this` 的值默认指向全局对象\r\n```javascript\r\nfunction f1(){\r\n  return this;\r\n}\r\n\r\nf1() === window;   // true\r\n```\r\n\r\n严格模式下，如果进入执行环境时没有设置 `this` 的值，`this` 会保持为 `undefined`\r\n```javascript\r\nfunction f2(){\r\n  \"use strict\";\r\n  return this;\r\n}\r\n\r\nf2() === undefined; // true\r\n```\r\n\r\n如果要想把 `this` 的值从一个环境传到另一个，就要用 `call` 或者 `apply` 方法\r\n\r\n## 3. 类内部\r\n`this` 在 `类` 中的表现与在函数中类似，因为类本质上也是函数，但也有一些区别和注意事项\r\n\r\n在类的构造函数中，this 是一个常规对象。类中所有 **非静态的方法** 都会被添加到 `this` 的原型中\r\n```javascript\r\nclass Example {\r\n  constructor() {\r\n    const proto = Object.getPrototypeOf(this);\r\n    console.log(Object.getOwnPropertyNames(proto));\r\n  }\r\n  first(){}\r\n  second(){}\r\n  static third(){}\r\n}\r\n\r\nnew Example(); // ['constructor', 'first', 'second']\r\n```\r\n## 4. 派生类内部\r\n派生类的构造函数没有初始的 `this` 绑定，在调用 super() 之前引用 `this` 会报错\r\n\r\n## 5. bind()后\r\n`this` 的值指向绑定的参数\r\n```javascript\r\nfunction f(){\r\n  return this.a;\r\n}\r\n\r\nvar g = f.bind({a:\"azerty\"});\r\nconsole.log(g()); // azerty\r\n```\r\n\r\n## 6. 箭头函数内部\r\n`this` 的值指向外部环境，相当于传递了 `this`"}]},{"number":10,"title":"【Q010】apply、call、bind的区别，及源码实现","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/10","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. apply()\r\n`apply()` 方法调用一个具有给定 `this` 值的函数，以及以一个数组的形式提供的参数\r\n```javascript\r\nconst numbers = [5, 6, 2, 3, 7];\r\n\r\nconst max = Math.max.apply(null, numbers); // 7\r\n```\r\n\r\n源码实现\r\n```javascript\r\nFunction.prototype.myApply = function (context, args) {\r\n    context = context || window;\r\n    let fn = Symbol();\r\n    context[fn] = this;\r\n    return context[fn](...args);\r\n}\r\n```\r\n\r\n## 2. call()\r\n`call` 方法使用一个指定的 `this` 值和单独给出的一个或多个参数来调用一个函数\r\n\r\n可以用来实现 **继承**\r\n```javascript\r\nfunction Product(name, price) {\r\n  this.name = name;\r\n  this.price = price;\r\n}\r\n\r\nfunction Food(name, price) {\r\n  Product.call(this, name, price);\r\n  this.category = 'food';\r\n}\r\n\r\nconsole.log(new Food('cheese', 5).name); // cheese\r\n```\r\n\r\n源码实现，与apply区别只有参数变化\r\n```javascript\r\nFunction.prototype.myCall = function (context, ...args) {\r\n    context = context || window;\r\n    let fn = Symbol();\r\n    context[fn] = this;\r\n    return context[fn](...args);\r\n}\r\n```\r\n\r\n## 3. bind()\r\n`bind()` 方法创建一个新的函数，在 ·bind()· 被调用时，这个新函数的 this 被指定为 `bind()` 的第一个参数，而其余参数将作为新函数的参数\r\n\r\n```javascript\r\nconst module = {\r\n  x: 42,\r\n  getX: function() {\r\n    return this.x;\r\n  }\r\n};\r\n\r\nconst unboundGetX = module.getX;\r\nconsole.log(unboundGetX()); // undefined（函数内this指向全局）\r\n\r\nconst boundGetX = unboundGetX.bind(module);\r\nconsole.log(boundGetX()); // 42\r\n```\r\n\r\n源码实现\r\n```javascript\r\n\r\nFunction.prototype.myBind = function (context) {\r\n    const self = this\r\n    const args = Array.from(arguments).slice(1)\r\n \r\n    return function F() {\r\n        const newArgs = args.concat([...arguments])\r\n        if (this instanceof F) {\r\n            return new self(...newArgs)\r\n        } else {\r\n            return self.apply(context, newArgs)\r\n        }\r\n    }\r\n```\r\n\r\n## 4. 区别\r\n\r\n- `apply` 与 `call` 非常相似，`call` 接受一个参数列表，而 `apply` 接受一个参数的单数组\r\n- `call`、`apply` 是直接调用，`bind` 是返回某个函数，等待某个状态触发再执行\r\n\r\n"}]},{"number":11,"title":"【Q011】js中new关键字原理","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/11","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## new原理\r\n`new` 操作符用来创建构造函数的实例，以这种方式调用构造函数会执行如下操作：\r\n\r\n- 在内存中创建一个新对象；\r\n- 这个对象内部的[[Prototype]]特性被复制为构造函数的prototype属性;\r\n- 构造函数内部的this被复制为这个新对象（即this指向新对象）；\r\n- 执行构造函数内部的代码（给新对象添加属性）；\r\n- 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新实例。\r\n\r\n## 代码实现\r\n\r\n1. 使用Object.create继承prototype属性\r\n```javascript\r\nfunction myNew (constructor, ...args) {\r\n    var obj = Object.create(constructor.prototype);\r\n    var result = constructor.apply(obj, args);\r\n    return typeof result === 'object' ? result : obj;\r\n}\r\n```\r\n\r\n2. 重写新对象的__proto__属性\r\n```javascript\r\nfunction myNew (constructor, ...args) {\r\n    var obj = new Object();\r\n    obj.__proto__  = constructor.prototype;\r\n    var result = constructor.apply(obj, args);\r\n    return typeof result === 'object' ? result : obj;\r\n}\r\n```"}]},{"number":12,"title":"【Q012】JS 中继承是如何实现的","labels":["javascript"],"body":"7种方法","url":"https://github.com/kangyana/daily-question/issues/12","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 原型链\r\n让一个 **构造函数** 的原型是另一个类型的实例，`new` 出来的实例\r\n```javascript\r\nfunction Person () {\r\n  this.name = 'zs';\r\n}\r\n\r\nfunction Man () {};\r\nMan.prototype = new Person();\r\n\r\nnew Man().name // 'zs'\r\n```\r\n\r\n优点：写法方便简洁，容易理解\r\n缺点：对象实例共享所有继承的属性和方法。传教子类型实例的时候，不能传递参数，因为这个对象是一次性创建的（没办法定制化）\r\n\r\n## 2. 借用构造函数继承\r\n在子类型构造函数的内部调用父类型构造函数；使用 apply() 或 call() 方法将父对象的构造函数绑定在子对象上\r\n```javascript\r\nfunction Person (name) {\r\n  this.name = name;\r\n}\r\n\r\nfunction Man (name) {\r\n  Person.call(this, name)\r\n};\r\n```\r\n\r\n优点：解决了原型链实现继承的不能传参的问题和父类的原型共享的问题\r\n缺点：借用构造函数的缺点是方法都在构造函数中定义，因此无法实现函数复用。在父类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式\r\n\r\n## 3. 组合继承（经典继承）\r\n将 `原型链` 和 `借用构造函数` 的组合到一块。\r\n使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。\r\n\r\n```javascript\r\nfunction Person (name) {\r\n  this.name = name;\r\n}\r\nPerson.prototype.sayName = function () {\r\n  console.log('My name is ' + this.name);\r\n}\r\n\r\nfunction Man (name) {\r\n  Person.call(this, name)\r\n};\r\nMan.prototype = new Person();\r\n\r\nnew Man('zs').sayName  // 'My name is zs'\r\n```\r\n\r\n优点: 解决了原型链继承和借用构造函数继承造成的影响\r\n缺点: 无论在什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部\r\n\r\n## 4. 原型式继承\r\n创建一个新对象，挂到新建对象的原型上\r\n```javascript\r\nfunction Person () {\r\n  this.name = 'zs';\r\n}\r\n\r\nvar man = Object.create(Person);\r\n\r\nman.name // 'zs'\r\n```\r\n优点是：不需要单独创建构造函数\r\n缺点是：属性中包含的引用值始终会在相关对象间共享，子类实例不能向父类传参\r\n\r\n## 5. 寄生式继承\r\n寄生式继承的思路与(寄生) `原型式继承` 和 `工厂模式` 似, 即创建一个仅用于封装继承过程的函数,该函数在内部以某种方式来增强对象,最后再像真的是它做了所有工作一样返回对象\r\n\r\n```javascrip\r\nfunction objectCopy(obj) {\r\n  function Fun() { };\r\n  Fun.prototype = obj;\r\n  return new Fun();\r\n}\r\n\r\nfunction createAnother(obj) {\r\n  let clone = objectCopy(obj);\r\n  clone.sayName = function () {\r\n    console.log('My name is ' + this.name);\r\n  };\r\n  return clone;\r\n}\r\n\r\nvar person = { name: 'zs' };\r\n\r\ncreateAnother(person).sayName(); // 'My name is zs'\r\n```\r\n\r\n优点：写法简单，不需要单独创建构造函数\r\n缺点：通过寄生式继承给对象添加函数会导致函数难以复用\r\n\r\n## 6. 寄生组合式继承\r\n通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型\r\n\r\n```javascript\r\n// ...\r\nfunction inheritPrototype(child, parent) {\r\n  let prototype = objectCopy(parent.prototype);\r\n  prototype.constructor = child;\r\n  Child.prototype = prototype;\r\n}\r\n```\r\n优点是：高效率只调用一次父构造函数，并且因此避免了在子原型上面创建不必要，多余的属性。与此同时，原型链还能保持不变\r\n缺点是：代码复杂\r\n\r\n# 7. Class实现继承\r\n优点：语法简单易懂,操作更方便\r\n缺点：并不是所有的浏览器都支持class关键字\r\n"}]},{"number":13,"title":"【Q013】JS 原型和原型链","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/13","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 原型\r\n每个函数都有一个特殊的属性叫作 `原型（prototype）`\r\n每个对象都有一个属性叫作 `__proto__`，这个属性会指向该对象的原型\r\n每个原型都有一个 `constructor` 属性指向关联的构造函数\r\n\r\n## 2. 原型链\r\n当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止\r\n这种原型组成的链状结构就是 `原型链`"}]},{"number":14,"title":"【Q014】闭包与作用域链","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/14","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 作用域\r\n`作用域` 是指程序源代码中 **定义变量** 的区域\r\n作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限\r\n\r\n## 2. 作用域链\r\n当访问一个变量时，解释器会首先在当前作用域查找，如果没有找到，就去父作用域找，直到找到该变量或者不在父作用域中，这就是 `作用域链`\r\n\r\n## 3. 闭包\r\n`闭包` 是指有权访问另外一个函数作用域中的变量的 `函数`\r\n闭包是将函数内部和函数外部连接起来的桥梁\r\n\r\n优点：\r\n\r\n- 闭包里的变量不会污染全局，因为变量被封在闭包里\r\n- 所有变量都在闭包里保证了隐私性和私有性\r\n- 可以让这些局部变量保存在内存中，实现变量数据共享\r\n\r\n缺点：\r\n形成闭包即要把一个函数当成值传递，而且该函数还引用这另一个函数的作用域链使得被引用的函数不能被回收，使用不当容易造成内存泄漏\r\n"}]},{"number":15,"title":"【Q015】let、const、var的区别","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/15","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. var\r\n`var` 语句 用于声明一个函数范围或全局范围的变量，并可将其初始化为一个值（可选）。\r\n\r\n用 `var` 声明的变量的作用域是它当前的执行上下文及其闭包（嵌套函数），或者对于声明在任何函数外的变量来说是全局。\r\n`var` 声明的变量，会提升到该作用域的最顶部。\r\n\r\n## 2. let\r\n`let` 语句声明一个块级作用域的局部变量，并可以初始化为一个值（可选）。\r\n\r\n与 `var` 关键字不同的是，`var` 声明的变量作用域是全局或者整个函数块的。\r\n`var` 和 `let` 的另一个重要区别，`let` 声明的变量不会在作用域中被提升，它是在编译时才初始化。\r\n\r\n## 3. const\r\n常量是块级范围的，非常类似用 `let`。但常量的值是无法（通过重新赋值）改变的，也不能被重新声明。\r\n\r\n`const` 声明创建一个值的只读引用。变量标识符不能重新分配，但改变对象的内容。\r\n\r\n## 4. 区别\r\n\r\n- `var` 在全局作用域声明的变量会变成全局变量，例如浏览器环境下挂载在window对象上。`var`和 `let` 不会。\r\n- `var`和 `let` 声明的变量可以重新赋值，`const` 声明的变量只能改变对象的内容。\r\n"}]},{"number":16,"title":"【Q016】JS 中变量声明提升","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/16","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 变量提升\r\n`var` 声明的 **变量** 和 **函数声明** ，会在代码执行前移动到全局代码的开头位置。\r\n```javascript\r\nbla = 2\r\nvar bla;\r\n\r\n// 可以隐式地（implicitly）将以上代码理解为：\r\n\r\nvar bla;\r\nbla = 2;\r\n```\r\n\r\n因此，建议始终在作用域顶部声明变量（全局代码的顶部和函数代码的顶部），这可以清楚知道哪些变量是函数作用域，哪些变量在作用域链上解决。\r\n\r\n重要的是，提升将影响变量声明，而不会影响其值的初始化。仅在运行到赋值语句时初始化变量的值。在此之前，变量的值始终为 `undefined` 。\r\n```javascript\r\nfunction do_something() {\r\n  console.log(bar); // undefined\r\n  var bar = 111;\r\n  console.log(bar); // 111\r\n}\r\n\r\n// 可以隐式地将以上代码理解为：\r\n\r\nfunction do_something() {\r\n  var bar;\r\n  console.log(bar); // undefined\r\n  bar = 111;\r\n  console.log(bar); // 111\r\n}\r\n```"}]},{"number":17,"title":"【Q017】JS 模块化","labels":["javascript"],"body":"理解模块化发展过程，理解 CommonJS，AMD，CMD，UMD，ES6 模块化","url":"https://github.com/kangyana/daily-question/issues/17","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 原生js的模块化\r\n原生js有几个问题：\r\n\r\n- 代码复用\r\n- 全局作用域污染\r\n- 可维护性\r\n\r\n为了解决这些问题，出现了 `命名空间`  和 `匿名闭包 IIFE 模式`，对代码进行封装，并通过提供外部方法来对它们进行访问。\r\n```javascript\r\n// 命名空间\r\nvar namespace = {}\r\nnamespace.add = function(a, b) {\r\n    console.log(a + b)\r\n}\r\nnamespace.add(1, 2)\r\n\r\n// IIEF\r\nvar utils = (function() {\r\n    var module = {}\r\n    module.multiply = function(a, b) {\r\n        console.log(a * b)\r\n    }\r\n    return module\r\n}())\r\nutils.multiply(1,2)\r\n```\r\n\r\n## 2. CommonJS\r\n09年 `CommonJS`（或者称作 CJS）规范推出，在 **NodeJS** 中实现。主要方法是 **exports** 和 **require**。\r\n```javascript\r\n// utils.js 文件\r\nfunction add(a, b) {\r\n    console.log(a + b)\r\n}\r\nmodule.exports.add = add\r\n\r\n// main.js 文件\r\nvar add = require('./utils').add\r\nadd(1, 2)\r\n```\r\n`CJS` 出来以后，服务端的模块概念已经形成，很自然地，大家就想要客户端模块。\r\n但是 `CJS` 是同步的，服务端读取本地硬盘可以很快同步加载完成，但是浏览器同步读取服务器端的模块可能需要很长的时间，浏览器将会处于”假死”状态。\r\n所以出现异步加载 js 文件的 AMD。\r\n\r\n## 3. AMD\r\n`AMD` 是异步模块定义（Asynchronous Module Definition）。\r\n它采用异步方式加载模块，模块的加载不影响它后面语句的运行。\r\n所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。\r\n\r\n```javascript\r\n// utils.js 文件\r\ndefine([], function() {\r\n    return {\r\n        add: function(a, b) {\r\n            console.log(a + b)\r\n        }\r\n    }\r\n})\r\n\r\n// main.js 文件\r\nrequire(['./utils'], function(utils) {\r\n    utils.add(1, 2)\r\n})\r\n```\r\n\r\n由于原生js不支持，使用 `AMD` 规范进行开发需要用到对应的库函数：`RequireJS`。\r\n`requireJS` 主要解决两个问题：\r\n\r\n- 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器\r\n- js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长\r\n\r\n## 4. CMD\r\n\r\n`CMD`（Common Module Definition）是玉伯在开发 `SeaJS` 的时候提出来的，`SeaJS` 要解决的问题和 `RequireJS` 一样。\r\n不同于 AMD 的依赖前置，CMD 是就近依赖。\r\n\r\n```javascript\r\n// AMD\r\nrequire(['./utils', 'a', 'b'], function(utils) {\r\n    console.log(1)\r\n    // 还没有用到 utils a b 等模块，但是 AMD 已经初始化了所有模块\r\n    console.log(2)\r\n    utils.add(1, 2)\r\n})\r\n\r\n// CMD\r\ndefine(function(require, exports, module){\r\n    console.log(1)\r\n    if(false) {\r\n        var utils = require('./utils') // 需要时再 require，不执行就不会加载\r\n        utils.add(1, 2)\r\n    }\r\n})\r\n```\r\n\r\n但是在 `AMD` 也是支持依赖就近，也就是 `CMD` 这样的写法的，所以，`RequireJS` 中，以上两种方式都能执行。\r\n不过，`RequireJS` 官方文档中，默认都是采用依赖前置的写法。\r\n\r\n## 5. UMD\r\n`UMD` 通用模块定义（Universal Module Definition），同时兼容服务端（CJS）和客户端（AMD）的模块化。\r\n\r\n```javascript\r\n// utils.js 文件同上\r\n(function(root, factory) {\r\n    if (typeof define === 'function' && define.amd) {\r\n        //AMD\r\n        define(['utils'], factory)\r\n    } else if (typeof exports === 'object') {\r\n        //CommonJS\r\n        var utils = require('utils')\r\n        module.exports = factory(utils)\r\n    } else {\r\n        root.result = factory(root.utils)\r\n    }\r\n}(this, function(utils) {\r\n    utils.add(1, 2)\r\n}))\r\n```\r\n\r\n## 6. ES6 模块化\r\n`ES6`（ES2015）自带的模块化，使用 **import** 和 **export** 关键字来导入和导出模块。\r\n\r\n```javascript\r\n// utils.js 文件\r\nexport const utils = {\r\n    add: function(a, b) {\r\n        console.log(a + b)\r\n    }\r\n}\r\n\r\n// main.js 文件\r\nimport { utils } from \"./utils\"\r\nutils.add(1, 2)\r\n```\r\n\r\n## 7. CommonJS 和 ES6 的区别\r\n`CommonJS` 模块输出的是一个值的拷贝，`ES6` 模块输出的是值的引用。\r\n`CommonJS` 模块是运行时加载，`ES6` 模块是编译时输出接口。"}]},{"number":18,"title":"【Q018】IIFE 立即执行函数","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/18","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. IIFE 立即调用函数表达式\r\n`IIFE` (Immediately Invoked Function Expression)是一个在定义时就会立即执行的函数。\r\n\r\n```javascript\r\n(function () {\r\n    // to something...\r\n})();\r\n```\r\n这是一个被称为 **自执行匿名函数** 的设计模式，主要包含两部分。\r\n第一部分是包围在 **圆括号运算符** 里的一个匿名函数，这个匿名函数拥有独立的词法作用域。\r\n这不仅避免了外界访问此 `IIFE` 中的变量，而且又不会污染全局作用域。\r\n\r\n## 2. IIFE 的优点\r\n\r\n- `IIFE` 中定义的任何变量和函数，都会在执行结束时被销毁。适合做初始化工作。\r\n- 创建 **块级作用域** ，避免了向全局作用域中添加变量和函数，因此也避免了多人开发中全局变量和函数的命名冲突。\r\n- `IIFE` 中定义的任何变量和函数，都会在执行结束时被销毁。这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了。"}]},{"number":19,"title":"【Q019】匿名函数","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/19","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 什么是匿名函数\r\n\r\n- `匿名函数`，即没有名称的函数\r\n- 如果单独只写一个匿名函数，此时是不符合语法要求的会报错。需要给 `匿名函数` 包裹一个括号，使之成为 **表达式**\r\n- 被小括号包裹的内容会被js识别为一个函数表达式\r\n\r\n## 2. 创建方式\r\n\r\n```javascript\r\n(function () {\r\n      // to something...\r\n}());\r\n```\r\n"}]},{"number":20,"title":"【Q020】箭头函数","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/20","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 箭头函数\r\n`箭头函数表达式` 的语法比 `函数表达式` 更简洁，并且没有自己的 this、arguments、super或new.target。\r\n`箭头函数表达式` 更适用于那些本来需要 `匿名函数` 的地方，并且它不能用作 `构造函数`。\r\n\r\n```javascript\r\nconst materials = [\r\n  'Hydrogen',\r\n  'Helium',\r\n  'Lithium',\r\n  'Beryllium'\r\n];\r\n\r\nconsole.log(materials.map(material => material.length)); // [8, 6, 7, 9]\r\n```\r\n\r\n## 更短的函数\r\n```javascript\r\nvar elements = [\r\n  'Hydrogen',\r\n  'Helium',\r\n  'Lithium',\r\n  'Beryllium'\r\n];\r\n\r\nelements.map(function(element) {\r\n  return element.length;\r\n}); // [8, 6, 7, 9]\r\n\r\n// 上面的普通函数可以改写成如下的箭头函数\r\nelements.map((element) => {\r\n  return element.length;\r\n});\r\n\r\n// 当箭头函数只有一个参数时，可以省略参数的圆括号\r\nelements.map(element => {\r\n return element.length;\r\n});\r\n\r\n// 当箭头函数的函数体只有一个 `return` 语句时，可以省略 `return` 关键字和方法体的花括号\r\nelements.map(element => element.length);\r\n```\r\n\r\n## 没有单独的this\r\n`箭头函数` 不会创建自己的this，它只会从自己的作用域链的上一层继承 `this`。\r\n```javascript\r\nfunction Person(){\r\n  this.age = 0;\r\n\r\n  setInterval(() => {\r\n    this.age++; // this 正确地指向 p 实例\r\n  }, 1000);\r\n}\r\n\r\nvar p = new Person();\r\n```\r\n\r\n## 与严格模式的关系\r\n鉴于 `this` 是词法层面上的，`严格模式` 中与 `this` 相关的规则都将被忽略。\r\n```javascript\r\nvar f = () => { 'use strict'; return this; };\r\nf() === window; // true\r\n```\r\n\r\n## 通过 call 或 apply 调用\r\n由于 `箭头函数` 没有自己的 `this` 指针，通过 call() 、apply()、bind() 方法调用一个函数时，只能传递参数，他们的第一个参数会被忽略。\r\n```javascript\r\nvar adder = {\r\n  base : 1,\r\n\r\n  add : function(a) {\r\n    var f = v => v + this.base;\r\n    return f(a);\r\n  },\r\n\r\n  addThruCall: function(a) {\r\n    var f = v => v + this.base;\r\n    var b = {\r\n      base : 2\r\n    };\r\n\r\n    return f.call(b, a);\r\n  }\r\n};\r\n\r\nconsole.log(adder.add(1));         // 输出 2\r\nconsole.log(adder.addThruCall(1)); // 仍然输出 2\r\n```\r\n\r\n## 不绑定arguments\r\n`箭头函数` 不绑定Arguments 对象。因此，在本示例中，arguments只是引用了封闭作用域内的 arguments：\r\n```javascript\r\nvar arguments = [1, 2, 3];\r\nvar arr = () => arguments[0];\r\n\r\narr(); // 1\r\n\r\nfunction foo(n) {\r\n  var f = () => arguments[0] + n; // 隐式绑定 foo 函数的 arguments 对象. arguments[0] 是 n，即传给 foo 函数的第一个参数\r\n  return f();\r\n}\r\n\r\nfoo(1); // 2\r\nfoo(2); // 4\r\nfoo(3); // 6\r\nfoo(3,2);//6\r\n```\r\n\r\n## 使用 new 操作符\r\n`箭头函数` 不能用作构造器，和 `new` 一起用会抛出错误。\r\n```javascript\r\nvar Foo = () => {};\r\nvar foo = new Foo(); // TypeError: Foo is not a constructor\r\n```\r\n\r\n## 使用prototype属性\r\n箭头函数没有 `prototype` 属性。\r\n```javascript\r\nvar Foo = () => {};\r\nconsole.log(Foo.prototype); // undefined\r\n```\r\n\r\n## 使用 yield 关键字\r\n`yield` 关键字通常不能在 `箭头函数` 中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作函数生成器。\r\n\r\n## 返回对象字面量\r\n记住用 `params => {object:literal}` 这种简单的语法 **返回对象字面量** 是行不通的。\r\n```javascript\r\nvar func = () => { foo: 1 };\r\n// Calling func() returns undefined!\r\n\r\nvar func = () => { foo: function() {} };\r\n// SyntaxError: function statement requires a name\r\n```\r\n\r\n这是因为花括号（`{}`）里面的代码被解析为一系列语句（即 `foo` 被认为是一个标签，而非对象字面量的组成部分）\r\n所以，记得用圆括号把对象字面量包起来：\r\n\r\n```javascript\r\nvar func = () => ({foo: 1});\r\n```\r\n"}]},{"number":21,"title":"【Q021】函数柯里化","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/21","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 柯里化（Currying）\r\n[柯里化（Currying）](https://en.wikipedia.org/wiki/Currying)是一种关于函数的高阶技术。它不仅被用于 JavaScript，还被用于其他编程语言。\r\n`柯里化` 是一种函数的 **转换** ，它是指将一个函数从可调用的 f(a, b, c) 转换为可调用的 f(a)(b)(c)。\r\n`柯里化` 不会调用函数，它只是对函数进行转换。\r\n\r\n```javascript\r\n// 柯里化函数\r\nfunction curry(f) {\r\n  return function(a) {\r\n    return function(b) {\r\n      return f(a, b);\r\n    };\r\n  };\r\n}\r\n\r\n// 求和函数\r\nfunction sum(a, b) {\r\n  return a + b;\r\n}\r\n\r\nconsole.log(curry(sum)(1)(2)) // 3\r\n```\r\n正如你所看到的，实现非常简单：只有两个包装器（wrapper）。\r\n\r\n- curry(func) 的结果就是一个包装器 function(a)。\r\n- 当它被像 curriedSum(1) 这样调用时，它的参数会被保存在词法环境中，然后返回一个新的包装器 function(b)。\r\n- 然后这个包装器被以 2 为参数调用，并且，它将该调用传递给原始的 sum 函数。\r\n\r\n柯里化更高级的实现，例如 lodash 库的 [_.curry](https://lodash.com/docs#curry)，会返回一个包装器，该包装器允许函数被正常调用或者以偏函数（partial）的方式调用：\r\n```javascript\r\nfunction sum(a, b) {\r\n  return a + b;\r\n}\r\n\r\nvar curriedSum = _.curry(sum); // 使用来自 lodash 库的 _.curry\r\nconsole.log(curriedSum(1, 2)); // 3，仍可正常调用\r\nconsole.log(curriedSum(1)(2)); // 3，以偏函数的方式调用\r\n```\r\n\r\n## 2. 柯里化的目的\r\n要了解它的好处，我们需要一个实际中的例子。\r\n\r\n例如，我们有一个用于格式化和输出信息的日志（logging）函数 `log(date, importance, message)`。\r\n在实际项目中，此类函数具有很多有用的功能，例如通过网络发送日志（log）：\r\n```javascript\r\nfunction log(date, importance, message) {\r\n  console.log(`[${date.getHours()}:${date.getMinutes()}] [${importance}] ${message}`);\r\n}\r\n```\r\n\r\n柯里化之后，log 仍正常运行，也可以以柯里化形式运行：\r\n```javascript\r\nlog = _.curry(log);\r\n\r\nlog(new Date(), \"DEBUG\", \"some debug\"); // log(a, b, c)\r\n\r\nlog(new Date())(\"DEBUG\")(\"some debug\"); // log(a)(b)(c)\r\n```\r\n\r\n现在可以轻松地为当前日志创建便捷函数：\r\n```javascript\r\n// logNow 会是带有固定第一个参数的日志的偏函数\r\nvar logNow = log(new Date());\r\n\r\n// 使用它\r\nlogNow(\"INFO\", \"message\"); // [HH:mm] INFO message\r\n```\r\n\r\n现在，logNow 是具有固定第一个参数的 log，换句话说，就是更简短的“偏应用函数（partially applied function）”或“偏函数（partial）”。\r\n\r\n可以更进一步，为当前的调试日志（debug log）提供便捷函数：\r\n```javascript\r\nvar debugNow = logNow(\"DEBUG\");\r\n\r\ndebugNow(\"message\"); // [HH:mm] DEBUG message\r\n```\r\n\r\n总结：\r\n\r\n- 柯里化之后，我们没有丢失任何东西：log 依然可以被正常调用。\r\n- 我们可以轻松地生成偏函数，例如用于生成今天的日志的偏函数。\r\n\r\n## 3. 柯里化的实现\r\n```javascript\r\nfunction curry(func) {\r\n  return function curried(...args) {\r\n    if (args.length >= func.length) {\r\n      return func.apply(this, args);\r\n    } else {\r\n      return function(...args2) {\r\n        return curried.apply(this, args.concat(args2));\r\n      }\r\n    }\r\n  };\r\n}\r\n```\r\n\r\n## 4. 总结\r\n\r\n- `柯里化` 是一种转换，将 f(a,b,c) 转换为可以被以 f(a)(b)(c) 的形式进行调用。JavaScript 实现通常都保持该函数可以被正常调用，并且如果参数数量不足，则返回偏函数。\r\n- `柯里化` 让我们能够更容易地获取偏函数。就像我们在日志记录示例中看到的那样，普通函数 log(date, importance, message) 在被柯里化之后，当我们调用它的时候传入一个参数（如 log(date)）或两个参数（log(date, importance)）时，它会返回偏函数。"}]},{"number":22,"title":"【Q022】Promise","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/22","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. promise\r\n`Promise` 对象用于表示一个异步操作的最终完成（或失败）及其结果值。\r\n异步方法并不会立即返回最终的值，而是会返回一个 promise，以便在未来某个时候把值交给使用者。\r\n\r\n一个 Promise 必然处于以下几种状态之一：\r\n\r\n- 待定（pending）：初始状态，既没有被兑现，也没有被拒绝。\r\n- 已兑现（fulfilled）：意味着操作成功完成。\r\n- 已拒绝（rejected）：意味着操作失败。\r\n\r\n## 2. Promise 的链式调用\r\n因为 `Promise.prototype.then`、`Promise.prototype.catch` 和 `Promise.prototype.finally`方法返回的是 promise，所以它们可以被链式调用。\r\n![Alt](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/promises.png)\r\n\r\n我们用 promise 的 `then` 方法排列起来的相关处理程序就会被调用。\r\n`.then()` 方法需要两个参数，第一个参数作为处理已兑现状态的回调函数，而第二个参数则作为处理已拒绝状态的回调函数。\r\n```javascript\r\nconst myPromise = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    resolve('foo');\r\n  }, 300);\r\n});\r\n\r\nmyPromise\r\n  .then(handleResolvedA, handleRejectedA)\r\n  .then(handleResolvedB, handleRejectedB)\r\n  .then(handleResolvedC, handleRejectedC);\r\n```\r\n\r\n当 `.then()` 中缺少能够返回 promise 对象的函数时，链式调用就直接继续进行下一环操作。\r\n因此，链式调用可以在最后一个 `.catch()` 之前把所有的处理已拒绝状态的回调函数都省略掉。\r\n```javascript\r\nmyPromise\r\n  .then(handleResolvedA)\r\n  .then(handleResolvedB)\r\n  .then(handleResolvedC)\r\n  .catch(handleRejectedAny);\r\n```\r\n\r\n## 3. finally清理\r\n如果你想在 promise 执行完毕后无论其结果怎样都做一些处理或清理时，`.finally()` 方法可能是有用的。\r\n\r\n`.finally()` 虽然与 `.then(onFinally, onFinally)` 类似，它们不同的是：\r\n\r\n- 调用内联函数时，不需要多次声明该函数或为该函数创建一个变量保存它。\r\n- 由于无法知道 promise 的最终状态，所以 finally 的回调函数中不接收任何参数，它仅用于无论最终结果如何都要执行的情况。"}]},{"number":23,"title":"【Q023】async/await","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/23","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. async 函数\r\n`async` 函数是使用 **async关键字** 声明的函数。`async` 函数是 `AsyncFunction` 构造函数的实例， 并且其中允许使用 **await关键字**。\r\n**async和await关键字** 让我们可以用一种更简洁的方式写出基于`Promise` 的异步行为，而无需刻意地链式调用 `promise`。\r\n\r\n在函数前面的 **async关键字** 做了一件事情：使用函数始终返回一个 promise。其他值将自动被包装在一个 resolved 的 promise 中。\r\n```javascript\r\nasync function f() {\r\n  return 1;\r\n}\r\n\r\nasync function f2() {\r\n  return Promise.resolve(1);\r\n}\r\n\r\nf().then(console.log); // 1\r\nf2().then(console.log); // 1\r\n```\r\n\r\n## 2. await 关键字\r\n`await` 让 JavaScript 引擎等待直到 promise 完成（settle）并返回结果。\r\n```javascript\r\nasync function f() {\r\n  var promise = new Promise((resolve, reject) => {\r\n    setTimeout(() => resolve(\"done!\"), 1000)\r\n  });\r\n\r\n  var result = await promise; // 等待，直到 promise resolve (*)\r\n  console.log(result); // \"done!\"\r\n}\r\n\r\nf();\r\n```\r\n这个函数在执行的时候，“暂停”在了` (*)` 那一行，并在 promise settle 时，拿到 `result` 作为结果继续往下执行。\r\n所以上面这段代码在一秒后显示 “done!”。\r\n\r\n强调一下：await 实际上会暂停函数的执行，直到 promise 状态变为 settled，然后以 promise 的结果继续执行。\r\n这个行为不会耗费任何 CPU 资源，因为 JavaScript 引擎可以同时处理其他任务：执行其他脚本，处理事件等。\r\n\r\n相比于 promise.then，它只是获取 promise 的结果的一个更优雅的语法，并且也更易于读写。\r\n\r\n## 3. Error 处理\r\n如果一个 promise 正常 resolve，`await promise` 返回的就是其结果。\r\n但是如果 promise 被 reject，它将 throw 这个 error，就像在这一行有一个 `throw` 语句那样。\r\n\r\n可以在函数调用后面添加 .catch 来处理这个 error：\r\n```javascript\r\nasync function f() {\r\n  var response = await fetch('http://no-such-url/');\r\n}\r\n\r\n// f() 变成了一个 rejected 的 promise\r\nf().catch(console.log); // TypeError: failed to fetch // (*)\r\n```\r\n\r\n## 4. 总结\r\n函数前面的关键字 async 有两个作用：\r\n\r\n- 让这个函数总是返回一个 promise。\r\n- 允许在该函数内使用 await。\r\n\r\nPromise 前的关键字 await 使 JavaScript 引擎等待该 promise settle，然后有两种情况：\r\n\r\n- 如果有 error，就会抛出异常 —— 就像那里调用了 throw error 一样。\r\n- 否则，就返回结果。\r\n\r\n"}]},{"number":24,"title":"【Q024】Generator","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/24","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. function* 生成器函数\r\n`function*` 这种声明方式会定义一个 **生成器函数** (generator function)，它返回一个 `Generator对象`。\r\n```javascript\r\nfunction* generator(i) {\r\n  yield i;\r\n  yield i + 10;\r\n}\r\n\r\nconst gen = generator(10);\r\nconsole.log(gen.next().value); // 10\r\nconsole.log(gen.next().value); // 20\r\n```\r\n\r\n**生成器函数** 在执行时能暂停，后面又能从暂停处继续执行。\r\n\r\n调用一个生成器函数并不会马上执行它里面的语句，而是返回一个这个生成器的 **迭代器（iterator）对象**。\r\n当这个迭代器的 `next()` 方法被调用时，其内的语句会执行到后续出现 `yield` 的位置为止，`yield` 后紧跟迭代器要返回的值。\r\n或者如果用的是 `yield*`，则表示将执行权移交给另一个生成器函数（当前生成器暂停执行）。\r\n\r\n调用 `next()` 方法时，如果传入了参数，那么这个参数会传给**上一条执行的 yield 语句左边的变量**，例如下面例子中的x：\r\n```javascript\r\nfunction *gen(){\r\n    yield 10;\r\n    x = yield 'foo';\r\n    yield x;\r\n}\r\n\r\nvar gen_obj = gen();\r\nconsole.log(gen_obj.next());// 执行 yield 10，返回 10\r\nconsole.log(gen_obj.next());// 执行 yield 'foo'，返回 'foo'\r\nconsole.log(gen_obj.next(100));// 将 100 赋给上一条 yield 'foo' 的左值，即执行 x=100，返回 100\r\nconsole.log(gen_obj.next());// 执行完毕，value 为 undefined，done 为 true\r\n\r\n```\r\n\r\nyield* 的示例：\r\n```javascript\r\nfunction* anotherGenerator(i) {\r\n  yield i + 1;\r\n  yield i + 2;\r\n  yield i + 3;\r\n}\r\n\r\nfunction* generator(i){\r\n  yield i;\r\n  yield* anotherGenerator(i);// 移交执行权\r\n  yield i + 10;\r\n}\r\n\r\nvar gen = generator(10);\r\nconsole.log(gen.next().value); // 10\r\nconsole.log(gen.next().value); // 11\r\nconsole.log(gen.next().value); // 12\r\nconsole.log(gen.next().value); // 13\r\nconsole.log(gen.next().value); // 20\r\n```\r\n\r\n## 2. Generator对象\r\n`生成器对象` 是由一个 `generator function` 返回的。\r\n```javascript\r\nfunction* gen() {\r\n  yield 1;\r\n  yield 2;\r\n  yield 3;\r\n}\r\n\r\nlet g = gen(); // \"Generator { }\"\r\n```\r\n\r\n## 3. 迭代器对象 iterator\r\n挖坑ing"}]},{"number":25,"title":"【Q025】对象遍历 和 数组遍历","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/25","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"# 一. 对象遍历\r\n## 1. for...in\r\n`for...in` 语句以任意顺序迭代一个对象的除[Symbol](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol)以外的[可枚举](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties)属性，包括继承的可枚举属性。\r\n\r\n```javascript\r\nvar obj = {a:1, b:2, c:3};\r\n\r\nfor (var prop in obj) {\r\n  console.log(\"obj.\" + prop + \" = \" + obj[prop]);\r\n}\r\n\r\n// \"obj.a = 1\"\r\n// \"obj.b = 2\"\r\n// \"obj.c = 3\"\r\n```\r\n\r\n`for...in` 还会获取到**原型链上的可枚举属性**，不过可以使用 `hasOwnProperty()` 方法过滤掉。\r\n```javascript\r\nvar triangle = {a: 1, b: 2, c: 3};\r\n\r\nfunction ColoredTriangle() {\r\n  this.color = 'red';\r\n}\r\n\r\nColoredTriangle.prototype = triangle;\r\n\r\nvar obj = new ColoredTriangle();\r\n\r\nfor (var prop in obj) {\r\n  if (obj.hasOwnProperty(prop)) {\r\n    console.log(`obj.${prop} = ${obj[prop]}`);\r\n  }\r\n}\r\n\r\n// \"obj.color = red\"\r\n```\r\n\r\n### 为什么用 for ... in?\r\n\r\n它最常用的地方应该是用于调试，可以更方便的去检查对象属性。\r\n你在处理有key-value数据，需要检查其中的任何键是否为某值的情况时，推荐用 `for...in`。\r\n\r\n## 2. for...of\r\n`for...of`语句在 **可迭代对象**（包括Array，Map，Set，String，TypedArray，arguments） 上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。\r\n\r\n如果使用 `for...of` 遍历对象，需要给对象的原型一个迭代器方法：\r\n```javascript\r\nvar obj = {\r\n    a:1,\r\n    b:2,\r\n    c:3\r\n};\r\n\r\nobj[Symbol.iterator] = function*(){\r\n    var keys = Object.keys(obj);\r\n    for(var k of keys){\r\n        yield k\r\n    }\r\n};\r\n\r\nfor(var k of obj){\r\n    console.log(k, obj[k]);\r\n}\r\n\r\n// 'a' 1\r\n// 'b' 2\r\n// 'c' 3\r\n```\r\n\r\n### for...of与for...in的区别?\r\n\r\n无论是 `for...in` 还是 `for...of` 语句都是迭代一些东西。它们之间的主要区别在于它们的迭代方式。\r\n- `for...in` 可以迭代Object。\r\n- `for...of` 可以迭代Array等其他 **可迭代对象** ，想迭代Object要给一个迭代器属性。\r\n- `for...in` 还会获取到**原型链上的可枚举属性**\r\n\r\n## 3. Object.keys()\r\n`Object.keys()` 方法会返回一个由一个给定对象的自身可枚举 **属性名（key）组成的数组**，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致。\r\n\r\n```javascript\r\nconst object1 = {\r\n  a: 'somestring',\r\n  b: 42,\r\n  c: false\r\n};\r\n\r\nconsole.log(Object.keys(object1)); //  [\"a\", \"b\", \"c\"]\r\n```\r\n注意：\r\n\r\n- 在 ES5 中，如果此方法的参数不是对象（而是一个原始值），那么它会抛出 **TypeError**。\r\n- 在 ES6 中，非对象的参数将被强制转换为一个对象。\r\n\r\n## 4. Object.getOwnPropertyNames()\r\n`Object.getOwnPropertyNames()` 方法返回一个由指定对象的所有自身属性的 **属性名（key）组成的数组**（属性名 包括不可枚举属性但不包括 `Symbol` 值作为名称的属性）。\r\n\r\n```javascript\r\n// 数组对象\r\nvar arr = [\"a\", \"b\", \"c\"];\r\nconsole.log(Object.getOwnPropertyNames(arr).sort()); // [\"0\", \"1\", \"2\", \"length\"]\r\n\r\n// 类数组对象\r\nvar obj = { 0: \"a\", 1: \"b\", 2: \"c\"};\r\nconsole.log(Object.getOwnPropertyNames(obj).sort()); // [\"0\", \"1\", \"2\"]\r\n\r\n//不可枚举属性\r\nvar my_obj = Object.create({}, {\r\n  getFoo: {\r\n    value: function() { return this.foo; },\r\n    enumerable: false\r\n  }\r\n});\r\nmy_obj.foo = 1;\r\nconsole.log(Object.getOwnPropertyNames(my_obj).sort()); // [\"foo\", \"getFoo\"]\r\n```\r\n\r\n### 如果你只要获取到可枚举属性，请使用 `Object.keys` 或用 `for...in` 循环。\r\n\r\n## 5. Object.getOwnPropertySymbols()\r\n`Object.getOwnPropertySymbols()` 方法返回一个给定对象自身的所有 `Symbol` 属性的数组。\r\n\r\n```javascript\r\nvar obj = {};\r\nvar a = Symbol(\"a\");\r\nvar b = Symbol.for(\"b\");\r\n\r\nobj[a] = \"localSymbol\";\r\nobj[b] = \"globalSymbol\";\r\n\r\nvar objectSymbols = Object.getOwnPropertySymbols(obj);\r\n\r\nconsole.log(objectSymbols.length); // 2\r\nconsole.log(objectSymbols)         // [Symbol(a), Symbol(b)]\r\nconsole.log(objectSymbols[0])      // Symbol(a)\r\n```\r\n\r\n### 与 `Object.getOwnPropertyNames()` 类似，您可以将给定对象的所有符号属性作为 `Symbol` 数组获取。\r\n请注意，`Object.getOwnPropertyNames()` 本身不包含对象的 `Symbol` 属性，只包含字符串属性。\r\n\r\n因为所有的对象在初始化的时候不会包含任何的 `Symbol`，除非你在对象上赋值了 `Symbol` 否则Object.getOwnPropertySymbols()只会返回一个空的数组。\r\n\r\n## 6. Reflect.ownKeys()\r\n`Reflect.ownKeys()` 返回一个由目标对象自身的**属性键（key）组成的数组**。\r\n```javascript\r\nconst object1 = {\r\n  property1: 42,\r\n  property2: 13\r\n};\r\n\r\nconst array1 = [];\r\n\r\nconsole.log(Reflect.ownKeys(object1)); // [\"property1\", \"property2\"]\r\nconsole.log(Reflect.ownKeys(array1)); //  [\"length\"]\r\n```\r\n\r\n### Reflect.ownKeys 方法返回一个由目标对象自身的属性键组成的数组。它的返回值等同于`Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))`。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"# 二、数组遍历\r\n## 1. for 循环\r\n`for循环` 很古老，它在 ECMAScript 1 中就已经存在了。for 循环记录 arr 每个元素的索引和值：\r\n```javascript\r\nconst arr = ['a', 'b', 'c'];\r\narr.prop = 'property value';\r\n\r\nfor (let index=0; index < arr.length; index++) {\r\n  const elem = arr[index];\r\n  console.log(index, elem);\r\n}\r\n\r\n// 0, 'a'\r\n// 1, 'b'\r\n// 2, 'c'\r\n```\r\n\r\n### for 循环的优缺点是什么？\r\n\r\n- 优：它用途广泛。\r\n- 缺：但是当我们要遍历数组时也很麻烦。\r\n- 优：如果我们不想从第一个数组元素开始循环时它仍然很有用，用其他的循环机制很难做到这一点。\r\n\r\n## 2. for-in循环\r\n`for-in循环` 与 `for循环` 一样古老，同样在 ECMAScript 1中就存在了。下面的代码用 for-in 循环输出 arr 的 key：\r\n```javascript\r\nconst arr = ['a', 'b', 'c'];\r\narr.prop = 'property value';\r\n\r\nfor (const key in arr) {\r\n  console.log(key);\r\n}\r\n\r\n// '0'\r\n// '1'\r\n// '2'\r\n// 'prop'\r\n```\r\n\r\n### for-in 不是循环遍历数组的好方法：\r\n\r\n- 它访问的是属性键（key），而不是值（value）。\r\n- 作为属性键（key），数组元素的索引是字符串，而不是数字。\r\n- 它访问的是所有可枚举的属性键（自己的和继承的），而不仅仅是 `Array` 元素的那些。\r\n\r\n### for-in 访问继承属性的实际用途是：遍历对象的所有可枚举属性。\r\n\r\n## 3. 数组方法 .forEach()\r\n鉴于 `for` 和 `for-in` 都不特别适合在数组上循环，因此在 ECMAScript 5 中引入了一个辅助方法：Array.prototype.forEach()：\r\n```javascript\r\nconst arr = ['a', 'b', 'c'];\r\narr.prop = 'property value';\r\n\r\narr.forEach((elem, index) => {\r\n  console.log(elem, index);\r\n});\r\n\r\n// 'a', 0\r\n// 'b', 1\r\n// 'c', 2\r\n```\r\n\r\n### forEach 循环的优缺点是什么？\r\n\r\n- 优：它使我们无需执行大量操作就能够可访问数组元素和索引。\r\n- 缺：不能在它的循环体中使用 `await`。\r\n- 缺：不能提前退出 `forEach()循环`。而在 `for循环` 中可以使用 `break`。\r\n\r\n### 中止 .forEach() 的解决方法\r\n\r\n## 4. 数组方法 .some()\r\n如果想要中止 `.forEach()` 之类的循环，建议使用：`.some()` \r\n`.some()` 还会循环遍历所有数组元素，并在其回调返回真值时停止。\r\n```javascript\r\nconst arr = ['red', 'green', 'blue'];\r\narr.some((elem, index) => {\r\n  if (index >= 2) {\r\n    return true; // 中止循环\r\n  }\r\n  console.log(elem);\r\n  //此回调隐式返回 `undefined`，这\r\n  //是一个伪值。 因此，循环继续。\r\n});\r\n\r\n// 'red'\r\n// 'green'\r\n```\r\n\r\n## 5. for-of 循环\r\nfor-of 循环在 ECMAScript 6 开始支持：\r\n\r\n```javascript\r\nconst arr = ['a', 'b', 'c'];\r\narr.prop = 'property value';\r\n\r\nfor (const elem of arr) {\r\n  console.log(elem);\r\n}\r\n\r\n// 'a'\r\n// 'b'\r\n// 'c'\r\n```\r\n\r\n### for-of 在循环遍历数组时非常有效：\r\n\r\n- 用来遍历数组元素。\r\n- 可以使用 `await`。\r\n- 可以将 `break` 和 `continue` 用于外部作用域。\r\n\r\n## 6. 总结\r\n`for-of` 循环的可用性比 `for`，`for-in` 和 `.forEach()` 更好。\r\n\r\n通常四种循环机制之间的性能差异应该是无关紧要。\r\n如果你要做一些运算量很大的事，还是切换到 `WebAssembly` 更好一些。\r\n\r\n"}]},{"number":26,"title":"【Q026】常见的数组方法","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/26","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"# 一、数组遍历相关\r\n## 1. Array.prototype.entries()\r\n`entries()` 方法返回一个新的 **Array Iterator** 对象，该对象包含数组中每个索引的键/值对。\r\n```javascript\r\nconst array1 = ['a', 'b', 'c'];\r\nconst iterator1 = array1.entries();\r\n\r\nconsole.log(iterator1.next().value); // [0, \"a\"]\r\nconsole.log(iterator1.next().value); // [1, \"b\"]\r\n```\r\n\r\n### 常用于与 `for...of` 构成数组遍历：\r\n```javascript\r\nconst a = [\"a\", \"b\", \"c\"];\r\n\r\nfor (const [index, element] of a.entries()) {\r\n    console.log(index, element);\r\n}\r\n\r\n// 0 'a'\r\n// 1 'b'\r\n// 2 'c'\r\n```\r\n\r\n## 2. Array.prototype.every()\r\n`every()` 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。\r\n\r\n备注： 若收到一个空数组，此方法在任何情况下都会返回 true。\r\n\r\n```javascript\r\nconst array1 = [1, 30, 39, 29, 10, 13];\r\n\r\nconst flag = array1.every((item) => item < 40);\r\nconsole.log(flag); // true\r\n```\r\n\r\n### 常用于判断每一项都符合条件\r\n\r\n## 3. Array.prototype.filter()\r\n`filter()` 方法创建给定数组一部分的 `浅拷贝`，其包含通过所提供函数实现的测试的所有元素。\r\n```javascript\r\nconst words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];\r\n\r\nconst result = words.filter(word => word.length > 6);\r\nconsole.log(result); // [\"exuberant\", \"destruction\", \"present\"]\r\n```\r\n\r\n### 常用于筛选数组\r\n\r\n## 4. Array.prototype.flat()\r\n`flat()` 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。\r\n\r\n根据参数提取嵌套数组的结构深度，默认值为 1：\r\n```javascript\r\nconst arr1 = [0, 1, 2, [3, 4], [[5, 6]]];\r\n\r\nconsole.log(arr1.flat()); // [0, 1, 2, 3, 4, [5, 6]]\r\nconsole.log(arr1.flat(2)); // [0, 1, 2, 3, 4, 5, 6]\r\n```\r\n\r\n还可以移除数组中的空项：\r\n```javascript\r\nvar arr4 = [1, 2, , 4, 5];\r\n\r\nconsole.log(arr4.flat()); // [1, 2, 4, 5]\r\n````\r\n\r\n### 常用于数组降维\r\n\r\n## 5. Array.prototype.flatMap()\r\n`flatMap()` 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。\r\n它与 `map` 连着深度值为 1 的 `flat` 的效果几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些。\r\n\r\n```javascript\r\nconst arr1 = [1, 2, [3], [4, 5], 6, []];\r\n\r\nconsole.log(arr1.flatMap(num => num)); // [1, 2, 3, 4, 5, 6]\r\n// 效果等同于\r\nconsole.log(arr1.map(num => num).flat()) // [1, 2, 3, 4, 5, 6]\r\n```\r\n\r\n### 可用于 需要在 `map()` 时 **插入/减少** 某一项\r\n```javascript\r\nvar a = [5, 4, -3, 20, 17, -33, -4, 18]\r\n\r\na.flatMap((n) => {\r\n  if (n < 0) return [];\r\n  if (n % 2 == 0) return [n];\r\n  return [n-1, 1]\r\n})\r\n\r\nconsole.log(a); // [4, 1, 4, 20, 16, 1, 18]\r\n```\r\n\r\n替代方案（低效，不推荐）：\r\n\r\n`reduce()` 加 `concat()`\r\n```javascript\r\nvar arr = [1, 2, 3, 4];\r\n\r\narr.flatMap(x => [x, x * 2]); // [1, 2, 2, 4, 3, 6, 4, 8]\r\n// \r\narr.reduce((acc, x) => acc.concat([x, x * 2]), []); // [1, 2, 2, 4, 3, 6, 4, 8]\r\n```\r\n\r\n## 6. Array.prototype.forEach()\r\n`forEach()` 方法对数组的每个元素执行一次给定的函数。\r\n```javascript\r\nconst array1 = ['a', 'b', 'c'];\r\n\r\narray1.forEach(element => console.log(element));\r\n\r\n// \"a\"\r\n// \"b\"\r\n// \"c\"\r\n```\r\n\r\n`forEach` 不会直接改变调用它的对象，但是那个对象可能会被 `callbackFn` 函数改变。\r\n\r\n备注：除了抛出异常以外，没有办法中止或跳出 forEach() 循环。\r\n\r\n若你需要提前终止循环，你可以使用：\r\n\r\n- for循环\r\n- for...in/for...of 循环\r\n- Array.prototype.every()\r\n- Array.prototype.some()\r\n- Array.prototype.find()\r\n- Array.prototype.findIndex()\r\n\r\n最后四个方法，甚至可以对数组元素判断，以便确定是否需要继续遍历。\r\n\r\n### 常用于 *不需要异步* 且 *不需要提前跳出* 的数组循环。\r\n\r\n## 7. Array.prototype.keys()\r\n`keys()` 方法返回一个包含数组中每个索引键的 `Array Iterator` 对象。\r\n```javascript\r\nconst array1 = ['a', 'b', 'c'];\r\nconst iterator = array1.keys();\r\n\r\nfor (const key of iterator) {\r\n  console.log(key);\r\n}\r\n\r\n// 0\r\n// 1\r\n// 2\r\n```\r\n\r\n### 此方法很少使用\r\n\r\n## 8. Array.prototype.map()\r\n`map()` 方法 **创建一个新数组**，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。\r\n```javascript\r\nconst array1 = [1, 4, 9, 16];\r\n\r\nconsole.log(array1.map(x => x * 2)); // [2, 8, 18, 32]\r\n```\r\n\r\n若你不想返回的新数组，请使用 `forEach()` 或 `for...of`。\r\n\r\n### 常用于 遍历修改某一项 且 创建新数组。\r\n\r\n### 经典八股文：\r\n```javascript\r\n[\"1\", \"2\", \"3\"].map(parseInt); \r\n```\r\n我们期望输出 [1, 2, 3], 而实际结果是 [1, NaN, NaN]\r\n\r\n`parseInt` 经常被带着一个参数使用，但是这里接受两个。\r\n第一个参数是一个表达式而第二个是回调函数的基，`Array.prototype.map` 传递 3 个参数：element，index，array\r\n\r\n第三个参数被 `parseInt` 忽视了，但不是第二个。因此可能出现混淆。\r\n下面是迭代步骤的拆解：\r\n```javascript\r\nparseInt(\"1\", 0); // 1\r\nparseInt(\"2\", 1); // NaN\r\nparseInt(\"3\", 2); // NaN\r\n```\r\n\r\n## 9. Array.prototype.reduce()\r\n`reduce()` 方法对数组中的每个元素按序执行一个由您提供的 **reducer** 函数。\r\n每一次运行 **reducer** 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。\r\n```javascript\r\nconst array1 = [1, 2, 3, 4];\r\n\r\n// 求和\r\nconst initialValue = 0;\r\nconst sum = array1.reduce((prev, cur) => prev + cur, initialValue);\r\n\r\nconsole.log(sum); // 10\r\n```\r\n\r\n### 常用于累加对象数组里的值，例如求和\r\n\r\n数组去重\r\n```javascript\r\nvar arrary1 = ['a', 'b', 'a', 'b', 'c', 'e', 'e', 'c', 'd', 'd', 'd', 'd']\r\n\r\nvar array2 = arrary1.reduce((prev, cur) => {\r\n  if (prev.indexOf(cur) === -1) prev.push(cur)\r\n  return prev\r\n}, [])\r\n\r\nconsole.log(array2); // ['a', 'b', 'c', 'e', 'd']\r\n```\r\n\r\n对象数组分组\r\n```javascript\r\nvar array1 = [\r\n  { type: 'fruit', name: 'apple' },\r\n  { type: 'vegetable', name: 'tomato' },\r\n  { type: 'fruit', name: 'mango' },\r\n]\r\n\r\nconst dictionary = {};\r\n\r\narray1.reduce((prev, cur) => {\r\n  if (prev[cur.type]) {\r\n    prev[cur.type].push(cur)\r\n  } else {\r\n    prev[cur.type] = [cur]\r\n  }\r\n  return prev\r\n}, dictionary)\r\n\r\nconsole.log(dictionary); // {fruit: Array(2), vegetable: Array(1)}\r\n```\r\n\r\n## 10. Array.prototype.reduceRight()\r\n`reduceRight()` 方法接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。\r\n```javascript\r\nconst array1 = [[0, 1], [2, 3], [4, 5]];\r\n\r\nconst result = array1.reduceRight((acc, cur) => acc.concat(cur));\r\nconsole.log(result); // [4, 5, 2, 3, 0, 1]\r\n```\r\n\r\n### `reduce` 与 `reduceRight` 之间的区别：正序遍历和倒序遍历\r\n```javascript\r\nvar a = ['1', '2', '3', '4', '5'];\r\nvar left  = a.reduce((prev, cur) => prev + cur);\r\nvar right = a.reduceRight((prev, cur) => prev + cur);\r\n\r\nconsole.log(left);  // \"12345\"\r\nconsole.log(right); // \"54321\"\r\n```\r\n\r\n## 11. Array.prototype.some()\r\n`some()` 方法测试数组中是不是至少有 1 个元素通过了被提供的函数测试。它返回的是一个 `Boolean` 类型的值。\r\n```javascript\r\nconst array = [1, 2, 3, 4, 5];\r\n\r\nconsole.log(array.some((item) => item % 2 === 0)); // true\r\n```\r\n\r\n备注： 如果用一个空数组进行测试，在任何情况下它返回的都是false。\r\n\r\n### 常用于检查数组是否存在不符合条件的值。（性能推荐，找到第一个值就跳出循环）\r\n\r\n## 12. Array.prototype.values()\r\n`values()` 方法返回一个新的 `Array Iterator` 对象，该对象包含数组每个索引的值。\r\n```javascript\r\nconst array1 = ['a', 'b', 'c'];\r\nconst iterator = array1.values();\r\n\r\nfor (const value of iterator) {\r\n  console.log(value);\r\n}\r\n\r\n// \"a\"\r\n// \"b\"\r\n// \"c\"\r\n```\r\n\r\n### 与 `key()` 方法一样很少被使用\r\n\r\n## 13. Array.prototype[@@iterator]()\r\n`@@iterator` 和 `values()` 的初始值是同一个函数对象。\r\n\r\n### 同 `values()` 方法使用"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"# 二、数组增删改\r\n## 1. Array.prototype.concat()\r\n`concat()` 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。\r\n```javascript\r\nconst array1 = ['a', 'b', 'c'];\r\nconst array2 = ['d', 'e', 'f'];\r\nconst array3 = array1.concat(array2);\r\n\r\nconsole.log(array3); // [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]\r\n```\r\n\r\n### 常用于合并数组\r\n\r\n使用 Symbol.isConcatSpreadable 合并类数组对象\r\n`concat` 默认情况下不会将类数组对象视作数组——仅在 `Symbol.isConcatSpreadable` 被设置为真值（例如，true）时才会将类数组对象视作数组。\r\n```javascript\r\nconst obj1 = { 0: 1, 1: 2, 2: 3, length: 3 };\r\nconst obj2 = { 0: 1, 1: 2, 2: 3, length: 3, [Symbol.isConcatSpreadable]: true };\r\n\r\nconsole.log([0].concat(obj1, obj2)); // [ 0, { '0': 1, '1': 2, '2': 3, length: 3 }, 1, 2, 3 ]\r\n```\r\n\r\n## 2. Array.prototype.copyWithin()\r\n`copyWithin()` 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。\r\n```javascript\r\nconst array1 = ['a', 'b', 'c', 'd', 'e'];\r\n\r\nconsole.log(array1.copyWithin(0, 3, 4)); // [\"d\", \"b\", \"c\", \"d\", \"e\"]\r\nconsole.log(array1.copyWithin(1, 3)); // [\"d\", \"d\", \"e\", \"d\", \"e\"]\r\n```\r\n\r\n### `copyWithin` 就像 C 和 C++ 的 `memcpy` 函数一样，且它是用来移动 `Array` 或者 `TypedArray` 数据的一个高性能的方法。\r\n复制以及粘贴序列这两者是为一体的操作;即使复制和粘贴区域重叠，粘贴的序列也会有拷贝来的值。\r\n\r\n## 3. Array.prototype.fill()\r\n`fill()` 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。\r\n```javascript\r\nconst array1 = [1, 2, 3, 4];\r\n\r\nconsole.log(array1.fill(0, 2, 4)); // [1, 2, 0, 0]\r\nconsole.log(array1.fill(5, 1)); // [1, 5, 5, 5]\r\nconsole.log(array1.fill(6)); // [6, 6, 6, 6]\r\n```\r\n\r\n### 常用于快速填充数组\r\n\r\n## 4. Array.prototype.pop()\r\n`pop()` 方法从数组中删除最后一个元素，并返回该元素的值。此方法会更改数组的长度。\r\n```javascript\r\nconst plants = ['broccoli', 'cauliflower', 'cabbage', 'kale', 'tomato'];\r\n\r\nconsole.log(plants.pop()); // \"tomato\"\r\nconsole.log(plants); // [\"broccoli\", \"cauliflower\", \"cabbage\", \"kale\"]\r\n\r\nplants.pop();\r\nconsole.log(plants); // [\"broccoli\", \"cauliflower\", \"cabbage\"]\r\n```\r\n\r\n### 常用于删除掉数组的最后一位\r\n\r\n## 5. Array.prototype.push()\r\n`push()` 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。\r\n```javascript\r\nconst animals = ['pigs', 'goats', 'sheep'];\r\n\r\nconst count = animals.push('cows');\r\nconsole.log(count); // 4\r\nconsole.log(animals); // [\"pigs\", \"goats\", \"sheep\", \"cows\"]\r\n\r\nanimals.push('chickens', 'cats', 'dogs');\r\nconsole.log(animals); // [\"pigs\", \"goats\", \"sheep\", \"cows\", \"chickens\", \"cats\", \"dogs\"]\r\n```\r\n\r\n### 常用于给数组添加元素\r\n\r\n合并两个数组\r\n```javascript\r\nvar vegetables = ['parsnip', 'potato'];\r\nvar moreVegs = ['celery', 'beetroot'];\r\n\r\n// 相当于 vegetables.push(...moreVegs);\r\nArray.prototype.push.apply(vegetables, moreVegs);\r\n\r\nconsole.log(vegetables); // ['parsnip', 'potato', 'celery', 'beetroot']\r\n```\r\n\r\n像数组一样使用对象\r\n`push` 是特意设计为通用的，我们可以使用它来获得便利。\r\n```javascript\r\nvar obj = {\r\n    length: 0,\r\n\r\n    addElem: function addElem (elem) {\r\n        // obj.length is automatically incremented\r\n        // every time an element is added.\r\n        [].push.call(this, elem);\r\n    }\r\n};\r\n\r\nobj.addElem({});\r\nobj.addElem({});\r\n\r\nconsole.log(obj.length); // 2\r\nconsole.log(obj); // {0: {}, 1: {}, length: 2, addElem: ƒ}\r\n```\r\n\r\n## 6. Array.prototype.shift()\r\n`shift()` 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。\r\n```javascript\r\nconst array1 = [1, 2, 3];\r\n\r\nconst firstElement = array1.shift();\r\n\r\nconsole.log(array1); // [2, 3]\r\nconsole.log(firstElement); // 1\r\n```\r\n\r\n### 常用于删除数组中第一位\r\n\r\n## 7. Array.prototype.slice()\r\n`slice()` 方法返回一个新的数组对象，这一对象是一个由 `begin` 和 `end` 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。\r\n```javascript\r\nconst animals = ['ant', 'bison', 'camel', 'duck', 'elephant'];\r\n\r\nconsole.log(animals.slice(2)); // [\"camel\", \"duck\", \"elephant\"]\r\nconsole.log(animals.slice(2, 4)); // [\"camel\", \"duck\"]\r\nconsole.log(animals.slice(1, 5)); // [\"bison\", \"camel\", \"duck\", \"elephant\"]\r\nconsole.log(animals.slice(-2)); // [\"duck\", \"elephant\"]\r\nconsole.log(animals.slice(2, -1)); // [\"camel\", \"duck\"]\r\nconsole.log(animals.slice()); // [\"ant\", \"bison\", \"camel\", \"duck\", \"elephant\"]\r\n```\r\n\r\n### 常用于截取数组\r\n\r\n类数组对象转数组\r\n```javascript\r\nfunction list() {\r\n  return Array.prototype.slice.call(arguments);\r\n}\r\n\r\nvar list1 = list(1, 2, 3); // [1, 2, 3]\r\n```\r\n除了使用 `Array.prototype.slice.call(arguments)`，你也可以简单的使用 `[].slice.call(arguments) 来代替`。另外，你可以使用 `bind` 来简化该过程。\r\n```javascript\r\nfunction list() {\r\n  return Function.prototype.call.bind(Array.prototype.slice)(arguments);\r\n}\r\n\r\nvar list1 = list(1, 2, 3); // [1, 2, 3]\r\n```\r\n\r\n## 8. Array.prototype.splice()\r\n`splice()` 方法通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容。此方法会改变原数组。\r\n```javascript\r\nconst months = ['Jan', 'March', 'April', 'June'];\r\nmonths.splice(1, 0, 'Feb');\r\n\r\nconsole.log(months); // [\"Jan\", \"Feb\", \"March\", \"April\", \"June\"]\r\n\r\nmonths.splice(4, 1, 'May');\r\n\r\nconsole.log(months); // [\"Jan\", \"Feb\", \"March\", \"April\", \"May\"]\r\n```\r\n\r\n### 常用于替换数组中某一段\r\n\r\n## 9. Array.prototype.unshift()\r\n`unshift()` 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度。\r\n```javascript\r\nconst array1 = [1, 2, 3];\r\n\r\nconsole.log(array1.unshift(4, 5)); // 5\r\nconsole.log(array1); // [4, 5, 1, 2, 3]\r\n```\r\n\r\n### 常用于添加多个元素到数组开头"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"# 3. 数组查询\r\n## 1. Array.prototype.at()\r\n`at()` 方法接收一个整数值并返回该索引的项目，允许正数和负数。负整数从数组中的最后一个项目开始倒数。\r\n```javascript\r\nconst array1 = [5, 12, 8, 130, 44];\r\n\r\nlet index = 2;\r\nconsole.log(`${index}: ${array1.at(index)}`); // \"2: 8\"\r\n\r\nindex = -2;\r\nconsole.log(`${index}: ${array1.at(index)}`); // \"-2: 130\"\r\n```\r\n\r\n### 常用于快速寻找数组最后一个值\r\n\r\n比较不同的数组方法\r\n这个例子比较了选择 `Array` 中倒数第二项的不同方法，凸显了 `at()` 方法的简洁性和可读性。\r\n```javascript\r\n// 数组及数组元素。\r\nconst colors = ['red', 'green', 'blue'];\r\n\r\n// 使用长度属性。\r\nconst lengthWay = colors[colors.length-2];\r\nconsole.log(lengthWay); // 'green'\r\n\r\n// 使用 slice() 方法。注意会返回一个数组。\r\nconst sliceWay = colors.slice(-2, -1);\r\nconsole.log(sliceWay[0]); // 'green'\r\n\r\n// 使用 at() 方法。\r\nconst atWay = colors.at(-2);\r\nconsole.log(atWay); // 'green'\r\n```\r\n\r\n## 2. Array.prototype.find()\r\n`find()` 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 `undefined`。\r\n```javascript\r\nconst array1 = [5, 12, 8, 130, 44];\r\n\r\nconst found = array1.find(element => element > 10);\r\nconsole.log(found); // 12\r\n```\r\n\r\n### 常用于 用对象的属性查找数组里的对象\r\n```javascript\r\nconst inventory = [\r\n  {name: 'apples', quantity: 2},\r\n  {name: 'bananas', quantity: 0},\r\n  {name: 'cherries', quantity: 5}\r\n];\r\n\r\nvar item = inventory.find(item => item.name === 'cherries');\r\nconsole.log(item); // { name: 'cherries', quantity: 5 }\r\n```\r\n\r\n## 3. Array.prototype.findIndex()\r\n`findIndex()` 方法返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1。\r\n```javascript\r\nconst array1 = [5, 12, 8, 130, 44];\r\n\r\nconst index = array1.findIndex(element => element > 13);\r\nconsole.log(index); // 3\r\n```\r\n\r\n### 常用于 查找数组中第一个匹配元素的索引。\r\n\r\n## 4. Array.prototype.findLast()\r\n`findLast()` 方法返回数组中满足提供的测试函数条件的最后一个元素的值。如果没有找到对应元素，则返回 `undefined`。\r\n```javascript\r\nconst array1 = [5, 12, 8, 130, 44];\r\n\r\nconst item = array1.findLast(element => element > 13);\r\nconsole.log(item); // 44\r\n```\r\n\r\n### 常用于 查找数组中最后一个匹配元素。\r\n\r\n## 5. Array.prototype.findLastIndex()\r\n`findLastIndex()` 方法返回数组中满足提供的测试函数条件的最后一个元素的索引。若没有找到对应元素，则返回 -1。\r\n```javascript\r\nconst array1 = [5, 12, 8, 130, 44];\r\n\r\nconst item = array1.findLastIndex(element => element > 13);\r\nconsole.log(item); // 4\r\n```\r\n\r\n### 常用于 查找数组中最后一个匹配元素的索引。\r\n\r\n## 6. Array.prototype.includes()\r\n`includes()` 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 `true`，否则返回 `false`。\r\n```javascript\r\nconst array1 = [1, 2, 3];\r\n\r\nconsole.log(array1.includes(2)); // true\r\n\r\nconst pets = ['cat', 'dog', 'bat'];\r\n\r\nconsole.log(pets.includes('cat')); // true\r\nconsole.log(pets.includes('at')); // false\r\n```\r\n\r\n`includes()` 方法有意设计为通用方法。它不要求this值是数组对象，所以它可以被用于其他类型的对象 (比如类数组对象)。\r\n```javascript\r\n(function() {\r\n  console.log([].includes.call(arguments, 'a')); // true\r\n  console.log([].includes.call(arguments, 'd')); // false\r\n})('a','b','c');\r\n···\r\n\r\n### 常用于 快速查找一个值是否包含在该数组中。\r\n\r\n## 7. Array.prototype.indexOf()\r\n`indexOf()` 方法返回在数组中可以找到给定元素的第一个索引，如果不存在，则返回 -1。\r\n```javascript\r\nconst beasts = ['ant', 'bison', 'camel', 'duck', 'bison'];\r\n\r\nconsole.log(beasts.indexOf('bison')); // 1\r\nconsole.log(beasts.indexOf('bison', 2)); // 4\r\nconsole.log(beasts.indexOf('giraffe')); // -1\r\n```\r\n\r\n### 常用于 快速查找数组中第一个匹配元素的索引。\r\n\r\n## 8. Array.prototype.lastIndexOf()\r\n`lastIndexOf()` 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。\r\n从数组的后面向前查找，从 `fromIndex` 处开始。\r\n```javascript\r\nconst animals = ['Dodo', 'Tiger', 'Penguin', 'Dodo'];\r\n\r\nconsole.log(animals.lastIndexOf('Dodo')); // 3\r\nconsole.log(animals.lastIndexOf('Tiger')); // 1\r\n```\r\n\r\n### 常用于 快速查找数组中最后一个匹配元素的索引。\r\n\r\n## 9. 总结\r\n如果你需要查找的方法：\r\n\r\n- 第一个匹配的元素，使用 `find()`。\r\n- 最后一个匹配的元素，使用 `findLast()`。\r\n- 第一个匹配元素的索引，使用 `findIndex()`。\r\n- 最后一个匹配元素的索引，使用 `findLastIndex()`。\r\n- 纯粹查第一个匹配的索引，使用 `indexOf()`。它类似于 `findIndex()`，但是会检查每个元素是否和值相等，而不是使用一个测试函数。\r\n- 纯粹查最后一个匹配的索引，使用 `lastIndexOf()`。\r\n- 一个值是否包含在该数组中，使用 `includes()`。同样地，它检查每个元素是否和值相等，而不是使用一个测试函数。\r\n- 是否有任意一个元素满足提供的测试函数，使用 `some()`。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"# 4. 数组创建\r\n## 1. Array.of()\r\n`Array.of()` 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。\r\n\r\n### `Array.of()` 和 `Array` 构造函数之间的区别在于处理整数参数：\r\nArray.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个长度为 7 的空数组。\r\n```javascrpt\r\nArray.of(7); // [7]\r\nArray(7); // [empty × 7]\r\n\r\nArray.of(1, 2, 3); // [1, 2, 3]\r\nArray(1, 2, 3);    // [1, 2, 3]\r\n```\r\n\r\n## 2. Array.from()\r\n`Array.from()` 方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。\r\n```javascript\r\nconsole.log(Array.from('foo')); // [\"f\", \"o\", \"o\"]\r\n\r\nconsole.log(Array.from([1, 2, 3], x => x + x)); // [2, 4, 6]\r\n```\r\n\r\n### 常用于 根据指定数据创建数组\r\n\r\n数组去重合并\r\n```javascript\r\nfunction combine(){\r\n    let arr = [].concat.apply([], arguments);  // 没有去重复的新数组\r\n    return Array.from(new Set(arr));\r\n}\r\n\r\nvar m = [1, 2, 2];\r\nvar n = [2, 3, 3];\r\nconsole.log(combine(m,n)); // [1, 2, 3]\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"# 5. 其他\r\n## 1. Array.isArray()\r\n`Array.isArray()` 用于确定传递的值是否是一个 `Array`。\r\n```javascript\r\nArray.isArray([1, 2, 3]);  // true\r\nArray.isArray({foo: 123}); // false\r\nArray.isArray('foobar');   // false\r\nArray.isArray(undefined);  // false\r\n```\r\n\r\n### `Array.isArray()` 和 `instanceof` 的区别\r\n当检测 `Array` 实例时，`Array.isArray` 优于 `instanceof`，因为 `Array.isArray` 能检测 `iframes`。\r\n```javascript\r\nconst iframe = document.createElement('iframe');\r\ndocument.body.appendChild(iframe);\r\nxArray = window.frames[window.frames.length-1].Array;\r\nconst arr = new xArray(1,2,3); // [1,2,3]\r\n\r\n// 正确检查 Array\r\nArray.isArray(arr);  // true\r\n// Considered harmful, because doesn't work through iframes\r\narr instanceof Array; // false\r\n```\r\n\r\n### 常用于 精准的判断数据类型是否为数组\r\n\r\n## 2. Array.prototype.join()\r\n`join()` 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。\r\n如果数组只有一个项目，那么将返回该项目而不使用分隔符。\r\n```javascript\r\nconst elements = ['Fire', 'Air', 'Water'];\r\n\r\nconsole.log(elements.join()); // \"Fire,Air,Water\"\r\nconsole.log(elements.join('')); // \"FireAirWater\"\r\nconsole.log(elements.join('-')); // \"Fire-Air-Water\"\r\n```\r\n\r\n警告： 如果一个元素为 `undefined` 或 `null`，它会被转换为空字符串。\r\n\r\n### 常用于拼接字符串\r\n\r\n## 3. Array.prototype.reverse()\r\n`reverse()` 方法将数组中元素的位置颠倒，并返回该数组。\r\n该方法会改变原数组。\r\n```javascript\r\nconst array1 = ['one', 'two', 'three'];\r\n\r\nconst reversed = array1.reverse();\r\nconsole.log('reversed:', reversed); // [\"three\", \"two\", \"one\"]\r\nconsole.log('array1:', array1); // [\"three\", \"two\", \"one\"]\r\n```\r\n\r\n### 常用于数组反转排序\r\n\r\n## 4. Array.prototype.sort()\r\n`sort()` 方法用[原地算法](https://zh.wikipedia.org/wiki/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)对数组的元素进行排序，并返回数组。\r\n默认排序顺序是在将元素转换为字符串，然后比较它们的 UTF-16 代码单元值序列时构建的。\r\n```javascript\r\nconst months = ['March', 'Jan', 'Feb', 'Dec'];\r\n\r\nconsole.log(months.sort()); // [\"Dec\", \"Feb\", \"Jan\", \"March\"]\r\n\r\nconst array1 = [1, 30, 4, 21, 100000];\r\n\r\nconsole.log(array1.sort()); // [1, 100000, 21, 30, 4]\r\n```\r\n\r\n比较函数的基本用法：\r\n```javascript\r\nfunction compareFn(a, b) {\r\n  if (在某些排序规则中，a 小于 b) {\r\n    return -1;\r\n  }\r\n  if (在这一排序规则下，a 大于 b) {\r\n    return 1;\r\n  }\r\n  // a 一定等于 b\r\n  return 0;\r\n}\r\n```\r\n\r\n比较数字（升序排列）\r\n```javascript\r\nfunction compareNumbers(a, b) {\r\n  return a - b;\r\n}\r\n```\r\n\r\n对非 ASCII 字符排序\r\n当排序非 ASCII 字符的字符串（如包含类似 e, é, è, a, ä 等字符的字符串）。\r\n一些非英语语言的字符串需要使用 `String.localeCompare`。\r\n```javascript\r\nvar items = ['réservé', 'premier', 'cliché', 'communiqué', 'café', 'adieu'];\r\nitems.sort((a, b) =>  a.localeCompare(b));\r\n\r\nconsole.log(items); //  ['adieu', 'café', 'cliché', 'communiqué', 'premier', 'réservé']\r\n```\r\n\r\n### 常用于数组手动排序\r\n\r\n## 5. Array.prototype.toLocaleString()\r\n`toLocaleString()` 返回一个字符串表示数组中的元素。\r\n数组中的元素将使用各自的 `toLocaleString` 方法转成字符串，这些字符串将使用一个特定语言环境的字符串（例如逗号）隔开。\r\n```javascript\r\nconst array1 = [1, 'a', new Date('21 Dec 1997 14:12:00 UTC')];\r\nconst localeString = array1.toLocaleString('en', { timeZone: 'UTC' });\r\n\r\nconsole.log(localeString); // \"1,a,12/21/1997, 2:12:00 PM\"\r\n```\r\n\r\n数组中的元素将会使用各自的 `toLocaleString` 方法：\r\n\r\n- Object: Object.prototype.toLocaleString()\r\n- Number: Number.prototype.toLocaleString()\r\n- Date: Date.prototype.toLocaleString()\r\n\r\n### 用于数字货币转换：\r\n```javascript\r\nvar prices = ['￥7', 500, 8123, 12];\r\n\r\nprices.toLocaleString('ja-JP', { style: 'currency', currency: 'JPY' }); // \"￥7,￥500,￥8,123,￥12\"\r\n```\r\n\r\n## 6. Array.prototype.toString()\r\n`toString()` 方法返回一个字符串，表示指定的数组及其元素。\r\n```javascript\r\nconst array1 = [1, 2, 'a', '1a'];\r\n\r\nconsole.log(array1.toString()); // \"1,2,a,1a\"\r\n```\r\n\r\n`Array` 对象覆盖了 `Object` 的 `toString` 方法。\r\n对于数组对象，`toString` 方法在内部调用 `join()` 方法拼接数组中的元素并返回一个字符串，其中包含用逗号分隔的每个数组元素。\r\n如果 `join` 方法不可用，或者它不是一个函数，将使用 `Object.prototype.toString` 代替，返回 `[object Array]`。\r\n\r\n备注：当一个数组被作为文本值或者进行字符串拼接操作时，将会自动调用其 `toString` 方法。\r\n\r\n### 经典八股文：\r\n`Object.prototype.toString` 和 `Object.toString` 是一回事吗？\r\n\r\n不是。 \r\n因为 `Object.toString` 是 `Object.__proto__.toString`，也就是去上一级的原型中拿的方法，是 `Function.prototype.toString`。\r\n同理 `Number`，`String`，`Array` 里的 `toString` 也和 `Object.prototype.toString` 不一样，而且它们也都被重写了 `toString` 方法。\r\n"}]},{"number":27,"title":"【Q027】Ajax 工作原理","labels":["javascript"],"body":"着重理解，XMLHttpRequest","url":"https://github.com/kangyana/daily-question/issues/27","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 什么是Ajax？\r\n`AJAX`（Asynchronous JavaScript And XML）是使用 `XMLHttpRequest` 对象与服务器通信。\r\n它可以使用 JSON，XML，HTML 和 text 文本等格式发送和接收数据。\r\n`AJAX` 最吸引人的就是它的“异步”特性，也就是说它可以在不重新刷新页面的情况下与服务器通信，交换数据，或更新页面。\r\n\r\n你可以使用 AJAX 最主要的两个特性做下列事：\r\n\r\n- 在不重新加载页面的情况下发送请求给服务器。\r\n- 接受并使用从服务器发来的数据。\r\n\r\n### 如何发送 http 请求\r\n使用 `XMLHttpRequest` 方法建立一个请求：\r\n```javascript\r\nif (window.XMLHttpRequest) { // Mozilla, Safari, IE7+ ...\r\n    httpRequest = new XMLHttpRequest();\r\n} else if (window.ActiveXObject) { // IE 6 and older\r\n    httpRequest = new ActiveXObject(\"Microsoft.XMLHTTP\");\r\n}\r\n```\r\n\r\n请求响应的回调函数：\r\n```javascript\r\nhttpRequest.onreadystatechange = function(){\r\n    if (httpRequest.readyState === XMLHttpRequest.DONE) {\r\n        // Everything is good, the response was received.\r\n    } else {\r\n        // Not ready yet.\r\n    }\r\n};\r\n```\r\n\r\n发送一个实际的请求：\r\n```javascript\r\nhttpRequest.open('GET', 'http://www.example.org/some.file', true);\r\nhttpRequest.send();\r\n```\r\n\r\n可以在 `send` 调用之前设置请求头：\r\n```javascript\r\nhttpRequest.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. Ajax 工作原理\r\n\r\n![Alt](https://raw.githubusercontent.com/kangyana/img-storage/master/xhr_process.png)\r\n\r\n1. 浏览器调用xhr去请求服务器。\r\n2. 浏览器继续做其他工作。\r\n3. xhr请求服务器。\r\n4. 服务器响应xhr。\r\n5. xhr通知浏览器响应的数据。\r\n6. 浏览器利用xhr收到的数据渲染页面。"}]},{"number":28,"title":"【Q028】fetch","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/28","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. fetch\r\n`fetch`API 用于访问和操纵 HTTP 管道的一些具体部分，例如请求和响应。\r\n\r\n这种功能以前是使用 `XMLHttpRequest` 实现的，`Fetch` 提供了一个更理想的替代方案。\r\n```javascript\r\nfetch('http://example.com/movies.json')\r\n  .then(response => response.json())\r\n  .then(data => console.log(data));\r\n```\r\n\r\n### `fetch` 与 `jQuery.ajax()` 的区别：\r\n\r\n- 当接收到一个代表错误的 HTTP 状态码时，从 fetch() 返回的 Promise 不会被标记为 reject，即使响应的 HTTP 状态码是 404 或 500。\r\n相反，它会将 Promise 状态标记为 resolve（如果响应的 HTTP 状态码不在 200 - 299 的范围内，则设置 resolve 返回值的 ok 属性为 false），仅当网络故障时或请求被阻止时，才会标记为 reject。\r\n- fetch 不会发送跨域 cookie，除非你使用了 credentials 的 初始化选项。"}]},{"number":29,"title":"【Q029】同源策略（same-origin policy）","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/29","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 同源策略\r\n`同源策略` 是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。\r\n\r\n## 2. 同源的定义\r\n如果两个 URL 的 protocol (如果有指定的话) 和 host 都相同的话，则这两个 URL 是同源。\r\n这个方案也被称为“协议/主机/端口元组”，或者直接是“元组”。（“元组”是指一组项目构成的整体，双重/三重/四重/五重/等的通用形式）。\r\n\r\n下表给出了与 URL `http://store.company.com/dir/page.html` 的源进行对比的示例：\r\n\r\nURL | 结果 | 原因\r\n-- | -- | --\r\nhttp://store.company.com/dir2/other.html | 同源 | 只有路径不同\r\nhttp://store.company.com/dir/inner/another.html | 同源 | 只有路径不同\r\nhttps://store.company.com/secure.html | 失败 | 协议不同\r\nhttp://store.company.com:81/dir/etc.html | 失败 | 端口不同 ( http:// 默认端口是 80)\r\nhttp://news.company.com/dir/other.html | 失败 | 主机不同\r\n\r\n## 3. 源的继承\r\n在页面中通过 `about:blank` 或 `javascript: URL` 执行的脚本会继承打开该 URL 的文档的源，因为这些类型的 URLs 没有包含源服务器的相关信息。\r\n\r\n## 4. 源的更改\r\n满足某些限制条件的情况下，页面是可以修改它的源。脚本可以将 `document.domain` 的值设置为其当前域或其当前域的父域。如果将其设置为其当前域的父域，则这个较短的父域将用于后续源检查。\r\n\r\n例如：假设 http://store.company.com/dir/other.html 文档中的一个脚本执行以下语句：\r\n```javascript\r\ndocument.domain = \"company.com\";\r\n```\r\n\r\n## 5. 跨源网络访问\r\n同源策略控制不同源之间的交互，例如在使用 `XMLHttpRequest` 或 `<img>` 标签时则会受到同源策略的约束。这些交互通常分为三类：\r\n\r\n- 跨源写操作（Cross-origin writes）一般是被允许的。例如链接（links），重定向以及表单提交。特定少数的 HTTP 请求需要添加 预检请求。\r\n- 跨源资源嵌入（Cross-origin embedding）一般是被允许（后面会举例说明）。\r\n- 跨源读操作（Cross-origin reads）一般是不被允许的，但常可以通过内嵌资源来巧妙的进行读取访问。例如，你可以读取嵌入图片的高度和宽度，调用内嵌脚本的方法，或 availability of an embedded resource。\r\n\r\n以下是可能嵌入跨源的资源的一些示例：\r\n\r\n- <script src=\"...\"></script> 标签嵌入跨源脚本。语法错误信息只能被同源脚本中捕捉到。\r\n- <link rel=\"stylesheet\" href=\"...\"> 标签嵌入 CSS。由于 CSS 的 松散的语法规则，CSS 的跨源需要一个设置正确的 HTTP 头部 Content-Type 。不同浏览器有不同的限制。\r\n- 通过 <img> 展示的图片。支持的图片格式包括 PNG,JPEG,GIF,BMP,SVG,...\r\n- 通过 <video> 播放的多媒体资源。\r\n- 通过 <object> 和 <applet>  嵌入的插件。\r\n- 通过 @font-face 引入的字体。一些浏览器允许跨源字体（cross-origin fonts），一些需要同源字体（same-origin fonts）。\r\n- 通过 <iframe> 载入的任何资源。站点可以使用 X-Frame-Options 消息头来阻止这种形式的跨源交互。\r\n\r\n### 总结：资源和脚本可能会跨域。\r\n\r\n如何允许跨源访问：\r\n可以使用 `CORS` 来允许跨源访问。CORS 是 `HTTP` 的一部分，它允许服务端来指定哪些主机可以从这个服务端加载资源。\r\n\r\n如何阻止跨源访问：\r\n\r\n- 阻止跨源写操作，只要检测请求中的一个不可推测的标记 (CSRF token) 即可，这个标记被称为 Cross-Site Request Forgery (CSRF) 标记。你必须使用这个标记来阻止页面的跨源读操作。\r\n- 阻止资源的跨源读取，需要保证该资源是不可嵌入的。阻止嵌入行为是必须的，因为嵌入资源通常向其暴露信息。\r\n- 阻止跨源嵌入，需要确保你的资源不能通过以上列出的可嵌入资源格式使用。浏览器可能不会遵守 Content-Type 头部定义的类型。例如，如果您在 HTML 文档中指定 <script> 标记，则浏览器将尝试将标签内部的 HTML 解析为 JavaScript。当您的资源不是您网站的入口点时，您还可以使用 CSRF 令牌来防止嵌入。\r\n\r\n## 6. 跨源脚本 API 访问\r\n\r\n允许以下对 Window 属性的跨源访问：\r\n\r\n方法\r\n-- | \r\nwindow.blur\r\nwindow.close\r\nwindow.focus\r\nwindow.postMessage\r\n\r\n属性 | 权限\r\n-- | --\r\nwindow.closed | 只读\r\nwindow.frames | 只读\r\nwindow.length | 只读\r\nwindow.location | 读/写\r\nwindow.opener | 只读\r\nwindow.parent | 只读\r\nwindow.self | 只读\r\nwindow.top | 只读\r\nwindow.window | 只读\r\n\r\n允许以下对 Location 属性的跨源访问：\r\n\r\n方法\r\n-- | \r\nlocation.replace\r\n\r\n属性 | 权限\r\n-- | --\r\nHTMLAnchorElement.href | 只写\r\n\r\n某些浏览器允许访问除上述外更多的属性。\r\n\r\n## 7. 跨源数据存储访问\r\n访问存储在浏览器中的数据，如 `localStorage` 和 `IndexedDB`，是以源进行分割。\r\n每个源都拥有自己单独的存储空间，一个源中的 JavaScript 脚本不能对属于其它源的数据进行读写操作。\r\n\r\n`Cookies`使用不同的源定义方式。\r\n一个页面可以为本域和其父域设置 cookie，只要是父域不是公共后缀（public suffix）即可。\r\nFirefox 和 Chrome 使用 `Public Suffix List` 检测一个域是否是公共后缀（public suffix）。\r\nInternet Explorer 使用其内部的方法来检测域是否是公共后缀。\r\n不管使用哪个协议（HTTP/HTTPS）或端口号，浏览器都允许给定的域以及其任何子域名 (sub-domains) 访问 cookie。\r\n当你设置 cookie 时，你可以使用 Domain、Path、Secure、和 HttpOnly 标记来限定其无障碍。\r\n当你读取 cookie 时，你无法知道它是在哪里被设置的。\r\n即使您只使用安全的 https 连接，您看到的任何 cookie 都有可能是使用不安全的连接进行设置的。"}]},{"number":30,"title":"【Q030】JS strict模式","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/30","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 严格模式（strict mode）\r\n**ECMAScript 5**的 `严格模式` 是采用具有限制性 JavaScript 变体的一种方式，从而使代码隐式地脱离“马虎模式/稀松模式/懒散模式“（sloppy mode）。\r\n\r\n`严格模式` 的效果：\r\n\r\n- 严格模式通过抛出错误来消除了一些原有静默错误。\r\n- 严格模式修复了一些导致 JavaScript 引擎难以执行优化的缺陷：有时候，相同的代码，严格模式可以比非严格模式下运行得更快。\r\n- 严格模式禁用了在 ECMAScript 的未来版本中可能会定义的一些语法。\r\n\r\n## 2. 开启严格模式\r\n`严格模式` 可以应用到整个脚本或个别函数中，下表给出了应用范围：\r\n\r\n环境 | 结果\r\n-- | --\r\neva | ✅\r\nFunction | ✅\r\n内联事件处理属性 | ✅\r\nWindowTimers.setTimeout()| ✅\r\n块级作用域 {} | ❌\r\n\r\n### 为脚本开启严格模式\r\n// 整个脚本都开启严格模式的语法\r\n```javascript\r\n\"use strict\";\r\nvar v = \"Hi!  I'm a strict mode script!\";\r\n```\r\n\r\n### 为函数开启严格模式\r\n```javascript\r\nfunction strict() {\r\n  // 函数级别严格模式语法\r\n  'use strict';\r\n  function nested() {\r\n    return \"And so am I!\";\r\n  }\r\n  return \"Hi!  I'm a strict mode function!  \" + nested();\r\n}\r\n\r\nfunction notStrict() {\r\n  return \"I'm not strict.\";\r\n}\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 3. 严格模式的效果\r\n\r\n### 1. 将过失错误转成异常\r\n\r\n- 不行允许意外直接创建全局变量\r\n```javascript\r\n\"use strict\";\r\n                       // 假如有一个全局变量叫做mistypedVariable\r\nmistypedVaraible = 17; // 因为变量名拼写错误\r\n                       // 这一行代码就会抛出 ReferenceError\r\n```\r\n\r\n- 静默失败，只读属性不允许赋值\r\n```javascript\r\n\"use strict\";\r\n\r\n// 给不可写属性赋值\r\nvar obj1 = {};\r\nObject.defineProperty(obj1, \"x\", { value: 42, writable: false });\r\nobj1.x = 9; // 抛出 TypeError 错误\r\n\r\n// 给只读属性赋值\r\nvar obj2 = { get x() { return 17; } };\r\nobj2.x = 5; // 抛出 TypeError 错误\r\n\r\n// 给不可扩展对象的新属性赋值\r\nvar fixed = {};\r\nObject.preventExtensions(fixed);\r\nfixed.newProp = \"ohai\"; // 抛出 TypeError 错误\r\n```\r\n- 不允许删除不可删除的属性\r\n```javascript\r\n\"use strict\";\r\ndelete Object.prototype; // 抛出 TypeError 错误\r\n```\r\n- 不允许重名属性\r\n```javascript\r\n\"use strict\";\r\nvar o = { p: 1, p: 2 }; // !!! 语法错误\r\n```\r\n- 不允许参数重名\r\n```javascript\r\nfunction sum(a, a, c) { // !!! 语法错误\r\n  \"use strict\";\r\n  return a + a + c; // 代码运行到这里会出错\r\n}\r\n```\r\n- 禁止八进制数字语法\r\n```javascript\r\nvar a = 0o10; // ES6: 八进制\r\n```\r\n- 禁止设置 `primitive` 值的属性\r\n```javascript\r\n(function() {\r\n  \"use strict\";\r\n\r\n  false.true = \"\";              //TypeError\r\n  (14).sailing = \"home\";        //TypeError\r\n  \"with\".you = \"far away\";      //TypeError\r\n})();\r\n```\r\n\r\n### 2. 简化变量的使用\r\n\r\n- 禁用 `with` 语法\r\n```javascript\r\n\"use strict\";\r\nvar x = 17;\r\nwith (obj) { // !!! 语法错误\r\n  // 如果没有开启严格模式，with 中的这个 x 会指向 with 上面的那个 x，还是 obj.x？\r\n  // 如果不运行代码，我们无法知道，因此，这种代码让引擎无法进行优化，速度也就会变慢。\r\n  x;\r\n}\r\n```\r\n- 限制 `eval` 的作用域，避免影响到上层\r\n```javascript\r\nvar x = 17;\r\nvar evalX = eval(\"'use strict'; var x = 42; x\");\r\nconsole.assert(x === 17);\r\nconsole.assert(evalX === 42);\r\n```\r\n- 禁止删除变量 delete name\r\n```javascript\r\n\"use strict\";\r\n\r\nvar x;\r\ndelete x; // !!! 语法错误\r\n\r\neval(\"var y; delete y;\"); // !!! 语法错误\r\n```\r\n\r\n### 3. 让eval和arguments变的简单\r\n\r\n- 名称 `eval` 和 `arguments` 不能通过程序语法被绑定或赋值\r\n```javascript\r\n\"use strict\";\r\neval = 17;\r\narguments++;\r\n++eval;\r\nvar obj = { set p(arguments) { } };\r\nvar eval;\r\ntry { } catch (arguments) { }\r\nfunction x(eval) { }\r\nfunction arguments() { }\r\nvar y = function eval() { };\r\nvar f = new Function(\"arguments\", \"'use strict'; return 17;\");\r\n```\r\n\r\n- 参数的值不会随 arguments 对象的值的改变而变化\r\n```javascript\r\nfunction f(a) {\r\n  \"use strict\";\r\n  a = 42;\r\n  return [a, arguments[0]];\r\n}\r\nvar pair = f(17);\r\nconsole.assert(pair[0] === 42);\r\nconsole.assert(pair[1] === 17);\r\n```\r\n\r\n- 不再支持 `arguments.callee`\r\n```javascript\r\n\"use strict\";\r\nvar f = function() { return arguments.callee; };\r\nf(); // 抛出类型错误\r\n```\r\n\r\n### 4. 严格模式下更安全\r\n\r\n- 在严格模式下通过this传递给一个函数的值不会被强制转换为一个对象。\r\n```javascript\r\n\"use strict\";\r\nfunction fun() { return this; }\r\nconsole.assert(fun() === undefined);\r\nconsole.assert(fun.call(2) === 2);\r\nconsole.assert(fun.apply(null) === null);\r\nconsole.assert(fun.call(undefined) === undefined);\r\nconsole.assert(fun.bind(true)() === true);\r\n```\r\n\r\n- 函数内禁止使用 `fun.caller 和 `fun.arguments` 进行拓展\r\n```javascript\r\nfunction restricted() {\r\n  \"use strict\";\r\n  restricted.caller;    // 抛出类型错误\r\n  restricted.arguments; // 抛出类型错误\r\n}\r\n\r\nfunction privilegedInvoker() {\r\n  return restricted();\r\n}\r\n\r\nprivilegedInvoker();\r\n```\r\n\r\n- arguments不会再提供访问与调用这个函数相关的变量的途径\r\n```javascript\r\n\"use strict\";\r\nfunction fun(a, b) {\r\n  \"use strict\";\r\n  var v = 12;\r\n  return arguments.caller; // 抛出类型错误\r\n}\r\nfun(1, 2); // 不会暴露 v（或者 a，或者 b）\r\n```\r\n\r\n## 4. 为未来的 ECMAScript 版本铺路\r\n未来版本的 ECMAScript 很有可能会引入新语法，严格模式对其有保护机制。\r\n\r\n- 一部分字符变成了保留的关键字。\r\n在严格模式下，你不能再用这些名字作为变量名或者形参名。\r\n\r\n关键字\r\n-- |\r\nimplements\r\ninterface\r\nlet\r\npackage\r\nprivate\r\nprotected\r\npublic\r\nstatic\r\nyield\r\n\r\n```javascript\r\nfunction package(protected) { // !!!\r\n  \"use strict\";\r\n  var implements; // !!!\r\n\r\n  interface: // !!!\r\n  while (true) {\r\n    break interface; // !!!\r\n  }\r\n\r\n  function private() { } // !!!\r\n}\r\nfunction fun(static) { 'use strict'; } // !!!\r\n```\r\n\r\n-  严格模式禁止了不在脚本或者函数层面上的函数声明\r\n```javascript\r\n\"use strict\";\r\nif (true) {\r\n  function f() { } // !!! 语法错误\r\n  f();\r\n}\r\n\r\nfor (var i = 0; i < 5; i++) {\r\n  function f2() { } // !!! 语法错误\r\n  f2();\r\n}\r\n\r\nfunction baz() { // 合法\r\n  function eit() { } // 同样合法\r\n}\r\n```\r\n这种禁止放到严格模式中并不是很合适，因为这样的函数声明方式从 ES5 中延伸出来的。但这是 ECMAScript 委员会推荐的做法，浏览器就实现了这一点。"}]},{"number":31,"title":"【Q031】cookie","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/31","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. cookie\r\n`Cookie` 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。\r\n通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。\r\n\r\n`Cookie` 主要用于以下三个方面：\r\n\r\n- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）\r\n- 个性化设置（如用户自定义设置、主题等）\r\n- 浏览器行为跟踪（如跟踪分析用户行为等）\r\n\r\n`Cookie` 曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。\r\n由于服务器指定 `Cookie` 后，浏览器的每次请求都会携带 `Cookie` 数据，会带来额外的性能开销（尤其是在移动环境下）。\r\n新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 `Web storage 或 `IndexedDB`。\r\n\r\n\r\n## 2. 设置cookie\r\n当服务器收到 HTTP 请求时，服务器可以在响应头里面添加一个 `Set-Cookie` 选项。\r\n浏览器收到响应后通常会保存下 `Cookie`，之后对该服务器每一次请求中都通过 `Cookie` 请求头部将 `Cookie` 信息发送给服务器。\r\n另外，`Cookie` 的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。\r\n\r\n```\r\nSet-Cookie: <cookie 名>=<cookie 值>\r\n```\r\n\r\n## 3.定义 Cookie 的生命周期\r\nCookie 的生命周期可以通过两种方式定义：\r\n\r\n- 会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。\r\n- 持久性 Cookie：生命周期取决于过期时间（Expires）或有效期（Max-Age）指定的一段时间。\r\n\r\n```\r\nSet-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;\r\n```\r\n\r\n## 4. 限制访问 Cookie\r\n有两种方法可以确保 Cookie 被安全发送，并且不会被意外的参与者或脚本访问：\r\n\r\n属性 | 效果 | 预防\r\n-- | -- | --\r\nSecure | 只通过 HTTPS 协议加密过的请求 |  `man-in-the-middle` 的攻击\r\nHttpOnly | 禁止 `document.cookie` 访问 Cookie | `XSS` 的攻击\r\n\r\n```\r\nSet-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly\r\n```\r\n\r\n## 5. Cookie 的作用域\r\n`Domain` 和 `Path` 标识定义了 Cookie 的*作用域：*即允许 Cookie 应该发送给哪些 URL。\r\n\r\n### Domain 属性\r\n`Domain` 指定了哪些主机可以接受 Cookie。如果不指定，默认为 **origin**，不包含子域名。\r\n如果指定了Domain，则一般包含子域名。因此，指定 `Domain` 比省略它的限制要少。\r\n但是，当子域需要共享有关用户的信息时，这可能会有所帮助。\r\n\r\n### Path 属性\r\n`Path` 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。\r\n以字符 %x2F (\"/\") 作为路径分隔符，子路径也会被匹配。\r\n\r\n例如，设置 Path=/docs，则以下地址都会匹配：\r\n\r\n- /docs\r\n- /docs/Web/\r\n- /docs/Web/HTTP"}]},{"number":32,"title":"【Q032】sessionStorage、localStorage","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/32","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. Web Storage\r\n`Web Strorage` 使浏览器能以一种比使用 Cookie 更直观的方式存储键/值对。\r\n\r\nWeb Storage 包含如下两种机制：\r\n\r\n- `sessionStorage` 为每一个给定的源（given origin）维持一个独立的存储区域，该存储区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。\r\n- `localStorage` 同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。\r\n\r\n## 2. sessionStorage\r\n`sessionStorage` 属性允许你访问一个，对应当前源的 **浏览器会议储存** 的对象。\r\n它的生命周期是 一次浏览器会话。\r\n\r\n```javascript\r\n// 保存数据到 sessionStorage\r\nsessionStorage.setItem('key', 'value');\r\n\r\n// 从 sessionStorage 获取数据\r\nlet data = sessionStorage.getItem('key');\r\n\r\n// 从 sessionStorage 删除保存的数据\r\nsessionStorage.removeItem('key');\r\n\r\n// 从 sessionStorage 删除所有保存的数据\r\nsessionStorage.clear();\r\n```\r\n## 3. localStorage\r\n`localStorage` 属性允许你访问一个，**Document源** 的对象。\r\n它的生命周期是长期，直到你手动清除。\r\n\r\n语法同 sessionStorage：\r\n```javascript\r\n// 保存 localStorage 项\r\nlocalStorage.setItem('myCat', 'Tom');\r\n\r\n// 读取 localStorage 项\r\nlet cat = localStorage.getItem('myCat');\r\n\r\n// 移除 localStorage 项\r\nlocalStorage.removeItem('myCat');\r\n\r\n// 移除所有的 localStorage 项\r\nlocalStorage.clear();\r\n```\r\n\r\n## 4. 区别\r\n\r\n- 生命周期：localStorage 是长久储存，sessionStorage 是一次浏览器会话。\r\n- 应用场景：localStorage 适合储存个性设置，sessionStorage 适合储存敏感信息（token等）。"}]},{"number":34,"title":"【Q034】web worker","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/34","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. web worker\r\n`Web Worker`  为 Web 内容在后台线程中运行脚本提供了一种简单的方法。\r\nworker 可以与 js 互相通信，线程可以执行任务而不干扰用户界面。\r\n\r\n### 常用来做 耗时的计算，Service worker等后台任务\r\n\r\n## 2. worker的使用\r\n### 生成一个专用 worker\r\n```javascript\r\n// main.js\r\nvar myWorker = new Worker('worker.js');\r\n```\r\n\r\n### worker 中消息的接收和发送\r\n你可以通过 `postMessage()` 方法和 `onmessage` 事件处理函数触发 workers 的方法。\r\n\r\n主线程向 worker 发消息\r\n```javascript\r\n// main.js\r\nfirst.onchange = function() {\r\n  myWorker.postMessage([first.value,second.value]);\r\n  console.log('Message posted to worker');\r\n}\r\n\r\nsecond.onchange = function() {\r\n  myWorker.postMessage([first.value,second.value]);\r\n  console.log('Message posted to worker');\r\n}\r\n```\r\nworker接收消息的回调\r\n```javascript\r\n// worker.js\r\nonmessage = function(e) {\r\n  console.log('Message received from main script');\r\n  var workerResult = 'Result: ' + (e.data[0] * e.data[1]);\r\n  console.log('Posting message back to main script');\r\n  postMessage(workerResult);\r\n}\r\n```\r\n\r\n主线程响应 worker 回传的消息\r\n```javascript\r\n// main.js\r\nmyWorker.onmessage = function(e) {\r\n  result.textContent = e.data;\r\n  console.log('Message received from worker');\r\n}\r\n```\r\n\r\n### 终止 worker\r\n主线程调用 `terminate` 方法关闭\r\n```javascript\r\n// main.js\r\nmyWorker.terminate();\r\n```\r\n\r\nworker线程调用 `close` 方法关闭\r\n```javascript\r\n// worker.js\r\nclose();\r\n```\r\n\r\n### 处理错误\r\n当 worker 出现运行中错误时，它的 `onerror` 事件处理函数会被调用。\r\n该事件不会冒泡并且可以被取消；为了防止触发默认动作，worker 可以调用错误事件的 `preventDefault()` 方法。\r\n```javascript\r\n// worker.js\r\nonerror = function(err) {\r\n  console.log('错误消息：', err.message);\r\n  console.log('错误文件：', err.filename);\r\n  console.log('错误行数：', err.lineno);\r\n}\r\n```\r\n\r\n### 生成 subworker\r\nworker 能够生成更多的 worker。\r\n\r\n### 引入脚本与库\r\nWorker 线程能够访问一个全局函数 `importScripts()` 来引入脚本，该函数接受 0 个或者多个 URI 作为参数来引入资源。\r\n```javascript\r\nimportScripts();                        /* 什么都不引入 */\r\nimportScripts('foo.js');                /* 只引入 \"foo.js\" */\r\nimportScripts('foo.js', 'bar.js');      /* 引入两个脚本 */\r\n```\r\n\r\n浏览器加载并运行每个的脚本，脚本中的全局对象都能够被 worker 使用。\r\n如果脚本无法加载，将抛出 NETWORK_ERROR 异常，接下来的代码也无法执行，而之前执行的代码 **异步执行的代码** 依然能够运行。\r\nimportScripts() 之后的函数声明有效，因为函数提升。\r\n\r\n备注： 脚本的下载顺序不固定，但执行时会按照传入 importScripts() 中的文件名顺序进行。\r\n这个过程是同步完成的；直到所有脚本都下载并运行完毕，importScripts() 才会返回。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 3. pwa 渐进式 Web 应用\r\n`PWA`（Progressive Web Apps）运用现代的 Web API 以及传统的渐进式增强策略来创建跨平台 Web 应用程序。\r\n`PWA` 使 **web应用** 具有与 **原生应用** 相同的用户体验。\r\n\r\n## 4. 通过 Service workers 让 PWA 离线工作\r\n`Service Worker` 是浏览器和网络之间的虚拟代理。\r\n它解决决了如何正确 **缓存网站资源** 并使其在离线时可用的问题。\r\n\r\n### Service Worker 的生命周期\r\n注册sw后，sw.js 文件会自动下载、安装，然后激活。\r\n\r\n### 注册 Service Worker\r\n```javascript\r\nif('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.register('/pwa-examples/js13kpwa/sw.js');\r\n};\r\n```\r\n\r\n### 安装\r\n安装sw，并缓存文件\r\n```javascript\r\nvar cacheName = 'js13kPWA-v1'; // 缓存版本号\r\nvar appShellFiles = [\r\n  '/pwa-examples/js13kpwa/index.html',\r\n  '/pwa-examples/js13kpwa/app.js',\r\n  '/pwa-examples/js13kpwa/style.css',\r\n]; // 需要缓存的资源路径\r\n\r\nself.addEventListener('install', function(e) {\r\n  console.log('SW 安装');\r\n  // 等待缓存后再安装\r\n  e.waitUntil(\r\n    caches.open(cacheName).then(function(cache) {\r\n          console.log('SW 缓存资源');\r\n      return cache.addAll(appShellFiles);\r\n    })\r\n  );\r\n});\r\n```\r\n\r\n### 拦截请求\r\n缓存中查找资源是否被缓存：如果存在，将会返回缓存的资源；如果不存在，会转而从网络中请求数据，然后将它缓存起来。\r\n```javascript\r\nself.addEventListener('fetch', function(e) {\r\n  e.respondWith(\r\n    caches.match(e.request).then(function(r) {\r\n      console.log('SW 拦截到请求'+e.request.url);\r\n      return r || fetch(e.request).then(function(response) {\r\n                return caches.open(cacheName).then(function(cache) {\r\n          console.log('[Service Worker] Caching new resource: '+e.request.url);\r\n          cache.put(e.request, response.clone());\r\n          return response;\r\n        });\r\n      });\r\n    })\r\n  );\r\n});\r\n```\r\n\r\n### 更新\r\n当有资源变动时，更新版本号，会创新一个新sw缓存文件。\r\n```javascript\r\nappShellFiles.push('/pwa-examples/js13kpwa/icons/icon-32.png');\r\n\r\ncacheName = 'js13kPWA-v2';\r\n```\r\n旧的 Service Worker 仍然会正常运行，直到没有任何页面使用到它为止。\r\n\r\n\r\n### 激活\r\n用来清理不需要的缓存。\r\n```javascript\r\nself.addEventListener('activate', function(e) {\r\n  console.log('SW 激活');\r\n  e.waitUntil(\r\n    caches.keys().then(function(keyList) {\r\n      return Promise.all(keyList.map(function(key) {\r\n        if(cacheName.indexOf(key) === -1) {\r\n          return caches.delete(key);\r\n        }\r\n      }));\r\n    })\r\n  );\r\n});\r\n\r\n```"}]},{"number":35,"title":"【Q035】请解释什么是单页面应用","labels":["javascript"],"body":"请解释什么是单页面应用（single page app），以及如何使其对搜索引擎友好（SEO-friendly）","url":"https://github.com/kangyana/daily-question/issues/35","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 单页面应用 SPA\r\n单页面应用（single page app）加载单个html，切换 url 不会再去请求html。\r\n原理是JS会感知到url的变化，然后js会动态的将当前页面的内容清除掉，然后将下一个页面的内容挂载到当前的页面上。\r\n路由是由前端来控制，判断显示哪个页面。\r\n\r\n![Alt](https://img-blog.csdnimg.cn/20190109220800340.jpeg)\r\n\r\n### 优点\r\n\r\n- 有良好的交互体验，不会重新加载页面\r\n- 不请求html文件，减轻服务器压力\r\n- 前后端分离开发，后端接口可以通用开放给 多个客户端（web，小程序，app）。\r\n\r\n### 缺点\r\n\r\n- 首屏加载时间比较慢\r\n- SEO效果差"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. 优化方案\r\n\r\n### 优化首屏加载体验\r\n\r\n- 资源懒加载\r\n- 构建骨架屏\r\n\r\n### 优化SEO\r\n\r\n- 完善 `title` 和 `meta` 标签\r\n- 服务器端渲染（SSR）\r\n"}]},{"number":36,"title":"【Q036】可变对象和不可变对象","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/36","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 可变\r\n`可变` (Mutable)是一种可以更改的变量。 JS 中，只有 **对象和数组** 是可变的，原始值不可变。\r\n`可变对象` 是在创建后可以修改其状态的对象。\r\n`不可变对象` 一旦创建，其状态无法更改。\r\n\r\n![Alt](https://img-blog.csdnimg.cn/b847f40a83c04cf3b7e1b58bc58a6acf.png)\r\n\r\n## 2. 创建不可变对象\r\n\r\n### 不可扩展\r\n`Object.preventExtensions()` 可以使一个对象不可再添加新的属性，参数为目标对象，返回修改后的对象。\r\n```javascript\r\nvar obj = Object.preventExtensions({});\r\n\r\n// 直接定义新的属性会报错\r\nObject.defineProperty(obj, 'content', {\r\n  value: 'hello'\r\n}); // TypeError: Cannot define property:p, object is not extensible.\r\n\r\n// 非严格模式下通过点符号添加不会报错，但会静默失败，原对象仍然没有 content 属性\r\nobj.content = 'hello';\r\nobj.content; // undefined\r\n```\r\n\r\n对应的，Object.isExtensible() 可以判断一个对象是否可扩展，即是否可以添加新的属性。参数是目标对象，返回布尔值， true 代表可扩展，false 不可扩展。\r\n```javascript\r\nvar obj = new Object();\r\nObject.isExtensible(obj); // true\r\nObject.preventExtensions(obj);\r\nObject.isExtensible(obj); // false\r\n```\r\n\r\n### 密封\r\n`Object.seal()` 可以使一个对象无法添加新属性的同时，也无法删除旧属性。参数是目标对象，返回修改后的对象。\r\n\r\n其本质是通过修改属性的 configurable 为 false 来实现的。在属性描述对象里讲到，configurable 为 false 时，其他配置不可改变，writable 只能 true 变 false，且属性无法被删除。而由于只要 writable 或 configurable 其中之一为 true，则 value 可改，所以密封之后的对象还是可以改属性值的。\r\n```javascript\r\nvar obj = {content: 'hello'};\r\nObject.getOwnPropertyDescriptor(obj, 'content');\r\n// Object {\r\n//   value: \"hello\",\r\n//   writable: true,\r\n//   enumerable: true,\r\n//   configurable: true\r\n// }\r\nObject.seal(obj);\r\nObject.getOwnPropertyDescriptor(obj, 'content'); // seal 后 configurable 变为 false\r\n// Object {\r\n//   value: \"hello\",\r\n//   writable: true,\r\n//   enumerable: true,\r\n//   configurable: false\r\n// }\r\n```\r\n\r\n对应的，Object.isSealed() 可以检测一个对象是否密封，即是否可以增删属性。参数是目标对象，返回布尔值，true 代表被密封不可增删属性，false 代表没被密封可增删属性。\r\n```javascript\r\nvar obj = new Object();\r\nObject.isExtensible(obj); // true\r\nObject.isSealed(obj); // false\r\nObject.seal(obj);\r\nObject.isExtensible(obj); // false，注意 seal 后对象的 isExtensible() 也随之改变\r\nObject.isSealed(obj); // true\r\n```\r\n\r\n### 冻结\r\n`Object.freeze()` 可以使对象一个对象不能再添加新属性，也不可以删除旧属性，且不能修改属性的值。参数是目标对象，返回修改后的对象。\r\n```javascript\r\nvar obj = Object.freeze({name: 'example'});\r\n\r\n// 直接定义新的属性会报错\r\nObject.defineProperty(obj, 'content', {\r\n  value: 'hello'\r\n}); // TypeError: Cannot define property:p, object is not extensible.\r\n\r\n// 非严格模式下通过点符号添加不会报错，但会静默失败，原对象仍然没有 content 属性\r\nobj.content = 'hello';\r\nobj.content; // undefined\r\n\r\ndelete obj.name; // 删除失败，返回 false\r\n\r\nobj.name = 'hello';\r\nobj.name; // 仍然是 \"example\"\r\n```\r\n\r\n对应的，`Object.isFrozen()` 可以检测一个对象是否冻结，即是否可以增删改。参数是目标对象，返回布尔值，true 表示已经冻结不可再增删改，false 反之。\r\n```javascript\r\nvar obj = new Object();\r\nObject.isExtensible(obj); // true\r\nObject.isSealed(obj); // false\r\nObject.isFrozen(obj); // false\r\nObject.freeze(obj);\r\nObject.isExtensible(obj); // false，注意 freeze 后对象的 isExtensible() 也随之改变\r\nObject.isSealed(obj); // true，注意 freeze 后对象的 isSealed() 也随之改变\r\nObject.isFrozen(obj); // true\r\n```\r\n\r\n### 总结\r\n无论是不可扩展，密封，还是冻结，都是 **浅层控制** 的，即只控制对象本身属性的增删改。如果对象属性是一个引用类型，比如数组 subArr 或对象 subObj等，虽然subArr、subObj 的不可被删改，但subArr、subObj 的 **属性** 仍然可增删改。\r\n```javascript\r\nvar obj = Object.freeze({\r\n  content: {name: 'example'}\r\n});\r\nobj.content = new Object();\r\nobj.content; // {name: \"example\"}，content 本身不可改\r\nobj.content.name = 'test';\r\nobj.content; // {name: \"test\"}，但 content 的属性仍可改，因为冻结的是 obj 而不是 obj.content\r\n```\r\n\r\n由于每个对象都有一个属性 `__proto__`，该属性的值是该对象的原型对象，也是引用类型，由于冻结是浅层的所以原型对象并不会被连着冻结，仍然可以通过给对象的原型对象加属性达到给当前对象新增属性的效果。所以如果想进一步冻结还需要把原型对象也冻结上。\r\n```javascript\r\nvar obj = Object.freeze({});\r\nobj.content = 'hello';\r\nobj.content; // undefined，增加失败\r\n\r\nvar proto = Object.getPrototypeOf(obj);\r\nproto.content = 'hello';\r\nobj.content; // \"hello\"，增加成功\r\n\r\nObject.freeze(proto);\r\nproto.name = 'example';\r\nobj.name; // undefined，冻结原型之后增加失败\r\n```\r\n\r\n"}]},{"number":37,"title":"【Q037】什么是事件循环（event loop）","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/37","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 事件循环\r\n之所以称之为 `事件循环`，是因为它经常按照类似如下的方式来被实现：\r\n```javascript\r\nwhile (queue.waitForMessage()) {\r\n  queue.processNextMessage();\r\n}\r\n```\r\n`queue.waitForMessage()` 会同步地等待消息到达 (如果当前没有任何消息等待被处理)。\r\n\r\n### 执行至完成\r\n每一个消息完整地执行后，其它消息才会被执行。这为程序的分析提供了一些优秀的特性，包括：当一个函数执行时，它不会被抢占，只有在它运行完毕之后才会去运行任何其他的代码，才能修改这个函数操作的数据。这与 C 语言不同，例如，如果函数在线程中运行，它可能在任何位置被终止，然后在另一个线程中运行其他代码。\r\n\r\n这个模型的一个缺点在于当一个消息需要太长时间才能处理完毕时，Web 应用程序就无法处理与用户的交互，例如点击或滚动。为了缓解这个问题，浏览器一般会弹出一个“这个脚本运行时间过长”的对话框。一个良好的习惯是缩短单个消息处理时间，并在可能的情况下将一个消息裁剪成多个消息。\r\n\r\n### 添加消息\r\n在浏览器里，每当一个事件发生并且有一个事件监听器绑定在该事件上时，一个消息就会被添加进消息队列。如果没有事件监听器，这个事件将会丢失。所以当一个带有点击事件处理器的元素被点击时，就会像其他事件一样产生一个类似的消息。\r\n\r\n函数 `setTimeout` 接受两个参数：待加入队列的消息和一个时间值（可选，默认为 0）。这个时间值代表了消息被实际加入到队列的最小延迟时间。如果队列中没有其它消息并且栈为空，在这段延迟时间过去之后，消息会被马上处理。但是，如果有其它消息，`setTimeout` 消息必须等待其它消息处理完。因此第二个参数仅仅表示最少延迟时间，而非确切的等待时间。\r\n\r\n下面的例子演示了这个概念（`setTimeout` 并不会在计时器到期之后直接执行）：\r\n```javascript\r\nconst s = new Date().getSeconds();\r\n\r\nsetTimeout(function() {\r\n  // 输出 \"2\"，表示回调函数并没有在 500 毫秒之后立即执行\r\n  console.log(\"Ran after \" + (new Date().getSeconds() - s) + \" seconds\");\r\n}, 500);\r\n\r\nwhile(true) {\r\n  if(new Date().getSeconds() - s >= 2) {\r\n    console.log(\"Good, looped for 2 seconds\");\r\n    break;\r\n  }\r\n}\r\n```\r\n\r\n### 零延迟\r\n零延迟并不意味着回调会立即执行。以 0 为第二参数调用 setTimeout 并不表示在 0 毫秒后就立即调用回调函数。\r\n\r\n其等待的时间取决于队列里待处理的消息数量。在下面的例子中，\"这是一条消息\" 将会在回调获得处理之前输出到控制台，这是因为延迟参数是运行时处理请求所需的最小等待时间，但并不保证是准确的等待时间。\r\n\r\n基本上，`setTimeout` 需要等待当前队列中所有的消息都处理完毕之后才能执行，即使已经超出了由第二参数所指定的时间。\r\n```javascript\r\n(function() {\r\n\r\n  console.log('这是开始');\r\n\r\n  setTimeout(function cb() {\r\n    console.log('这是来自第一个回调的消息');\r\n  });\r\n\r\n  console.log('这是一条消息');\r\n\r\n  setTimeout(function cb1() {\r\n    console.log('这是来自第二个回调的消息');\r\n  }, 0);\r\n\r\n  console.log('这是结束');\r\n\r\n})();\r\n\r\n// \"这是开始\"\r\n// \"这是一条消息\"\r\n// \"这是结束\"\r\n// \"这是来自第一个回调的消息\"\r\n// \"这是来自第二个回调的消息\"\r\n```\r\n\r\n### 多个运行时互相通信\r\n一个 web worker 或者一个跨域的 `iframe` 都有自己的栈、堆和消息队列。两个不同的运行时只能通过 `postMessage` 方法进行通信。如果另一个运行时侦听 `message` 事件，则此方法会向该运行时添加消息。\r\n\r\n### 永不阻塞\r\nJavaScript 的事件循环模型与许多其他语言不同的一个非常有趣的特性是，它永不阻塞。处理 I/O 通常通过事件和回调来执行，所以当一个应用正等待一个 `IndexedDB` 请求返回时，它仍然可以处理其它事情，比如用户输入。\r\n\r\n由于历史原因有一些例外，如 `alert` 或者同步 XHR，但应该尽量避免使用它们。"}]},{"number":38,"title":"【Q038】创建对象有几种方法","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/38","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 通过{}创建对象\r\n```javascript\r\nvar obj = {};\r\n```\r\n\r\n如果对象不用重复创建，这种方式是比较方便的。\r\n\r\n## 2. 通过new Object()创建对象\r\n```javascript\r\nvar obj = new Object();\r\n```\r\n\r\n## 3. 使用字面量创建对象\r\n```javascript\r\nvar person = { name: 'zhang', age: 20 };\r\n\r\n// 等同于\r\nvar person = {};\r\nperson.name = 'zhang';\r\nperson.age = 20;\r\n```\r\n\r\n## 4. 使用工厂模式创建对象\r\n这种方式是使用一个函数来创建对象，减少重复代码，解决了前面三种方式的代码冗余的问题，但是方法不能共享的问题还是存在。\r\n```javascript\r\nfunction createObject(name){\r\n    var o = new Object();\r\n    o.name = name;\r\n    o.sayName = function(){\r\n        alert(this.name);\r\n    };\r\n    return o;\r\n}\r\n\r\nvar o1 = createObject('zhang');\r\nvar o2 = createObject('li');\r\n\r\n// 优点：解决了前面的代码重复的问题\r\n// 缺点：调用的还是不同的方法\r\nconsole.log(o1.sayName===o2.sayName); // false\r\n```\r\n\r\n## 5. 通过构造函数创建对象\r\n所谓构造函数，是首字母大写的函数。通过new 构造函数来创建对象。\r\n还是没有解决方法不能共享的问题。\r\n```javascript\r\nfunction Person(name){\r\n    this.name = name;\r\n    this.sayName = function(){\r\n        alert(this.name);\r\n    };\r\n}\r\n\r\nvar p1 = new Person('zhang');\r\nvar p2 = new Person('li');\r\n\r\nconsole.log(p1.constructor === p2.constructor); // true\r\nconsole.log(p1.constructor === Person); // true\r\nconsole.log(p1.sayName===p2.sayName); // false\r\n```\r\n\r\n## 6. 通过原型模式创建对象\r\n每个方法中都有一个原型（prototype），每个原型都有一个构造器（constructor），构造器又指向这个方法。\r\n```javascript\r\nfunction Animal(){}\r\nconsole.log(Animal.prototype.constructor === Animal); // true\r\n```\r\n\r\n原型创建对象：\r\n```javascript\r\nfunction Animal() { }\r\n\r\nAnimal.prototype.name = 'animal';\r\nAnimal.prototype.sayName = function () { alert(this.name); };\r\n\r\nvar a1 = new Animal();\r\nvar a2 = new Animal();\r\n\r\na1.sayName();\r\n\r\nconsole.log(a1.sayName === a2.sayName); // true\r\nconsole.log(Animal.prototype.constructor); // function Animal(){}\r\nconsole.log(Animal.prototype.constructor === Animal); // true\r\n```\r\n通过原型创建对象，把属性和方法绑定到prototype上，通过这种方式创建对象，方法是共享的，每个对象调用的是同一个方法。\r\n\r\n这种方式创建的对象会存在问题，假如原型中包含有引用类型的属性，那么如果某个对象修改了该属性的值，所有的该原型创建的对象访问的值都会改变。\r\n```javascript\r\nfunction Animal (){}\r\n\r\nAnimal.prototype = {\r\n    name: 'animal',\r\n    friends: ['dog','cat'],\r\n    sayName: function(){\r\n        alert(this.name);\r\n    }\r\n};\r\n\r\nvar a1 = new Animal();\r\nvar a2 = new Animal();\r\n\r\na2.friends.push('snake');\r\nconsole.log(a2.friends); // [dog,cat,snake]\r\nconsole.log(a1.friends); // [dog,cat,snake]\r\n```\r\n\r\n## 7. 通过原型 + 构造函数的方式创建对象\r\n这种方式结合了上面两种方式，解决了代码冗余，方法不能共享，引用类型改变值的问题。\r\n```javascript\r\nfunction Animal(name){\r\n    this.name = name;\r\n    this.friends = ['dog','cat'];\r\n}\r\n\r\nAnimal.prototype.sayName = function(){\r\n    alert(this.name);\r\n};\r\n\r\nvar a1 = new Animal('d');\r\nvar a2 = new Animal('c');\r\n\r\na1.friends.push('snake');\r\nconsole.log(a1.friends); // [dog,cat,snake]\r\nconsole.log(a2.friends); // [dog,cat]\r\n```"}]},{"number":39,"title":"【Q039】深拷贝和浅拷贝","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/39","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 浅拷贝\r\n如果属性是基本类型，拷贝的就是基本类型的值，\r\n如果属性是引用类型，拷贝的就是内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。\r\n\r\n### 赋值和浅拷贝的区别\r\n\r\n对原始数据的影响：\r\n  | 是否指向同一对象 | 改变基本数据类型 | 改变引用数据类型\r\n-- | -- | -- | --\r\n赋值 | √ | √ | √\r\n浅拷贝 | × | × | √\r\n\r\n## 2. 浅拷贝的实现\r\n### 展开运算符...\r\n```javascript\r\nvar obj2 = {...obj1};\r\n```\r\n\r\n### Object.assign()\r\n```javascript\r\nvar obj2 = Object.assign({}, obj1);\r\n```\r\n\r\n### Array.prototype.concat()\r\n此方法只对数组\r\n```javascript\r\nvar arr2 = arr1.concat([]);\r\n```\r\n\r\n### Array.prototype.slice()\r\n此方法只对数组\r\n```javascript\r\nvar arr2 = arr1.slice();\r\n```\r\n\r\n\r\n## 3. 深拷贝的实现\r\n深拷贝是将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象，且修改新对象不会影响原对象。\r\n\r\n### JSON.parse(JSON.stringify())\r\n```javascript\r\nvar obj2 = JSON.parse(JSON.stringify(obj1));\r\n```\r\n\r\n### 手写递归\r\n递归效果：遍历对象、数组直到里边都是基本数据类型，然后再去复制。\r\n```javascript\r\n// 检测数据类型的功能函数\r\nconst checkedType = (target) => Object.prototype.toString.call(target).replace(/\\[object (\\w+)\\]/, \"$1\").toLowerCase();\r\n// 实现深拷贝（Object/Array）\r\nconst cloneDeep = (target) => {\r\n    let result;\r\n    let type = checkedType(target);\r\n    if(type === 'object') result = {};\r\n    else if(type === 'array') result = [];\r\n    else  return target;\r\n    for (let key in target) {\r\n        if(checkedType(target[key]) === 'object' || checkedType(target[key]) === 'array') {\r\n            result[key] = clone(target[key]);\r\n        } else {\r\n            result[key] = target[key]; \r\n        }\r\n    }\r\n    return result;\r\n}\r\n```"}]},{"number":41,"title":"【Q041】requestAnimationFrame","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/41","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. window.requestAnimationFrame\r\n`window.requestAnimationFrame()` 执行一个动画，并在浏览器下次重绘之前调用指定的回调函数更新动画。\r\n该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。\r\n\r\n一个向右侧移动的方块：\r\n```javascript\r\nfunction animationTest() {\r\n\tvar div = document.createElement('div');\r\n\tdiv.style.width = '100px'\r\n\tdiv.style.height = '100px'\r\n\tdiv.style.position = 'absolute'\r\n\tdiv.style.top = '0px';\r\n\tdiv.style.left = '0px';\r\n\tdiv.style.backgroundColor = '#f00'\r\n\tdiv.style.zIndex = '999999'\r\n\tdocument.body.appendChild(div);\r\n\t\r\n\tlet distance = 0;\r\n\tfunction move(){\r\n\t\tdistance++\r\n\t\tconsole.log(distance) // 打印当前帧，方块移动的距离\r\n\t\tdiv.style.left = distance + 'px'\r\n\t\trequestAnimationFrame(move); // 通知浏览器开始绘制下一帧的时候，继续执行move函数\r\n\t}\r\n\tmove();\r\n}\r\n\r\nanimationTest()\r\n```\r\n\r\n## 2. window.cancelAnimationFrame\r\n取消一个先前通过调用window.requestAnimationFrame()方法添加到计划中的动画帧请求。\r\n\r\n```javascript\r\nfunction animationTest(){\r\n\tlet animationId;\r\n\tconst button = document.createElement(\"button\");\r\n\tbutton.innerHTML = \"停止动画\"\r\n\tbutton.style.position = 'absolute'\r\n\tbutton.style.top = '150px';\r\n\tbutton.style.left = '0px';\r\n\tbutton.style.zIndex = '999999'\r\n\tbutton.onclick = () => {\r\n\t\tif(!!animationId){\r\n\t\t\twindow.cancelAnimationFrame(animationId);\r\n\t\t\tbutton.innerHTML = \"开始动画\"\r\n\t\t\tanimationId = void 0;\r\n\t\t}else{\r\n\t\t\tmove()\r\n\t\t\tbutton.innerHTML = \"停止动画\"\r\n\t\t}\r\n\t}\r\n\r\n\tconst div = document.createElement(\"div\");\r\n\tdiv.style.width = '100px'\r\n\tdiv.style.height = '100px'\r\n\tdiv.style.position = 'absolute'\r\n\tdiv.style.top = '0px';\r\n\tdiv.style.left = '0px';\r\n\tdiv.style.backgroundColor = '#f00'\r\n\tdiv.style.zIndex = '999999'\r\n\tdocument.body.appendChild(div);\r\n\tdocument.body.appendChild(button);\r\n\t\r\n\tlet distance = 0;\r\n\tfunction move(){\r\n\t\tdistance++\r\n\t\tconsole.log(distance) // 打印当前帧，方块移动的距离\r\n\t\tdiv.style.left = distance + 'px'\r\n\t\tanimationId = requestAnimationFrame(move); // 通知浏览器开始绘制下一帧的时候，继续执行move函数\r\n\t}\r\n\tmove();\r\n}\r\n\r\nanimationTest()\r\n```\r\n\r\n## 3. 应用\r\n### 可以用来替代mousemove的动画\r\nmousemove的触发频率很高，很多时候，我们不需要这么高的触发频率，常常为了优化性能，我们会写一个截流函数，来降低它触发的频率。\r\n如果你仅仅是为了让画面看起来更流畅，对频率没有特殊的需求。那么你可以直接使用requestAnimationFrame。\r\n\r\n```javascript\r\nfunction mousemoveTest(){\r\n\tdocument.addEventListener(\"mousemove\", move);\r\n\t\r\n\tfunction move(){\r\n\t\trequestAnimationFrame(() => {\r\n\t\t\t// todo 高性能消耗的代码\r\n\t\t\tconsole.log(\"move 函数执行了\")\r\n\t\t})\r\n\t}\r\n}\r\nmousemoveTest()\r\n```"}]},{"number":42,"title":"【Q042】requestIdleCallback","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/42","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. requestIdleCallback\r\n`window.requestIdleCallback()` 方法插入一个函数，这个函数将在浏览器空闲时期被调用。\r\n这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间timeout，则有可能为了在超时前执行函数而打乱执行顺序。\r\n\r\n你可以在空闲回调函数中调用 requestIdleCallback()，以便在下一次通过事件循环之前调度另一个回调。\r\n\r\n```javascript\r\n// 回调函数执行：当前帧有空闲时间，或者指定时间到了\r\nlet id = requestIdleCallback(function someHeavyComputation(deadline) {\r\n  while((deadline.timeRemaining() > 0 || deadline.didTimeout) && thereIsMoreWorkToDo) {\r\n    doWorkIfNeeded(); // 一定会在将来某个比较空闲的时间（或者在指定时间过期后）得到反复执行\r\n  }\r\n\r\n  if(thereIsMoreWorkToDo) {\r\n    id = requestIdleCallback(someHeavyComputation);\r\n  }\r\n}, { timeout: 1000 });\r\n\r\nwindow.cancelIdleCallback(id);\r\n```\r\n"}]},{"number":43,"title":"【Q043】webassembly","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/43","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. WebAssembly\r\n`Wasm` 是一种新的编码方式，可以在现代的网络浏览器中运行。\r\n它是一种低级的类汇编语言，具有紧凑的二进制格式，可以接近原生的性能运行，并为诸如 C / C ++等语言提供一个编译目标，以便它们可以在 Web 上运行。\r\n它也被设计为可以与 JavaScript 共存，允许两者一起工作。\r\n\r\n### 常用于需要 **安全稳定的** 运行程序的环境\r\n\r\n## 2. WebAssembly 实现\r\n根据所使用的语言，有四种方法可以在 Web 应用程序中实现 WebAssembly。\r\n\r\n- 使用 `Emscripten` 移植 C/C++ 应用程序。\r\n- 直接在程序集级别编写或生成 WebAssembly\r\n- 编写一个 `Rust` 应用程序并将 WebAssembly 作为其输出。\r\n- 使用编译为 WebAssembly 二进制文件的 AssemblyScript。\r\n\r\n## 3. WebAssembly 优势\r\nWebAssembly 正在迅速成为一种主流技术，它被所有主要的浏览器供应商采用，特别是因为接近原生的代码性能。除此之外 WebAssembly 还拥有以下优势：\r\n\r\n- **更好的性能**：WebAssembly 在两个方面提供了增强的性能，即启动速度和吞吐量。缩小的 JavaScript 需要被解析、解释、编译和优化。另一方面，wasm 更紧凑，并且由于其简洁的设计，二进制格式允许更快的解析和快速优化。\r\n- **便携且安全**：它独立于平台、独立于硬件和独立于语言，它不对设备或浏览器没有任何特殊要求，这增强了其便携性，代码在内存安全的沙盒环境中进行验证和执行，可以防止安全漏洞和数据损坏。\r\n- **集成遗留库**：如果应用程序使用 C/C++ 或任何其他兼容语言，WebAssembly 可以轻松地将代码或桌面应用程序可用于 Web。通常使用两个库；用于 Rust 的 wasm-pack 和用于 C/C++ 的 Emscripten。\r\n\r\n## 4. WebAssembly 局限性\r\n\r\n- **没有垃圾回收机制**：与采用垃圾回收的 JavaScript 不同，Wasm 使用平面/线性内存模型，在实例化时分配大量内存并且不会自动回收内存。\r\n- **不能直接访问DOM**：WebAssembly 无法访问文档对象模型 (DOM)，任何 DOM 操作都需要使用 JavaScript 间接完成。或者，在通过 JavaScript 胶水代码完成 DOM 操作的情况下，也可以使用任何工具链，例如 Emscripten。性能取决于所使用的库。\r\n- **旧浏览器不支持**：通常较旧的浏览器没有可用于实例化和加载 Wasm 模块的所需对象。\r\n\r\n## 5. WebAssembly 应用场景\r\nWebAssembly 通常用于需要高性能的计算密集型应用程序。这些包括元宇宙相关技术 AR/VR 实时开发、视频编辑、VPN、图像识别等。\r\n\r\n- 在 tensorflow.js 中加入 wasm 后端支持后，模型的性能提升了 10 倍左右。\r\n- 由于它最初是用 C++ 编写的，因此 Figma 使用 Emscripten 导出到 Asm.js，通过添加适当的 Emscripten 标志启动 WebAssembly 后，大概 3 倍的性能提升。\r\n- 切换到 WebAssembly 后，OpenCV Python 库的性能提升非常明显。 ResNet50 的推理时间增加了 15 倍，内核性能测试速度提高了 3.5 倍。\r\n- Unity 使用 Emscripten 输出 WebAssembly 为游戏导出网络播放器，传统上由于 JavaScript 速度变慢而无法导出到 Web 的游戏，在 Web 上获得了始终如一的良好性能。\r\n"}]},{"number":44,"title":"【Q044】垃圾回收","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/44","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. 垃圾回收机制 Garbage Collection\r\n创建一个基本类型、对象、函数……都是需要占用内存的，但js会自动分配，不需要显式手动的去分配内存。\r\njs 也会自动回收，不需要手动的去回收。\r\n\r\n## 2. GC 策略\r\n在 JS 内存管理中有一个概念叫做 **可达性**，就是那些以某种方式可访问或者说可用的值，它们被保证存储在内存中，反之不可访问则需回收。\r\n至于如何回收，其实就是怎样发现这些不可达的垃圾它并给予清理的问题， JS 定期找出用不到的内存并释放。\r\n\r\n回收流程就涉及到了一些算法策略：\r\n"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 3. 标记清除算\r\n标记清除（Mark-Sweep），大多数浏览器的 JS 都在采用标记清除算法。\r\n此算法分为 **标记** 和 **清除** 两个阶段，标记阶段即为所有活动对象做上标记，清除阶段则把没有标记销毁。\r\n引擎在执行 GC 时，需要从出发点去遍历内存中所有的对象去打标。\r\n\r\n### 标记清除算法的流程：\r\n\r\n- GC 在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0\r\n- 然后从各个根对象开始遍历，把不是垃圾的节点改成1\r\n- 清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间\r\n- 最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收\r\n\r\n### 优点：\r\n简单，打标识只用二进制位（0和1）\r\n\r\n### 缺点：\r\n\r\n清除之后，剩余的对象内存位置是不变的，会导致空闲内存空间是不连续的，出现了 `内存碎片` （如下图）\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12247ac3d8f249a5ab85b9b40ba1147b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n这就牵扯出了内存分配的问题，新建对象分配内存时候，要找到尺寸符合的空块才能插入。\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb5107f04a3249ce8d37ec7cc5fd9668~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n## 4. 引用计数算法\r\n引用计数（Reference Counting），这其实是早先的一种垃圾回收算法，它把 对象是否不再需要 简化定义为 对象有没有其他对象引用到它，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收，目前很少使用这种算法了，因为它的问题很多，不过我们还是需要了解一下。\r\n\r\n### 它的策略是跟踪记录每个变量值被使用的次数：\r\n\r\n- 当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1\r\n- 如果同一个值又被赋给另一个变量，那么引用数加 1\r\n- 如果该变量的值被其他的值覆盖了，则引用次数减 1\r\n- 当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存\r\n\r\n```javascript\r\nlet a = new Object() \t// 此对象的引用计数为 1（a引用）\r\nlet b = a \t\t// 此对象的引用计数是 2（a,b引用）\r\na = null  \t\t// 此对象的引用计数为 1（b引用）\r\nb = null \t \t// 此对象的引用计数为 0（无引用）\r\n```\r\n\r\n当两个对象互相引用时，假如被多次调用，那么就会造成大量的内存不会被释放\r\n```javascript\r\nfunction test(){\r\n  let A = new Object()\r\n  let B = new Object()\r\n  \r\n  A.b = B\r\n  B.a = A\r\n}\r\n```\r\n\r\n### 优点：\r\n结构清晰，引用值为 0 时，也就是在变成垃圾的那一刻就会被回收，所以它可以立即回收垃圾。\r\n而标记清除算法需要每隔一段时间进行一次，那在应用程序（JS脚本）运行过程中线程就必须要暂停去执行一段时间的 GC，另外，标记清除算法需要遍历堆里的活动以及非活动对象来清除，而引用计数则只需要在引用时计数就可以了。\r\n\r\n### 缺点：\r\n首先它需要一个计数器，而此计数器需要占很大的位置，因为我们也不知道被引用数量的上限。\r\n还有就是无法解决循环引用无法回收的问题，这也是最严重的。\r\n\r\n## 5. V8对GC的优化\r\n\r\n### 分代式垃圾回收：\r\n分代式机制把一些新、小、存活时间短的对象作为新生代，采用一小块内存频率较高的快速清理，而一些大、老、存活时间长的对象作为老生代，使其很少接受检查，新老生代的回收机制及频率是不同的，可以说此机制的出现很大程度提高了垃圾回收机制的效率。\r\n\r\n**新生代** 的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1～8M 的容量。\r\n**老生代** 的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大。\r\nV8 整个堆内存的大小就等于新生代加上老生代的内存（如下图）\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abae5b06648a40d2aaa453b5d8a83939~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n### 新生代垃圾回收\r\n新生代对象是通过一个名为 Scavenge 的算法进行垃圾回收，在 Scavenge算法 的具体实现中，主要采用了一种复制式的方法即 Cheney算法。\r\n\r\nCheney算法 中将堆内存一分为二，一个是处于使用状态的空间我们暂且称之为 使用区，一个是处于闲置状态的空间我们称之为 空闲区，如下图所示\r\n\r\n![Alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa2d5ad1d89b4b7b919f20e4a5f8973a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作。\r\n\r\n当开始进行垃圾回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记完成之后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段，即将非活动对象占用的空间清理掉。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区。\r\n\r\n当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理。\r\n\r\n另外还有一种情况，如果复制一个对象到空闲区时，空闲区空间占用超过了 25%，那么这个对象会被直接晋升到老生代空间中，设置为 25% 的比例的原因是，当完成 Scavenge 回收后，空闲区将翻转成使用区，继续进行对象内存的分配，若占比过大，将会影响后续内存分配。\r\n\r\n### 老生代垃圾回收\r\n相比于新生代，老生代的垃圾回收就比较容易理解了，上面我们说过，对于大多数占用空间大、存活时间长的对象会被分配到老生代里，因为老生代中的对象通常比较大，如果再如新生代一般分区然后复制来复制去就会非常耗时，从而导致回收执行效率不高，所以老生代垃圾回收器来管理其垃圾回收执行，它的整个流程就采用的就是上文所说的标记清除算法了。\r\n\r\n首先是标记阶段，从一组根元素开始，递归遍历这组根元素，遍历过程中能到达的元素称为活动对象，没有到达的元素就可以判断为非活动对象。\r\n\r\n清除阶段老生代垃圾回收器会直接将非活动对象，也就是数据清理掉。\r\n\r\n前面我们也提过，标记清除算法在清除后会产生大量不连续的内存碎片，过多的碎片会导致大对象无法分配到足够的连续内存，而 V8 中就采用了我们上文中说的标记整理算法来解决这一问题来优化空间。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 6. 内存泄露\r\n虽然js引擎有内存回收，v8也做出了优化。\r\n我们的代码中依然要主动避免一些不利于引擎做垃圾回收操作，因为不是所有无用对象内存都可以被回收的，那当不再用到的内存，没有及时回收时，我们叫它 `内存泄漏`（Memory leak）。\r\n\r\n### 不正当的闭包\r\n```javascript\r\nfunction fn2(){\r\n  let test = new Array(1000).fill('isboyjc')\r\n  return function(){\r\n    console.log(test)\r\n    return test\r\n  }\r\n}\r\nlet fn2Child = fn2()\r\nfn2Child()\r\n\r\n// 解决方案：\r\nfn2Child = null\r\n```\r\n\r\n### 额外的全局变量\r\n```javascript\r\nfunction fn(){\r\n  // 没有声明从而制造了隐式全局变量test1\r\n  test1 = new Array(1000).fill('isboyjc1')\r\n  \r\n  // 函数内部this指向window，制造了隐式全局变量test2\r\n  this.test2 = new Array(1000).fill('isboyjc2')\r\n}\r\nfn()\r\n```\r\n\r\n### 游离DOM引用\r\n```javascript\r\nlet root = document.querySelector('#root')\r\nlet ul = document.querySelector('#ul')\r\nlet li3 = document.querySelector('#li3')\r\n\r\n// 由于ul变量存在，整个ul及其子元素都不能GC\r\nroot.removeChild(ul)\r\n\r\n// 虽置空了ul变量，但由于li3变量引用ul的子节点，所以ul元素依然不能被GC\r\nul = null\r\n\r\n// 已无变量引用，此时可以GC\r\nli3 = null\r\n```\r\n\r\n### 遗忘的定时器\r\n```javascript\r\n// 获取数据\r\nlet someResource = getData()\r\nsetInterval(() => {\r\n  const node = document.getElementById('Node')\r\n\tif(node) {\r\n    node.innerHTML = JSON.stringify(someResource))\r\n\t}\r\n}, 1000)\r\n```\r\n\r\n### 遗忘的事件监听器\r\n```javascript\r\nwindow.addEventListener(\"resize\", function() {})\r\n```\r\n\r\n### 遗忘的Map、Set对象\r\n当使用 `Map` 或 `Set` 存储对象时，同 `Object` 一致都是强引用，如果不将其主动清除引用，其同样会造成内存不自动进行回收。\r\n\r\n### 未清理的console输出\r\n\r\n## 7. 内存膨胀\r\n在短时间内内存占用极速上升到达一个峰值，想要避免需要使用技术手段减少对内存的占用。\r\n\r\n## 8. 频繁 GC\r\nGC 执行的特别频繁，一般出现在频繁使用大的临时变量导致新生代空间被装满的速度极快，而每次新生代装满时就会触发 GC，频繁 GC 同样会导致页面卡顿，想要避免的话就不要搞太多的临时变量，因为临时变量不用了就会被回收。"}]},{"number":45,"title":"【Q045】proxy","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/45","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. Proxy\r\n`Proxy` 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。\r\n\r\n```javascript\r\nconst handler = {\r\n    get: function(obj, prop) {\r\n        return prop in obj ? obj[prop] : 37;\r\n    }\r\n};\r\n\r\nconst p = new Proxy({}, handler);\r\np.a = 1;\r\np.b = undefined;\r\n\r\nconsole.log(p.a, p.b);      // 1, undefined\r\nconsole.log('c' in p, p.c); // false, 3\r\n```\r\n\r\n## 2. 用法\r\n\r\n### 无操作转发代理\r\n在以下例子中，我们使用了一个原生 JavaScript 对象，代理会将所有应用到它的操作转发到这个对象上。\r\n```javascript\r\nlet target = {};\r\nlet p = new Proxy(target, {});\r\n\r\np.a = 37;   // 操作转发到目标\r\n\r\nconsole.log(target.a);    // 37. 操作已经被正确地转发\r\n```\r\n\r\n### 验证\r\n通过代理，你可以轻松地验证向一个对象的传值。下面的代码借此展示了 `set handler` 的作用。\r\n```javascript\r\nlet validator = {\r\n  set: function(obj, prop, value) {\r\n    if (prop === 'age') {\r\n      if (!Number.isInteger(value)) {\r\n        throw new TypeError('The age is not an integer');\r\n      }\r\n      if (value > 200) {\r\n        throw new RangeError('The age seems invalid');\r\n      }\r\n    }\r\n\r\n    // The default behavior to store the value\r\n    obj[prop] = value;\r\n\r\n    // 表示成功\r\n    return true;\r\n  }\r\n};\r\n\r\nlet person = new Proxy({}, validator);\r\nperson.age = 100;\r\n\r\nconsole.log(person.age); // 100\r\nperson.age = 'young'; // Uncaught TypeError: The age is not an integer\r\nperson.age = 300; // Uncaught RangeError: The age seems invalid\r\n```\r\n\r\n### 扩展构造函数\r\n方法代理可以轻松地通过一个新构造函数来扩展一个已有的构造函数。这个例子使用了 `construct` 和 `apply`。\r\n```javascript\r\nfunction extend(sup, base) {\r\n  var descriptor = Object.getOwnPropertyDescriptor(\r\n    base.prototype, \"constructor\"\r\n  );\r\n  base.prototype = Object.create(sup.prototype);\r\n  var handler = {\r\n    construct: function(target, args) {\r\n      var obj = Object.create(base.prototype);\r\n      this.apply(target, obj, args);\r\n      return obj;\r\n    },\r\n    apply: function(target, that, args) {\r\n      sup.apply(that, args);\r\n      base.apply(that, args);\r\n    }\r\n  };\r\n  var proxy = new Proxy(base, handler);\r\n  descriptor.value = proxy;\r\n  Object.defineProperty(base.prototype, \"constructor\", descriptor);\r\n  return proxy;\r\n}\r\n\r\nvar Person = function (name) {\r\n  this.name = name\r\n};\r\n\r\nvar Boy = extend(Person, function (name, age) {\r\n  this.age = age;\r\n});\r\n\r\nBoy.prototype.sex = \"M\";\r\n\r\nvar Peter = new Boy(\"Peter\", 13);\r\nconsole.log(Peter.sex);  // \"M\"\r\nconsole.log(Peter.name); // \"Peter\"\r\nconsole.log(Peter.age);  // 13\r\n```\r\n\r\n## 互换 DOM 节点的属性\r\n有时，我们可能需要互换两个不同的元素的属性或类名。下面的代码以此为目标，展示了 `set handler` 的使用场景。\r\n```javascript\r\nlet view = new Proxy({\r\n  selected: null\r\n}, {\r\n  set: function(obj, prop, newval) {\r\n    let oldval = obj[prop];\r\n\r\n    if (prop === 'selected') {\r\n      if (oldval) {\r\n        oldval.setAttribute('aria-selected', 'false');\r\n      }\r\n      if (newval) {\r\n        newval.setAttribute('aria-selected', 'true');\r\n      }\r\n    }\r\n\r\n    // 默认行为是存储被传入 setter 函数的属性值\r\n    obj[prop] = newval;\r\n\r\n    // 表示操作成功\r\n    return true;\r\n  }\r\n});\r\n\r\nlet i1 = view.selected = document.getElementById('item-1');\r\nconsole.log(i1.getAttribute('aria-selected')); // 'true'\r\n\r\nlet i2 = view.selected = document.getElementById('item-2');\r\nconsole.log(i1.getAttribute('aria-selected')); // 'false'\r\nconsole.log(i2.getAttribute('aria-selected')); // 'true'\r\n```\r\n\r\n### 值修正及附加属性\r\n以下 `products` 代理会计算传值并根据需要转换为数组。这个代理对象同时支持一个叫做 `latestBrowser` 的附加属性，这个属性可以同时作为 getter 和 setter。\r\n```javascript\r\nlet products = new Proxy({\r\n  browsers: ['Internet Explorer', 'Netscape']\r\n}, {\r\n  get: function(obj, prop) {\r\n    // 附加一个属性\r\n    if (prop === 'latestBrowser') {\r\n      return obj.browsers[obj.browsers.length - 1];\r\n    }\r\n\r\n    // 默认行为是返回属性值\r\n    return obj[prop];\r\n  },\r\n  set: function(obj, prop, value) {\r\n    // 附加属性\r\n    if (prop === 'latestBrowser') {\r\n      obj.browsers.push(value);\r\n      return;\r\n    }\r\n\r\n    // 如果不是数组，则进行转换\r\n    if (typeof value === 'string') {\r\n      value = [value];\r\n    }\r\n\r\n    // 默认行为是保存属性值\r\n    obj[prop] = value;\r\n\r\n    // 表示成功\r\n    return true;\r\n  }\r\n});\r\n\r\nconsole.log(products.browsers); // ['Internet Explorer', 'Netscape']\r\nproducts.browsers = 'Firefox';  // 如果不小心传入了一个字符串\r\nconsole.log(products.browsers); // ['Firefox'] <- 也没问题，得到的依旧是一个数组\r\n\r\nproducts.latestBrowser = 'Chrome';\r\nconsole.log(products.browsers);      // ['Firefox', 'Chrome']\r\nconsole.log(products.latestBrowser); // 'Chrome'\r\n```"}]},{"number":46,"title":"【Q046】Object.defineProperty","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/46","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. Object.defineProperty\r\n`Object.defineProperty()` 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。\r\n\r\n备注： 应当直接在 `Object` 构造器对象上调用此方法，而不是在任意一个 Object 类型的实例上调用。\r\n\r\n### 参数\r\n- obj：要定义属性的对象。\r\n- prop：要定义或修改的属性的名称 。\r\n- descriptor：要定义或修改的属性描述符。\r\n\r\n```javascript\r\nconst object1 = {};\r\n\r\nObject.defineProperty(object1, 'property1', {\r\n  value: 42,\r\n  writable: false\r\n});\r\n\r\nobject1.property1 = 77; // 严格模式下报错\r\nconsole.log(object1.property1); // 42\r\n```\r\n\r\n### 该方法允许精确地添加或修改对象的属性。\r\n通过赋值操作添加的普通属性是可枚举的，可以改变这些属性的值，也可以 `delete` 这些属性。\r\n这个方法允许修改默认的额外选项。默认情况下，使用 `Object.defineProperty()` 添加的属性值是 **不可修改的**（immutable）。"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 2. 属性描述符\r\n对象里目前存在的属性描述符有两种主要形式：\r\n\r\n- 数据描述符：是一个具有值的属性，该值可以是可写的，也可以是不可写的。\r\n- 存取描述符：是由 getter 函数和 setter 函数所描述的属性。一个描述符只能是这两者其中之一；不能同时是两者。\r\n\r\n这两种描述符都是对象。以下为可选键值：\r\n\r\n可选键 | 类型 | 描述 | 默认值\r\n-- | -- | -- | --\r\nconfigurable | 通用 | 当且仅当该属性的 configurable 键值为 true 时，<br />该属性的描述符才能够被改变，<br />同时该属性也能从对应的对象上被删除。| false\r\nenumerable | 通用 | 当且仅当该属性的 configurable 键值为 true 时，<br />该属性的描述符才能够被改变，<br />同时该属性也能从对应的对象上被删除。| false\r\nvalue | 数据描述符 | 该属性对应的值。可以是任何有效的 JS 值（数值，对象，函数等）。| undefined\r\nwritable | 数据描述符 | 当且仅当该属性的 writable 键值为 true 时，<br />属性的值（value）才能被直接赋值。 | false\r\nget | 存取描述符 | 属性的 getter 函数，如果没有 getter，则为 undefined。<br />当访问该属性时，会调用此函数。执行时会传入 this 对象。<br />该函数的返回值会被用作属性的值。| undefined\r\nset | 存取描述符 | 属性的 setter 函数，如果没有 setter，则为 undefined。<br />当属性值被修改时，会调用此函数。执行时会传入 this 对象。| undefined\r\n\r\n记住，这些选项不一定是自身属性，也要考虑继承来的属性。\r\n为了确认保留这些默认值，在设置之前，可能要冻结 `Object.prototype`，明确指定所有的选项，或者通过 `Object.create(null)` 将 `__proto__` 属性指向 `null`。\r\n\r\n```javascript\r\n// 使用 __proto__\r\nvar obj = {};\r\nvar descriptor = Object.create(null); // 没有继承的属性\r\n// 默认没有 enumerable，没有 configurable，没有 writable\r\ndescriptor.value = 'static';\r\nObject.defineProperty(obj, 'key', descriptor);\r\n\r\n// 显式\r\nObject.defineProperty(obj, \"key\", {\r\n  enumerable: false,\r\n  configurable: false,\r\n  writable: false,\r\n  value: \"static\"\r\n});\r\n\r\n// 循环使用同一对象\r\nfunction withValue(value) {\r\n  var d = withValue.d || (\r\n    withValue.d = {\r\n      enumerable: false,\r\n      writable: false,\r\n      configurable: false,\r\n      value: null\r\n    }\r\n  );\r\n  d.value = value;\r\n  return d;\r\n}\r\n// ... 并且 ...\r\nObject.defineProperty(obj, \"key\", withValue(\"static\"));\r\n\r\n// 如果 freeze 可用，防止后续代码添加或删除对象原型的属性\r\n// （value, get, set, enumerable, writable, configurable）\r\n(Object.freeze||Object)(Object.prototype);\r\n```\r\n"}]},{"number":47,"title":"【Q047】map set","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/47","comments":[{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 1. Map\r\n`Map` 对象保存键值对，并且能够记住键的原始插入顺序。任何值都可以作为一个键或一个值。\r\n\r\n```javascript\r\nconst map1 = new Map();\r\n\r\nmap1.set('a', 1);\r\nmap1.set('b', 2);\r\nmap1.set('c', 3);\r\nconsole.log(map1.get('a')); // 1\r\n\r\nmap1.set('a', 97);\r\nconsole.log(map1.get('a')); // 97\r\nconsole.log(map1.size); // 3\r\n\r\nmap1.delete('b');\r\nconsole.log(map1.size); // 2\r\n```\r\n\r\n### 键的相等\r\n\r\n- 键的比较基于 `零值相等` 算法。\r\n- `NaN` 是与 NaN 相等的（虽然 NaN !== NaN），剩下所有其它的值是根据 === 运算符的结果判断是否相等。\r\n- 在目前的 ECMAScript 规范中，-0 和 +0 被认为是相等的。\r\n\r\n## 2. Object 和 Map 的比较\r\n`Object` 和 `Map` 类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值。\r\n因此 ES6 以前我们一直都把对象当成 `Map` 使用。\r\n\r\n不过 `Map` 和 `Object` 有一些重要的区别，在下列情况中使用 `Map` 会是更好的选择：\r\n\r\n  | Map | Object\r\n-- | -- | --\r\n意外的键 | 默认无键 | 原型链上的键可能会冲突\r\n键的类型 | 任何 | `String` \\| `Symbol`\r\n键的顺序 | 有序 | 不规则\r\n键值个数 | `size` | 手动计算\r\n迭代 | √ | ×\r\n性能 | 频繁操作下表现好 | 无优化\r\n序列化和解析 | × | √\r\n\r\n## 3. Set\r\n`Set` 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。\r\n`Set` 对象是值的集合，你可以按照插入的顺序迭代它的元素。Set 中的元素只会出现一次，即 Set 中的元素是唯一的。\r\n其他特性同 `Map`\r\n\r\n### 常用于数组去重\r\n```javascript\r\nconst numbers = [2,3,4,4,2,3,3,4,4,5,5,6,6,7,5,32,3,4,5]\r\nconsole.log([...new Set(numbers)]) // [2, 3, 4, 5, 6, 7, 32]\r\n```"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 4. 对于Object 和 Map的使用取舍的知识点补充\r\n## HashMap\r\n基于哈希表的 Map，提供所有可选的映射操作。\r\n很多语言里有这个内置对象，例如java、php、rust...\r\njs 因为历史原因，es6才加入Map 内置对象。在此之前我们使用Object模拟 HashMap做映射效果。\r\n也是因为Map加入的很晚，大部分开发者没有对其充分利用，现代框架设计上对Map的支持度也不足（例如react hooks的deps）。\r\n\r\n下面，列举一些应该更多考虑使用 Map 的一些原因：\r\n\r\n## 为什么 Object 不符合 HashMap 的使用情况\r\n\r\n- 限制 **键的类型** 为 `String` 和 `Symbol`，其他类型的键都被 `toString` 转为 `String`。\r\n```javascript\r\nconst foo = []\r\nconst bar = {}\r\nconst obj = {[foo]: 'foo', [bar]: 'bar'}\r\n\r\nconsole.log(obj) // {\"\": 'foo', [object Object]: 'bar'}\r\n```\r\n- Object可能会存在继承到的键，这些 **意外的键** 可能会造成冲突。\r\n- Object **键的顺序** 在 js低版本下很混乱。ES6 新增了定义时的有序，ES11 新增了继承属性的有序。\r\n\r\n## 不必要的继承\r\n在ES6之前，获得 hash map 的唯一方法是创建一个空对象：\r\n```javascript\r\nvar hashMap = {}\r\n```\r\n\r\n然而，在创建时，这个对象不再是空的。\r\n尽管 hashMap 是用一个空的对象字面量创建的，但它自动继承了 `Object.prototype`。\r\n这就是为什么我们可以在 hashMap 上调用 `hasOwnProperty`、`toString`、`constructor` 等方法，尽管我们从未在该对象上明确定义这些方法。\r\n```javascript\r\nvar hashMap = {}\r\n\r\nconsole.log(hashMap.__proto__ === Object.prototype) // true\r\n```\r\n\r\n由于原型继承，我们现在有两种类型的属性被混淆了：存在于对象本身的属性，即它自己的属性，以及存在于原型链的属性，即继承的属性。\r\n\r\n因此，我们需要一个额外的检查（例如 `hasOwnProperty`）来确保一个给定的属性确实是用户提供的，而不是从原型继承的。\r\n```javascript\r\nvar hashMap = { name: 'zs' }\r\n\r\nconsole.log(hashMap.hasOwnProperty('name')) // true\r\nconsole.log(hashMap.hasOwnProperty('__proto__')) // false\r\n```\r\n\r\n除此之外，在运行时对 `Object.prototype` 的任何改变都会在所有对象中引起连锁反应。这就为原型污染攻击打开了大门，这对大型的 JS 应用程序来说是一个严重的安全问题。\r\n```javascript\r\nvar hashMap = {}\r\nObject.prototype.age = 18\r\n\r\nconsole.log(hashMap.age) // 18\r\n```\r\n\r\n不过，我们可以通过使用 es5的 `Object.create(null)` 来解决这个问题，它可以生成一个不继承 `Object.prototype` 的对象。\r\n```javascript\r\nvar hashMap = Object.create(null)\r\n\r\nconsole.log(hashMap) // undefined\r\n```\r\n\r\n### 键值冲突\r\n当一个对象自己的属性与它的原型上的属性有名称冲突时，它就会打破预期，从而使程序崩溃。\r\n\r\n`hasOwnProperty` 有一个风险，当对象里定义了hasOwnProperty属性会覆盖。\r\n```javascript\r\nvar hashMap = { name: 'zs' }\r\nconsole.log(hashMap.hasOwnProperty('name')) // true\r\n\r\nhashMap.hasOwnProperty = 1;\r\nconsole.log(hashMap.hasOwnProperty('name')) // hashMap.hasOwnProperty is not a function\r\n```\r\n\r\n可以做 **防御性编程** 来防止这种情况。例如，我们可以从 `Object.prototype` 中借用`hasOwnProperty` 来代替\r\n```javascript\r\nvar hashMap = { name: 'zs' }\r\nhashMap.hasOwnProperty = 1;\r\n\r\nconsole.log(Object.prototype.hasOwnProperty.call(hashMap, 'name')) // true\r\n```\r\n\r\n还有一个更简短的方法就是在一个对象的字面量上调用该方法，如`{}.hasOwnProperty.call` 和 ES2022 新出的方法 `Object.hasOwn`。\r\n\r\n### 次优的人机工程学\r\n`Object` 没有提供足够的人机工程学，不能作为 HashMap 使用，许多常见的任务不能直观地执行。\r\n\r\n#### size\r\nObject 并没有提供方便的API来获取 size，即属性的数量。而且，对于什么是一个对象的 size ，还有一些细微的差别：\r\n\r\n- 如果只关心字符串、可枚举的键，那么可以用 Object.keys() 将键转换为数组，并获得其length。\r\n- 如果k只想要不可枚举的字符串键，那么必须得使用 Object.getOwnPropertyNames 来获得一个键的列表并获得其 length。\r\n- 如果只对 symbol  键感兴趣，可以使用 getOwnPropertySymbols 来显示 symbol  键。或者可以使用 Reflect.ownKeys 来一次获得字符串键和 symbol  键，不管它是否是可枚举的。\r\n\r\n上述所有选项的运行时复杂度为 **O(n)**，因为我们必须先构造一个键的数组，然后才能得到其长度。\r\n\r\n#### iterate\r\n循环遍历对象也有类似的复杂性。\r\n我们可以使用 `for...in` 循环。但它会读取到继承的可枚举属性。\r\n```javascript\r\nObject.prototype.foo = 'bar'\r\n\r\nconst obj = {id: 1} \r\n\r\nfor (const key in obj) {\r\n\tconsole.log(key) // 'id', 'foo'\r\n}\r\n```\r\n\r\n我们不能对一个对象使用 `for ... of`，因为默认情况下它不是一个可迭代的对象，除非我们明确定义 `Symbol.iterator` 方法在它上面。\r\n```javascript\r\nObject.prototype.foo = 'bar'\r\n\r\nconst obj = {id: 1}\r\n\r\nobj[Symbol.iterator] = function*(){\r\n    var keys = Object.keys(obj);\r\n    for(var k of keys){\r\n        yield k\r\n    }\r\n};\r\n\r\nfor(var key of obj){\r\n    console.log(key) // 'id', 'foo'\r\n}\r\n```\r\n\r\n我们可以使用 `Object.keys`、`Object.values` 和 `Object.entry` 来获得一个可枚举的字符串键（或/和值）的列表，并通过该列表进行迭代，这引入了一个额外的开销步骤。\r\n```javascript\r\nObject.prototype.foo = 'bar'\r\n\r\nconst obj = {id: 1} \r\n\r\nfor (const key of Object.keys(obj)) {\r\n\tconsole.log(key) // 'id', 'foo'\r\n}\r\n```\r\n\r\n还有一个是 插入对象的键的顺序并不是按我们的顺序来的，这是一个很蛋疼的地方。在大多数浏览器中，整数键是按升序排序的，并优先于字符串键，即使字符串键是在整数键之前插入的：\r\n```javascript\r\nconst obj = {}\r\n\r\nobj.foo = 'first'\r\nobj[2] = 'second'\r\nobj[1] = 'last'\r\n\r\nconsole.log(obj) // {1: 'last', 2: 'second', foo: 'first'}\r\n```\r\n\r\n## clear\r\n没有简单的方法来删除一个对象的所有属性，我们必须用 `delete` 操作符一个一个地删除每个属性，这在历史上是众所周知的慢。\r\n```javascript\r\n// 对象删除所有属性\r\nconst obj = {id: 1, foo: 'bar'}\r\n\r\nfor (const key in obj) {\r\n\tdelete obj[key]\r\n}\r\n\r\n// HashMap删除所有属性\r\nconst map1 = new Map();\r\n\r\nmap1.clear();\r\n```\r\n\r\n## 检查属性是否存在\r\n我们不能依靠点/括号符号来检查一个属性的存在，因为值本身可能被设置为 undefined。相反，得使用 `Object.prototype.hasOwnProperty` 或 `Object.hasOwn`。\r\n```javascript\r\n// 对象检查属性\r\nconst obj = {a: undefined}\r\n\r\nObject.hasOwn(obj, 'a') // true\r\n\r\n// HashMap检查属性\r\nconst map1 = new Map();\r\nmap1.has('a') // false\r\n```\r\n\r\n## Map\r\nES6 为我们带来了 Map，首先，与只允许键值为 String 和 symbols 的 Object 不同，`Map` 支持任何数据类型的键。\r\n但更重要的是，Map 在用户定义的和内置的程序数据之间提供了一个干净的分离，代价是需要一个额外的 `Map.prototype.get` 来获取对应的项。\r\nMap 也提供了更好的人机工程学。Map 默认是一个可迭代的对象。这说明可以用 for ... of 轻松地迭代，并做一些事情，比如使用嵌套的解构来从 Map 中取出第一个项。\r\n```javascript\r\nconst [[firstKey, firstValue]] = map\r\n```\r\n\r\n与 Object 相比，Map 为各种常见任务提供了专门的方法：\r\nMap.prototype.has 检查一个给定的项是否存在，与必须在对象上使用Object.prototype.hasOwnProperty/Object.hasOwn 相比，不那么尴尬了。\r\n\r\n- `Map.prototype.has` 检查一个给定的项是否存在，与在对象上使用`Object.prototype.hasOwnProperty/Object.hasOwn` 相比要好。\r\n- `Map.prototype.get` 返回与提供的键相关的值。有的可能会觉得这比对象上的点符号或括号符号更笨重。不过，它提供了一个干净的用户数据和内置方法之间的分离。\r\n- `Map.prototype.size` 返回 Map 中的项的个数，与获取对象大小的操作相比，这明显好太多了。此外，它的速度也更快。\r\n- `Map.prototype.clear` 可以删除 Map 中的所有项，它比 delete 操作符快得多。\r\n\r\n### 性能差异\r\n在 JS 社区中，似乎有一个共同的信念，即在大多数情况下，Map 要比 Object 快。有些人声称通过从 Object 切换到 Map 可以看到明显的性能提升。\r\n我在 LeetCode 上也证实了这种想法，对于数据量大的 Object 会超时，但 Map 上则不会。\r\n\r\n### 内存使用情况\r\nMap 比 Object 消耗的内存少20%到50%，因为 Map 不像 Object 那样存储属性描述符，比如 writable/enumerable/configurable 。\r\n\r\n"},{"author":{"login":"kangyana","url":"https://github.com/kangyana"},"body":"## 5. 总结\r\n\r\n- Map 比 Object 快，除非有小的整数、数组索引的键，而且它更节省内存。\r\n- 如果你需要一个频繁更新的 HashMap，请使用 Map；如果你想一个固定的键值集合（即记录），请使用Object，并注意原型继承带来的陷阱。\r\n- 现代框架下的日常工作使用Object更利于维护。（例如react hooks的deps不检测Map/Set）。"}]},{"number":48,"title":"【Q048】null 和 undefined 的区别","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/48","comments":[]},{"number":49,"title":"【Q049】symbol","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/49","comments":[]},{"number":50,"title":"【Q050】Object.assign","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/50","comments":[]},{"number":51,"title":"【Q051】常见的 DOM 方法","labels":["javascript"],"body":null,"url":"https://github.com/kangyana/daily-question/issues/51","comments":[]}]}